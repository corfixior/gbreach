Directory structure:
└── corfixior-gbreach/
    ├── gamemode_documentation.md
    ├── cw2/
    │   └── lua/
    │       ├── autorun/
    │       │   ├── cw_init.lua
    │       │   └── client/
    │       │       └── cw_cl_init.lua
    │       ├── cw/
    │       │   ├── client/
    │       │   │   ├── cw_clientmenu.lua
    │       │   │   ├── cw_hooks.lua
    │       │   │   ├── cw_hud.lua
    │       │   │   ├── cw_iv_message.lua
    │       │   │   ├── cw_statdisplay.lua
    │       │   │   └── cw_umsgs.lua
    │       │   ├── server/
    │       │   │   ├── cw_concommands.lua
    │       │   │   ├── cw_hooks.lua
    │       │   │   └── cw_weapondrop.lua
    │       │   └── shared/
    │       │       ├── cw_actionsequences.lua
    │       │       ├── cw_ammo.lua
    │       │       ├── cw_attachmentpossession.lua
    │       │       ├── cw_attachments.lua
    │       │       ├── cw_callbacks.lua
    │       │       ├── cw_cmodel_management.lua
    │       │       ├── cw_colorableparts.lua
    │       │       ├── cw_firemodes.lua
    │       │       ├── cw_grenadetypes.lua
    │       │       ├── cw_interactionmenuhandler.lua
    │       │       ├── cw_originalvaluesaving.lua
    │       │       ├── cw_particles.lua
    │       │       ├── cw_physical_bullets.lua
    │       │       ├── cw_preset.lua
    │       │       ├── cw_quickgrenade.lua
    │       │       ├── cw_shells.lua
    │       │       ├── cw_sight_position_adjustment.lua
    │       │       ├── cw_sounds.lua
    │       │       ├── ammotypes/
    │       │       │   ├── am_flechetterounds.lua
    │       │       │   ├── am_magnum.lua
    │       │       │   ├── am_matchgrade.lua
    │       │       │   ├── am_reducedpowderload.lua
    │       │       │   ├── am_slugrounds.lua
    │       │       │   └── am_ultramegamatchammo.lua
    │       │       ├── attachments/
    │       │       │   ├── bg_ak74_rpkbarrel.lua
    │       │       │   ├── bg_ak74_ubarrel.lua
    │       │       │   ├── bg_ak74foldablestock.lua
    │       │       │   ├── bg_ak74heavystock.lua
    │       │       │   ├── bg_ak74rpkmag.lua
    │       │       │   ├── bg_ar1560rndmag.lua
    │       │       │   ├── bg_ar15heavystock.lua
    │       │       │   ├── bg_ar15sturdystock.lua
    │       │       │   ├── bg_bipod.lua
    │       │       │   ├── bg_deagle_compensator.lua
    │       │       │   ├── bg_deagle_extendedbarrel.lua
    │       │       │   ├── bg_foldsight.lua
    │       │       │   ├── bg_longbarrel.lua
    │       │       │   ├── bg_longbarrelmr96.lua
    │       │       │   ├── bg_longris.lua
    │       │       │   ├── bg_magpulhandguard.lua
    │       │       │   ├── bg_mp530rndmag.lua
    │       │       │   ├── bg_mp5_kbarrel.lua
    │       │       │   ├── bg_mp5_sdbarrel.lua
    │       │       │   ├── bg_nostock.lua
    │       │       │   ├── bg_regularbarrel.lua
    │       │       │   ├── bg_retractablestock.lua
    │       │       │   ├── bg_ris.lua
    │       │       │   ├── bg_sg1scope.lua
    │       │       │   ├── md_acog.lua
    │       │       │   ├── md_aimpoint.lua
    │       │       │   ├── md_anpeq15.lua
    │       │       │   ├── md_bipod.lua
    │       │       │   ├── md_cmag_556_official.lua
    │       │       │   ├── md_cmag_9x19_official.lua
    │       │       │   ├── md_cobram2.lua
    │       │       │   ├── md_eotech.lua
    │       │       │   ├── md_foregrip.lua
    │       │       │   ├── md_insight_x2.lua
    │       │       │   ├── md_kobra.lua
    │       │       │   ├── md_m203.lua
    │       │       │   ├── md_microt1.lua
    │       │       │   ├── md_nightforce_nxs.lua
    │       │       │   ├── md_pbs1.lua
    │       │       │   ├── md_pso1.lua
    │       │       │   ├── md_rmr.lua
    │       │       │   ├── md_saker.lua
    │       │       │   ├── md_schmidt_shortdot.lua
    │       │       │   └── md_tundra9mm.lua
    │       │       ├── colors/
    │       │       │   ├── cw_lasercolors.lua
    │       │       │   └── cw_reticlecolors.lua
    │       │       ├── grenadetypes/
    │       │       │   ├── 40mm_buckshot.lua
    │       │       │   └── 40mm_smoke.lua
    │       │       └── menutabs/
    │       │           ├── customization.lua
    │       │           ├── presets.lua
    │       │           ├── sight_adjustment.lua
    │       │           └── weaponstats.lua
    │       ├── effects/
    │       │   └── cw_muzzleflash.lua
    │       ├── entities/
    │       │   ├── cw_40mm_explosive/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_40mm_smoke/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_ammo_338lapua/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_ammo_40mm/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_ammo_44magnum/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_ammo_50ae/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_ammo_545x39/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_ammo_556x45/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_ammo_762x51/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_ammo_9x19/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_ammo_crate_regular/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_ammo_crate_small/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_ammo_ent_base/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_ammo_fraggrenades/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_ammo_kit_regular/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_ammo_kit_small/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_ak74_barrels/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_ak74_misc/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_ak74_stocks/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_ammotypes_rifles/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_ammotypes_shotguns/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_ar15_barrels/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_ar15_barrels_large/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_ar15_misc/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_ar15_stocks/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_base/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_deagle_barrels/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_g3_sg1package/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_mp5_barrels/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_mp5_misc/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_mp5_stocks/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_mr96_barrels/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_sights_cqb/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_sights_longrange/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_sights_midrange/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_sights_sniper/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_suppressors/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_attpack_various/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_dropped_weapon/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_flash_thrown/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_grenade_thrown/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_grenade_unthrown/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_smoke_thrown/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   └── cw_smokescreen_impact/
    │       │       ├── cl_init.lua
    │       │       ├── init.lua
    │       │       └── shared.lua
    │       └── weapons/
    │           ├── cw_ak74/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_akm_official/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_ar15/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_base/
    │           │   ├── cl_calcview.lua
    │           │   ├── cl_cvars.lua
    │           │   ├── cl_hooks.lua
    │           │   ├── cl_hud.lua
    │           │   ├── cl_model.lua
    │           │   ├── cl_playerbindpress.lua
    │           │   ├── cl_render.lua
    │           │   ├── cl_umsgs.lua
    │           │   ├── sh_ammotypes.lua
    │           │   ├── sh_anims.lua
    │           │   ├── sh_attachments.lua
    │           │   ├── sh_bullets.lua
    │           │   ├── sh_general.lua
    │           │   ├── sh_hooks.lua
    │           │   ├── sh_mixins.lua
    │           │   ├── sh_move.lua
    │           │   ├── sh_plugininit.lua
    │           │   ├── sh_sounds.lua
    │           │   ├── sh_stats.lua
    │           │   ├── shared.lua
    │           │   ├── sv_attachments.lua
    │           │   ├── sv_filestodownload.lua
    │           │   └── sv_hooks.lua
    │           ├── cw_deagle/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_famasg2_official/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_flash_grenade/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_frag_grenade/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_g3a3/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_grenade_base/
    │           │   ├── cl_hooks.lua
    │           │   ├── cl_player_funcs.lua
    │           │   ├── cl_umsgs.lua
    │           │   └── shared.lua
    │           ├── cw_l115/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_mp5/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_mr96/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_smoke_grenade/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           └── cw_svd_official/
    │               ├── sh_sounds.lua
    │               └── shared.lua
    ├── cw2extra/
    │   └── lua/
    │       ├── autorun/
    │       │   ├── ecw_init.lua
    │       │   └── cw/
    │       │       └── attachments/
    │       │           ├── asval_attachments.lua
    │       │           └── mac11_attachments.lua
    │       ├── ecw/
    │       │   └── shared/
    │       │       ├── ammotypes/
    │       │       │   └── am_sp7.lua
    │       │       └── attachments/
    │       │           ├── asval_attachments.lua
    │       │           ├── mac11_attachments.lua
    │       │           ├── makarov_attachments.lua
    │       │           └── mp7_attachments.lua
    │       ├── entities/
    │       │   ├── cw_ammo_12gauge/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_ammo_45acp/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   ├── cw_ammo_9x17/
    │       │   │   ├── cl_init.lua
    │       │   │   ├── init.lua
    │       │   │   └── shared.lua
    │       │   └── cw_ammo_9x39/
    │       │       ├── cl_init.lua
    │       │       ├── init.lua
    │       │       └── shared.lua
    │       └── weapons/
    │           ├── cw_fiveseven/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_g36c/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_l85a2/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_m14/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_m1911/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_m249_official/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_m3super90/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_mac11/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_makarov/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_mp7_official/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_mp9_official/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_p99/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_saiga12k_official/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_scarh/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_shorty/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_ump45/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           ├── cw_vss/
    │           │   ├── sh_sounds.lua
    │           │   └── shared.lua
    │           └── cw_xm1014_official/
    │               ├── sh_sounds.lua
    │               └── shared.lua
    ├── gamemodes/
    │   └── breach/
    │       ├── breach.txt
    │       ├── UPGRADER_README.txt
    │       ├── effects/
    │       │   ├── effect_alienblaster.lua
    │       │   ├── effect_blaster_hit.lua
    │       │   ├── pearl_particle.lua
    │       │   ├── scp294_dispense.lua
    │       │   └── sillytracer.lua
    │       ├── entities/
    │       │   ├── ender_pearl.lua
    │       │   ├── effects/
    │       │   │   └── br_heal.lua
    │       │   ├── entities/
    │       │   │   ├── armor_base.lua
    │       │   │   ├── armor_chaosins.lua
    │       │   │   ├── armor_csecurity.lua
    │       │   │   ├── armor_electroproof.lua
    │       │   │   ├── armor_fireproof.lua
    │       │   │   ├── armor_goc.lua
    │       │   │   ├── armor_hazmat.lua
    │       │   │   ├── armor_heavysupport.lua
    │       │   │   ├── armor_mtfcom.lua
    │       │   │   ├── armor_mtfguard.lua
    │       │   │   ├── armor_mtfl.lua
    │       │   │   ├── armor_mtfmedic.lua
    │       │   │   ├── armor_ntf.lua
    │       │   │   ├── armor_security.lua
    │       │   │   ├── br_gift.lua
    │       │   │   ├── br_kebab_meat.lua
    │       │   │   ├── br_kebab_stand.lua
    │       │   │   ├── breach_baseammo.lua
    │       │   │   ├── ent_aaaaaaaaaaaaaaaaaaa.lua
    │       │   │   ├── ent_kapkan_mine.lua
    │       │   │   ├── ent_scp_018.lua
    │       │   │   ├── item_cctv.lua
    │       │   │   ├── item_pistolammo.lua
    │       │   │   ├── item_rifleammo.lua
    │       │   │   ├── item_scp_0761.lua
    │       │   │   ├── item_scp_268.lua
    │       │   │   ├── item_smgammo.lua
    │       │   │   ├── scp_1048b_sawent.lua
    │       │   │   ├── scp_1123.lua
    │       │   │   ├── scp_297.lua
    │       │   │   ├── scp_wall_hole.lua
    │       │   │   ├── br_c4/
    │       │   │   │   ├── cl_init.lua
    │       │   │   │   ├── init.lua
    │       │   │   │   └── shared.lua
    │       │   │   ├── br_intercom/
    │       │   │   │   ├── cl_init.lua
    │       │   │   │   ├── init.lua
    │       │   │   │   └── shared.lua
    │       │   │   ├── breach_jarate_projectile/
    │       │   │   │   ├── cl_init.lua
    │       │   │   │   ├── init.lua
    │       │   │   │   └── shared.lua
    │       │   │   ├── canebar/
    │       │   │   │   ├── cl_init.lua
    │       │   │   │   ├── init.lua
    │       │   │   │   └── shared.lua
    │       │   │   ├── ent_br_blockade/
    │       │   │   │   ├── cl_init.lua
    │       │   │   │   ├── init.lua
    │       │   │   │   └── shared.lua
    │       │   │   ├── falling_lava/
    │       │   │   │   ├── init.lua
    │       │   │   │   └── shared.lua
    │       │   │   ├── impostor_vent/
    │       │   │   │   └── init.lua
    │       │   │   ├── item_scp_215/
    │       │   │   │   ├── cl_init.lua
    │       │   │   │   ├── init.lua
    │       │   │   │   └── shared.lua
    │       │   │   ├── item_scp_330/
    │       │   │   │   ├── README.md
    │       │   │   │   ├── cl_init.lua
    │       │   │   │   ├── init.lua
    │       │   │   │   └── shared.lua
    │       │   │   ├── plasma_lava/
    │       │   │   │   ├── init.lua
    │       │   │   │   └── shared.lua
    │       │   │   ├── scp106_barrier/
    │       │   │   │   ├── cl_init.lua
    │       │   │   │   ├── init.lua
    │       │   │   │   └── shared.lua
    │       │   │   ├── scp_035/
    │       │   │   │   ├── cl_init.lua
    │       │   │   │   ├── init.lua
    │       │   │   │   └── shared.lua
    │       │   │   ├── scp_207/
    │       │   │   │   ├── init.lua
    │       │   │   │   └── shared.lua
    │       │   │   ├── scp_294/
    │       │   │   │   ├── cl_init.lua
    │       │   │   │   ├── init.lua
    │       │   │   │   └── shared.lua
    │       │   │   ├── scp_294_drink/
    │       │   │   │   ├── cl_init.lua
    │       │   │   │   ├── init.lua
    │       │   │   │   └── shared.lua
    │       │   │   └── scp_313/
    │       │   │       ├── init.lua
    │       │   │       └── shared.lua
    │       │   └── weapons/
    │       │       ├── br_entity_remover.lua
    │       │       ├── br_holster.lua
    │       │       ├── br_id.lua
    │       │       ├── br_keycard.lua
    │       │       ├── br_tool_teleporter.lua
    │       │       ├── item_cameraview.lua
    │       │       ├── item_czysty.lua
    │       │       ├── item_eyedrops.lua
    │       │       ├── item_medkit.lua
    │       │       ├── item_nvg.lua
    │       │       ├── item_radio.lua
    │       │       ├── item_scp_268.lua
    │       │       ├── item_scp_420j.lua
    │       │       ├── item_scp_500.lua
    │       │       ├── item_scp_714.lua
    │       │       ├── item_snav_300.lua
    │       │       ├── item_snav_ultimate.lua
    │       │       ├── item_ultramedkit.lua
    │       │       ├── swep_czysty.lua
    │       │       ├── weapon_bodycam_tablet.lua
    │       │       ├── weapon_br_zombie.lua
    │       │       ├── weapon_br_zombie_infect.lua
    │       │       ├── weapon_breach_basemelee.lua
    │       │       ├── weapon_breach_syringe.lua
    │       │       ├── weapon_broom.lua
    │       │       ├── weapon_doner_ayran.lua
    │       │       ├── weapon_doner_ayran_ayran.lua
    │       │       ├── weapon_doner_knife.lua
    │       │       ├── weapon_doorcontrol.lua
    │       │       ├── weapon_house_canebar.lua
    │       │       ├── weapon_house_canebar_holstered.lua
    │       │       ├── weapon_house_canebar_recall.lua
    │       │       ├── weapon_jailbird.lua
    │       │       ├── weapon_jarate.lua
    │       │       ├── weapon_kapkan_placer.lua
    │       │       ├── weapon_pencil.lua
    │       │       ├── weapon_pocket_knife.lua
    │       │       ├── weapon_scp330_candy.lua
    │       │       ├── weapon_scp_005.lua
    │       │       ├── weapon_scp_018.lua
    │       │       ├── weapon_scp_023.lua
    │       │       ├── weapon_scp_049.lua
    │       │       ├── weapon_scp_054.lua
    │       │       ├── weapon_scp_066.lua
    │       │       ├── weapon_scp_069.lua
    │       │       ├── weapon_scp_076.lua
    │       │       ├── weapon_scp_082.lua
    │       │       ├── weapon_scp_096.lua
    │       │       ├── weapon_scp_1048a.lua
    │       │       ├── weapon_scp_1048b.lua
    │       │       ├── weapon_scp_106.lua
    │       │       ├── weapon_scp_1316.lua
    │       │       ├── weapon_scp_1471.lua
    │       │       ├── weapon_scp_1499.lua
    │       │       ├── weapon_scp_173.lua
    │       │       ├── weapon_scp_2137j.lua
    │       │       ├── weapon_scp_239.lua
    │       │       ├── weapon_scp_2521.lua
    │       │       ├── weapon_scp_3166.lua
    │       │       ├── weapon_scp_3199.lua
    │       │       ├── weapon_scp_457.lua
    │       │       ├── weapon_scp_617.lua
    │       │       ├── weapon_scp_682.lua
    │       │       ├── weapon_scp_689.lua
    │       │       ├── weapon_scp_8602.lua
    │       │       ├── weapon_scp_939.lua
    │       │       ├── weapon_scp_957.lua
    │       │       ├── weapon_scp_966.lua
    │       │       ├── weapon_scp_999.lua
    │       │       ├── weapon_scp_base.lua
    │       │       ├── weapon_scp_doomguyj.lua
    │       │       ├── weapon_scp_impostor_j.lua
    │       │       ├── weapon_scp_radar.lua
    │       │       ├── weapon_scp_santaj.lua
    │       │       ├── weapon_scp_steve_j.lua
    │       │       ├── weapon_scp_ttt_sahur.lua
    │       │       ├── weapon_zeus.lua
    │       │       ├── weapon_zeus_exp.lua
    │       │       ├── item_scp_215/
    │       │       │   ├── README.md
    │       │       │   ├── cl_init.lua
    │       │       │   ├── init.lua
    │       │       │   ├── shared.lua
    │       │       │   └── sv_hooks.lua
    │       │       ├── weapon_br_c4/
    │       │       │   └── shared.lua
    │       │       └── weapon_scp_207/
    │       │           ├── cl_init.lua
    │       │           └── shared.lua
    │       └── gamemode/
    │           ├── cl_init.lua
    │           ├── init.lua
    │           ├── shared.lua
    │           ├── autorun/
    │           │   ├── cl_scp035_visuals.lua
    │           │   └── opa_canebar_throw.lua
    │           ├── languages/
    │           │   ├── english.lua
    │           │   └── wep_english.lua
    │           ├── mapconfigs/
    │           │   └── gm_site19.lua
    │           └── modules/
    │               ├── _oldsetup.lua
    │               ├── canebar_throw.lua
    │               ├── cl_bodycam_config.lua
    │               ├── cl_bomber_lottery.lua
    │               ├── cl_chaos_markers.lua
    │               ├── cl_classmenu.lua
    │               ├── cl_credits_hud.lua
    │               ├── cl_deathcard.lua
    │               ├── cl_door_access_hud.lua
    │               ├── cl_eq.lua
    │               ├── cl_font.lua
    │               ├── cl_fonts.lua
    │               ├── cl_fps_ping_display.lua
    │               ├── cl_headbob.lua
    │               ├── cl_hud.lua
    │               ├── cl_hud_custom.lua
    │               ├── cl_hud_new.lua
    │               ├── cl_kill_notifications.lua
    │               ├── cl_minigames.lua
    │               ├── cl_module.lua
    │               ├── cl_mtfmenu.lua
    │               ├── cl_sam_breach.lua
    │               ├── cl_scoreboard.lua
    │               ├── cl_scp035_visuals.lua
    │               ├── cl_scp1123.lua
    │               ├── cl_scp207.lua
    │               ├── cl_scp330.lua
    │               ├── cl_settings_menu.lua
    │               ├── cl_sounds.lua
    │               ├── cl_splash.lua
    │               ├── cl_targetid.lua
    │               ├── cl_upgrader_menu.lua
    │               ├── cl_vest_hud.lua
    │               ├── cl_vip_panic.lua
    │               ├── cl_weapon_damage_menu.lua
    │               ├── jarate_example.txt
    │               ├── sh_bodycam_sounds.lua
    │               ├── sh_class_breach.lua
    │               ├── sh_classes.lua
    │               ├── sh_ezquadcopter_loader.lua
    │               ├── sh_gteams.lua
    │               ├── sh_jailbird_sounds.lua
    │               ├── sh_jarate.lua
    │               ├── sh_kapkan_config.lua
    │               ├── sh_module.lua
    │               ├── sh_module_debug.lua
    │               ├── sh_player.lua
    │               ├── sh_rules.lua
    │               ├── sh_sam_breach.lua
    │               ├── sh_ulx.lua
    │               ├── sh_upgrader_config.lua
    │               ├── sh_utils.lua
    │               ├── sh_weapons.lua
    │               ├── sv_base_scps — kopia.lua.bac
    │               ├── sv_base_scps.lua
    │               ├── sv_bodycam_audio.lua
    │               ├── sv_credits_system.lua
    │               ├── sv_deathcard.lua
    │               ├── sv_door_access_sync.lua
    │               ├── sv_jailbird_admin.lua
    │               ├── sv_model_camera_heights.lua
    │               ├── sv_module.lua
    │               ├── sv_player.lua
    │               ├── sv_player_hooks.lua
    │               ├── sv_player_infected_fix.lua
    │               ├── sv_round.lua
    │               ├── sv_round_setup.lua
    │               ├── sv_rounds.lua
    │               ├── sv_scp.lua
    │               ├── sv_scp1123.lua
    │               ├── sv_scp207.lua
    │               ├── sv_scp313.lua
    │               ├── sv_scp330.lua
    │               ├── sv_server.lua
    │               ├── sv_syringe_regen.lua
    │               ├── sv_vip_panic.lua
    │               ├── sv_weapon_damage_modifiers.lua
    │               └── zz_sam_breach.lua
    ├── lua/
    │   └── autorun/
    │       ├── autorun_3199.lua
    │       └── tfa_crucible.lua
    └── models/
        ├── breach/
        │   ├── cctvcamera.dx80.vtx
        │   ├── cctvcamera.dx90.vtx
        │   ├── cctvcamera.mdl
        │   ├── cctvcamera.phy
        │   ├── cctvcamera.sw.vtx
        │   ├── cctvcamera.vvd
        │   ├── keycard_new.dx80.vtx
        │   ├── keycard_new.dx90.vtx
        │   ├── keycard_new.mdl
        │   ├── keycard_new.phy
        │   ├── keycard_new.sw.vtx
        │   └── keycard_new.vvd
        ├── combine_vests/
        │   ├── militaryvest.dx80.vtx
        │   ├── militaryvest.dx90.vtx
        │   ├── militaryvest.mdl
        │   ├── militaryvest.phy
        │   ├── militaryvest.sw.vtx
        │   └── militaryvest.vvd
        ├── doner_makinesi/
        │   ├── ayran.dx80.vtx
        │   ├── ayran.dx90.vtx
        │   ├── ayran.mdl
        │   ├── ayran.phy
        │   ├── ayran.sw.vtx
        │   ├── ayran.vvd
        │   ├── doner_doner.dx80.vtx
        │   ├── doner_doner.dx90.vtx
        │   ├── doner_doner.mdl
        │   ├── doner_doner.phy
        │   ├── doner_doner.sw.vtx
        │   ├── doner_doner.vvd
        │   ├── doner_stand.dx80.vtx
        │   ├── doner_stand.dx90.vtx
        │   ├── doner_stand.mdl
        │   ├── doner_stand.phy
        │   ├── doner_stand.sw.vtx
        │   ├── doner_stand.vvd
        │   ├── ekmek.dx80.vtx
        │   ├── ekmek.dx90.vtx
        │   ├── ekmek.mdl
        │   ├── ekmek.phy
        │   ├── ekmek.sw.vtx
        │   └── ekmek.vvd
        └── weapons/
            ├── v_zombiearms.dx80.vtx
            ├── v_zombiearms.dx90.vtx
            ├── v_zombiearms.mdl
            ├── v_zombiearms.sw.vtx
            ├── v_zombiearms.vvd
            ├── scp076/
            │   ├── v_katana.dx80.vtx
            │   ├── v_katana.dx90.vtx
            │   ├── v_katana.mdl
            │   ├── v_katana.sw.vtx
            │   ├── v_katana.vvd
            │   ├── w_katana.dx80.vtx
            │   ├── w_katana.dx90.vtx
            │   ├── w_katana.mdl
            │   ├── w_katana.phy
            │   ├── w_katana.sw.vtx
            │   └── w_katana.vvd
            ├── scp082/
            │   ├── v_machete.dx80.vtx
            │   ├── v_machete.dx90.vtx
            │   ├── v_machete.mdl
            │   ├── v_machete.sw.vtx
            │   ├── v_machete.vvd
            │   ├── v_machete.xbox.vtx
            │   ├── w_fc2_machete.dx80.vtx
            │   ├── w_fc2_machete.dx90.vtx
            │   ├── w_fc2_machete.mdl
            │   ├── w_fc2_machete.phy
            │   ├── w_fc2_machete.sw.vtx
            │   └── w_fc2_machete.vvd
            └── scp500/
                ├── scp500model.dx80.vtx
                ├── scp500model.dx90.vtx
                ├── scp500model.mdl
                ├── scp500model.phy
                ├── scp500model.sw.vtx
                └── scp500model.vvd

================================================
FILE: gamemode_documentation.md
================================================
# SCP: Breach Gamemode Documentation

## Overview
SCP: Breach is a Garry's Mod gamemode based on the SCP Foundation universe, featuring multiple teams, classes, and SCP entities. The gamemode emphasizes role-based gameplay with balanced teams and special abilities.

## Game Structure

### Core Files
- `init.lua`: Main initialization file
- `shared.lua`: Shared code between client and server
- `cl_init.lua`: Client-side initialization
- `gamemode/modules/`: Directory containing all modular components

### Game Flow
1. **Initialization**: Game loads and registers all modules
2. **Preparation Phase**: Players spawn and are assigned roles
3. **Active Round**: Main gameplay phase with objectives
4. **Post-Round**: Round cleanup and statistics display
5. **Round Restart**: Map cleanup and new round setup

## Player Classes and Teams

### Team Structure
The gamemode features 7 main teams with distinct roles and objectives:

| Team | Color | Description |
|------|-------|-----------|
| SCP | Red | SCP entities with unique abilities |
| MTF Guards | Blue | Mobile Task Force security personnel |
| Class D | Orange | Test subjects with various roles |
| Scientists | Light Blue | Research staff |
| Chaos Insurgency | Blue | Rebel faction with military equipment |
| GOC | Yellow | Global Occult Coalition |
| Spectators | Green | Dead players and observers |

### Class System
Classes are defined in `sh_classes.lua` with a hierarchical structure:

```lua
ALLCLASSES = {
    classds = { -- Class D Personnel
        roles = {
            {name = ROLES.ROLE_CLASSD, weapons = {"br_holster", "br_id"}, health = 100, walkspeed = 1, runspeed = 1, armor = 0, max = 0},
            {name = ROLES.ROLE_VETERAN, weapons = {"br_holster", "br_id", "weapon_piss"}, health = 120, walkspeed = 1.1, runspeed = 1.1, armor = 0, max = 2},
            -- Additional Class D roles...
        }
    },
    researchers = { -- Scientists
        roles = {
            {name = ROLES.ROLE_RES, weapons = {"br_holster", "br_id"}, health = 100, walkspeed = 1, runspeed = 1, armor = 0, max = 0},
            {name = ROLES.ROLE_MEDIC, weapons = {"br_holster", "br_id", "item_ultramedkit"}, health = 100, walkspeed = 1, runspeed = 1, armor = 0, max = 2},
            -- Additional researcher roles...
        }
    },
    security = { -- MTF Guards
        roles = {
            {name = ROLES.ROLE_SECURITY, weapons = {"br_holster", "br_id", "item_radio", "weapon_stunstick", "cw_mp5"}, health = 100, walkspeed = 0.9, runspeed = 0.95, armor = 0, vest = "armor_security", max = 0},
            {name = ROLES.ROLE_MTFGUARD, weapons = {"br_holster", "br_id", "item_radio", "weapon_stunstick", "cw_mp5"}, health = 100, walkspeed = 0.85, runspeed = 0.92, armor = 0, vest = "armor_mtfguard", max = 10},
            -- Additional security roles...
        }
    },
    support = { -- Armed Site Support
        roles = {
            {name = ROLES.ROLE_MTFNTF, weapons = {"br_holster", "br_id", "item_radio", "item_nvg", "weapon_stunstick", "cw_ar15"}, health = 100, walkspeed = 0.86, runspeed = 0.93, armor = 0, vest = "armor_ntf", max = 5},
            {name = ROLES.ROLE_CHAOS, weapons = {"br_holster", "br_id", "item_radio", "weapon_stunstick", "cw_ak74"}, health = 100, walkspeed = 0.86, runspeed = 0.93, armor = 0, vest = "armor_chaosins", max = 5},
            -- Additional support roles...
        }
    },
    goc = { -- Global Occult Coalition
        roles = {
            {name = ROLES.ROLE_GOC_SOLDIER, weapons = {"br_holster", "br_id", "item_radio", "item_medkit", "weapon_stunstick", "cw_g36c"}, health = 120, walkspeed = 0.9, runspeed = 0.95, armor = 0, vest = "armor_goc", max = 8},
            {name = ROLES.ROLE_GOC_OPERATIVE, weapons = {"br_holster", "br_id", "item_radio", "item_nvg", "item_medkit", "weapon_stunstick", "cw_ar15"}, health = 130, walkspeed = 0.92, runspeed = 0.97, armor = 0, vest = "armor_goc", max = 3},
            -- Additional GOC roles...
        }
    }
}
```

## Key Systems

### Player Management
Player functionality is handled in `sv_player.lua` with extensive meta-table extensions:

```lua
local mply = FindMetaTable("Player")

-- Role assignment based on level and availability
function mply:SetRoleBestFrom(role)
    local thebestone = nil
    for k,v in pairs(ALLCLASSES[role]["roles"]) do
        local can = true
        if v.customcheck != nil then
            if v.customcheck(self) == false then
                can = false
            end
        end
        local using = 0
        for _,pl in pairs(player.GetAll()) do
            if pl:GetNClass() == v.name then
                using = using + 1
            end
        end
        if using >= v.max then can = false end
        if can == true then
            if self:GetLevel() >= v.level then
                if thebestone != nil then
                    if thebestone.level < v.level then
                        thebestone = v
                    end
                else
                    thebestone = v
                end
            end
        end
    end
    if thebestone == nil then
        thebestone = ALLCLASSES[role]["roles"][1]
    end
    self:SetupNormal()
    self:ApplyRoleStats(thebestone)
end
```

### Special Abilities
Several classes have unique passive abilities:

#### D-Class Infected
- **Viral Aura**: Damages players who stay within 50 units for 10+ seconds
- Deals 2 damage per second after exposure threshold
- Visual poison effect

```lua
-- D-CLASS INFECTED PASSIVE ABILITY
-- Viral Aura - damages players who stay too close for too long
local InfectedProximity = {}

timer.Create("DClassInfected_ViralAura", 1, 0, function()
    for _, infected in pairs(player.GetAll()) do
        if IsValid(infected) and infected:Alive() and infected:GetNClass() == ROLES.ROLE_DCLASS_INFECTED then
            local nearbyPlayers = ents.FindInSphere(infected:GetPos(), 50)
            
            for _, ply in pairs(nearbyPlayers) do
                if IsValid(ply) and ply:IsPlayer() and ply:Alive() and ply != infected and ply:GetNClass() != ROLES.ROLE_DCLASS_INFECTED then
                    local steamID = ply:SteamID()
                    
                    if not InfectedProximity[steamID] then
                        InfectedProximity[steamID] = 0
                    end
                    
                    InfectedProximity[steamID] = InfectedProximity[steamID] + 1
                    
                    if InfectedProximity[steamID] >= 10 then
                        ply:SetHealth(ply:Health() - 2)
                        ply:ScreenFade(SCREENFADE.IN, Color(50, 200, 50, 20), 0.5, 0)
                    end
                end
            end
            
            -- Reset timer for players who moved away
            for steamID, time in pairs(InfectedProximity) do
                local ply = player.GetBySteamID(steamID)
                if not IsValid(ply) or not ply:Alive() or ply:GetPos():Distance(infected:GetPos()) > 50 then
                    InfectedProximity[steamID] = 0
                end
            end
        end
    end
end)
```

#### Psychologist
- **Therapeutic Presence**: Healing aura for nearby injured players
- Heals 1 HP per second to players below 50 HP
- Range: 125 units

```lua
-- PSYCHOLOGIST PASSIVE ABILITIES
-- Passive 1: Therapeutic Presence - Healing Aura
timer.Create("Psychologist_TherapeuticPresence", 1, 0, function()
    for _, psychologist in pairs(player.GetAll()) do
        if IsValid(psychologist) and psychologist:Alive() and psychologist:GetNClass() == ROLES.ROLE_PSYCHOLOGIST then
            local nearbyPlayers = ents.FindInSphere(psychologist:GetPos(), 125)
            
            for _, ply in pairs(nearbyPlayers) do
                if IsValid(ply) and ply:IsPlayer() and ply:Alive() and ply != psychologist then
                    local team = ply:GTeam()
                    local class = ply:GetNClass()
                    
                    if team == TEAM_SCI or team == TEAM_GUARD or (team == TEAM_CHAOS and class == ROLES.ROLE_CHAOSSPY) then
                        local currentHP = ply:Health()
                        if currentHP < 50 and currentHP > 0 then
                            ply:SetHealth(math.min(currentHP + 1, 50))
                        end
                    end
                end
            end
        end
    end
end)
```

#### Thief D
- **Weapon Theft**: Steal active weapon from other players
- 60-second cooldown
- Cannot steal from SCPs or self

```lua
-- THIEF D PASSIVE ABILITY
-- Weapon Theft - steal active weapon from other players
hook.Add("PlayerUse", "ThiefD_WeaponTheft", function(ply, ent)
    if not IsValid(ply) or not ply:IsPlayer() then return end
    if not IsValid(ent) or not ent:IsPlayer() then return end
    if preparing or postround then return end
    
    if ply:GetNClass() != ROLES.ROLE_THIEF_D then return end
    
    if ply.ThiefNextSteal and ply.ThiefNextSteal > CurTime() then
        local timeLeft = math.ceil(ply.ThiefNextSteal - CurTime())
        ply:PrintMessage(HUD_PRINTCENTER, "Theft on cooldown: " .. timeLeft .. "s")
        return false
    end
    
    if ent:GTeam() == TEAM_SCP then 
        return false
    end
    
    if ply == ent then return end
    
    local distance = ply:GetPos():Distance(ent:GetPos())
    if distance > 50 then
        return false
    end
    
    local targetWeapon = ent:GetActiveWeapon()
    if not IsValid(targetWeapon) then 
        return false
    end
    
    local weaponClass = targetWeapon:GetClass()
    
    if weaponClass == "br_holster" or weaponClass == "br_tag" then
        return false
    end
    
    if ply:HasWeapon(weaponClass) then
        return false
    end
    
    local weaponAmmo = 0
    local ammoType = targetWeapon:GetPrimaryAmmoType()
    if ammoType and ammoType != -1 then
        weaponAmmo = ent:GetAmmoCount(ammoType)
    end
    
    local keycardType = nil
    if weaponClass == "br_keycard" then
        keycardType = targetWeapon:GetNWString("K_TYPE", "safe")
    end
    
    ent:StripWeapon(weaponClass)
    
    local newWeapon = ply:Give(weaponClass)
    if IsValid(newWeapon) then
        if weaponClass == "br_keycard" and keycardType then
            newWeapon:SetKeycardType(keycardType)
        end
        
        if ammoType and ammoType != -1 and weaponAmmo > 0 then
            ply:GiveAmmo(weaponAmmo, ammoType)
        end
    end
    
    ply:SelectWeapon(weaponClass)
    ply.ThiefNextSteal = CurTime() + 60
    
    ply:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 20), 0.3, 0)
    ent:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 30), 0.5, 0)
    
    ply:EmitSound("buttons/button14.wav", 50, 120)
    ent:EmitSound("buttons/button10.wav", 50, 80)
    
    return false
end)
```

#### Dr. House
- **Death Harvest**: Gains 10 HP when someone dies within 300 units
- Healing is capped at maximum health

```lua
-- DR. HOUSE PASSIVE ABILITY
-- Death Harvest - gains 10 HP when someone nearby dies
hook.Add("PostPlayerDeath", "DrHouse_DeathHarvest", function(victim, inflictor, attacker)
    if not IsValid(victim) or not victim:IsPlayer() then return end
    if preparing or postround then return end
    
    for _, drhouse in pairs(player.GetAll()) do
        if IsValid(drhouse) and drhouse:Alive() and drhouse:GetNClass() == ROLES.ROLE_DRHOUSE then
            local distance = drhouse:GetPos():Distance(victim:GetPos())
            
            if distance <= 300 then
                local currentHP = drhouse:Health()
                local maxHP = drhouse:GetMaxHealth()
                local newHP = math.min(currentHP + 10, maxHP)
                
                drhouse:SetHealth(newHP)
                drhouse:PrintMessage(HUD_PRINTTALK, "[DR. HOUSE] Death nearby healed you for " .. (newHP - currentHP) .. " HP!")
                drhouse:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 30), 0.5, 0)
            end
        end
    end
end)
```

## SCP System

### SCP Registration
SCPs are registered using the `RegisterSCP` function in `sv_base_scps.lua`:

```lua
RegisterSCP( "SCP023", "models/Novux/023/Novux_SCP-023.mdl", "weapon_scp_023", {
    jump_power = 200,
    prep_freeze = true,
}, {
    base_health = 2000,
    max_health = 2000,
    base_speed = 150,
    run_speed = 250,
    max_speed = 250,
} )
```

### SCP Properties
Each SCP has configurable properties:

| Property | Description |
|----------|-------------|
| `jump_power` | Jump height multiplier |
| `prep_freeze` | Prevents movement during preparation phase |
| `no_ragdoll` | Prevents ragdoll on death |
| `model_scale` | Player model scale |
| `hands_model` | Custom hands model |
| `no_spawn` | Prevents position change on spawn |
| `no_model` | Prevents model change |
| `no_swep` | Prevents weapon assignment |
| `no_strip` | Prevents weapon stripping |
| `no_select` | Hides from player selection |

## Round Management

### Round Phases
The round system in `sv_round.lua` manages three main phases:

1. **Preparation Phase**: 
   - Duration controlled by `br_time_preparing` convar
   - Players are frozen and assigned roles
   - Teams are balanced based on player count

2. **Active Round**:
   - Duration controlled by `br_time_round` convar
   - Main gameplay with objectives
   - Win conditions checked periodically

3. **Post-Round**:
   - Duration controlled by `br_time_post` convar
   - Statistics displayed
   - Round restarts after timer completion

### Team Balancing
The team balancing algorithm in `sv_round_setup.lua` distributes players based on total count:

```lua
function GetRoleTable( all )
    local scp = 0
    local mtf = 0
    local res = 0

    if all < 9 then
        scp = 1
    elseif all < 15 then
        scp = 2
    else
        scp = math.floor( ( all - 14 ) / 7 ) + 3
    end
    
    all = all - scp
    
    mtf = math.Round( all * 0.3 )
    
    all = all - mtf
    
    res = math.floor( all * 0.3 )
    all = all - res
    
    return {scp, mtf, res, all}
end
```

## Special Items

### SCP-207
- **Function**: Speed and jump boost
- **Effect**: +25% speed and jump per bottle consumed
- **Stacking**: Effects are cumulative
- **Implementation**: Server-side tracking in `sv_scp207.lua`

### SCP-330
- **Function**: Candy dispenser with consequences
- **Mechanics**:
  - Players can take up to 2 candies
  - Taking more than 2 results in hands being cut off
  - Cut hands prevent weapon use and interactions
- **Implementation**: Server-side tracking in `sv_scp330.lua`

### SCP-1123
- **Function**: Skull of Memories
- **Effect**: Allows player to see through another player's eyes
- **Implementation**: Server-side tracking in `sv_scp1123.lua`

## Networking

### Key Network Strings
- `BR_UpdateVest`: Updates client vest display
- `NVG_Toggle`: Controls NVG state
- `TranslatedMessage`: Sends localized messages
- `DropWeapon`: Client request to drop weapon
- `RolesSelected`: Notifies clients that roles are assigned
- `UpdateRoundType`: Updates client with current round type
- `PrepStart`: Notifies clients that preparation phase starts
- `RoundStart`: Notifies clients that round starts
- `PostStart`: Notifies clients that post-round starts

## Configuration

### ConVars
Key configuration variables include:

| ConVar | Default | Description |
|--------|---------|-----------|
| `br_min_players` | 2 | Minimum players to start round |
| `br_time_preparing` | 30 | Preparation phase duration |
| `br_time_round` | 600 | Main round duration |
| `br_time_post` | 15 | Post-round duration |
| `br_scp_penalty` | 2 | SCP penalty duration |
| `br_premium_penalty` | 1 | Premium player SCP penalty |
| `br_specialround_pct` | 15 | Chance of special round |
| `br_expscale` | 1 | Experience scaling factor |
| `br_premium_mult` | 1.5 | Premium experience multiplier |

## Player Progression

### Level System
Players gain experience and level up:

```lua
function mply:AddExp(amount, msg)
    amount = amount * GetConVar("br_expscale"):GetInt()
    if self.Premium == true then
        amount = amount * GetConVar("br_premium_mult"):GetFloat()
    end
    amount = math.Round(amount)
    
    if not self.GetNEXP then
        player_manager.RunClass( self, "SetupDataTables" )
    end
    
    if self.GetNEXP and self.SetNEXP then
        self:SetNEXP( self:GetNEXP() + amount )
        local xp = self:GetNEXP()
        local lvl = self:GetNLevel()
        
        if lvl == 0 then
            if xp >= 3000 then
                self:AddLevel(1)
                self:SetNEXP(xp - 3000)
                self:SaveLevel()
                PrintMessage(HUD_PRINTTALK, self:Nick() .. " reached level 1! Congratulations!")
            end
        elseif lvl == 1 then
            if xp >= 5000 then
                self:AddLevel(1)
                self:SetNEXP(xp - 5000)
                self:SaveLevel()
                PrintMessage(HUD_PRINTTALK, self:Nick() .. " reached level 2! Congratulations!")
            end
        -- Additional level thresholds...
        end
    end
end
```

## Conclusion
SCP: Breach is a well-structured gamemode with a comprehensive class system, balanced team mechanics, and unique special abilities. The codebase shows good organization with proper separation of concerns between client and server code, effective use of hooks, and robust networking for multiplayer synchronization.


================================================
FILE: cw2/lua/autorun/cw_init.lua
================================================
AddCSLuaFile()

-- convenience function which calls AddCSLuaFile and include on the specified file
function loadFile(path)
	AddCSLuaFile(path)
	include(path)
end

-- load client files
AddCSLuaFile("autorun/client/cw_cl_init.lua")
AddCSLuaFile("cw/client/cw_clientmenu.lua")
AddCSLuaFile("cw/client/cw_hud.lua")
AddCSLuaFile("cw/client/cw_umsgs.lua")
AddCSLuaFile("cw/client/cw_hooks.lua")
AddCSLuaFile("cw/client/cw_statdisplay.lua")

-- main table
CustomizableWeaponry = {}
CustomizableWeaponry.baseFolder = "cw2_0"

-- load all necessary files
-- do not change the load order
include("cw/shared/cw_callbacks.lua")
include("cw/shared/cw_originalvaluesaving.lua")
include("cw/shared/cw_sounds.lua")
include("cw/shared/cw_shells.lua")
include("cw/shared/cw_particles.lua")
include("cw/shared/cw_colorableparts.lua")
include("cw/shared/cw_grenadetypes.lua")
include("cw/shared/cw_attachments.lua")
include("cw/shared/cw_ammo.lua")
include("cw/shared/cw_quickgrenade.lua")
include("cw/shared/cw_actionsequences.lua")
include("cw/shared/cw_preset.lua")
include("cw/shared/cw_attachmentpossession.lua")
include("cw/shared/cw_interactionmenuhandler.lua")
include("cw/shared/cw_cmodel_management.lua")
include("cw/shared/cw_sight_position_adjustment.lua")
include("cw/shared/cw_firemodes.lua")
include("cw/shared/cw_physical_bullets.lua")

if SERVER then
	-- load server files
	include("cw/server/cw_hooks.lua")
	include("cw/server/cw_concommands.lua")
	include("cw/server/cw_weapondrop.lua")
end

-- create base folder to store various CW 2.0 related stuff in
-- OH LOOK AT THAT, I AM GOING TO STORE ATTACHMENT PRESETS IN THE 'DATA' FOLDER
-- ACCORDING TO MAGENTA, DELETING THE 'DATA' FOLDER ON COMPUTERS OF SOME PEOPLE IS NOT A BIG DEAL, SINCE, YOU KNOW, THERE IS NOTHING IMPORTANT IN THERE
-- fuck off cunt
file.CreateDir("cw2_0")


================================================
FILE: cw2/lua/autorun/client/cw_cl_init.lua
================================================
include("cw/client/cw_clientmenu.lua")
include("cw/client/cw_hud.lua")
include("cw/client/cw_umsgs.lua")
include("cw/client/cw_hooks.lua")
include("cw/client/cw_statdisplay.lua")


================================================
FILE: cw2/lua/cw/client/cw_clientmenu.lua
================================================
local function CW2_GetLaserQualityText(level)
	if level <= 1 then
		return " Normal"
	end
	
	return " High"
end

CustomizableWeaponry.renderTargetSizes = {[1] = {size = 256, text = "Low (256x256)"},
	[2] = {size = 512, text = "Medium (512x512)"},
	[3] = {size = 768, text = "High (768x768)"},
	[4] = {size = 1024, text = "Very high (1024x1024)"},
	[5] = {size = 2048, text = "wtf man (2048x2048)"}}
	
function CustomizableWeaponry:clampRenderTargetLevel(level)
	return math.Clamp(level, 1, #self.renderTargetSizes)
end

function CustomizableWeaponry:getRenderTargetData(level)
	return self.renderTargetSizes[self:clampRenderTargetLevel(level)]
end

function CustomizableWeaponry:getRenderTargetText(level)
	return self.renderTargetSizes[self:clampRenderTargetLevel(level)].text
end

function CustomizableWeaponry:getRenderTargetSize(level)
	return self.renderTargetSizes[self:clampRenderTargetLevel(level)].size
end

local function CW2_ClientsidePanel(panel)
	panel:ClearControls()
	
	panel:AddControl("Label", {Text = "HUD Control"})
	
	panel:AddControl("CheckBox", {Label = "Use custom HUD?", Command = "cw_customhud"})
	panel:AddControl("CheckBox", {Label = "HUD: use 3D2D ammo display?", Command = "cw_customhud_ammo"})
	panel:AddControl("CheckBox", {Label = "Display crosshair?", Command = "cw_crosshair"})
	
	panel:AddControl("Label", {Text = "Visual effects control"})
	
	panel:AddControl("CheckBox", {Label = "BLUR: On reload?", Command = "cw_blur_reload"})
	panel:AddControl("CheckBox", {Label = "BLUR: On customize?", Command = "cw_blur_customize"})
	panel:AddControl("CheckBox", {Label = "BLUR: On aim?", Command = "cw_blur_aim_telescopic"})
	panel:AddControl("CheckBox", {Label = "Use simple telescopics?", Command = "cw_simple_telescopics"})
	
	panel:AddControl("CheckBox", {Label = "FREE AIM: activate?", Command = "cw_freeaim"})
	panel:AddControl("CheckBox", {Label = "FREE AIM: use auto-center?", Command = "cw_freeaim_autocenter"})
	panel:AddControl("CheckBox", {Label = "FREE AIM: auto-center while aiming?", Command = "cw_freeaim_autocenter_aim"})
	
	-- autocenter time slider
	local slider = vgui.Create("DNumSlider", panel)
	slider:SetDecimals(2)
	slider:SetMin(0.1)
	slider:SetMax(2)
	slider:SetConVar("cw_freeaim_autocenter_time")
	slider:SetValue(GetConVarNumber("cw_freeaim_autocenter_time"))
	slider:SetText("AUTO-CENTER: time")
	
	panel:AddItem(slider)
	
	local slider = vgui.Create("DNumSlider", panel)
	slider:SetDecimals(2)
	slider:SetMin(0)
	slider:SetMax(0.9)
	slider:SetConVar("cw_freeaim_center_mouse_impendance")
	slider:SetValue(GetConVarNumber("cw_freeaim_center_mouse_impendance"))
	slider:SetText("FREE AIM: mouse impendance")
	
	panel:AddItem(slider)
	
	local slider = vgui.Create("DNumSlider", panel)
	slider:SetDecimals(3)
	slider:SetMin(0)
	slider:SetMax(0.05)
	slider:SetConVar("cw_freeaim_lazyaim")
	slider:SetValue(GetConVarNumber("cw_freeaim_lazyaim"))
	slider:SetText("FREE AIM: 'lazy aim'")
	
	panel:AddItem(slider)
	
	-- pitch limit
	local slider = vgui.Create("DNumSlider", panel)
	slider:SetDecimals(1)
	slider:SetMin(5)
	slider:SetMax(15)
	slider:SetConVar("cw_freeaim_pitchlimit")
	slider:SetValue(GetConVarNumber("cw_freeaim_pitchlimit"))
	slider:SetText("FREE AIM: pitch freedom")
	
	panel:AddItem(slider)
	
	local slider = vgui.Create("DNumSlider", panel)
	slider:SetDecimals(1)
	slider:SetMin(5)
	slider:SetMax(30)
	slider:SetConVar("cw_freeaim_yawlimit")
	slider:SetValue(GetConVarNumber("cw_freeaim_yawlimit"))
	slider:SetText("FREE AIM: yaw freedom")
	
	panel:AddItem(slider)
	
	local laserQ = vgui.Create("DComboBox", panel)
	laserQ:SetText("Laser quality:" .. CW2_GetLaserQualityText(GetConVarNumber("cw_laser_quality")))
	laserQ.ConVar = "cw_laser_quality"
	
	laserQ:AddChoice("Normal")
	laserQ:AddChoice("High")
	
	laserQ.OnSelect = function(panel, index, value, data)
		laserQ:SetText("Laser quality:" .. CW2_GetLaserQualityText(tonumber(index)))
		RunConsoleCommand(laserQ.ConVar, tonumber(index))
	end
	
	panel:AddItem(laserQ)
	
	local rtScope = vgui.Create("DComboBox", panel)
	rtScope:SetText("RT scope quality: " .. CustomizableWeaponry:getRenderTargetText(GetConVarNumber("cw_rt_scope_quality")))
	rtScope.ConVar = "cw_rt_scope_quality"
	
	for key, data in ipairs(CustomizableWeaponry.renderTargetSizes) do
		rtScope:AddChoice(data.text)
	end
	
	rtScope.OnSelect = function(panel, index, value, data)
		index = tonumber(index)
		
		rtScope:SetText("RT scope quality: " .. CustomizableWeaponry:getRenderTargetText(index))
		local prevQuality = GetConVarNumber(rtScope.ConVar)
		
		RunConsoleCommand(rtScope.ConVar, index)
		local wepBase = weapons.GetStored("cw_base")
		
		if prevQuality ~= tonumber(index) then -- only re-create the render target in case we changed the quality
			wepBase:initRenderTarget(CustomizableWeaponry:getRenderTargetSize(index))
		end
	end
	
	panel:AddItem(rtScope)
	
	panel:AddControl("Label", {Text = "Misc"})
	
	panel:AddControl("CheckBox", {Label = "Custom weapon origins?", Command = "cw_alternative_vm_pos"})
	
	panel:AddControl("Button", {Label = "Drop CW 2.0 weapon", Command = "cw_dropweapon"})
end

local function CW2_AdminPanel(panel)
	if not LocalPlayer():IsAdmin() then
		panel:AddControl("Label", {Text = "Not an admin - don't look here."})
		return
	end
	
	local checkBox = "CheckBox"
	local baseText = "ON SPAWN: Give "
	local questionMark = "?"
	
	panel:AddControl(checkBox, {Label = "Keep attachments after dying?", Command = "cw_keep_attachments_post_death"})
	
	for k, v in ipairs(CustomizableWeaponry.registeredAttachments) do
		if v.displayName and v.clcvar then
			panel:AddControl(checkBox, {Label = baseText .. v.displayName .. questionMark, Command = v.clcvar})
		end
	end
	
	panel:AddControl("Button", {Label = "Apply Changes", Command = "cw_applychanges"})
end

local function CW2_PopulateToolMenu()
	spawnmenu.AddToolMenuOption("Utilities", "CW 2.0 SWEPs", "CW 2.0 Client", "Client", "", "", CW2_ClientsidePanel)
	spawnmenu.AddToolMenuOption("Utilities", "CW 2.0 SWEPs", "CW 2.0 Admin", "Admin", "", "", CW2_AdminPanel)
end

hook.Add("PopulateToolMenu", "CW2_PopulateToolMenu", CW2_PopulateToolMenu)


================================================
FILE: cw2/lua/cw/client/cw_hooks.lua
================================================
function CustomizableWeaponry.InitPostEntity()
	local ply = LocalPlayer()

	CustomizableWeaponry.initCWVariables(ply)
end

hook.Add("InitPostEntity", "CustomizableWeaponry.InitPostEntity", CustomizableWeaponry.InitPostEntity)


================================================
FILE: cw2/lua/cw/client/cw_hud.lua
================================================
CustomizableWeaponry.ITEM_PACKS_TOP_COLOR = Color(0, 200, 255, 255)

local noDraw = {CHudAmmo = true,
	CHudSecondaryAmmo = true,
	CHudHealth = true,
	CHudBattery = true}

local noDrawAmmo = {CHudAmmo = true,
	CHudSecondaryAmmo = true}
	
local wep, ply

local function CW_HUDShouldDraw(n)
	local customHud = GetConVarNumber("cw_customhud") >= 1
	local customAmmo = GetConVarNumber("cw_customhud_ammo") >= 1
	
	if customAmmo or customHud then
		ply = LocalPlayer()
		
		if IsValid(ply) and ply:Alive() then
			wep = ply:GetActiveWeapon()
		end
	else
		ply, wep = nil, nil
	end
	
	if customAmmo then
		if IsValid(ply) and ply:Alive() then
			if IsValid(wep) and wep.CW20Weapon then
				if noDrawAmmo[n] then
					return false
				end
			end
		end
	end
	
	if customHud then
		if IsValid(ply) and ply:Alive() then
			if IsValid(wep) and wep.CW20Weapon then
				if noDraw[n] then
					return false
				end
			end
		end
	end
end

hook.Add("HUDShouldDraw", "CW_HUDShouldDraw", CW_HUDShouldDraw)


================================================
FILE: cw2/lua/cw/client/cw_iv_message.lua
================================================
-- if you don't want this message to pop up on your server, just uncomment the line below
do return end

local displayFrequency = 43200 -- time in seconds before we can show the message again
local baseDate = 1633415189 -- the message starting point
local maxMessageDuration = 60 * 60 * 24 * 14 -- the message will be displayed once every 12 hours upon loading into a map, for 14 days, after that it won't show

-- it's time out, don't display the message at all
if os.time() > baseDate + maxMessageDuration then
	return
end

local timerDelay = 5

local targetFile = CustomizableWeaponry.baseFolder .. "/iv_message_time.txt" -- file where we store the last time we showed the message

hook.Add("InitPostEntity", "CW20_IVMessage", function()
	-- ensure directory exists
	if not file.IsDir(CustomizableWeaponry.baseFolder, "DATA") then
		file.CreateDir(CustomizableWeaponry.baseFolder)
	end
	
	-- read the data, make sure it exists and is a number
	local data = file.Read(targetFile, "DATA")
	local timestamp = os.time()
	
	if data then
		local dataNum = tonumber(data)
		
		-- too early to display the message yet? don't do anything
		if dataNum and timestamp < dataNum + displayFrequency then
			return
		end
	end
	
	local white = Color(255, 255, 255)
	local highlight = Color(117, 190, 255)
	
	-- looks like it passes, write the timestamp and show the message
	timer.Simple(timerDelay, function()
		file.Write(targetFile, timestamp)
		chat.AddText(white, "Hey! ", highlight, "Creator of Customizable Weaponry 2.0 here", white, ". I've recently released a game called '", highlight, "Intravenous", white, "' on Steam. It's a ", highlight, "stealth/action game with heavy emphasis on stealth.", white, " It does it's own thing, but some folks describe it as ", highlight, "'Hotline Miami mixed with Splinter Cell and Metal Gear'", white, " - if that sounds interesting to you, take the time to check it out on Steam. :)")
		
		timer.Simple(10, function()
			chat.AddText(white, "Thanks for using my addons. I've had a lot of fun making them, and it lead me to start making games as a consequence. Best of luck to you.")
		end)
	end)
end)


================================================
FILE: cw2/lua/cw/client/cw_statdisplay.lua
================================================
CustomizableWeaponry.statDisplay = {}
CustomizableWeaponry.statDisplay.registered = {}
CustomizableWeaponry.statDisplay.highest = {}
CustomizableWeaponry.statDisplay.totalCount = 0
CustomizableWeaponry.statDisplay.descFont = "CW_HUD32"
CustomizableWeaponry.statDisplay.vertSpacing = 45

local orig = "_Orig"
local fallbackFuncs = {}
fallbackFuncs.roundValue = 0
fallbackFuncs.mulAmount = 1

-- this default comparator function compares values and returns color tables based on the result
function fallbackFuncs:compare(wep)
	if self.reverse then
		local var1, var2 = wep[self.varName], wep[self.origVarName]
		
		if var1 < var2 then
			return CustomizableWeaponry.textColors.POSITIVE
		elseif var1 > var2 then
			return CustomizableWeaponry.textColors.NEGATIVE
		end
	else
		local var1, var2 = wep[self.varName], wep[self.origVarName]
		
		if var1 > var2 then
			return CustomizableWeaponry.textColors.POSITIVE
		elseif var1 < var2 then
			return CustomizableWeaponry.textColors.NEGATIVE
		end
	end
	
	return CustomizableWeaponry.textColors.REGULAR
end

local percentage = "%"

function fallbackFuncs:textFunc(wep)
	local addition, finalText
	
	if self.percentage then
		addition = percentage
	end
	
	finalText = math.Round(wep[self.varName])

	if addition then
		finalText = finalText .. addition
	end
	
	return finalText
end

function fallbackFuncs:origTextFunc(wep)
	return wep[self.origVarName]
end

fallbackFuncs.mtindex = {__index = fallbackFuncs}

-- you can register stats to display by calling this function
-- take a look at the structure of already registered stats to see how it's done
function CustomizableWeaponry.statDisplay:addStat(tbl)
	-- add fallback functions
	setmetatable(tbl, fallbackFuncs.mtindex)
	
	-- setup fonts and var names
	tbl.origVarName = tbl.varName .. orig
	tbl.textFont = tbl.textFont or "CW_HUD40"
	tbl.statFont = tbl.statFont or "CW_HUD40"
	
	-- break up the line breaks into separate strings
	tbl.desc = string.Explode("\n", tbl.desc)
	
	-- increment amount of displayed stats by 1
	self.totalCount = self.totalCount + 1
	table.insert(self.registered, tbl)
end

local hud48 = "CW_HUD48"
local hud40 = "CW_HUD40"
local gradient = surface.GetTextureID("cw2/gui/gradient")

function CustomizableWeaponry.statDisplay:draw(wep, tab)
	local baseY = -self.totalCount * self.vertSpacing * 0.5 + 100
	local baseX = -100
	
	surface.SetTexture(gradient)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawTexturedRect(baseX, baseY - 170, 500, 100)
	
	draw.ShadowText(wep:getKeyBind("+attack") .. " - cycle descriptions forward", hud48, baseX + 2, baseY - 147, wep.HUDColors.white, wep.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	draw.ShadowText(wep:getKeyBind("+attack2") .. " - cycle descriptions back", hud48, baseX + 2, baseY - 96, wep.HUDColors.white, wep.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		
	draw.ShadowText("STAT", hud48, baseX, baseY, CustomizableWeaponry.textColors.REGULAR, CustomizableWeaponry.textColors.BLACK, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	draw.ShadowText("BASE", hud48, baseX + 400, baseY, CustomizableWeaponry.textColors.REGULAR, CustomizableWeaponry.textColors.BLACK, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	draw.ShadowText("CUR", hud48, baseX + 580, baseY, CustomizableWeaponry.textColors.REGULAR, CustomizableWeaponry.textColors.BLACK, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	
	surface.SetDrawColor(0, 0, 0, 150)
	
	baseY = baseY + self.vertSpacing
	
	surface.DrawRect(baseX + 340, baseY - self.vertSpacing * 0.5, 120, self.totalCount * self.vertSpacing)
	surface.DrawRect(baseX + 520, baseY - self.vertSpacing * 0.5, 120, self.totalCount * self.vertSpacing)
	
	for k, v in ipairs(self.registered) do
		-- draw stat name
		
		if tab.descOfStat == k then
			draw.ShadowText(">", v.textFont, baseX - 50, baseY + (k - 1) * self.vertSpacing, CustomizableWeaponry.textColors.POSITIVE, CustomizableWeaponry.textColors.BLACK, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			draw.ShadowText(v.display, v.textFont, baseX, baseY + (k - 1) * self.vertSpacing, CustomizableWeaponry.textColors.POSITIVE, CustomizableWeaponry.textColors.BLACK, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			
			if v.desc then
				local lines = #v.desc
				surface.SetDrawColor(0, 0, 0, 200)
				surface.DrawTexturedRect(baseX + 695, baseY - 20, 500, lines * self.vertSpacing)

				for k2, v2 in pairs(v.desc) do
					draw.ShadowText(v2, self.descFont, baseX + 700, baseY + (k2 - 1) * self.vertSpacing, CustomizableWeaponry.textColors.REGULAR, CustomizableWeaponry.textColors.BLACK, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER) 
				end
			end
		else
			draw.ShadowText(v.display, v.textFont, baseX, baseY + (k - 1) * self.vertSpacing, CustomizableWeaponry.textColors.REGULAR, CustomizableWeaponry.textColors.BLACK, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end
		
		-- draw original stat value
		draw.ShadowText(v:origTextFunc(wep), v.statFont, baseX + 400, baseY + (k - 1) * self.vertSpacing, CustomizableWeaponry.textColors.GRAY, CustomizableWeaponry.textColors.BLACK, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		
		-- draw current stat value, with cock :)
		draw.ShadowText(v:textFunc(wep), v.statFont, baseX + 580, baseY + (k - 1) * self.vertSpacing, v:compare(wep), CustomizableWeaponry.textColors.BLACK, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end
end

-- below is the registration of all displayed stats

local stat = {}
stat.varName = "Damage"
stat.display = "DAMAGE"
stat.desc = "Damage each shot deals within half its effective range."

function stat:textFunc(wep)
	return math.Round(wep.Damage) .. "x" .. wep.Shots
end

function stat:origTextFunc(wep)
	return math.Round(wep.Damage_Orig) .. "x" .. wep.Shots_Orig
end

CustomizableWeaponry.statDisplay:addStat(stat)

local stat = {}
stat.varName = "Damage"
stat.display = "DAMAGE PER MAG"
stat.desc = "Damage that can be dealt from a single magazine within\nhalf the weapon's effective range."

function stat:compare(wep)
	if wep.Damage * wep.Primary.ClipSize_Orig * wep.Shots > wep.Damage_Orig * wep.Primary.ClipSize_ORIG_REAL * wep.Shots_Orig then 
		return CustomizableWeaponry.textColors.POSITIVE
	elseif wep.Damage * wep.Primary.ClipSize_Orig * wep.Shots < wep.Damage_Orig * wep.Primary.ClipSize_ORIG_REAL * wep.Shots_Orig then
		return CustomizableWeaponry.textColors.NEGATIVE
	end
	
	return CustomizableWeaponry.textColors.REGULAR
end

function stat:textFunc(wep)
	return math.Round(wep.Damage * wep.Primary.ClipSize_Orig * wep.Shots)
end

function stat:origTextFunc(wep)
	return math.Round(wep.Damage_Orig * wep.Primary.ClipSize_ORIG_REAL * wep.Shots_Orig)
end

CustomizableWeaponry.statDisplay:addStat(stat)

local stat = {}
stat.varName = "Damage"
stat.display = "DAMAGE PER SEC"
stat.desc = "Damage that can be dealt in a single second\nwithin half the weapon's effective range."

function stat:compare(wep)
	if wep.Damage * wep.Shots / wep.FireDelay > wep.Damage_Orig * wep.Shots_Orig / wep.FireDelay_Orig  then 
		return CustomizableWeaponry.textColors.POSITIVE
	elseif wep.Damage * wep.Shots / wep.FireDelay < wep.Damage_Orig * wep.Shots_Orig / wep.FireDelay_Orig then
		return CustomizableWeaponry.textColors.NEGATIVE
	end
	
	return CustomizableWeaponry.textColors.REGULAR
end

function stat:textFunc(wep)
	return math.Round(wep.Damage * wep.Shots / wep.FireDelay)
end

function stat:origTextFunc(wep)
	return math.Round(wep.Damage_Orig * wep.Shots_Orig / wep.FireDelay_Orig)
end

CustomizableWeaponry.statDisplay:addStat(stat)

local stat = {}
stat.varName = "EffectiveRange"
stat.display = "EFFECTIVE RANGE"
stat.statFont = "CW_HUD36"
stat.desc = "The effective range of this weapon.\nOnce the bullet's flight distance surpasses 50% of this value,\nthe damage will slowly start falling off.\nDistance in meters."

function stat:compare(wep)
	if wep.EffectiveRange > wep.EffectiveRange_Orig then 
		return CustomizableWeaponry.textColors.POSITIVE
	elseif wep.EffectiveRange < wep.EffectiveRange_Orig then
		return CustomizableWeaponry.textColors.NEGATIVE
	end
	
	return CustomizableWeaponry.textColors.REGULAR
end

function stat:textFunc(wep)
	return math.Round(wep.EffectiveRange / 39.37, 1) .. "M"
end

function stat:origTextFunc(wep)
	return math.Round(wep.EffectiveRange_Orig / 39.37, 1) .. "M"
end

CustomizableWeaponry.statDisplay:addStat(stat)

local stat = {}
stat.varName = "DamageFallOff"
stat.display = "DAMAGE FALL OFF"
stat.statFont = "CW_HUD36"
stat.desc = "The shot's damage will be decreased by this much\nonce it has traveled past it's effective range.\nThe damage also lowers past 50% of the effective range."

function stat:compare(wep)
	if wep.EffectiveRange > wep.EffectiveRange_Orig then 
		return CustomizableWeaponry.textColors.POSITIVE
	elseif wep.EffectiveRange < wep.EffectiveRange_Orig then
		return CustomizableWeaponry.textColors.NEGATIVE
	end
	
	return CustomizableWeaponry.textColors.REGULAR
end

function stat:textFunc(wep)
	return math.Round(wep.DamageFallOff * 100) .. "%"
end

function stat:origTextFunc(wep)
	return math.Round(wep.DamageFallOff_Orig * 100) .. "%"
end

CustomizableWeaponry.statDisplay:addStat(stat)

local stat = {}
stat.varName = "FireDelay"
stat.display = "FIRERATE"
stat.reverse = true
stat.desc = "The weapon's rate of fire.\nThe weapon can fire this many rounds in 60 seconds."

function stat:textFunc(wep)
	return math.Round(60 / wep.FireDelay)
end

function stat:origTextFunc(wep)
	return math.Round(60 / wep.FireDelay_Orig)
end

CustomizableWeaponry.statDisplay:addStat(stat)

local stat = {}
stat.varName = "HipSpread"
stat.display = "HIP SPREAD"
stat.reverse = true
stat.desc = "The weapon's inaccuracy when firing from the hip.\nGenerally should be low for CQC weapons."

function stat:textFunc(wep)
	return math.Round(wep.HipSpread * 1000) .. "%"
end

function stat:origTextFunc(wep)
	return math.Round(wep.HipSpread_Orig * 1000) .. "%"
end

CustomizableWeaponry.statDisplay:addStat(stat)

local stat = {}
stat.varName = "AimSpread"
stat.display = "AIM ACCURACY"
stat.statFont = "CW_HUD36"
stat.reverse = true
stat.desc = "The weapon's accuracy when firing while aiming.\nAcceptable percentage for mid-range: 87% and up\nAcceptable percentage for long range: 95% and up"

function stat:textFunc(wep)
	return math.Round((100 - wep.AimSpread * 1000), 1) .. "%"
end

function stat:origTextFunc(wep)
	return math.Round((100 - wep.AimSpread_Orig * 1000), 1) .. "%"
end

CustomizableWeaponry.statDisplay:addStat(stat)

local stat = {}
stat.varName = "ClumpSpread"
stat.display = "CLUMP SPREAD"
stat.statFont = "CW_HUD36"
stat.reverse = true
stat.desc = "The shot's clump spread.\nEach buckshot's clump has a maximum spread of this value."

function stat:compare(wep)
	-- if the weapon has clump spread now, but originally had none, that's a bad thing
	if wep.ClumpSpread and not wep.ClumpSpread_Orig then
		return CustomizableWeaponry.textColors.NEGATIVE
	end
	
	-- if it does not have clump spread now, but it had originally, that's a good thing
	if not wep.ClumpSpread and wep.ClumpSpread_Orig then
		return CustomizableWeaponry.textColors.POSITIVE
	end
	
	if wep.ClumpSpread and wep.ClumpSpread_Orig then
		-- if it has clump spread, and it's lower than the original clump spread - it's good; otherwise - it's bad
		if wep.ClumpSpread < wep.ClumpSpread_Orig then
			return CustomizableWeaponry.textColors.POSITIVE
		elseif wep.ClumpSpread > wep.ClumpSpread_Orig then
			return CustomizableWeaponry.textColors.NEGATIVE
		end
	end
	
	-- none of the conditions match, that means there is no difference between now and then
	return CustomizableWeaponry.textColors.REGULAR
end

function stat:textFunc(wep)
	if wep.ClumpSpread then
		return math.Round(wep.ClumpSpread * 1000) .. "%"
	end
	
	return "N/A"
end

function stat:origTextFunc(wep)
	if wep.ClumpSpread_Orig then
		return math.Round(wep.ClumpSpread_Orig * 1000) .. "%"
	end
	
	return "N/A"
end

CustomizableWeaponry.statDisplay:addStat(stat)

local stat = {}
stat.varName = "SpreadPerShot"
stat.display = "SPREAD PER SHOT"
stat.statFont = "CW_HUD36"
stat.reverse = true
stat.desc = "Spread added per each shot."

function stat:textFunc(wep)
	return "+" .. math.Round(wep.SpreadPerShot * 1000, 1) .. "%"
end

function stat:origTextFunc(wep)
	return "+" .. math.Round(wep.SpreadPerShot_Orig * 1000, 1) .. "%"
end

CustomizableWeaponry.statDisplay:addStat(stat)

local stat = {}
stat.varName = "MaxSpreadInc"
stat.display = "MAX SPREAD INC"
stat.statFont = "CW_HUD36"
stat.reverse = true
stat.desc = "How much additional spread can the weapon accumulate\nfrom continuous fire.\nLower percentages allow for more rounds to be fired without\nhaving to take breaks from firing to normalize the spread."

function stat:textFunc(wep)
	return "+" .. math.Round(wep.MaxSpreadInc * 1000, 1) .. "%"
end

function stat:origTextFunc(wep)
	return "+" .. math.Round(wep.MaxSpreadInc_Orig * 1000, 1) .. "%"
end

CustomizableWeaponry.statDisplay:addStat(stat)

local stat = {}
stat.varName = "Recoil"
stat.display = "RECOIL"
stat.reverse = true
stat.desc = "The weapon's recoil from each shot.\nWeapon recoil increases as your weapon's accuracy\nlowers from continuous fire."

function stat:textFunc(wep)
	return math.Round(wep.Recoil / 3 * 100) .. "%"
end

function stat:origTextFunc(wep)
	return math.Round(wep.Recoil_Orig / 3 * 100) .. "%"
end

CustomizableWeaponry.statDisplay:addStat(stat)

local stat = {}
stat.varName = "VelocitySensitivity"
stat.display = "MOBILITY"
stat.reverse = true
stat.desc = "Defines how much spread will be added to the weapon\nwhen moving. Higher values mean less spread.\nTaking aim while moving greatly reduces the spread increase."

function stat:textFunc(wep)
	return math.Round(100 - wep.VelocitySensitivity / 3 * 100) .. "%"
end

function stat:origTextFunc(wep)
	return math.Round(100 - wep.VelocitySensitivity_Orig / 3 * 100) .. "%"
end

CustomizableWeaponry.statDisplay:addStat(stat)

local stat = {}
stat.varName = "OverallMouseSens"
stat.display = "HANDLING"
stat.desc = "Affects mouse sensitivity and weapon controllability during sustained fire.\nLower means less sensitivity, and less control over the weapon when sustaining fire.\nIn general should be as high as possible for CQC weapons."

function stat:textFunc(wep)
	return math.Round((wep.OverallMouseSens / 1) * 100) .. "%"
end

function stat:origTextFunc(wep)
	return math.Round((wep.OverallMouseSens_Orig / 1) * 100) .. "%"
end

CustomizableWeaponry.statDisplay:addStat(stat)

local stat = {}
stat.varName = "DeployTime"
stat.display = "DEPLOY TIME"
stat.desc = "Time it takes in seconds to have the weapon be combat-ready upon deploying."

function stat:compare(wep)
	local orig = wep.DeployTime_Orig / wep.DrawSpeed_Orig
	local cur = wep.DeployTime / wep.DrawSpeed
	
	if cur < orig then
		return CustomizableWeaponry.textColors.POSITIVE
	elseif cur > orig then
		return CustomizableWeaponry.textColors.NEGATIVE
	end

	-- none of the conditions match, that means there is no difference between now and then
	return CustomizableWeaponry.textColors.REGULAR
end

function stat:textFunc(wep)
	return math.Round(wep.DeployTime / wep.DrawSpeed, 2) .. "s"
end

function stat:origTextFunc(wep)
	return math.Round(wep.DeployTime_Orig / wep.DrawSpeed_Orig, 2) .. "s"
end

CustomizableWeaponry.statDisplay:addStat(stat)

local stat = {}
stat.varName = "ReloadHalt"
stat.display = "RELOAD TIME"
stat.desc = "Time it takes in seconds to do a partial weapon reload.\nFor shotguns it indicates the amount of time taken to bring the gun up\nand insert one shell."

function stat:compare(wep)
	if wep.ShotgunReload then
		local time = self:shotgunTextFunc(wep)
		
		if time / wep.ReloadSpeed < time / wep.ReloadSpeed_Orig then
			return CustomizableWeaponry.textColors.POSITIVE
		elseif time / wep.ReloadSpeed > time / wep.ReloadSpeed_Orig then
			return CustomizableWeaponry.textColors.NEGATIVE
		end
		
		return CustomizableWeaponry.textColors.REGULAR
	end
	
	local orig = wep.ReloadHalt_Orig / wep.ReloadSpeed_Orig
	local cur = wep.ReloadHalt / wep.ReloadSpeed
	
	if cur < orig then
		return CustomizableWeaponry.textColors.POSITIVE
	elseif cur > orig then
		return CustomizableWeaponry.textColors.NEGATIVE
	end

	-- none of the conditions match, that means there is no difference between now and then
	return CustomizableWeaponry.textColors.REGULAR
end

function stat:shotgunTextFunc(wep)
	return (wep.ReloadStartTime + wep.InsertShellTime)
end

function stat:textFunc(wep)
	if wep.ShotgunReload then
		return math.Round(self:shotgunTextFunc(wep) / wep.ReloadSpeed, 2) .. "s"
	end
	
	return math.Round(wep.ReloadHalt / wep.ReloadSpeed, 2) .. "s"
end

function stat:origTextFunc(wep)
	if wep.ShotgunReload then
		return math.Round(self:shotgunTextFunc(wep) / wep.ReloadSpeed_Orig, 2) .. "s"
	end
	
	return math.Round(wep.ReloadHalt_Orig / wep.ReloadSpeed_Orig, 2) .. "s"
end

CustomizableWeaponry.statDisplay:addStat(stat)

local stat = {}
stat.varName = "ReloadHalt_Empty"
stat.display = "FULL RELOAD TIME"
stat.desc = "Time it takes in seconds to do a full weapon reload.\nFor shotguns it indicates the time it takes to fully reload an empty weapon."

function stat:compare(wep)
	if wep.ShotgunReload then
		local time = self:shotgunTextFunc(wep)
		
		if time / wep.ReloadSpeed < time / wep.ReloadSpeed_Orig then
			return CustomizableWeaponry.textColors.POSITIVE
		elseif time / wep.ReloadSpeed > time / wep.ReloadSpeed_Orig then
			return CustomizableWeaponry.textColors.NEGATIVE
		end
		
		return CustomizableWeaponry.textColors.REGULAR
	end
	
	local orig = wep.ReloadHalt_Empty_Orig / wep.ReloadSpeed_Orig
	local cur = wep.ReloadHalt_Empty / wep.ReloadSpeed
	
	if cur < orig then
		return CustomizableWeaponry.textColors.POSITIVE
	elseif cur > orig then
		return CustomizableWeaponry.textColors.NEGATIVE
	end

	-- none of the conditions match, that means there is no difference between now and then
	return CustomizableWeaponry.textColors.REGULAR
end

function stat:shotgunTextFunc(wep)
	return (wep.ReloadStartTime + wep.InsertShellTime * wep.Primary.ClipSize + wep.ReloadFinishWait)
end

function stat:textFunc(wep)
	if wep.ShotgunReload then
		return math.Round(self:shotgunTextFunc(wep) / wep.ReloadSpeed, 2) .. "s"
	end
	
	return math.Round(wep.ReloadHalt_Empty / wep.ReloadSpeed, 2) .. "s"
end

function stat:origTextFunc(wep)
	if wep.ShotgunReload then
		return math.Round(self:shotgunTextFunc(wep) / wep.ReloadSpeed_Orig, 2) .. "s"
	end
	
	return math.Round(wep.ReloadHalt_Empty_Orig / wep.ReloadSpeed_Orig, 2) .. "s"
end

CustomizableWeaponry.statDisplay:addStat(stat)


================================================
FILE: cw2/lua/cw/client/cw_umsgs.lua
================================================
local function CW20_LOSTATTACHMENTS()
	local ply = LocalPlayer()

	CustomizableWeaponry.postSpawn(ply)
end

usermessage.Hook("CW20_LOSTATTACHMENTS", CW20_LOSTATTACHMENTS)

-- this event removes previous attachments and adds new ones
net.Receive("CW20_OVERWRITEATTACHMENTS", function()
	local ply = LocalPlayer()
	
	ply.CWAttachments = ply.CWAttachments or {}
	local ply = LocalPlayer()
	local str = net.ReadString()
	
	-- remove previous attachments
	for k, v in pairs(ply.CWAttachments) do
		ply.CWAttachments[k] = nil
	end

	CustomizableWeaponry.decodeAttachmentString(ply, str)
end)

net.Receive("CW20_NEWATTACHMENTS", function()
	local ply = LocalPlayer()
	local str = net.ReadString()

	CustomizableWeaponry.decodeAttachmentString(ply, str)
end)

local comma = ", "

net.Receive("CW20_NEWATTACHMENTS_NOTIFY", function()
	local ply = LocalPlayer()
	local str = net.ReadString()
	
	-- decode the string
	local attNames = string.Explode(" ", str)
	
	-- figure out how many attachments we're missing
	local missingAttachments = CustomizableWeaponry:countMissingAttachments(ply, attNames)
	
	local final = ""
	local arraySize = #attNames
	
	local found = false
	
	-- assemble the attachment names
	for k, v in ipairs(attNames) do
		local target = CustomizableWeaponry.registeredAttachmentsSKey[v]
		
		-- make sure the player has the attachment and the specified attachment actually exists
		if target and not ply.CWAttachments[v] then
			if k == arraySize then
				final = final .. target.displayName
			else
				-- if only 1 attachment is missing, we shouldn't place a comma
				if missingAttachments == 1 then
					final = final .. target.displayName
				else
					final = final .. target.displayName .. comma
				end
			end
			
			-- add the attachments to the clientside table
			ply.CWAttachments[v] = true
			
			found = true
		end
	end
	
	if found then
		-- print the attachments we got
		chat.AddText(Color(255, 255, 255, 255), "Got new attachments: ", Color(0, 175, 255, 255), final, Color(255, 255, 255, 255), ".")
	else
		-- if there are none, let the player know (this shouldn't happen, since he shouldn't be able to pick up a package the contents of which he already has anyway)
		chat.AddText(Color(255, 175, 175, 255), "Got no new attachments from package.")
	end
end)


================================================
FILE: cw2/lua/cw/server/cw_concommands.lua
================================================
local function CW20_ApplyChanges(ply, com, args)
	if not ply:IsAdmin() then
		return
	end
	
	local newLine = "\n"
	local space = " "
	
	-- process attachments
	for k, v in ipairs(CustomizableWeaponry.registeredAttachments) do
		local value = tonumber(ply:GetInfo(v.clcvar))
		
		game.ConsoleCommand(v.cvar .. space .. value .. newLine)
	end
	
	timer.Simple(0, function()
		CustomizableWeaponry:updateAdminCVars()
	end)
end

concommand.Add("cw_applychanges", CW20_ApplyChanges)

local function CW20_DisableAllAttachmentsOnSpawn(ply, com, args)
	if not ply:IsAdmin() then
		return
	end
	
	for key, attData in ipairs(CustomizableWeaponry.registeredAttachments) do
		game.ConsoleCommand(attData.cvar .. " 0\n")
	end
end

concommand.Add("cw_disable_all_attachments_on_spawn", CW20_DisableAllAttachmentsOnSpawn)

local function CW20_EnableAllAttachmentsOnSpawn(ply, com, args)
	if not ply:IsAdmin() then
		return
	end
	
	for key, attData in ipairs(CustomizableWeaponry.registeredAttachments) do
		game.ConsoleCommand(attData.cvar .. " 1\n")
	end
end

concommand.Add("cw_enable_all_attachments_on_spawn", CW20_EnableAllAttachmentsOnSpawn)

local function CW20_DropWeapon(ply, com, args) -- makes you drop your CW 2.0 weapon with all attachments stored on it
	if not CustomizableWeaponry.canDropWeapon then
		return
	end
	
	if not ply:Alive() then
		return
	end
	
	CustomizableWeaponry:dropWeapon(ply)
end

concommand.Add("cw_dropweapon", CW20_DropWeapon)


================================================
FILE: cw2/lua/cw/server/cw_hooks.lua
================================================
function CustomizableWeaponry.PlayerInitialSpawn(ply)
	timer.Simple(3, function()
		CustomizableWeaponry.postSpawn(ply)
	end)
end

hook.Add("PlayerInitialSpawn", "CustomizableWeaponry.PlayerInitialSpawn", CustomizableWeaponry.PlayerInitialSpawn)

function CustomizableWeaponry.PlayerSpawn(ply)
	CustomizableWeaponry.postSpawn(ply)
end

hook.Add("PlayerSpawn", "CustomizableWeaponry.PlayerSpawn", CustomizableWeaponry.PlayerSpawn)

function CustomizableWeaponry.AllowPlayerPickup(ply, ent)
	wep = ply:GetActiveWeapon()
	
	if wep.CW20Weapon then
		return false
	end
end

hook.Add("AllowPlayerPickup", "CustomizableWeaponry.AllowPlayerPickup", CustomizableWeaponry.AllowPlayerPickup)


================================================
FILE: cw2/lua/cw/server/cw_weapondrop.lua
================================================
CustomizableWeaponry.canDropWeapon = true -- set this to false to disable cw_dropweapon concommand
CustomizableWeaponry.enableWeaponDrops = true -- set this to false to disable weapon dropping in general (no idea why you would want to do that though)

function CustomizableWeaponry:dropWeapon(ply, wep, velocity, angleVelocity, pos, ang)
	if not self.enableWeaponDrops then
		return
	end
	
	wep = wep or ply:GetActiveWeapon()
	
	if not IsValid(wep) or not wep.CW20Weapon or wep.disableDropping then
		return
	end
	
	local eyePos = nil
	
	if not pos then
		eyePos = ply:EyePos()
		local aimVec = ply:GetAimVector()
		eyePos = eyePos + aimVec * 40
	else
		eyePos = pos
	end
	
	local eyeAng = nil
	
	if not ang then
		eyeAng = ply:EyeAngles()
		eyeAng:RotateAroundAxis(eyeAng:Up(), 90)
	else
		eyeAng = ang
	end
	
	local droppedWep = ents.Create("cw_dropped_weapon")
	droppedWep:SetPos(eyePos)
	droppedWep:SetAngles(eyeAng)
	droppedWep:setWeapon(wep)
	
	droppedWep:Spawn()
	droppedWep:Activate()
	
	local physObj = droppedWep:GetPhysicsObject()
	
	if velocity then
		physObj:SetVelocity(velocity)
	end
	
	if angleVelocity then
		physObj:AddAngleVelocity(angleVelocity)
	end
	
	CustomizableWeaponry.callbacks.processCategory(wep, "droppedWeapon", droppedWep)
	
	ply:StripWeapon(wep:GetClass())
end


================================================
FILE: cw2/lua/cw/shared/cw_actionsequences.lua
================================================
AddCSLuaFile()

-- GMod's stock timers are clunky as all fuck, so I just made my own timer system
-- with less pointless shit and more straight to the point functionality
-- the :process function is called within the SWEP's Think function
-- this is not intended to be used as a replacement for the timer system in garry's mod, but rather to time specific actions that bring a global delay (to all actions) on the weapon
-- the action sequences are unique to each weapon, meaning that the moment the player dies/loses the weapon object, all active action sequences will not be processed
-- this is very useful to not do consistency checks
-- these are designed to be used when the holstering is temporarily disabled (holstering/throwing grenades, etc.)
-- this class is a critical part of CW 2.0, don't remove it

CustomizableWeaponry.actionSequence = {}

function CustomizableWeaponry.actionSequence:new(time, actionDelay, func)
	-- don't insert nil
	if not func or not time then
		return
	end
	
	local CT = UnPredictedCurTime()
	
	table.insert(self._activeSequences, {time = CT + time, func = func})
	
	if actionDelay then
		self:setGlobalDelay(actionDelay)
	end
end

function CustomizableWeaponry.actionSequence:process()
	local CT = UnPredictedCurTime()
	
	for k, v in pairs(self._activeSequences) do
		if CT >= v.time then
			v.func()
			self._activeSequences[k] = nil
		end
	end
	
	table.Sanitise(self._activeSequences)
end


================================================
FILE: cw2/lua/cw/shared/cw_ammo.lua
================================================
AddCSLuaFile()

CustomizableWeaponry.ammoTypes = CustomizableWeaponry.ammoTypes or {}

-- base ammo registration function
function CustomizableWeaponry:registerAmmo(name, text, bulletDiameter, caseLength)
	CustomizableWeaponry.ammoTypes[name] = {bulletDiameter = bulletDiameter, caseLength = caseLength}
	
	game.AddAmmoType({name = name,
	dmgtype = DMG_BULLET})
	
	if CLIENT then
		language.Add(name .. "_ammo", text)
	end
end

-- aliases
CustomizableWeaponry.registerAmmoType = CustomizableWeaponry.registerAmmo
CustomizableWeaponry.registerNewAmmo = CustomizableWeaponry.registerAmmo

CustomizableWeaponry:registerAmmo("7.62x39MM", "7.62x39MM Rounds", 7.62, 39)
CustomizableWeaponry:registerAmmo("7.62x51MM", "7.62x51MM Rounds", 7.62, 51)
CustomizableWeaponry:registerAmmo("7.62x54MMR", "7.62x54MMR Rounds", 7.62, 39)
CustomizableWeaponry:registerAmmo("5.45x39MM", "5.45x39MM Rounds", 5.45, 39)
CustomizableWeaponry:registerAmmo("5.56x45MM", "5.56x45MM Rounds", 5.56, 45)
CustomizableWeaponry:registerAmmo("5.7x28MM", "5.7x28MM Rounds", 5.7, 28)
CustomizableWeaponry:registerAmmo(".44 Magnum", ".44 Magnum Rounds", 10.9, 32.6)
CustomizableWeaponry:registerAmmo(".45 ACP", ".45 ACP Rounds", 11.5, 22.8)
CustomizableWeaponry:registerAmmo(".50 AE", ".50 AE Rounds", 12.7, 32.6)
CustomizableWeaponry:registerAmmo("9x19MM", "9x19MM Rounds", 9, 19)
CustomizableWeaponry:registerAmmo("12 Gauge", "12 Gauge Rounds", 5, 10)
CustomizableWeaponry:registerAmmo("40MM", "40MM Grenades", 0, 0)
CustomizableWeaponry:registerAmmo("Frag Grenades", "Frag Grenades", 0, 0)
CustomizableWeaponry:registerAmmo("Smoke Grenades", "Smoke Grenades", 0, 0)
CustomizableWeaponry:registerAmmo("Flash Grenades", "Flash Grenades", 0, 0)


================================================
FILE: cw2/lua/cw/shared/cw_attachmentpossession.lua
================================================
AddCSLuaFile()

if SERVER then
	CreateConVar("cw_keep_attachments_post_death", 0, {FCVAR_ARCHIVE, FCVAR_NOTIFY}, "Should players keep their attachments after they die?")
	
	util.AddNetworkString("CW20_OVERWRITEATTACHMENTS")
	util.AddNetworkString("CW20_NEWATTACHMENTS")
	util.AddNetworkString("CW20_NEWATTACHMENTS_NOTIFY")
end

CustomizableWeaponry.useAttachmentPossessionSystem = true -- change this to false if you want to disable attachment possession restrictions (aka all attachments available regardless of whether the players have them or not)
CustomizableWeaponry.suppressOnSpawnAttachments = false

function CustomizableWeaponry:initCWVariables()
	if not self.CWAttachments then
		self.CWAttachments = {}
	end
end

local empty, space = "", " "

function CustomizableWeaponry:buildAttachmentString()
	local final = ""
	
	-- loop through the attachment table, find attachments that are given on spawn and concatenate a string that we'll network with them
	-- also add attachments to the serverside player attachment table to save a loop
	for k, v in ipairs(CustomizableWeaponry.registeredAttachments) do
		if GetConVarNumber(v.cvar) >= 1 then
			if not self.CWAttachments[v.name] then
				self.CWAttachments[v.name] = true
				
				if final == empty then
					final = v.name
				else
					final = final .. space .. v.name
				end
			end
		end
	end
	
	return final
end

function CustomizableWeaponry:decodeAttachmentString(str)
	self.CWAttachments = self.CWAttachments or {}
	
	local result = string.Explode(space, str)
	
	for k, v in pairs(result) do
		self.CWAttachments[v] = true
	end
end

function CustomizableWeaponry:postSpawn()
	if not self.CWAttachments then
		CustomizableWeaponry.initCWVariables(self)
		return
	end
	
	if CustomizableWeaponry.useAttachmentPossessionSystem and not CustomizableWeaponry.suppressOnSpawnAttachments then
		if SERVER then
			local keepAttachments = GetConVarNumber("cw_keep_attachments_post_death") >= 1
			
			if not keepAttachments then
				for k, v in pairs(self.CWAttachments) do
					self.CWAttachments[k] = nil
				end
				
				local attachments = CustomizableWeaponry.buildAttachmentString(self)
				
				if attachments ~= empty then
					net.Start("CW20_OVERWRITEATTACHMENTS")
						net.WriteString(attachments)
					net.Send(self)
				else
					SendUserMessage("CW20_LOSTATTACHMENTS", self)
				end
			else
				local attachments = CustomizableWeaponry.buildAttachmentString(self)
				
				if attachments ~= empty then
					net.Start("CW20_NEWATTACHMENTS")
						net.WriteString(attachments)
					net.Send(self)
				end
			end
		else
			for k, v in pairs(self.CWAttachments) do
				self.CWAttachments[k] = nil
			end
		end
	end
	
	CustomizableWeaponry.callbacks.processCategory(self, "postSpawn")
end

function CustomizableWeaponry:hasAttachment(ply, att, lookIn)
	if not self.useAttachmentPossessionSystem then
		return true
	end
	
	lookIn = lookIn or ply.CWAttachments
	
	local has = hook.Call("CW20HasAttachment", nil, ply, att, lookIn)
	
	if lookIn[att] or has then
		return true
	end
	
	return false
end

-- this function checks whether the player has specified attachments in his inventory
-- accepts an array
function CustomizableWeaponry:hasSpecifiedAttachments(ply, tbl)
	-- failsafes, failsafes everywhere
	ply.CWAttachments = ply.CWAttachments or {}
	
	if not self.useAttachmentPossessionSystem then
		return true
	end
	
	for k, v in ipairs(tbl) do
		if not ply.CWAttachments[v] then
			return false
		end
	end
	
	return true
end

function CustomizableWeaponry:countMissingAttachments(ply, tbl)
	if not self.useAttachmentPossessionSystem then
		return 0
	end
	
	local count = 0
	
	for k, v in ipairs(tbl) do
		if not ply.CWAttachments[v] then
			count = count + 1
		end
	end
	
	return count
end

function CustomizableWeaponry:updateAdminCVars()
	for k, v in pairs(player.GetAll()) do
		if v:IsAdmin() then
			for k2, v2 in ipairs(CustomizableWeaponry.registeredAttachments) do
				v:ConCommand(v2.clcvar .. space .. GetConVarNumber(v2.cvar))
			end
		end
	end
end

function CustomizableWeaponry:giveAttachment(ply, att, noNetwork)
	if not att or not ply or not IsValid(ply) then
		return
	end
	
	ply.CWAttachments[att] = true
	
	if not noNetwork then
		umsg.Start("CW20_NEWATTACHMENT", ply)
			umsg.String(att)
		umsg.End()
	end
end

-- use this func when you want to send a certain amount of specific attachments to the client
function CustomizableWeaponry:giveAttachments(tbl, dontNotify, overwrite)
	CustomizableWeaponry.initCWVariables(self)
	
	-- add the attachments to the player's inventory
	for k, v in ipairs(tbl) do
		if CustomizableWeaponry.registeredAttachmentsSKey[v] then
			self.CWAttachments[v] = true
		end
	end
	
	-- concatenate the table into a string
	local result = table.concat(tbl, " ")
	
	if SERVER then
		-- send it to the client
		
		if overwrite then
			net.Start("CW20_OVERWRITEATTACHMENTS")
				net.WriteString(result)
			net.Send(self)
		else
			if dontNotify then
				net.Start("CW20_NEWATTACHMENTS")
					net.WriteString(result)
				net.Send(self)
			else
				net.Start("CW20_NEWATTACHMENTS_NOTIFY")
					net.WriteString(result)
				net.Send(self)
			end
		end
	end
end

function CustomizableWeaponry:giveAllAttachments(ply, att)
	if not att or not ply or not IsValid(ply) then
		return
	end
	
	for k, v in ipairs(CustomizableWeaponry.registeredAttachments) do
		ply.CWAttachments[v.name] = true
	end
	
	umsg.Start("CW20_ALLATTACHMENTS", ply)
		umsg.String(att)
	umsg.End()
end

function CustomizableWeaponry:removeAllAttachments(ply)
	net.Start("CW20_OVERWRITEATTACHMENTS")
		net.WriteString("")
	net.Send(ply)
	
	table.Empty(ply.CWAttachments)
end

function CustomizableWeaponry:removeAttachment(ply, att, noNetwork)
	if not att or not ply or not IsValid(ply) then
		return
	end
	
	ply.CWAttachments[att] = nil

	if not noNetwork then
		umsg.Start("CW20_REMOVEATTACHMENT", ply)
			umsg.String(att)
		umsg.End()
	end
end

-- builds attachment name strings for display on package entities
function CustomizableWeaponry:ent_buildAttachmentNameStrings(tbl)
	local result = {}
	
	for k, v in ipairs(tbl) do
		local att = CustomizableWeaponry.registeredAttachmentsSKey[v]
		
		if att then
			table.insert(result, {name = att.name, display = att.displayName})
		end
	end
	
	return result
end


================================================
FILE: cw2/lua/cw/shared/cw_attachments.lua
================================================
AddCSLuaFile()

-- thanks to this module/plug-in based design, you can simply change a few vars to whatever you wish to get the desired functionality in your gamemode without having to modify the base itself

CustomizableWeaponry.registeredAttachments = {}
CustomizableWeaponry.registeredAttachmentsSKey = {} -- SKey stands for 'string key', whereas the registeredAttachments has numerical indexes
CustomizableWeaponry.suppressors = {}
CustomizableWeaponry.sights = {}
CustomizableWeaponry.knownStatTexts = {}
CustomizableWeaponry.knownVariableTexts = {}
CustomizableWeaponry.giveAllAttachmentsOnSpawn = 1 -- set to 0 to disable all attachments on spawn
CustomizableWeaponry.canOpenInteractionMenu = true -- whether the interaction menu can be opened
CustomizableWeaponry.playSoundsOnInteract = true -- whether it should play sounds when interacting with the weapon (attaching stuff, changing ammo, etc)
CustomizableWeaponry.customizationEnabled = true -- whether we can customize our guns in general
CustomizableWeaponry.customizationMenuKey = "+menu_context" -- the key we need to press to toggle the customization menu

CustomizableWeaponry.textColors = {POSITIVE = Color(177, 216, 171, 255),
	NEGATIVE = Color(229, 150, 133, 255),
	VPOSITIVE = Color(190, 242, 181, 255),
	VNEGATIVE = Color(247, 156, 136, 255),
	REGULAR = Color(255, 255, 255, 255),
	COSMETIC = Color(169, 240, 255, 255),
	BLACK = Color(0, 0, 0, 255),
	GRAY = Color(200, 200, 200, 255)}
	
CustomizableWeaponry.sounds = {UNSUPPRESSED = 0,
	SUPPRESSED = 1}
	
local fallbackFuncs = {}

function fallbackFuncs:canEquip()
	return true
end

local totalAtts = 1

-- base func for registering atts
function CustomizableWeaponry:registerAttachment(tbl)
	-- register suppressors in a separate table with it's name as a key to avoid having to loop when doing stuff with attachments
	if tbl.isSuppressor then
		CustomizableWeaponry.suppressors[tbl.name] = tbl
	end
	
	if tbl.isSight then
		CustomizableWeaponry.sights[tbl.name] = tbl
	end
	
	if tbl.reticle then
		tbl._reticle = Material(tbl.reticle)
		tbl._reticleIcon = surface.GetTextureID(tbl.reticle)
	end
	
	tbl.id = totalAtts
	
	-- create convars for setting up which attachments should be given upon spawn
	
	if SERVER then
		local cvName = "cw_att_" .. tbl.name
		CreateConVar(cvName, CustomizableWeaponry.giveAllAttachmentsOnSpawn, {FCVAR_ARCHIVE, FCVAR_NOTIFY})
		tbl.cvar = cvName
	end
	
	local cvName = "cw_att_" .. tbl.name .. "_cl"
	
	if CLIENT then
		CreateClientConVar(cvName, CustomizableWeaponry.giveAllAttachmentsOnSpawn, true, true)
	end
	
	tbl.clcvar = cvName
	
	-- set the metatable of the current attachment to a fallback table, so that we can fallback to pre-defined funcs in case we're calling a nil method
	setmetatable(tbl, {__index = fallbackFuncs})
	
	tbl.FOVModifier = tbl.FOVModifier and tbl.FOVModifier or 15
	
	local val, key = self:findAttachment(tbl.name)
	-- don't register attachments that are already registered
	
	if val then
		-- instead, just override them
		self.registeredAttachments[key] = tbl
		self.registeredAttachmentsSKey[tbl.name] = tbl
		return
	end
	
	if CLIENT then
		if tbl.description then
			tbl._description = {}
			
			for a, b in ipairs(tbl.description) do
				tbl._description[a] = b
			end
		end
		
		self:createStatText(tbl)
	end

	table.insert(self.registeredAttachments, tbl)
	
	self.registeredAttachmentsSKey[tbl.name] = tbl
	
	totalAtts = totalAtts + 1
end

function CustomizableWeaponry:findAttachment(name)
	-- find the matching attachment
	for k, v in ipairs(self.registeredAttachments) do
		if v.name == name then
			return v, k
		end
	end
	
	-- if there is none, return nil
	return nil
end

function CustomizableWeaponry:canBeAttached(attachmentData, attachmentList)
	if not attachmentData.dependencies then
		return true
	end
	
	attachmentList = attachmentList or self.Attachments
	
	local dependency = nil
	
	for k, v in pairs(attachmentList) do
		if v.last then
			for k2, v2 in ipairs(v.atts) do
				if attachmentData.dependencies[v2] then
					if v.last == k2 then
						return true
					else
						dependency = attachmentData.dependencies[v2]
					end
				end
			end
		end
	end
	
	return false, dependency
end

local emptyString = ""

function CustomizableWeaponry:formAdditionalText(att)
	if att.isGrenadeLauncher then
		return CustomizableWeaponry.grenadeTypes.getGrenadeText(self)
	end
	
	return emptyString
end

function CustomizableWeaponry:cycleSubCustomization()
	if self.SightColorTarget then
		CustomizableWeaponry.colorableParts.cycleColor(self, self.SightColorTarget)
	elseif self.GrenadeTarget then
		CustomizableWeaponry.grenadeTypes.cycleGrenades(self)
	end
	
	self.SubCustomizationCycleTime = nil
end

local by = " by "
local percentage = "%"

local tempPositive = {}
local tempNegative = {}

function CustomizableWeaponry:prepareText(text, color)
	if text and color then -- sort into 2 different tables
		if color == CustomizableWeaponry.textColors.POSITIVE then
			table.insert(tempPositive, {t = text, c = color})
		else
			table.insert(tempNegative, {t = text, c = color})
		end
	end
end

-- this func is called only once per attachment, so don't worry about a possible performance bottleneck, even if it has a lot of loops
function CustomizableWeaponry:createStatText(att)
	-- no point in doing anything if there are no stat modifiers
	if not att.statModifiers then
		return
	end
	
	-- create a new desc table regardless
	att.description = {}
	
	if att._description then
		for key, data in ipairs(att._description) do
			att.description[key] = data
		end
	end
	
	local pos = 0
	
	-- get position of positive stat text
	for key, value in ipairs(att.description) do
		if value.c == CustomizableWeaponry.textColors.POSITIVE or value.c == CustomizableWeaponry.textColors.VPOSITIVE then
			pos = math.max(pos, key) + 1
		end
	end
	
	-- if there is none, assume first possible position
	if pos == 0 then
		pos = #att.description + 1
	end
	
	-- loop through, format negative and positive texts into 2 separate tables
	for stat, amount in pairs(att.statModifiers) do
		self:prepareText(self:formatWeaponStatText(stat, amount))
	end
	
	for stat, data in pairs(CustomizableWeaponry.knownVariableTexts) do
		if att[stat] then
			self:prepareText(self:formatWeaponVariableText(att, stat, data))
		end
	end
	
	-- now insert the positive text first and increment the position of positive text by 1 (since it's positive text we're inserting)
	for key, data in ipairs(tempPositive) do
		table.insert(att.description, pos, data)
		pos = pos + 1
	end
	
	-- now insert negative text, but don't increment the position, since it's negative text
	for key, data in ipairs(tempNegative) do
		table.insert(att.description, pos, data)
	end
	
	table.Empty(tempNegative)
	table.Empty(tempPositive)
	
	-- loop through, find the spot where the positive stat text is
	--[[for k, v in ipairs(att.description) do
		if v.c == CustomizableWeaponry.textColors.POSITIVE or v.c == CustomizableWeaponry.textColors.VPOSITIVE then
			pos = k + 1
			break
		end
	end
	
	-- loop through, insert POSITIVE text, count amount of text inserts
	for stat, amount in pairs(att.statModifiers) do
		local text, color = self:formatWeaponStatText(stat, amount)
		
		if text and color and color == CustomizableWeaponry.textColors.POSITIVE then
			table.insert(att.description, pos, {t = text, c = color})
		end
	end
	
	pos = nil
	
	-- loop through again, this time, find where the negative text is
	for k, v in ipairs(att.description) do
		if v.c == CustomizableWeaponry.textColors.NEGATIVE or v.c == CustomizableWeaponry.textColors.VNEGATIVE then
			pos = k + 1
			break
		end
	end
	
	-- if there is none, assume bottom of description table
	
	if not pos then
		pos = #att.description + 1
	end
	
	for stat, amount in pairs(att.statModifiers) do
		local text, color = self:formatWeaponStatText(stat, amount)
		
		if text and color and color == CustomizableWeaponry.textColors.NEGATIVE then
			table.insert(att.description, pos, {t = text, c = color})
		end
	end]]--
end

function CustomizableWeaponry:formatWeaponStatText(target, amount)
	local statText = self.knownStatTexts[target]
	
	if statText then
		-- return text and colors as specified in the table
		if amount < 0 then
			return statText.lesser .. by .. math.Round(math.abs(amount * 100), 1) .. percentage, statText.lesserColor
		elseif amount > 0 then
			return statText.greater .. by .. math.Round(math.abs(amount * 100), 1) .. percentage, statText.greaterColor
		end
	end
	
	-- no result, rip
	return nil
end

function CustomizableWeaponry:formatWeaponVariableText(attachmentData, variable, varData)
	local var = attachmentData[variable]

	if var then
		if varData.formatText then
			return varData.formatText(attachmentData, var, varData)
		else
			if var < 0 then
				return varData.lesser .. by .. var, varData.lesserColor
			elseif var > 0 then
				return varData.greater .. by .. var, varData.greaterColor
			end
		end
	end
end

-- 'name' - name of the stat in the 'statModifiers' table
-- 'greaterThan' - the text to display when the stat is greater than zero
-- 'lesserThan' - the text to display when the stat is lesser than zero
function CustomizableWeaponry:registerRecognizedStat(name, lesser, greater, lesserColor, greaterColor)
	self.knownStatTexts[name] = {lesser = lesser, greater = greater, lesserColor = lesserColor, greaterColor = greaterColor}
end

function CustomizableWeaponry:registerRecognizedVariable(name, lesser, greater, lesserColor, greaterColor, attachCallback, detachCallback, formatText)
	self.knownVariableTexts[name] = {lesser = lesser, greater = greater, lesserColor = lesserColor, greaterColor = greaterColor, attachCallback = attachCallback, detachCallback = detachCallback, formatText = formatText}
end

-- register the recognized stats so that people just have to fill out the 'statModifiers' table and be done with it
CustomizableWeaponry:registerRecognizedStat("DamageMult", "Decreases damage", "Increases damage", CustomizableWeaponry.textColors.NEGATIVE, CustomizableWeaponry.textColors.POSITIVE)
CustomizableWeaponry:registerRecognizedStat("RecoilMult", "Decreases recoil", "Increases recoil", CustomizableWeaponry.textColors.POSITIVE, CustomizableWeaponry.textColors.NEGATIVE)
CustomizableWeaponry:registerRecognizedStat("FireDelayMult", "Increases firerate", "Decreases firerate", CustomizableWeaponry.textColors.POSITIVE, CustomizableWeaponry.textColors.NEGATIVE)
CustomizableWeaponry:registerRecognizedStat("HipSpreadMult", "Decreases hip spread", "Increases hip spread", CustomizableWeaponry.textColors.POSITIVE, CustomizableWeaponry.textColors.NEGATIVE)
CustomizableWeaponry:registerRecognizedStat("AimSpreadMult", "Decreases aim spread", "Increases aim spread", CustomizableWeaponry.textColors.POSITIVE, CustomizableWeaponry.textColors.NEGATIVE)
CustomizableWeaponry:registerRecognizedStat("ClumpSpreadMult", "Decreases clump spread", "Increases clump spread", CustomizableWeaponry.textColors.POSITIVE, CustomizableWeaponry.textColors.NEGATIVE)
CustomizableWeaponry:registerRecognizedStat("DrawSpeedMult", "Decreases deploy speed", "Increases deploy speed", CustomizableWeaponry.textColors.NEGATIVE, CustomizableWeaponry.textColors.POSITIVE)
CustomizableWeaponry:registerRecognizedStat("ReloadSpeedMult", "Decreases reload speed", "Increases reload speed", CustomizableWeaponry.textColors.NEGATIVE, CustomizableWeaponry.textColors.POSITIVE)
CustomizableWeaponry:registerRecognizedStat("OverallMouseSensMult", "Decreases handling", "Increases handling", CustomizableWeaponry.textColors.NEGATIVE, CustomizableWeaponry.textColors.POSITIVE)
CustomizableWeaponry:registerRecognizedStat("VelocitySensitivityMult", "Increases mobility", "Decreases mobility", CustomizableWeaponry.textColors.POSITIVE, CustomizableWeaponry.textColors.NEGATIVE)
CustomizableWeaponry:registerRecognizedStat("SpreadPerShotMult", "Decreases spread per shot", "Increases spread per shot", CustomizableWeaponry.textColors.POSITIVE, CustomizableWeaponry.textColors.NEGATIVE)
CustomizableWeaponry:registerRecognizedStat("MaxSpreadIncMult", "Decreases accumulative spread", "Increases accumulative spread", CustomizableWeaponry.textColors.POSITIVE, CustomizableWeaponry.textColors.NEGATIVE)

CustomizableWeaponry:registerRecognizedVariable("SpeedDec", "Increases movement speed by ", "Decreases movement speed by ", CustomizableWeaponry.textColors.POSITIVE, CustomizableWeaponry.textColors.NEGATIVE, 
	function(weapon, attachmentData)
		weapon.SpeedDec = weapon.SpeedDec + attachmentData.SpeedDec
	end,
	
	function(weapon, attachmentData)
		weapon.SpeedDec = weapon.SpeedDec - attachmentData.SpeedDec
	end,
	
	-- attachmentData is the current attachment
	-- value is the value of the variable
	-- varData is the variable data we’re registering with registerRecognizedVariable
	function(attachmentData, value, varData)
		if value > 0 then
			return varData.greater .. math.abs(value) .. " points", varData.greaterColor
		end
		
	return varData.lesser .. math.abs(value) .. " points", varData.lesserColor
end)

-- too lazy to re-write the directory every single time, so just create a local string that we'll concatenate
local path = "cw/shared/attachments/"

-- load attachment files
for k, v in pairs(file.Find("cw/shared/attachments/*", "LUA")) do
	loadFile(path .. v)
end

local path = "cw/shared/ammotypes/"

-- load ammo type files (they're the same as attachments, really, but this way it's very easy to integrate it with the weapon customization menu)
for k, v in pairs(file.Find("cw/shared/ammotypes/*", "LUA")) do
	loadFile(path .. v)
end


================================================
FILE: cw2/lua/cw/shared/cw_callbacks.lua
================================================
AddCSLuaFile()

CustomizableWeaponry.callbacks = {}
CustomizableWeaponry.callbacks.categories = {}

-- adds a new callback function to an EXISTING callback category
function CustomizableWeaponry.callbacks:addNew(category, callbackName, func)
	-- don't add nil callbacks to a category, silly!
	if not func then
		return
	end
	
	if not self.categories[category] then
		self.categories[category] = {}
	end
	
	local cat = self.categories[category]
	
	if cat then
		cat[callbackName] = func
		--table.insert(cat, func)
	end
end

-- processes all callback functions within a certain category
-- allows to pass on a maximum of 4 args
function CustomizableWeaponry.callbacks:processCategory(category, a1, a2, a3, a4, a5)
	local cat = CustomizableWeaponry.callbacks.categories[category]
	
	local res1, res2, res3, res4, res5 = nil, nil, nil, nil, nil
	
	if cat then
		for callbackName, func in pairs(cat) do
			local r1, r2, r3, r4, r5 = func(self, a1, a2, a3, a4, a5)
			
			res1 = res1 or r1
			res2 = res2 or r2
			res3 = res3 or r3
			res4 = res4 or r4
			res5 = res5 or r5
		end
	end
	
	return res1, res2, res3, res4, res5
end


================================================
FILE: cw2/lua/cw/shared/cw_cmodel_management.lua
================================================
AddCSLuaFile()

if CLIENT then
	-- clientsidemodel manager
	-- removes clientside models that have lost references to their weapon objects since they're not garbage collected anymore (wtf)

	CustomizableWeaponry.cmodels = {}
	CustomizableWeaponry.cmodels.curModels = {}

	function CustomizableWeaponry.cmodels:add(model, wep)
		model.wepParent = wep
		self.curModels[#self.curModels + 1] = model
	end

	function CustomizableWeaponry.cmodels:validate()
		local removalIndex = 1 -- increment the removalIndex value every time we don't remove an index, since table.remove reorganizes the table
		
		for i = 1, #self.curModels do
			local cmodel = self.curModels[removalIndex]
			
			if not IsValid(cmodel.wepParent) then
				SafeRemoveEntity(cmodel)
				table.remove(self.curModels, removalIndex)
			else
				removalIndex = removalIndex + 1
			end
		end
	end

	timer.Create("Customizable Weaponry 2.0 CModel Manager", 5, 0, function()
		CustomizableWeaponry.cmodels:validate()
	end)
end


================================================
FILE: cw2/lua/cw/shared/cw_colorableparts.lua
================================================
AddCSLuaFile()

-- this module adds the ability to choose various colors for your reticles/laser sights

CustomizableWeaponry.colorableParts = {}

CustomizableWeaponry.colorableParts.COLOR_TYPE_SIGHT = 1
CustomizableWeaponry.colorableParts.COLOR_TYPE_BEAM = 2
CustomizableWeaponry.colorableParts.colors = {[CustomizableWeaponry.colorableParts.COLOR_TYPE_SIGHT] = {},
	[CustomizableWeaponry.colorableParts.COLOR_TYPE_BEAM] = {}}
	
CustomizableWeaponry.colorableParts.colorText = {[CustomizableWeaponry.colorableParts.COLOR_TYPE_SIGHT] = " (HOLD - change reticle color)",
	[CustomizableWeaponry.colorableParts.COLOR_TYPE_BEAM] = " (HOLD - change beam color)"}

function CustomizableWeaponry.colorableParts:addReticleColor(ret)
	--self.reticleColors[] = ret
	table.insert(self.colors[self.COLOR_TYPE_SIGHT], ret)
end

function CustomizableWeaponry.colorableParts:addLaserColor(laser)
	--self.laserColors[laser.name] = laser
	table.insert(self.colors[self.COLOR_TYPE_BEAM], laser)
end

-- use this function to register new categories for colorable stuff
function CustomizableWeaponry.colorableParts:registerNewColorableCategory(name, enumeration, id)
	CustomizableWeaponry.colorableParts[enumeration] = id
	CustomizableWeaponry.colorableParts.colors[enumeration] = {}
end

function CustomizableWeaponry.colorableParts:cycleColor(data)
	local result
	local colors = CustomizableWeaponry.colorableParts.colors[data.type]
	
	-- if there is another entry in the table, use it
	if colors[data.last + 1] then
		data.last = data.last + 1
		result = colors[data.last]
	else
		-- if there isn't, go back to the beginning of it
		data.last = 1
		result = colors[1]
	end
	
	-- apply the new color
	data.color = result.color
	data.display = CustomizableWeaponry.colorableParts:makeColorDisplayText(result.display)
	
	self.SightColorTarget = nil
	
	if CustomizableWeaponry.playSoundsOnInteract then
		surface.PlaySound("cw/selector.wav")
	end
end

function CustomizableWeaponry.colorableParts:setColor(index, position)
	-- can't load if not enough info is provided
	if not index or not position then
		return
	end
	
	local target = self.SightColors[index]
	local colors = CustomizableWeaponry.colorableParts.colors[target.type]
	
	if not colors then
		return
	end
	
	colors = colors[position]
	
	target.last = position
	target.color = colors.color
	target.display = CustomizableWeaponry.colorableParts:makeColorDisplayText(colors.display)
end

function CustomizableWeaponry.colorableParts:resetColors()
	for k, v in pairs(self.SightColors) do
		CustomizableWeaponry.colorableParts.resetColor(self, v)
	end
end

function CustomizableWeaponry.colorableParts:resetColor(entry)
	local def = CustomizableWeaponry.colorableParts.defaultColors[entry.type]
	
	entry.last = 1
	entry.color = def.color
	entry.display = CustomizableWeaponry.colorableParts:makeColorDisplayText(def.display)
end

function CustomizableWeaponry.colorableParts:makeColorDisplayText(text)
	return " - " .. text
end

local path = "cw/shared/colors/"

-- load colorable part files

for k, v in pairs(file.Find("cw/shared/colors/*", "LUA")) do
	loadFile(path .. v)
end

CustomizableWeaponry.colorableParts.defaultColors = {[CustomizableWeaponry.colorableParts.COLOR_TYPE_SIGHT] = CustomizableWeaponry.colorableParts.colors[CustomizableWeaponry.colorableParts.COLOR_TYPE_SIGHT][1],
[CustomizableWeaponry.colorableParts.COLOR_TYPE_BEAM] = CustomizableWeaponry.colorableParts.colors[CustomizableWeaponry.colorableParts.COLOR_TYPE_BEAM][1]}


================================================
FILE: cw2/lua/cw/shared/cw_firemodes.lua
================================================
AddCSLuaFile()

CustomizableWeaponry.firemodes = {}
CustomizableWeaponry.firemodes.registered = {}
CustomizableWeaponry.firemodes.registeredByID = {}

-- id - the ID of the firemode
-- display - the text to display when the firemode is active
-- automatic - whether it is a full-auto firemode
-- burstAmount - amount of rounds to fire, pass 0 to make it not have a burst system
-- bulletDisplay - amount of rounds to display on the HUD
function CustomizableWeaponry.firemodes:registerFiremode(id, display, automatic, burstAmount, bulletDisplay)
	local fireModeData = {id = id, display = display, auto = automatic, burstamt = burstAmount, buldis = bulletDisplay}
	
	table.insert(self.registered, fireModeData)
	self.registeredByID[id] = fireModeData
end

CustomizableWeaponry.firemodes:registerFiremode("auto", "FULL-AUTO", true, 0, 5)
CustomizableWeaponry.firemodes:registerFiremode("semi", "SEMI-AUTO", false, 0, 1)
CustomizableWeaponry.firemodes:registerFiremode("double", "DOUBLE-ACTION", false, 0, 1)
CustomizableWeaponry.firemodes:registerFiremode("bolt", "BOLT-ACTION", false, 0, 1)
CustomizableWeaponry.firemodes:registerFiremode("pump", "PUMP-ACTION", false, 0, 1)
CustomizableWeaponry.firemodes:registerFiremode("break", "BREAK-ACTION", false, 0, 1)
CustomizableWeaponry.firemodes:registerFiremode("2burst", "2-ROUND BURST", true, 2, 2)
CustomizableWeaponry.firemodes:registerFiremode("3burst", "3-ROUND BURST", true, 3, 3)
CustomizableWeaponry.firemodes:registerFiremode("safe", "SAFE", false, 0, 0)


================================================
FILE: cw2/lua/cw/shared/cw_grenadetypes.lua
================================================
AddCSLuaFile()

-- adds customizable grenade types for the M203

CustomizableWeaponry.grenadeTypes = {}
CustomizableWeaponry.grenadeTypes.registered = {}
CustomizableWeaponry.grenadeTypes.total = 0
CustomizableWeaponry.grenadeTypes.defaultText = " - 40MM HE"
CustomizableWeaponry.grenadeTypes.defaultFireSound = "CW_M203_FIRE"
CustomizableWeaponry.grenadeTypes.cycleText = " (HOLD - cycle grenades)"
CustomizableWeaponry.grenadeTypes.defaultGrenadeEntity = "cw_40mm_explosive"

function CustomizableWeaponry.grenadeTypes:addNew(gren)
	self.total = self.total + 1
	gren.id = self.total
	
	table.insert(self.registered, gren)
end

local SP = game.SinglePlayer()

-- maximum greande fire spread of underbarrel grenade launchers
CustomizableWeaponry.grenadeTypes.grenadeSpread = Angle(1.5, 1.5, 0)

function CustomizableWeaponry.grenadeTypes:createGrenadeEntity(name)
	local pos = self.Owner:GetShootPos()
	local eyeAng = self.Owner:EyeAngles()
	local forward = eyeAng:Forward()
	
	local spread = CustomizableWeaponry.grenadeTypes.grenadeSpread
	local offset = forward * 30 + eyeAng:Right() * 4 - eyeAng:Up() * 3
	-- adjust the angle of the charge
	eyeAng.p = eyeAng.p + math.Rand(-spread.p, spread.p)
	eyeAng.y = eyeAng.y + math.Rand(-spread.y, spread.y)
	
	forward = eyeAng:Forward()
	
	local nade = ents.Create(name)
	nade:SetPos(pos + offset)
	nade:SetAngles(eyeAng)
	nade:Spawn()
	nade:Activate()
	nade:SetOwner(self.Owner)
	local phys = nade:GetPhysicsObject()
	
	if IsValid(phys) then
		phys:SetVelocity(forward * 2996)
	end
end

function CustomizableWeaponry.grenadeTypes:defaultFireFunc()
	if SERVER then
		CustomizableWeaponry.grenadeTypes.createGrenadeEntity(self, CustomizableWeaponry.grenadeTypes.defaultGrenadeEntity)
	end
end

function CustomizableWeaponry.grenadeTypes:selectFireSound(target)
	if self:filterPrediction() then
		if target and target.fireSound then
			self:EmitSound(target.fireSound)
		else
			self:EmitSound(CustomizableWeaponry.grenadeTypes.defaultFireSound)
		end
	end
end

function CustomizableWeaponry.grenadeTypes:selectFireFunc(firstTimePrediction)
	if firstTimePrediction then
		local target = CustomizableWeaponry.grenadeTypes.registered[self.Grenade40MM]
		
		if not target then
			CustomizableWeaponry.grenadeTypes.defaultFireFunc(self)
		else
			target.fireFunc(self)
		end
		
		CustomizableWeaponry.grenadeTypes.selectFireSound(self, target)
	end
	
	self.dt.State = CW_IDLE
end

function CustomizableWeaponry.grenadeTypes:cycleGrenades()
	if CLIENT then
		RunConsoleCommand("cw_cycle40mm")
		return
	end
	
	if self.Grenade40MM >= CustomizableWeaponry.grenadeTypes.total then
		self.Grenade40MM = 0 -- reset to default 40MM grenade behavior
	else
		self.Grenade40MM = self.Grenade40MM + 1 -- increment 40MM grenade behavior
	end
	
	self.GrenadeTarget = false
end

function CustomizableWeaponry.grenadeTypes:setTo(target, network)
	if self.Grenade40MM == target then
		return
	end
		
	self.Grenade40MM = math.Clamp(target, 0, CustomizableWeaponry.grenadeTypes.total)
	
	if network then
		net.Start("CW20_GRENADETYPE")
			net.WriteUInt(self.Grenade40MM, 8)
		net.End(self.Owner)
	end
end

function CustomizableWeaponry.grenadeTypes:getGrenadeText()
	local target = CustomizableWeaponry.grenadeTypes.registered[self.Grenade40MM]
	
	return target and target.display or CustomizableWeaponry.grenadeTypes.defaultText
end

function CustomizableWeaponry.grenadeTypes:get(id)
	return self.registered[id]
end

function CustomizableWeaponry.grenadeTypes:canUseProperSights(id)
	local target = self.registered[id]
	
	if target and target.allowSights then
		return true
	end
	
	return false
end

local path = "cw/shared/grenadetypes/"

-- load 40MM grenade type files

for k, v in pairs(file.Find("cw/shared/grenadetypes/*", "LUA")) do
	loadFile(path .. v)
end


================================================
FILE: cw2/lua/cw/shared/cw_interactionmenuhandler.lua
================================================
AddCSLuaFile()

CustomizableWeaponry.interactionMenu = {}
CustomizableWeaponry.interactionMenu.CUSTOMIZATION_TAB = 1
CustomizableWeaponry.interactionMenu.PRESET_TAB = 2
CustomizableWeaponry.interactionMenu.tabs = {}

function CustomizableWeaponry.interactionMenu:keyPressed(key, pressed)
	-- loop through customization menu tab key bindings and set to one of them in case we find something
	-- return TRUE to suppress key bindings
	-- return FALSE to not suppress key bindings but stop further key press processing
	-- return NIL to not suppress key bindings and allow further key press processing
	local found = nil
	
	for k, v in pairs(CustomizableWeaponry.interactionMenu.tabs) do
		if key == v.switchToKey then
			-- make sure we're not setting it to a tab we're already in
			if self.CustomizationTab ~= v.id then
				local curTab = CustomizableWeaponry.interactionMenu.tabs[self.CustomizationTab]
				
				if curTab and curTab.switchAway then -- check if there's a switchAway callback for the current tab, and if there is, call it
					curTab.switchAway(self)
				end
				
				self.CustomizationTab = v.id
				
				if v.callback then
					return v.callback(self, key)
				end
				
				found = true
				CustomizableWeaponry.interactionMenu.activeTab = v.id
				break
			else
				found = true
				break
			end
			
			-- no action done, suppress key binds
			found = true
			break
		else
			if v.id == self.CustomizationTab then
				if v.processKey then
					found = v.processKey(self, key, pressed)
				end
			end
		end
	end
	
	return found
end
	
function CustomizableWeaponry.interactionMenu:draw()
	local section = CustomizableWeaponry.interactionMenu.tabs[self.CustomizationTab]
	
	if section then
		if section.drawFunc then
			section.drawFunc(self)
		end
	end
end

function CustomizableWeaponry.interactionMenu:addTab(tab)
	local tabId = tab.id or #self.tabs + 1
	tab.id = tabId
	
	self[tab.name] = tabId
	self.tabs[tabId] = tab
end

local path = "cw/shared/menutabs/"

-- load menu interaction tab files

for k, v in pairs(file.Find("cw/shared/menutabs/*", "LUA")) do
	loadFile(path .. v)
end


================================================
FILE: cw2/lua/cw/shared/cw_originalvaluesaving.lua
================================================
AddCSLuaFile()

-- This is a small module-thing that assigns a specified value a value with _Orig at the end of it
-- and can also, optionally, assign the value with a 'Mult' ending that's always 1, which can be used for attachments that modify a weapon's stats

CustomizableWeaponry.originalValue = {}
CustomizableWeaponry.originalValue.registered = {}

function CustomizableWeaponry.originalValue:add(varName, makeMultiplier, clientOnly)
	if clientOnly and SERVER then
		return
	end
	
	self.registered[varName] = makeMultiplier
end

local orig = "_Orig"
local mult = "Mult"

function CustomizableWeaponry.originalValue:assign()
	for varName, makeMult in pairs(CustomizableWeaponry.originalValue.registered) do
		self[varName .. orig] = self[varName]
		
		if makeMult then
			self[varName .. mult] = 1
		end
	end
end

CustomizableWeaponry.originalValue:add("HipSpread", true)
CustomizableWeaponry.originalValue:add("AimSpread", true)
CustomizableWeaponry.originalValue:add("FireDelay", true)
CustomizableWeaponry.originalValue:add("Damage", true)
CustomizableWeaponry.originalValue:add("VelocitySensitivity", true)
CustomizableWeaponry.originalValue:add("Recoil", true)
CustomizableWeaponry.originalValue:add("ReloadSpeed", true)
CustomizableWeaponry.originalValue:add("MaxSpreadInc", true)
CustomizableWeaponry.originalValue:add("OverallMouseSens", true, true)
CustomizableWeaponry.originalValue:add("DrawSpeed", true)
CustomizableWeaponry.originalValue:add("SpreadPerShot", true)
CustomizableWeaponry.originalValue:add("Shots", false)
CustomizableWeaponry.originalValue:add("ClumpSpread", false)
CustomizableWeaponry.originalValue:add("DeployTime", false)
CustomizableWeaponry.originalValue:add("ReloadHalt", false)
CustomizableWeaponry.originalValue:add("ReloadHalt_Empty", false)


================================================
FILE: cw2/lua/cw/shared/cw_particles.lua
================================================
AddCSLuaFile()

game.AddParticles("particles/muzzleflashes_test.pcf")
game.AddParticles("particles/muzzleflashes_test_b.pcf")
game.AddParticles("particles/cstm_muzzleflashes.pcf")

PrecacheParticleSystem("muzzleflash_g3")
PrecacheParticleSystem("muzzleflash_m14")
PrecacheParticleSystem("muzzleflash_ak47")
PrecacheParticleSystem("muzzleflash_ak74")
PrecacheParticleSystem("muzzleflash_6")
PrecacheParticleSystem("muzzleflash_pistol_rbull")
PrecacheParticleSystem("muzzleflash_pistol")
PrecacheParticleSystem("muzzleflash_suppressed")
PrecacheParticleSystem("muzzleflash_pistol_deagle")
PrecacheParticleSystem("muzzleflash_OTS")
PrecacheParticleSystem("muzzleflash_M3")
PrecacheParticleSystem("muzzleflash_smg")
PrecacheParticleSystem("muzzleflash_SR25")
PrecacheParticleSystem("muzzleflash_shotgun")
PrecacheParticleSystem("muzzle_center_M82")

PrecacheParticleSystem("cstm_smoke")


================================================
FILE: cw2/lua/cw/shared/cw_physical_bullets.lua
================================================
AddCSLuaFile()

CustomizableWeaponry.physicalBulletsEnabled = false
CustomizableWeaponry.SUPPRESS_CLIENTSIDE_BULLET_IMPACTS = false
CustomizableWeaponry.SUPPRESS_SERVERSIDE_BULLET_IMPACTS = true

CustomizableWeaponry.MUZZLE_VELOCITY_MULTIPLIER = 1
CustomizableWeaponry.WHIZ_DISTANCE = 192
CustomizableWeaponry.WHIZ_EVERY = 0.2

CustomizableWeaponry.physicalBulletBuffer = {} -- contains all physical bullets

-- don't run any additional code if the physical bullets are disabled
if not CustomizableWeaponry.physicalBulletsEnabled then
	return
end

if SERVER then
	util.AddNetworkString("CW20_PHYSBUL")
end

if CLIENT then -- register a different callback for server and client to avoid if CLIENT then/if SERVER then checks
	CustomizableWeaponry.callbacks:addNew("suppressDefaultImpactEffect", "CW20_suppressDefaultImpactEffect", function(self)
		if CustomizableWeaponry.SUPPRESS_CLIENTSIDE_BULLET_IMPACTS then
			return true, CLIENT
		end
		
		return false, CLIENT
	end)
else
	CustomizableWeaponry.callbacks:addNew("suppressDefaultImpactEffect", "CW20_suppressDefaultImpactEffect", function(self)
		if CustomizableWeaponry.SUPPRESS_SERVERSIDE_BULLET_IMPACTS then
			return true, SERVER
		end
		
		return false, SERVER
	end)
end

CustomizableWeaponry.callbacks:addNew("initialize", "CW20_initializePhysBullet", function(self)
	self.tracerRoundCounter = 0
end)

-- we suppress default bullets and their impact effects if phys bullets are enabled and create physical bullets per each shot instead
CustomizableWeaponry.callbacks:addNew("suppressDefaultBullet", "CW20_suppressDefaultBullet", function(self, startPos, direction, commmandNumber)
	-- fire and process a single step for the bullet, so that if we're close to an enemy, we'll hit them in the same tick when we fire
	local struct, index = CustomizableWeaponry:firePhysicalBullet(self.Owner, self:GetClass(), startPos, direction, (self.MuzzleVelocityConverted or 10000), true, self.Damage, nil, commmandNumber)
	
	if CustomizableWeaponry:processPhysicalBullet(struct, FrameTime()) then
		CustomizableWeaponry:removePhysicalBullet(self.Owner, index)
	end
	
	return true
end)

function CustomizableWeaponry:removePhysicalBullet(ply, index)
	table.remove(self.physicalBulletBuffer[ply], index)
end

function CustomizableWeaponry:createPhysicalBulletStructure(ply, wepClass, startPos, direction, velocity, isTracer, damage, fallSpeed, bulletID, noRicochet)
	return {
		player = ply,
		weapon = wepClass, -- we store the weapon class rather than the weapon object so that we can retrieve it's data later on when the bullet hits even if the weapon object is not valid anymore
		position = startPos,
		direction = direction,
		velocity = velocity,
		isTracer = isTracer,
		damage = damage,
		noRicochet = noRicochet,
		bulletID = bulletID,
		fallSpeed = fallSpeed or 1.5
	}
end

function CustomizableWeaponry:finalizePhysicalBulletStructure(wep, data)
	data.initialVelocity = data.velocity
	data.initialShotPosition = data.position * 1
	data.directionAngle = data.direction:Angle()
	
	if wep then
		CustomizableWeaponry.callbacks.processCategory(wep, "finalizePhysicalBullet", data)
	end
end

-- helper functions, since WriteVector compresses the vector and it loses precision
function net.WritePreciseVector(vector)
	net.WriteFloat(vector.x)
	net.WriteFloat(vector.y)
	net.WriteFloat(vector.z)
end

function net.ReadPreciseVector()
	local x = net.ReadFloat()
	local y = net.ReadFloat()
	local z = net.ReadFloat()
	
	return Vector(x, y, z)
end

local SP = game.SinglePlayer()

function CustomizableWeaponry:firePhysicalBullet(ply, wepClass, startPos, direction, velocity, isTracer, damage, fallSpeed, bulletID, noRicochet, skipNetwork)
	local wep = ply:GetActiveWeapon()
	
	if IsValid(wep) then
		wep.tracerRoundCounter = wep.tracerRoundCounter + 1
		
		if wep.tracerRoundCounter >= 3 then
			isTracer = true
			wep.tracerRoundCounter = 0
		else
			isTracer = false
		end
		
		if wep.dt.State ~= CW_AIMING then
			startPos = startPos + ply:EyeAngles():Right() * 4
		end
	end
	
	velocity = velocity * CustomizableWeaponry.MUZZLE_VELOCITY_MULTIPLIER
	local struct = self:createPhysicalBulletStructure(ply, wepClass, startPos, direction, velocity, isTracer, damage, fallSpeed, bulletID, noRicochet)
	self.physicalBulletBuffer[ply] = self.physicalBulletBuffer[ply] or {}
	table.insert(self.physicalBulletBuffer[ply], struct)
	
	local pos, dir = struct.position, struct.direction
	
	if not skipNetwork then
		if SERVER then
			struct.position = nil -- set these 2 variables to nil so that they're not written (we do this because WriteVector compresses the vectors and we need them uncompressed on the client for precision)
			struct.direction = nil
			
			local recipients = player.GetAll()
			
			if not SP then
				for key, recipient in ipairs(recipients) do
					if recipient == ply then -- we don't send the bullet data to ourselves since it's already predicted in MP
						table.remove(recipients, key)
						break
					end
				end
			end

			net.Start("CW20_PHYSBUL")
				net.WriteTable(struct)
				net.WritePreciseVector(pos)
				net.WritePreciseVector(dir)
			net.Send(recipients)
			
			struct.position = pos
			struct.direction = dir
		end
	end
	
	self:finalizePhysicalBulletStructure(wep, struct)
	
	return struct, #self.physicalBulletBuffer[ply]
end

local traceData = {}
local bulletData = {}

local baseData = nil
local trace_normal = nil
local trace_walls = nil

-- initialize the vars above in InitPostEntity, because that's when the base files will be 100% registered
hook.Add("InitPostEntity", "CW20_PhysBul_InitPostEntity", function()
	baseData = weapons.Get("cw_base")
	trace_normal = baseData.NormalTraceMask
	trace_walls = baseData.WallTraceMask
end)

bulletData.Callback = function(attacker, traceResult, dmgInfo)
	local victim = traceResult.Entity

	if IsValid(victim) then 
		victim.LAST_HIT_BY_PHYSBUL = bulletData.BULLET_STRUCT -- store the last hit by the physical bullet
	end
	
	baseData = baseData or weapons.Get("cw_base")
	baseData.bulletCallback(attacker, traceResult, dmgInfo)
end

bulletData.Num = 1
bulletData.Tracer = 0

local zeroVec = Vector(0, 0, 0)
local tickRate = engine.TickInterval()

local PLAYER = FindMetaTable("Player")

if CLIENT then
	function PLAYER:cw20LagCompensation(state)
		-- do nothing, since according to the wiki "Despite being defined shared, it (:LagCompensation) can only be used server side in a Predicted Hook." and we don't want to set up different code on client and server
	end
else
	PLAYER.cw20LagCompensation = PLAYER.LagCompensation -- use the LagCompensation code instead
end

function CustomizableWeaponry:processPhysicalBullet(bullet, dt)
	-- disabled accumulator, since it might be incorrect and I think it causes insane fps drops in specific cases (down to like 1 fps lol)
	--[[if dt > tickRate then -- primitive accumulator, for proper prediction
		while true do
			local newDelta = math.min(tickRate, dt)
			dt = dt - tickRate
			
			if self:processPhysicalBullet(bullet, newDelta) then
				return true
			end
			
			if dt <= 0 then -- we're out of delta time, end here
				return
			end
		end
	end]]--
	
	if util.PointContents(bullet.position) == CONTENTS_SOLID then
		return true
	end

	traceData.start = bullet.position
	traceData.endpos = traceData.start + bullet.direction * bullet.velocity * dt
	traceData.filter = bullet.player
	traceData.mask = trace_normal
	
	local oldPosition = bullet.position
	local oldDirection = bullet.direction
	
	local normalized = math.NormalizeAngle(bullet.directionAngle.p)
	bullet.directionAngle.p = math.Approach(normalized, 90, bullet.fallSpeed * dt) -- generate less garbage this way (angle -> direction VS direction -> angle -> direction)
	bullet.direction = bullet.directionAngle:Forward()
	
	bullet.player:cw20LagCompensation(true)
		local trace = util.TraceLine(traceData)
	bullet.player:cw20LagCompensation(false)
	
	bullet.velocity = math.Approach(bullet.velocity, bullet.initialVelocity * 0.9, dt * 10000) -- lose velocity over the flight
	bullet.position = trace.HitPos
	
	if trace.Hit or trace.HitSky then
		bulletData.Src = oldPosition
		bulletData.Dir = oldDirection
		bulletData.Spread 	= zeroVec
		bulletData.Force	= bullet.damage * 0.3
		bulletData.Damage = math.Round(bullet.damage)
		bulletData.BULLET_STRUCT = bullet
		
		local wepData = weapons.Get(bullet.weapon)
		local firer = bullet.player

		bullet.player:cw20LagCompensation(true)
			bullet.player:FireBullets(bulletData)
		bullet.player:cw20LagCompensation(false)
		
		if not bullet.noRicochet then
			if not trace.HitSky then
				local canPenetrate, dot = wepData:canPenetrate(trace, bullet.direction)
				local effRange, dmgFallOff, penStr, penRange = wepData:getEffectiveRange()
				
				if canPenetrate and dot > 0.26 then	
					traceData.start = trace.HitPos
					traceData.endpos = traceData.start + bullet.direction * penStr * (wepData.PenetrationMaterialInteraction[trace.MatType] and wepData.PenetrationMaterialInteraction[trace.MatType] or 1) * wepData.PenMod
					traceData.mask = trace_walls
					
					trace = util.TraceLine(traceData)
					
					traceData.start = trace.HitPos
					traceData.endpos = traceData.start + bullet.direction * 0.1
					traceData.mask = trace_normal

					trace = util.TraceLine(traceData) -- run ANOTHER trace to check whether we've penetrated a surface or not
					
					if not trace.Hit then
						math.randomseed(bullet.bulletID)
						self:firePhysicalBullet(bullet.player, bullet.weapon, trace.HitPos, math.randomizeVector(bullet.direction, 0.02), bullet.velocity * 0.6, bullet.tracer, bullet.damage * 0.5, bullet.fallSpeed * 3, bullet.bulletID, true, true)
					end
				else
					if dot and not bullet.noRicochet and wepData:canRicochet(trace, penRange) then
						local newDir = bullet.direction + (trace.HitNormal * dot) * 3
						math.randomseed(bullet.bulletID)
						math.randomizeVector(bullet.direction, 0.06)
						
						self:firePhysicalBullet(bullet.player, bullet.weapon, trace.HitPos, newDir, bullet.velocity * 0.6, bullet.tracer, bullet.damage * 0.5, bullet.fallSpeed * 2, bullet.bulletID, true, true)
					end
				end
			end
		end
		
		return true
	end
end

function CustomizableWeaponry:processBullets(ply, ucmd)
	local curIndex = 1
	local bullets = self.physicalBulletBuffer[ply]
	local frameTime = FrameTime()
	
	if bullets then
		local ft = FrameTime()
		
		for i = 1, #bullets do			
			if self:processPhysicalBullet(bullets[curIndex], ft) then
				table.remove(bullets, curIndex)
			else
				curIndex = curIndex + 1
			end
		end
	end
end

hook.Add("PlayerCanPickupWeapon", "CW20_PlayerCanPickupWeapon", function(ply, wep)
	if wep.CW20_CANT_PICKUP then
		return false
	end
	
	return nil
end)

-- on the server we just process the bullets as usual, since the hook is ran for every single player
-- on the client we do a player.GetAll iteration, since the hook is called only on the local player
if SERVER then
	hook.Add("StartCommand", "CW20_processBulletsStartCommand", function(ply, ucmd)
		CustomizableWeaponry:processBullets(ply, ucmd) -- simulate bullets on a per-player basis to enable prediction
	end)
else
	hook.Add("StartCommand", "CW20_processBulletsStartCommand", function(localPly, ucmd)
		if (SERVER or ucmd:TickCount() ~= 0) then
			for key, ply in ipairs(player.GetAll()) do
				CustomizableWeaponry:processBullets(ply, ucmd)
			end
		end
	end)
end

hook.Add("PlayerDisconnected", "CW20_PlayerDisconnectedPhysBul", function(ply)
	CustomizableWeaponry.physicalBulletBuffer[ply] = nil -- wipe bullets when a player disconnects
end)

if CLIENT then
	net.Receive("CW20_PHYSBUL", function(len, pl)
		local struct = net.ReadTable()
		struct.position = net.ReadPreciseVector()
		struct.direction = net.ReadPreciseVector()
	
		CustomizableWeaponry:finalizePhysicalBulletStructure(struct.weapon, struct)
		CustomizableWeaponry.physicalBulletBuffer[struct.player] = CustomizableWeaponry.physicalBulletBuffer[struct.player] or {}
		
		table.insert(CustomizableWeaponry.physicalBulletBuffer[struct.player], struct)
		
		if CustomizableWeaponry:processPhysicalBullet(struct, FrameTime()) then
			CustomizableWeaponry:removePhysicalBullet(struct.player, index)
		end
	end)
	
	local t = {["$basetexture"] = "sprites/glow03",
		["$additive"] = "1",
		["$vertexcolor"] = "1",
		["$vertexalpha"] = "1"}
		
	local bulletTracer = CreateMaterial("cw20_bullet_tracer", "UnlitGeneric", t)
	local clr = Color(255, 167, 112, 255)
	
	local bulletWhizTime = 0

	function CustomizableWeaponry:renderTracerBullets()
		local localPlayer, CT = LocalPlayer(), CurTime() 
		local playerPos = EyePos()
		local eyeAngles = EyeAngles():Forward()
		
		for ply, data in pairs(self.physicalBulletBuffer) do
			if not IsValid(ply) then -- player does not exist, don't draw his bullets
				self.physicalBulletBuffer[ply] = nil
			else
				for key, bulletData in ipairs(data) do
					local pos = bulletData.position
					local norm = bulletData.direction:GetNormal()

					if bulletData.player ~= localPlayer and norm:DotProduct(eyeAngles:GetNormalized()) < 0 and CT > bulletWhizTime and bulletData.position:Distance(playerPos) <= self.WHIZ_DISTANCE then -- emit a whiz sound
						EmitSound("weapons/fx/nearmiss/bulletLtoR0" .. math.random(3, 9) .. ".wav", pos, ply:EntIndex(), CHAN_AUTO, 1, 70, 0, 100)
						bulletWhizTime = CT + self.WHIZ_EVERY
					end
					
					if bulletData.isTracer or bulletData.player == localPlayer then
						render.SetMaterial(bulletTracer)
						render.DrawSprite(pos + norm * 128, 8, 8, clr)
						render.DrawBeam(pos + norm * 256, pos, 4, 0, 1, clr)
					end
				end
			end
		end
	end
	
	hook.Add("PostDrawOpaqueRenderables", "CW20_PostDrawOpaqueRenderables", function()
		CustomizableWeaponry:renderTracerBullets()
	end)
end


================================================
FILE: cw2/lua/cw/shared/cw_preset.lua
================================================
AddCSLuaFile()

-- as with all other classes, don't remove this one
-- just set 'enabled' to false if you want to disable the preset system

CustomizableWeaponry.preset = {}
CustomizableWeaponry.preset.enabled = true -- set this to 'false' to disable preset saving/loading
CustomizableWeaponry.preset.delay = 1 -- amount of time in seconds to delay the ability to load a preset after the client did that just now
CustomizableWeaponry.preset.networkString = "CW20_PRESET_LOAD" -- the string that will be used for preset loading networking
CustomizableWeaponry.preset.presetSavedString = "CW20_PRESET_SAVED" -- the string that will be sent to the server to notify that we saved a preset
CustomizableWeaponry.preset.folder = CustomizableWeaponry.baseFolder .. "/presets/"
CustomizableWeaponry.preset.invalidSymbols = "[/.:;']"

-- setup directory to save files in

if not file.IsDir(CustomizableWeaponry.preset.folder, "DATA") then
	file.CreateDir(CustomizableWeaponry.preset.folder)
end

if CustomizableWeaponry.preset.enabled then
	if SERVER then
		net.Receive(CustomizableWeaponry.preset.networkString, function(len, ply)
			-- read and decode the received string
			local name_sv = net.ReadString()
			local data = net.ReadString()
			data = util.JSONToTable(data)
			
			local wep = ply:GetActiveWeapon()
			
			-- make sure we're trying to load the preset onto a CW 2.0 weapon
			if not IsValid(wep) or not wep.CW20Weapon then
				return
			end
			
			if (wep.ThisClass or wep:GetClass()) ~= data.wepClass then
				return
			end
			
			CustomizableWeaponry.preset.load(wep, data, name_sv)
		end)
		
		net.Receive(CustomizableWeaponry.preset.presetSavedString, function(len, ply)
			-- read and decode the received string
			local presetName = net.ReadString()
			
			local wep = ply:GetActiveWeapon()
			
			-- make sure we're trying to load the preset onto a CW 2.0 weapon
			if not IsValid(wep) or not wep.CW20Weapon then
				return
			end

			wep.LastPreset = presetName
		end)
		
		util.AddNetworkString(CustomizableWeaponry.preset.networkString)
		util.AddNetworkString(CustomizableWeaponry.preset.presetSavedString)
	end
end

--[[ ideally the save function should only be called on the client, since the load/save system works like this:
SAVE:
1. client attaches stuff on his weapon
2. client saves the preset on HIS COMPUTER
3. client tells the server that he saved a new preset

LOAD:
1. client decides to load a certain preset
2. client sends JSON string to server containing the preset
3. server decodes the preset
4. server attaches the attachments and networks it to the client

this is mainly to make presets independent from the server and not have a fuckton of preset files on the server
]]--

function CustomizableWeaponry.preset:getWeaponFolder()
	return CustomizableWeaponry.preset.folder .. (self.ThisClass or self:GetClass()) .. "/"
end

function CustomizableWeaponry.preset:postLoad(name)
	local dir = CustomizableWeaponry.preset.getWeaponFolder(self)
	local path = dir .. "colors/" .. name .. ".txt"
	
	if file.Exists(path, "DATA") then
		local data = file.Read(path, "DATA")
		data = util.JSONToTable(data)
		CustomizableWeaponry.preset.loadColors(self, data)
	end
	
	local path = dir .. "offsets/" .. name .. ".txt"
	
	if file.Exists(path, "DATA") then
		local data = file.Read(path, "DATA")
		data = util.JSONToTable(data)
		
		for key, value in pairs(data) do
			local modelData = self.AttachmentModelsVM[key]
			
			modelData.pos[modelData.adjustment.axis] = value
		end
	end	
end

function CustomizableWeaponry.preset:loadColors(data)
	-- welp, nothing to read
	if not data then
		return
	end
	
	for k, v in pairs(data) do
		CustomizableWeaponry.colorableParts.setColor(self, k, v)
	end
end

function CustomizableWeaponry.preset:save(name)
	if not CustomizableWeaponry.customizationEnabled then
		return false
	end
	
	-- can't save if presets are disabled
	if not CustomizableWeaponry.preset.enabled then
		return
	end
	
	-- can't save presets on a non-CW 2.0 weapon
	if not self.CW20Weapon then
		return
	end
	
	local dir = CustomizableWeaponry.preset.getWeaponFolder(self)
	
	-- make sure all the directories are present prior to saving
	if not file.IsDir(dir, "DATA") then
		file.CreateDir(dir) 
	end
	
	if not file.IsDir(dir .. "colors/", "DATA") then
		file.CreateDir(dir .. "colors/")
	end
	
	if not file.IsDir(dir .. "offsets/", "DATA") then
		file.CreateDir(dir .. "offsets/")
	end
	
	-- either save the preset with a specified name or with the amount of presets in the folder as it's name
	name = name or "preset" .. #file.Find(dir .. "preset_*", "DATA") + 1
	name = string.gsub(name, CustomizableWeaponry.preset.invalidSymbols, "")
	
	-- setup data to save
	local data = {}
	data.wepClass = (self.ThisClass or self:GetClass())
	data.grenadeType = self.Grenade40MM
	
	-- get attachments that are installed on the weapon and add them to the table for saving
	-- subtract by one since when the attachment check loop begins, it increments the 'position' value by 1
	for k, v in pairs(self.Attachments) do
		if v.last and v.last > 0 then
			data[k] = v.last
		end
	end
	
	local offsets = {}
	
	if self.AttachmentModelsVM then
		for k, v in pairs(self.AttachmentModelsVM) do
			if v.active and v.adjustment then
				offsets[k] = v.pos[v.adjustment.axis]
			end
		end
	end
	
	-- setup the reticle/beam/etc. colors to save
	local colors = {}
	
	-- save active sight colors
	for k, v in pairs(self.SightColors) do
		if v.last > 1 then
			colors[k] = v.last
			canWriteColors = true
		end
	end
	
	local encoded = util.TableToJSON(data)
	
	-- save the preset file
	file.Write(dir .. name .. ".txt", encoded)
	
	-- save the sight colors only if we have any of them modified
	if table.Count(colors) > 0 then
		local encodedColors = util.TableToJSON(colors)
		file.Write(dir .. "colors/" .. name .. ".txt", encodedColors)
	end
	
	-- save sight offsets
	if table.Count(offsets) > 0 then
		local encodedOffsets = util.TableToJSON(offsets)
		file.Write(dir .. "offsets/" .. name .. ".txt", encodedOffsets)
	end
	
	self.LastPreset = CustomizableWeaponry.preset.specifiedName
	CustomizableWeaponry.preset.specifiedName = nil
	
	if CLIENT then
		-- let the server know that we've saved a preset, so that when we try to remove it, it'll remove it rather than re-equip it
		net.Start(CustomizableWeaponry.preset.presetSavedString)
			net.WriteString(name)
		net.SendToServer()
	end
end

function CustomizableWeaponry.preset:delete(dir, fileName)
	if not CustomizableWeaponry.customizationEnabled then
		return false
	end
	
	dir = dir or CustomizableWeaponry.preset.getWeaponFolder(self)
	local targetFile = dir .. fileName .. ".txt"
	
	if file.Exists(targetFile, "DATA") then
		file.Delete(targetFile)
	end
	
	CustomizableWeaponry.preset.updateList(self, dir)
end

--[[ the load function should be called on the client
it'll send the desired attachment preset to the server, which will decode it, attach it (if possible) and network it to the client
]]--

function CustomizableWeaponry.preset:canSave()
	if not CustomizableWeaponry.customizationEnabled then
		return false
	end
	
	-- if the weapon has any attachments on it, that means that we can save a preset
	for k, v in pairs(self.ActiveAttachments) do
		if v then
			return true
		end
	end
	
	return false
end

function CustomizableWeaponry.preset:attemptDelete(entry)
	if not self.PresetResults then
		return false
	end
	
	entry = entry - 1
	
	local result = self.PresetResults[entry]
	
	if not result then
		return false
	end

	local dir = CustomizableWeaponry.preset.getWeaponFolder(self)
	
	if not file.Exists(dir .. result.name, "DATA") then
		return false
	end
	
	CustomizableWeaponry.preset.delete(self, dir, result.displayName)
	return true
end

function CustomizableWeaponry.preset:canDelete(fileName)
	if not file.Exists(CustomizableWeaponry.preset.getWeaponFolder(self) .. fileName, "DATA") then 
		return false
	end
	
	return true
end

function CustomizableWeaponry.preset:updateList(folder)
	folder = folder or CustomizableWeaponry.preset.getWeaponFolder(self)
	local result = file.Find(folder .. "*", "DATA")
	
	for k, v in pairs(result) do
		if file.IsDir(v, "DATA") then
			result[k] = nil
		else
			-- remove .txt format in advance to not do pointless string operations when drawing
			result[k] = {displayName = string.gsub(v, ".txt", ""), name = v}
		end
	end
	
	table.Sanitise(result)
	
	self.PresetResults = result
end

if CLIENT then
	function CustomizableWeaponry.preset:makeSavePopup()
		-- better save than sorry
		if not CustomizableWeaponry.preset.canSave(self) then
			return
		end
		
		CustomizableWeaponry.preset.specifiedName = nil
		
		local frame = vgui.Create("DFrame")
		frame:SetSize(220, 90)
		frame:SetTitle("Saving new preset")
		frame:Center()
		frame:MakePopup()
		
		function frame:Paint()
			local w, h = self:GetSize()
			
			surface.SetDrawColor(0, 0, 0, 255)
			surface.DrawOutlinedRect(0, 0, w, h)
			surface.DrawRect(2, 2, w - 4, 21)
			
			surface.SetDrawColor(0, 0, 0, 200)
			surface.DrawRect(1, 1, w - 2, h - 2)
		end
		
		local textBox = vgui.Create("DTextEntry", frame)
		textBox:SetPos(20, 30)
		textBox:SetSize(180, 20)
		textBox:SetText("Enter preset name...")
		
		function textBox:OnMousePressed()
			self:SetText("")
		end
		
		function textBox:OnTextChanged()
			local text = self:GetText()
			
			if text == "" then
				CustomizableWeaponry.preset.specifiedName = nil
			else
				CustomizableWeaponry.preset.specifiedName = text
			end
		end
		
		textBox.OnEnter = function()
			CustomizableWeaponry.preset.save(self, CustomizableWeaponry.preset.specifiedName)
			CustomizableWeaponry.preset.updateList(self)
			frame:Close()
		end
		
		local saveButton = vgui.Create("DButton", frame)
		saveButton:SetPos(20, 60)
		saveButton:SetSize(80, 18)
		saveButton:SetText("Save")
		saveButton.DoClick = function()
			CustomizableWeaponry.preset.save(self, CustomizableWeaponry.preset.specifiedName)
			CustomizableWeaponry.preset.updateList(self)
			frame:Close()
		end
		
		local cancelButton = vgui.Create("DButton", frame)
		cancelButton:SetPos(120, 60)
		cancelButton:SetSize(80, 18)
		cancelButton:SetText("Cancel")
		cancelButton.DoClick = function()
			frame:Close()
		end
	end
end

function CustomizableWeaponry.preset:load(data, name_sv)
	if not CustomizableWeaponry.customizationEnabled then
		return false
	end
	
	-- can't load if preset system is disabled
	if not CustomizableWeaponry.preset.enabled then
		return
	end
	
	local CT = CurTime()
	
	-- anti-spam
	if CT < self.PresetLoadDelay then
		return
	end
	
	-- can't load a non-existing preset
	-- on the client, 'data' is the preset name
	-- on the server, 'data' is the decoded JSON string
	if not data then
		return
	end
	
	-- can't load a preset on a non-CW 2.0 weapon
	if not self.CW20Weapon then
		return
	end
	
	if CLIENT then
		local preset = file.Read(CustomizableWeaponry.preset.getWeaponFolder(self) .. data .. ".txt", "DATA")
		
		-- can't load a non-existant preset, or a blank file
		if not preset or preset == "" then
			return
		end
		
		net.Start(CustomizableWeaponry.preset.networkString)
			net.WriteString(data)
			net.WriteString(preset)
		net.SendToServer()
	end
	
	if SERVER then
		-- if our preset names don't match, that means we want to switch to a new one
		if self.LastPreset ~= name_sv then
			-- we need to set up a load order, since some attachments depend on others
			local loadOrder = {}
			
			for k, v in pairs(data) do
				local attCategory = self.Attachments[k]
				
				-- make sure we're loading a registered attachment
				if attCategory then
					local att = CustomizableWeaponry.registeredAttachmentsSKey[attCategory.atts[v]]
					
					if att then
						local pos = 1
						
						-- if the attachment has dependencies, put it in the back of the load order, and load ones that don't depend on anything
						if att.dependencies or attCategory.dependencies or (self.AttachmentDependencies and self.AttachmentDependencies[att.name]) then
							pos = #loadOrder + 1
						end
						
						table.insert(loadOrder, pos, {category = k, position = v})
					end
				end
			end
		
			-- don't forget to detach everything prior to loading an attachment preset
			self:detachAll()
			
			for k, v in ipairs(loadOrder) do
				self:attach(v.category, v.position - 1)
			end
			
			CustomizableWeaponry.grenadeTypes.setTo(self, (data.grenadeType or 0), true)
			
			self.LastPreset = name_sv

			net.Start("CW20_PRESETSUCCESS")
				net.WriteString(name_sv)
			net.Send(self.Owner)
		else
			-- if they do, that means we just want to remove a preset
			self:detachAll()
			SendUserMessage("CW20_PRESETDETACH", self.Owner)
			
			-- reset the 40MM grenade type
			CustomizableWeaponry.grenadeTypes.setTo(self, 0, true)
		end
	end
	
	self.PresetLoadDelay = CT + CustomizableWeaponry.preset.delay
end


================================================
FILE: cw2/lua/cw/shared/cw_quickgrenade.lua
================================================
AddCSLuaFile()

CustomizableWeaponry.quickGrenade = CustomizableWeaponry.quickGrenade or {}

-- set this to 'false' to disable quick grenade functionality
CustomizableWeaponry.quickGrenade.enabled = true

-- the weapon action delay after throwing a grenade and re-equipping the weapon
CustomizableWeaponry.quickGrenade.postGrenadeWeaponDelay = 0.3
CustomizableWeaponry.quickGrenade.throwVelocity = 800
CustomizableWeaponry.quickGrenade.addVelocity = Vector(0, 0, 150) -- additional velocity independant from any factors
CustomizableWeaponry.quickGrenade.movementAddVelocity = 300 -- how much additional direction based velocity the grenade will receive based on the player's movement speed

CustomizableWeaponry.quickGrenade.canDropLiveGrenadeIfKilled = true
CustomizableWeaponry.quickGrenade.liveGrenadeVelocity = 100
CustomizableWeaponry.quickGrenade.liveGrenadeAddVelocity = Vector(0, 0, 20)
CustomizableWeaponry.quickGrenade.unthrownGrenadesGiveWeapon = false

-- func is called from the SWEP base	
function CustomizableWeaponry.quickGrenade:initializeQuickGrenade()
	if not self.enabled then
		return
	end
	
	-- this table defines in which states the player can't use the 'quick grenade' feature
	self.restrictedStates = {[CW_RUNNING] = true, 
		[CW_ACTION] = true,
		[CW_CUSTOMIZE] = true}
end

local td = {}

function CustomizableWeaponry.quickGrenade:getThrowOffset(player)
	local aimDir = player:EyeAngles() -- EyeAngles():Forward() because GetAimVector works in a retarded manner
	
	return aimDir:Up() * -3 + aimDir:Forward() * 30 + aimDir:Right() * 3
end

function CustomizableWeaponry.quickGrenade:getThrowVelocity(playerEnt, throwVelocity, addVelocity)
	throwVelocity = throwVelocity or self.throwVelocity
	addVelocity = addVelocity or self.addVelocity
	
	local forward = playerEnt:EyeAngles():Forward()
	local overallSideMod = playerEnt:KeyDown(IN_SPEED) and 2 or 1

	-- take the velocity into account
	addMod = math.Clamp(playerEnt:GetVelocity():Length() / playerEnt:GetRunSpeed(), 0, 1)
	
	local velocity = forward * throwVelocity + addVelocity
	local velNorm = playerEnt:GetVelocity():GetNormal()
	velNorm.z = 0
	
	-- add velocity based on player velocity normal
	velocity = velocity + velNorm * self.movementAddVelocity * addMod
	
	return velocity
end

function CustomizableWeaponry.quickGrenade:applyThrowVelocity(playerEnt, nade, throwVelocity, addVelocity)
	local phys = nade:GetPhysicsObject()
	
	if IsValid(phys) then
		local vel = self:getThrowVelocity(playerEnt, throwVelocity, addVelocity)
		
		phys:SetVelocity(vel)
		phys:AddAngleVelocity(Vector(math.random(-500, 500), math.random(-500, 500), math.random(-500, 500)))
	end
end

function CustomizableWeaponry.quickGrenade:canThrow()
	-- it's disabled, can't throw
	if not CustomizableWeaponry.quickGrenade.enabled then
		return false
	end
	
	-- can't throw if we're within a restricted state
	if CustomizableWeaponry.quickGrenade.restrictedStates[self.dt.State] then
		return false
	end
	
	-- can't throw while reloading
	if self.ReloadDelay then
		return false
	end
	
	-- can't throw with an active bipod
	if self.dt.BipodDeployed then
		return false
	end
	
	-- can't throw while changing weapons
	if self.HolsterDelay then
		return false
	end
	
	-- can't throw with no grenades
	if self.Owner:GetAmmoCount("Frag Grenades") <= 0 then
		return false
	end
	
	-- can't throw the grenade if we're really close to an object
	td.start = self.Owner:GetShootPos()
	td.endpos = td.start + CustomizableWeaponry.quickGrenade:getThrowOffset(self)
	td.filter = self.Owner
	
	local tr = util.TraceLine(td)
	
	-- something in front of us, can't throw
	if tr.Hit then
		return false
	end
	
	-- everything passes, can throw, woo!
	return true
end

local pinPullAnims = {"pullpin", "pullpin2", "pullpin3", "pullpin4"}
local SP = game.SinglePlayer()

function CustomizableWeaponry.quickGrenade:createThrownGrenade(player)
	local pos = player:GetShootPos()
	local offset = CustomizableWeaponry.quickGrenade:getThrowOffset(player)
	local eyeAng = player:EyeAngles()
	local forward = eyeAng:Forward()
	
	local nade = ents.Create("cw_grenade_thrown")
	nade:SetPos(pos + offset)
	nade:SetAngles(eyeAng)
	nade:Spawn()
	nade:Activate()
	nade:Fuse(3)
	nade:SetOwner(player)
	
	return nade
end

function CustomizableWeaponry.quickGrenade:createUnthrownGrenade(player)
	local pos = player:GetShootPos()
	local offset = CustomizableWeaponry.quickGrenade:getThrowOffset(player)
	local eyeAng = player:EyeAngles()
	local forward = eyeAng:Forward()
	
	local nade = ents.Create("cw_grenade_unthrown") -- it's inactive and can be picked up as ammo
	nade:SetPos(pos + offset)
	nade:SetAngles(eyeAng)
	nade:Spawn()
	nade:Activate()
	
	return nade
end

function CustomizableWeaponry.quickGrenade:throw(predictOverride)
	local CT = CurTime()
	
	self:setGlobalDelay(1.9)
	self:SetNextPrimaryFire(CT + 1.9)
	
	if SERVER and SP then
		SendUserMessage("CW20_THROWGRENADE", self.Owner)
	end
	
	self.dt.State = CW_ACTION
		
	if (not SP and (IsFirstTimePredicted() or predictOverride)) or SP then
		if self:filterPrediction() then
			if SERVER and not SP and predictOverride then
				SuppressHostEvents(self.Owner)
			end
			
			self:EmitSound("CW_HOLSTER")
		end
		
		CustomizableWeaponry.callbacks.processCategory(self, "beginThrowGrenade")
		
		if CLIENT then
			CustomizableWeaponry.actionSequence.new(self, 0.45, nil, function()
				self.GrenadePos.z = -10
				self.grenadeTime = CurTime() + 1.5
				self:playAnim(table.Random(pinPullAnims), 1, 0, self.CW_GREN)
			end)
			
			CustomizableWeaponry.actionSequence.new(self, 0.5, nil, function()
				surface.PlaySound("weapons/pinpull.wav")
			end)
			
			CustomizableWeaponry.actionSequence.new(self, 1.1, nil, function()
				self:playAnim("throw", 1.1, 0, self.CW_GREN)
			end)
		end
		
		if SERVER then
			CustomizableWeaponry.actionSequence.new(self, 0.3, nil, function()
				self.canDropGrenade = true
			end)
		
			CustomizableWeaponry.actionSequence.new(self, 0.5, nil, function()
				self.liveGrenade = true
			end)
		
			CustomizableWeaponry.actionSequence.new(self, 1.15, nil, function()
				local nade = CustomizableWeaponry.quickGrenade:createThrownGrenade(self.Owner)
				CustomizableWeaponry.quickGrenade:applyThrowVelocity(self.Owner, nade, throwVelocity, addVelocity)
				
				self.liveGrenade = false
				self.canDropGrenade = false
				self.Owner:RemoveAmmo(1, "Frag Grenades")
				
				CustomizableWeaponry.callbacks.processCategory(self, "finishThrowGrenade")
			end)
		end
		
		CustomizableWeaponry.actionSequence.new(self, 1.8, nil, function()
			local delay = CustomizableWeaponry.quickGrenade.postGrenadeWeaponDelay
			self:SetNextPrimaryFire(CT + delay)
			self:SetNextSecondaryFire(CT + delay)
		end)
	end
end

function CustomizableWeaponry.quickGrenade.DoPlayerDeathCallback(victim, attacker, dmginfo)
	local wep = victim:GetActiveWeapon()
	
	if IsValid(wep) and wep.CW20Weapon then
		if wep.canDropGrenade then
			local nade = nil
			local throwVel, addVel = nil, nil
			
			if wep.liveGrenade then
				nade = CustomizableWeaponry.quickGrenade:createThrownGrenade(victim)
			else
				nade = CustomizableWeaponry.quickGrenade:createUnthrownGrenade(victim) 
			end
			
			CustomizableWeaponry.quickGrenade:applyThrowVelocity(victim, nade, CustomizableWeaponry.quickGrenade.liveGrenadeVelocity, CustomizableWeaponry.quickGrenade.liveGrenadeAddVelocity)
		end
	end
end

hook.Add("DoPlayerDeath", "CustomizableWeaponry.quickGrenade.DoPlayerDeathCallback", CustomizableWeaponry.quickGrenade.DoPlayerDeathCallback)


================================================
FILE: cw2/lua/cw/shared/cw_shells.lua
================================================
AddCSLuaFile()

CustomizableWeaponry.shells = {}
CustomizableWeaponry.shells.cache = {}

-- register new shell types with this function
-- name - the name of the shell
-- model - the model of the shell
-- collideSound - table containing the collision sounds this shell should make
-- keep in mind that the shells are somewhat fake

function CustomizableWeaponry.shells:addNew(name, model, collideSound)
	self.cache[name] = {m = model, s = collideSound}
end

function CustomizableWeaponry.shells:getShell(name)
	return self.cache[name]
end

local up = Vector(0, 0, -100)
local shellMins, shellMaxs = Vector(-0.5, -0.15, -0.5), Vector(0.5, 0.15, 0.5)

function CustomizableWeaponry.shells:make(pos, ang, velocity, soundTime, removeTime)
	if not pos or not ang then
		return
	end

	CustomizableWeaponry.shells.finishMaking(self, pos, ang, velocity, soundTime, removeTime)
end

local angleVel = Vector(0, 0, 0)
local cback = nil

function CustomizableWeaponry.shells:collideCallback(collData)
	sound.Play(self.shellSound, self:GetPos())
	self:RemoveCallback("PhysicsCollide", self.physCollCBID)
	-- don't play the shell sound on every impact
end

cback = CustomizableWeaponry.shells.collideCallback

function CustomizableWeaponry.shells:finishMaking(pos, ang, velocity, soundTime, removeTime)
	velocity = velocity or up
	velocity.x = velocity.x + math.Rand(-5, 5)
	velocity.y = velocity.y + math.Rand(-5, 5)
	velocity.z = velocity.z + math.Rand(-5, 5)
	
	time = time or 0.5
	removetime = removetime or 5
	
	local t = self._shellTable or CustomizableWeaponry.shells:getShell("mainshell") -- default to the 'mainshell' shell type if there is none defined
	
	local ent = ClientsideModel(t.m, RENDERGROUP_BOTH) 
	ent:SetPos(pos)
	ent:PhysicsInitBox(shellMins, shellMaxs)
	ent:SetAngles(ang)
	ent:SetModelScale((self.ShellScale or 1), 0)
	ent:SetMoveType(MOVETYPE_VPHYSICS) 
	ent:SetSolid(SOLID_VPHYSICS) 
	ent:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	ent.shellSound = t.s
	
	local phys = ent:GetPhysicsObject()
	phys:SetMaterial("gmod_silent")
	phys:SetMass(10)
	phys:SetVelocity(velocity)
	
	angleVel.x = math.random(-500, 500)
	angleVel.y = math.random(-500, 500)
	angleVel.z = math.random(-500, 500)
	
	phys:AddAngleVelocity(ang:Right() * 100 + angleVel)

	if t.s then
		ent.physCollCBID = ent:AddCallback("PhysicsCollide", cback)
	end
	
	SafeRemoveEntityDelayed(ent, removetime)
end

CustomizableWeaponry:addRegularSound("CW_SHELL_MAIN", {"player/pl_shell1.wav", "player/pl_shell2.wav", "player/pl_shell3.wav"}, 65)
CustomizableWeaponry:addRegularSound("CW_SHELL_SMALL", {"player/pl_shell1.wav", "player/pl_shell2.wav", "player/pl_shell3.wav"}, 65)
CustomizableWeaponry:addRegularSound("CW_SHELL_SHOT", {"weapons/fx/tink/shotgun_shell1.wav", "weapons/fx/tink/shotgun_shell2.wav", "weapons/fx/tink/shotgun_shell3.wav"}, 65)

CustomizableWeaponry.shells:addNew("mainshell", "models/weapons/rifleshell.mdl", "CW_SHELL_MAIN")
CustomizableWeaponry.shells:addNew("smallshell", "models/weapons/shell.mdl", "CW_SHELL_SMALL")
CustomizableWeaponry.shells:addNew("shotshell", "models/weapons/Shotgun_shell.mdl", "CW_SHELL_SHOT")


================================================
FILE: cw2/lua/cw/shared/cw_sight_position_adjustment.lua
================================================
AddCSLuaFile()

if CLIENT then
	CustomizableWeaponry.sightAdjustment = {}
	CustomizableWeaponry.sightAdjustment.adjustAmount = 0.15 -- percentage of maximum offset to move the sight by
	CustomizableWeaponry.sightAdjustment.currentAttData = nil
	CustomizableWeaponry.sightAdjustment.currentAttConfigData = nil
	CustomizableWeaponry.sightAdjustment.currentModelData = nil
	CustomizableWeaponry.sightAdjustment.folder = CustomizableWeaponry.baseFolder .. "/default_offsets/"
	CustomizableWeaponry.sightAdjustment.notificationAlpha = 0
	CustomizableWeaponry.sightAdjustment.notificationTime = 0
	CustomizableWeaponry.sightAdjustment.notificationText = nil
	
	function CustomizableWeaponry.sightAdjustment:adjust(wep, direction, adjustAmount)
		adjustAmount = adjustAmount or self.adjustAmount
		direction = adjustAmount * direction
		
		local modelData = self:getModelConfig(self.currentAttConfigData)
		local adjustRange = self.currentAttConfigData.adjustment
		local range = math.abs(adjustRange.min - adjustRange.max)
		
		if adjustRange.inverse then
			direction = -direction
		end
		
		local lastOffset = math.floor(self:getOffset(self.currentAttConfigData, self.currentAttConfigData.adjustment) * 20) -- floor + multiply by 20 to achieve increases in the value every 5
		modelData.pos[adjustRange.axis] = math.Clamp(modelData.pos[adjustRange.axis] + range * direction, adjustRange.min, adjustRange.max)
		
		local curOffset = math.floor(self:getOffset(self.currentAttConfigData, self.currentAttConfigData.adjustment) * 20)
		
		if CustomizableWeaponry.playSoundsOnInteract then
			if lastOffset ~= curOffset then -- only play the adjust sound if we actually changed the position
				wep:EmitSound("CW_ADJUST_SIGHT_POSITION")
			end
		end
	end
	
	function CustomizableWeaponry.sightAdjustment:setCurrentAttachment(attData, attData2, modelData)
		self.currentAttData = attData
		self.currentAttConfigData = attData2
		self.currentModelData = modelData
		
		if modelData then		
			-- create a new vector object, so that it doesn't overwrite origPos
			local pos = modelData.pos * 1
			modelData.pos = pos
		end
	end
	
	function CustomizableWeaponry.sightAdjustment:getCurrentAttachment()
		return self.currentAttData, self.currentModelData
	end
	
	function CustomizableWeaponry.sightAdjustment:getAdjustmentModelData(modelData, adjustment)
		if modelData.models then
			
			if modelData.adjustment.index then
				modelData = modelData.models[modelData.adjustment.index]
			else
				modelData = modelData.models[1]
			end
		end
	end
	
	function CustomizableWeaponry.sightAdjustment:canSetAttachment(wep, category)
		if not wep.AttachmentModelsVM then
			return false, nil
		end
		
		local attCategory = wep.Attachments[category]
		
		if attCategory then -- if there is one, check if there is an active attachment
			local attachment = nil
			
			if attCategory.last then
				attachment = attCategory.atts[attCategory.last] -- get the current attachment
			end
			
			if attachment then
				local attData = wep.AttachmentModelsVM[attachment]
				
				if attData and attData.adjustment and not wep:getPreventedAdjustment(attData) then -- if there is an attachment like this, and it can be adjusted, set it as the current adjustable attachment
					local modelData = attData
					
					if modelData.models then
						if attData.adjustment.index then
							modelData = modelData.models[attData.adjustment.index]
						else
							modelData = modelData.models[1]
						end
					end
					
					return attCategory, attData, modelData
				end
			end
		end
	end
	
	function CustomizableWeaponry.sightAdjustment:attemptSetAttachment(wep, category)
		local attData, attData2, modelData = self:canSetAttachment(wep, category)
		
		if attData and modelData then
			CustomizableWeaponry.sightAdjustment:setCurrentAttachment(attData, attData2, modelData)
			return true
		end
		
		return nil
	end
	
	function CustomizableWeaponry.sightAdjustment:getOffset(attData, adjustRange)
		local range = math.abs(adjustRange.min - adjustRange.max)
		
		attData = self:getModelConfig(attData)
		
		local curPos = attData.pos[adjustRange.axis]
		return math.abs(curPos - (adjustRange.inverseOffsetCalc and adjustRange.min or adjustRange.max)) / range
	end
	
	function CustomizableWeaponry.sightAdjustment:getIntendedRange(data, wep, offset)
		local curAtt = data.atts[data.last]
		
		if not wep.AttachmentModelsVM[curAtt].adjustment then
			return nil
		end
		
		if offset >= 0.66 then
			return "(FAR)"
		elseif offset >= 0.33 then
			return "(MID)"
		else
			return "(CLOSE)"
		end
	end
	
	function CustomizableWeaponry.sightAdjustment:setDefaultOffset(wep)
		local baseDir = CustomizableWeaponry.sightAdjustment.folder
		
		if not file.IsDir(baseDir, "DATA") then
			file.CreateDir(baseDir)
		end
		
		local name = wep.ThisClass or wep:GetClass()
		local fileName = baseDir .. name .. ".txt"
		local offsets = nil
		
		if file.Exists(fileName, "DATA") then -- if we currently have a file that contains default offsets, load it up so that we can append more data to it
			offsets = util.JSONToTable(file.Read(fileName, "DATA"))
		else -- otherwise we just create a new table that we'll write data to
			offsets = {}
		end
		
		local attData, attCfg = self.currentAttData, self.currentAttConfigData
		local modelData = self:getModelConfig(attCfg)
		local curAttName = attData.atts[attData.last]
		
		offsets[curAttName] = modelData.pos[attCfg.adjustment.axis] -- set the default offset
		file.Write(fileName, util.TableToJSON(offsets)) -- write to file
		self:setNotification("Saved offset successfully!", 2, 255)
	end
	
	function CustomizableWeaponry.sightAdjustment:setNotification(text, duration, startAlpha)
		self.notificationText = text
		self.notificationTime = CurTime() + duration
		self.notificationAlpha = startAlpha
	end
	
	function CustomizableWeaponry.sightAdjustment:getModelConfig(attData)
		if attData.models then
			if attData.adjustment.index then
				return attData.models[attData.adjustment.index]
			else
				return attData.models[1]
			end
		end
		
		return attData
	end
	
	function CustomizableWeaponry.sightAdjustment:loadDefaultOffsets(wep)
		local baseDir = CustomizableWeaponry.sightAdjustment.folder
		
		local name = wep.ThisClass or wep:GetClass()
		local fileName = baseDir .. name .. ".txt"
		
		if file.Exists(fileName, "DATA") then -- if we currently have a file that contains default offsets, load it up so that we can append more data to it
			local offsets = util.JSONToTable(file.Read(fileName, "DATA"))
			
			for attName, offset in pairs(offsets) do
				local att = wep.AttachmentModelsVM[attName]
				
				if att and att.adjustment then -- check for adjustment in case an adjustment for some attachment gets removed in later versions
					local modelData = self:getModelConfig(att)
					
					modelData.pos[att.adjustment.axis] = offset
				end
			end
		end
	end
	
	CustomizableWeaponry.callbacks:addNew("initialize", function(wep)
		local ply = LocalPlayer()
		
		-- make sure: 1) the weapon is valid, 2) it has an owner, 3) we're the owner, 4) we don't have this weapon yet
		if wep and wep.Owner and wep.Owner == ply and not ply:HasWeapon(wep:GetClass()) then
			CustomizableWeaponry.sightAdjustment:loadDefaultOffsets(wep)
		end
	end)
	
	local emptyString = ""
	local hud16 = "CW_HUD32"
	local hud18 = "CW_HUD38"
	local hud20 = "CW_HUD40"
	local hud36 = "CW_HUD48"
	local hud24 = "CW_HUD48"
	
	function CustomizableWeaponry.sightAdjustment:draw(wep)
		wep.HUDColors.white.a = 255 * wep.CustomizeMenuAlpha
		wep.HUDColors.black.a = 255 * wep.CustomizeMenuAlpha
				
		if not self.currentModelData then
			local validAdjustments = 0 -- amount of sights/attachments that can have their position adjusted
			
			for k, v in pairs(wep.Attachments) do
				local attCategoryData, attData, modelData = self:canSetAttachment(wep, k)
				
				if attCategoryData and modelData then
					-- first index of 'offset' table is X, second is Y
					local x, y = v.offset[1], v.offset[2]
					
					draw.ShadowText(v.keyText .. " - Adjust "  .. v.header .. " category", hud36, x, y + 6, wep.HUDColors.white, wep.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
					local offset = self:getOffset(attData, attData.adjustment)
					
					local rangeText = self:getIntendedRange(v, wep, offset)
			
					draw.ShadowText("Current offset: " .. math.floor(offset * 100) .. "% " .. (rangeText or ""), hud18, x, y + 50, wep.HUDColors.white, wep.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
					validAdjustments = validAdjustments + 1
				end
			end
			
			if validAdjustments == 0 then
				draw.ShadowText("None of the currently active attachments can be adjusted.", hud36, 200, -300, wep.HUDColors.white, wep.HUDColors.black, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end
		else
			local attCategoryData, attData, modelData = self.currentAttData, self.currentAttConfigData, self.currentModelData
			local x, y = attCategoryData.offset[1], attCategoryData.offset[2]
			
			local dist = self:getOffset(attData, attData.adjustment)
			
			draw.ShadowText("Adjusting category: " .. attCategoryData.header, hud36, x, y + 6, wep.HUDColors.white, wep.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			draw.ShadowText("Current offset: " .. math.floor(dist * 100) .. "% ", hud18, x, y + 50, wep.HUDColors.white, wep.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			
			surface.SetDrawColor(0, 0, 0, 255 * wep.CustomizeMenuAlpha)
			
			-- left side, black shadow
			surface.DrawRect(x, y + 80, 8, 50)
			surface.DrawRect(x + 8, y + 80, 10, 6)
			surface.DrawRect(x + 8, y + 124, 10, 6)
			
			surface.DrawRect(x + 10, y + 94, 300 * dist, 20) -- offset "progress bar"
			
			-- right side
			surface.DrawRect(x + 312, y + 80, 8, 50)
			surface.DrawRect(x + 302, y + 80, 10, 6)
			surface.DrawRect(x + 302, y + 124, 10, 6)
			
			surface.SetDrawColor(255, 255, 255, 255 * wep.CustomizeMenuAlpha)
			
			-- left side, white base
			surface.DrawRect(x - 2, y + 80, 8, 49)
			surface.DrawRect(x + 6, y + 80, 10, 6)
			surface.DrawRect(x + 6, y + 123, 10, 6)
			
			surface.DrawRect(x + 310, y + 80, 8, 49)
			surface.DrawRect(x + 300, y + 80, 10, 6)
			surface.DrawRect(x + 300, y + 123, 10, 6)
			
			surface.DrawRect(x + 10, y + 94, 298 * dist, 18)
			
			local rangeText = self:getIntendedRange(self.currentAttData, wep, dist)
			
			if rangeText then
				draw.ShadowText(rangeText, hud36, x + 330, y + 103, wep.HUDColors.white, wep.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			end
			
			local catOffset = 200
			
			if not wep.Owner:KeyDown(IN_ATTACK) then
				draw.ShadowText(wep:getKeyBind("+attack") .. " - Hold to begin adjusting", hud18, x, y + 160, wep.HUDColors.white, wep.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			else
				draw.ShadowText(wep:getKeyBind("+attack") .. " - Release to stop adjusting", hud18, x, y + 160, wep.HUDColors.white, wep.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
				draw.ShadowText("Move mouse horizontally to adjust", hud18, x, y + 200, wep.HUDColors.white, wep.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
				catOffset = 240
			end
			
			draw.ShadowText(wep:getKeyBind("+attack2") .. " - Deselect category", hud18, x, y + catOffset, wep.HUDColors.white, wep.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			draw.ShadowText(wep:getKeyBind("+reload") .. " - Save current offset as default offset", hud18, x, y + catOffset + 40, wep.HUDColors.white, wep.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			
			if CurTime() > self.notificationTime then
				self.notificationAlpha = math.Approach(self.notificationAlpha, 0, FrameTime() * 200)
			end
			
			if self.notificationAlpha > 0 then
				wep.HUDColors.green.a = self.notificationAlpha
				wep.HUDColors.black.a = self.notificationAlpha
				
				draw.ShadowText(self.notificationText, hud36, x, y + catOffset + 80, wep.HUDColors.green, wep.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			end
		end
		
		wep.HUDColors.white.a = 255
		wep.HUDColors.black.a = 255
		wep.HUDColors.green.a = 255
	end
	
	CustomizableWeaponry:addRegularSound("CW_ADJUST_SIGHT_POSITION", {"cw/switch1.wav", "cw/switch2.wav", "cw/switch3.wav"}) -- we only need this sound on the client
end


================================================
FILE: cw2/lua/cw/shared/cw_sounds.lua
================================================
AddCSLuaFile()

CustomizableWeaponry.registeredSoundNames = {}
CustomizableWeaponry.reloadSoundVolume = 60

-- default settings
CustomizableWeaponry.reloadSoundTable = {
	channel = CHAN_AUTO, 
	volume = 1,
	level = CustomizableWeaponry.reloadSoundVolume, 
	pitchstart = 100,
	pitchend = 100,
	name = "noName",
	sound = "path/to/sound"
	}
	
CustomizableWeaponry.fireSoundTable = {
	channel = CHAN_AUTO, 
	volume = 1,
	level = 97, 
	pitchstart = 92,
	pitchend = 112,
	name = "noName",
	sound = "path/to/sound"
	}
	
CustomizableWeaponry.regularSoundTable = {
	channel = CHAN_AUTO,
	volume = 1,
	level = 65, 
	pitchstart = 92,
	pitchend = 112,
	name = "noName",
	sound = "path/to/sound"
	}

-- "<" makes the sound directional, refer to https://developer.valvesoftware.com/wiki/Soundscripts#Sound_Characters
function CustomizableWeaponry:makeSoundDirectional(snd)
	if type(snd) == "table" then
		for key, sound in ipairs(snd) do
			snd[key] = "<" .. sound
		end
	else
		snd = "<" .. snd
	end
	
	return snd
end
	
function CustomizableWeaponry:addFireSound(name, snd, volume, soundLevel, channel, pitchStart, pitchEnd, noDirection)
	-- use defaults if no args are provided
	volume = volume or 1
	soundLevel = soundLevel or 97
	channel = channel or CHAN_AUTO
	pitchStart = pitchStart or 92
	pitchEnd = pitchEnd or 112
	
	if not noDirection then
		snd = self:makeSoundDirectional(snd)
	end
	
	self.fireSoundTable.name = name
	self.fireSoundTable.sound = snd
	
	self.fireSoundTable.channel = channel
	self.fireSoundTable.volume = volume
	self.fireSoundTable.level = soundLevel
	self.fireSoundTable.pitchstart = pitchStart
	self.fireSoundTable.pitchend = pitchEnd
	
	sound.Add(self.fireSoundTable)
	
	-- precache the registered sounds
	
	if type(self.fireSoundTable.sound) == "table" then
		for k, v in pairs(self.fireSoundTable.sound) do
			util.PrecacheSound(v)
		end
	else
		util.PrecacheSound(snd)
	end
	
	-- store all registered sound names so that we can retrieve them with findFireSound (in case someone names their firing sound in a lowercase manner and then uses upper case in the SWEP file)
	self.registeredSoundNames[string.lower(name)] = name
end

function CustomizableWeaponry:addReloadSound(name, snd, noDirection)
	if not noDirection then
		snd = self:makeSoundDirectional(snd)
	end
	
	self.reloadSoundTable.name = name
	self.reloadSoundTable.sound = snd

	sound.Add(self.reloadSoundTable)
	
	-- precache the registered sounds
	
	if type(self.reloadSoundTable.sound) == "table" then
		for k, v in pairs(self.reloadSoundTable.sound) do
			util.PrecacheSound(v)
		end
	else
		util.PrecacheSound(snd)
	end
end

function CustomizableWeaponry:addRegularSound(name, snd, level, noDirection)
	if not noDirection then
		snd = self:makeSoundDirectional(snd)
	end
	
	level = level or 65
	self.regularSoundTable.name = name
	self.regularSoundTable.sound = snd
	self.regularSoundTable.level = level

	sound.Add(self.regularSoundTable)
	
	-- precache the registered sounds
	
	if type(self.regularSoundTable.sound) == "table" then
		for k, v in pairs(self.regularSoundTable.sound) do
			util.PrecacheSound(v)
		end
	else
		util.PrecacheSound(snd)
	end
end

function CustomizableWeaponry:findFireSound(snd)
	snd = string.lower(snd)
	
	if self.registeredSoundNames[snd] then
		return self.registeredSoundNames[snd]
	end
	
	-- welp
	return nil
end


================================================
FILE: cw2/lua/cw/shared/ammotypes/am_flechetterounds.lua
================================================
local att = {}
att.name = "am_flechetterounds"
att.displayName = "Flechette rounds"
att.displayNameShort = "Flechette"

att.statModifiers = {ClumpSpreadMult = -0.15,
	DamageMult = -0.4}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/flechetterounds")
	att.description = {{t = "Increases amount of rounds per shot to 20.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self.Shots = 20
	self:unloadWeapon()
end

function att:detachFunc()
	self.Shots = self.Shots_Orig
	self:unloadWeapon()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/ammotypes/am_magnum.lua
================================================
local att = {}
att.name = "am_magnum"
att.displayName = "Magnum rounds"
att.displayNameShort = "Magnum"

att.statModifiers = {DamageMult = 0.15,
	RecoilMult = 0.25}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/magnumrounds")
	att.description = {}
end

function att:attachFunc()
	self:unloadWeapon()
end

function att:detachFunc()
	self:unloadWeapon()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/ammotypes/am_matchgrade.lua
================================================
local att = {}
att.name = "am_matchgrade"
att.displayName = "Match grade rounds"
att.displayNameShort = "Match"

att.statModifiers = {AimSpreadMult = -0.3}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/matchgradeammo")
	att.description = {}
end

function att:attachFunc()
	self:unloadWeapon()
end

function att:detachFunc()
	self:unloadWeapon()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/ammotypes/am_reducedpowderload.lua
================================================
local att = {}
att.name = "am_reducedpowderload"
att.displayName = "Reduced powder load"
att.displayNameShort = "RPL"

att.statModifiers = {DamageMult = -0.25,
	RecoilMult = -0.3,
	SpreadPerShotMult = -0.3}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/magnumrounds")
	att.description = {{t = "Reduced powder load, which reduces muzzle velocity and recoil alike.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self:unloadWeapon()
end

function att:detachFunc()
	self:unloadWeapon()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/ammotypes/am_slugrounds.lua
================================================
local att = {}
att.name = "am_slugrounds"
att.displayName = "Slug rounds"
att.displayNameShort = "Slug"

att.statModifiers = {DamageMult = 8,
	AimSpreadMult = 1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/slugrounds")
	att.description = {{t = "Greatly increases accuracy.", c = CustomizableWeaponry.textColors.POSITIVE},
	{t = "Fires out only 1 pellet.", c = CustomizableWeaponry.textColors.NEGATIVE}}
end

function att:attachFunc()
	self.Shots = 1
	self.ClumpSpread = nil
	self:unloadWeapon()
end

function att:detachFunc()
	self.Shots = self.Shots_Orig
	self.ClumpSpread = self.ClumpSpread_Orig
	self:unloadWeapon()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/ammotypes/am_ultramegamatchammo.lua
================================================
local att = {}
att.name = "am_ultramegamatchammo"
att.displayName = "Ultra Mega Match grade rounds"
att.displayNameShort = "UMGMatch"

att.statModifiers = {AimSpreadMult = -0.99}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/matchgradeammo")
	att.description = {
		{t = "ur gay lol", c = CustomizableWeaponry.textColors.VNEGATIVE},
		{t = "i kiss you on the lips", c = CustomizableWeaponry.textColors.VPOSITIVE},
		{t = "i love you", c = CustomizableWeaponry.textColors.VPOSITIVE},
		{t = "oh god im gonna cum", c = CustomizableWeaponry.textColors.VPOSITIVE},
		{t = "hello buy Intravenous :)", c = CustomizableWeaponry.textColors.VPOSITIVE},
	}
end

function att:attachFunc()
	self:unloadWeapon()
end

function att:detachFunc()
	self:unloadWeapon()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_ak74_rpkbarrel.lua
================================================
local att = {}
att.name = "bg_ak74_rpkbarrel"
att.displayName = "RPK variant"
att.displayNameShort = "RPK"
att.isBG = true
att.categoryFactors = {cqc = -1, lmg = 3}
att.SpeedDec = 3

att.statModifiers = {DamageMult = 0.1,
AimSpreadMult = -0.2,
OverallMouseSensMult = -0.15}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/ak74_rpkbarrel")
	att.description = {[1] = {t = "Allows the use of a bipod.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.rpk)
	self:setBodygroup(self.ReceiverBGs.main, self.ReceiverBGs.rpk)
	self:updateSoundTo("CW_AK74_RPK_FIRE", CustomizableWeaponry.sounds.UNSUPPRESSED)
	self:updateSoundTo("CW_AK74_RPK_FIRE_SUPPRESSED", CustomizableWeaponry.sounds.SUPPRESSED)
	self:setupCurrentIronsights(self.RPKPos, self.RPKAng)
	self.BipodInstalled = true
	
	if not self:isAttachmentActive("sights") then
		self:updateIronsights("RPK")
	end
end

function att:detachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.regular)
	self:setBodygroup(self.ReceiverBGs.main, self.ReceiverBGs.regular)
	self.BipodInstalled = false
	
	self:restoreSound()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_ak74_ubarrel.lua
================================================
local att = {}
att.name = "bg_ak74_ubarrel"
att.displayName = "Shortened barrel"
att.displayNameShort = "Short"
att.isBG = true
att.categoryFactors = {cqc = 3}
att.SpeedDec = -3

att.statModifiers = {RecoilMult = 0.05,
AimSpreadMult = 1,
OverallMouseSensMult = 0.1,
DrawSpeedMult = 0.15,
DamageMult = -0.1,
FireDelayMult = -0.0714285}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/ak74_ubarrel")
end

function att:attachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.short)
	self:setupCurrentIronsights(self.ShortenedPos, self.ShortenedAng)
	
	if not self:isAttachmentActive("sights") then
		self:updateIronsights("Shortened")
	end
end

function att:detachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.regular)
	self:restoreSound()
	self:revertToOriginalIronsights()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_ak74foldablestock.lua
================================================
local att = {}
att.name = "bg_ak74foldablestock"
att.displayName = "Foldable stock"
att.displayNameShort = "F. stock"
att.isBG = true
att.SpeedDec = -5

att.statModifiers = {DrawSpeedMult = 0.15,
RecoilMult = 0.1,
OverallMouseSensMult = 0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/ak74foldablestock")
end

function att:attachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.foldable)
end

function att:detachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.regular)
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_ak74heavystock.lua
================================================
local att = {}
att.name = "bg_ak74heavystock"
att.displayName = "Heavy stock"
att.displayNameShort = "H. stock"
att.isBG = true

att.statModifiers = {RecoilMult = -0.1,
OverallMouseSensMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/ak74heavystock")
end

function att:attachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.heavy)
end

function att:detachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.regular)
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_ak74rpkmag.lua
================================================
local att = {}
att.name = "bg_ak74rpkmag"
att.displayName = "RPK Magazine"
att.displayNameShort = "RPK Mag"
att.isBG = true

att.statModifiers = {ReloadSpeedMult = -0.1,
OverallMouseSensMult = -0.05}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/rpkmag")
	att.description = {[1] = {t = "Increases mag size to 45 rounds.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self:setBodygroup(self.MagBGs.main, self.MagBGs.rpk)
	self:unloadWeapon()
	self.Primary.ClipSize = 45
	self.Primary.ClipSize_Orig = 45
end

function att:detachFunc()
	self:setBodygroup(self.MagBGs.main, self.MagBGs.regular)
	self:unloadWeapon()
	self.Primary.ClipSize = self.Primary.ClipSize_ORIG_REAL
	self.Primary.ClipSize_Orig = self.Primary.ClipSize_ORIG_REAL
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_ar1560rndmag.lua
================================================
local att = {}
att.name = "bg_ar1560rndmag"
att.displayName = "Quad-stack mag"
att.displayNameShort = "Quad"
att.isBG = true
att.SpeedDec = 2

att.statModifiers = {ReloadSpeedMult = -0.15,
DrawSpeedMult = -0.05,
HipSpreadMult = 0.075,
VelocitySensitivityMult = 0.07,
OverallMouseSensMult = -0.05}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/ar1560rndmag")
	att.description = {[1] = {t = "Increases mag size to 60 rounds.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self:setBodygroup(self.MagBGs.main, self.MagBGs.round60)
	self:unloadWeapon()
	self.Primary.ClipSize = 60
	self.Primary.ClipSize_Orig = 60
end

function att:detachFunc()
	self:setBodygroup(self.MagBGs.main, self.MagBGs.regular)
	self:unloadWeapon()
	self.Primary.ClipSize = self.Primary.ClipSize_ORIG_REAL
	self.Primary.ClipSize_Orig = self.Primary.ClipSize_ORIG_REAL
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_ar15heavystock.lua
================================================
local att = {}
att.name = "bg_ar15heavystock"
att.displayName = "Heavy stock"
att.displayNameShort = "H. stock"
att.isBG = true
att.SpeedDec = 2

att.statModifiers = {RecoilMult = -0.1,
OverallMouseSensMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/ar15heavystock")
end

function att:attachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.heavy)
end

function att:detachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.regular)
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_ar15sturdystock.lua
================================================
local att = {}
att.name = "bg_ar15sturdystock"
att.displayName = "Sturdy stock"
att.displayNameShort = "S. stock"
att.isBG = true

att.statModifiers = {RecoilMult = -0.05,
OverallMouseSensMult = -0.05}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/ar15sturdystock")
end

function att:attachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.sturdy)
end

function att:detachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.regular)
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_bipod.lua
================================================
local att = {}
att.name = "bg_bipod"
att.displayName = "Bipod"
att.displayNameShort = "Bipod"
att.isBG = true

att.statModifiers = {OverallMouseSensMult = -0.1,
DrawSpeedMult = -0.15}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/bipod")
	att.description = {[1] = {t = "When deployed:", c = CustomizableWeaponry.textColors.REGULAR},
	[2] = {t = "Decreases recoil by 70%", c = CustomizableWeaponry.textColors.POSITIVE},
	[3] = {t = "Greatly increases hip fire accuracy", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self:setBodygroup(self.BipodBGs.main, self.BipodBGs.on)
	self.BipodInstalled = true
end

function att:detachFunc()
	self:setBodygroup(self.BipodBGs.main, self.BipodBGs.off)
	self.BipodInstalled = false
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_deagle_compensator.lua
================================================
local att = {}
att.name = "bg_deagle_compensator"
att.displayName = "Compensator"
att.displayNameShort = "Comp"
att.isBG = true

att.statModifiers = {RecoilMult = -0.3,
AimSpreadMult = 0.15,
OverallMouseSensMult = -0.1,
DrawSpeedMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/deagle_compensator")
end

function att:attachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.compensator)
end

function att:detachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.regular)
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_deagle_extendedbarrel.lua
================================================
local att = {}
att.name = "bg_deagle_extendedbarrel"
att.displayName = "Extended barrel"
att.displayNameShort = "Ext. b."
att.isBG = true

att.statModifiers = {AimSpreadMult = -0.2,
OverallMouseSensMult = -0.1,
DrawSpeedMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/deagle_extendedbarrel")
end

function att:attachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.extended)
end

function att:detachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.regular)
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_foldsight.lua
================================================
local att = {}
att.name = "bg_foldsight"
att.displayName = "Folding sights"
att.displayNameShort = "Fold"
att.isBG = true
att.isSight = true
att.aimPos = {"FoldSightPos", "FoldSightAng"}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/foldsight")
	att.description = {[1] = {t = "A folding variant of regular ironsights.", c = CustomizableWeaponry.textColors.COSMETIC}}
	
	function att:attachFunc()
		self:setBodygroup(self.SightBGs.main, self.SightBGs.foldsight)
	end
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_longbarrel.lua
================================================
local att = {}
att.name = "bg_longbarrel"
att.displayName = "Long barrel"
att.displayNameShort = "LNGRNG"
att.isBG = true
att.SpeedDec = 2

att.statModifiers = {DamageMult = 0.05,
AimSpreadMult = -0.1,
OverallMouseSensMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/ar15longbarrel")
	att.description = {[1] = {t = "A barrel for long range engagements.", c = CustomizableWeaponry.textColors.REGULAR}}
end

function att:attachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.long)
	self:updateSoundTo("CW_AR15_LONGBARREL_FIRE", CustomizableWeaponry.sounds.UNSUPPRESSED)
	self:updateSoundTo("CW_AR15_LONGBARREL_FIRE_SUPPRESSED", CustomizableWeaponry.sounds.SUPPRESSED)
end

function att:detachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.regular)
	self:restoreSound()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_longbarrelmr96.lua
================================================
local att = {}
att.name = "bg_longbarrelmr96"
att.displayName = "Long barrel"
att.displayNameShort = "Long"
att.isBG = true

att.statModifiers = {RecoilMult = 0.2,
AimSpreadMult = -0.2,
DrawSpeedMult = -0.2,
OverallMouseSensMult = -0.1,
DamageMult = 0.2}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/longbarrel_revolver")
end

function att:attachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.long)
	self:updateSoundTo("CW_MR96_FIRE_LONG", CustomizableWeaponry.sounds.UNSUPPRESSED)
end

function att:detachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.short)
	self:restoreSound()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_longris.lua
================================================
local att = {}
att.name = "bg_longris"
att.displayName = "Long barrel RIS"
att.displayNameShort = "EXT RIS"
att.isBG = true
att.SpeedDec = 3

att.statModifiers = {DamageMult = 0.05,
AimSpreadMult = -0.1,
RecoilMult = 0.05,
OverallMouseSensMult = -0.1
}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/ar15longris")
	att.description = {[1] = {t = "A rail interface for long barrels.", c = CustomizableWeaponry.textColors.REGULAR},
	[2] = {t = "Allows additional attachments.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.longris)
	self:updateSoundTo("CW_AR15_LONGBARREL_FIRE", CustomizableWeaponry.sounds.UNSUPPRESSED)
	self:updateSoundTo("CW_AR15_LONGBARREL_FIRE_SUPPRESSED", CustomizableWeaponry.sounds.SUPPRESSED)
end

function att:detachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.regular)
	self:restoreSound()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_magpulhandguard.lua
================================================
local att = {}
att.name = "bg_magpulhandguard"
att.displayName = "Magpul handguard"
att.displayNameShort = "Magpul"
att.isBG = true

att.statModifiers = {OverallMouseSensMult = 0.1,
	DrawSpeedMult = 0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/ar15magpul")
	att.description = {[1] = {t = "A comfortable, lightweight handguard.", c = CustomizableWeaponry.textColors.REGULAR}}
end

function att:attachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.magpul)
end

function att:detachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.regular)
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_mp530rndmag.lua
================================================
local att = {}
att.name = "bg_mp530rndmag"
att.displayName = "30 round magazine"
att.displayNameShort = "30 RND"
att.isBG = true

att.statModifiers = {ReloadSpeedMult = -0.1,
OverallMouseSensMult = -0.05}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/mp530rnd")
	att.description = {[1] = {t = "Increases mag size to 30 rounds.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self:setBodygroup(self.MagBGs.main, self.MagBGs.round30)
	self:unloadWeapon()
	self.Primary.ClipSize = 30
	self.Primary.ClipSize_Orig = 30
end

function att:detachFunc()
	self:setBodygroup(self.MagBGs.main, self.MagBGs.round15)
	self:unloadWeapon()
	self.Primary.ClipSize = self.Primary.ClipSize_ORIG_REAL
	self.Primary.ClipSize_Orig = self.Primary.ClipSize_ORIG_REAL
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_mp5_kbarrel.lua
================================================
local att = {}
att.name = "bg_mp5_kbarrel"
att.displayName = "K variant"
att.displayNameShort = "Short"
att.isBG = true
att.SpeedDec = -5

att.statModifiers = {RecoilMult = -0.2,
AimSpreadMult = 0.7,
OverallMouseSensMult = 0.15,
DrawSpeedMult = 0.2,
FireDelayMult = -0.11111111111111}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/mp5_kbarrel")
end

function att:attachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.k)
	self:setupCurrentIronsights(self.SDPos, self.SDAng)
	self:updateSoundTo("CW_MP5K_FIRE", CustomizableWeaponry.sounds.UNSUPPRESSED)
	self.ForegripOverride = true
	self.ForegripParent = "bg_mp5_kbarrel"
	self.MuzzleEffect = "muzzleflash_smg"
	
	if not self:isAttachmentActive("sights") then
		self:updateIronsights("K")
	end
end

function att:detachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.regular)
	self:restoreSound()
	self:revertToOriginalIronsights()
	self.ForegripOverride = false
	self.MuzzleEffect = "muzzleflash_smg"
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_mp5_sdbarrel.lua
================================================
local att = {}
att.name = "bg_mp5_sdbarrel"
att.displayName = "SD variant"
att.displayNameShort = "SD"
att.isBG = true

att.statModifiers = {RecoilMult = -0.25,
AimSpreadMult = 0.3,
OverallMouseSensMult = 0.15,
FireDelayMult = 0.14285714285714}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/mp5_sdbarrel")
end

function att:attachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.sd)
	self:setupCurrentIronsights(self.SDPos, self.SDAng)
	self:updateSoundTo("CW_MP5_FIRE_SUPPRESSED", CustomizableWeaponry.sounds.SUPPRESSED)
	self.ForegripOverride = true
	self.ForegripParent = "bg_mp5_sdbarrel"
	self.dt.Suppressed = true
	
	if not self:isAttachmentActive("sights") then
		self:updateIronsights("SD")
	end
end

function att:detachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.regular)
	self:restoreSound()
	self:revertToOriginalIronsights()
	self.ForegripOverride = false
	self.dt.Suppressed = false
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_nostock.lua
================================================
local att = {}
att.name = "bg_nostock"
att.displayName = "No stock"
att.displayNameShort = "None"
att.isBG = true
att.SpeedDec = -5

att.statModifiers = {DrawSpeedMult = 0.2,
OverallMouseSensMult = 0.2,
RecoilMult = 0.2}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/nostock")
end

function att:attachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.none)
end

function att:detachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.regular)
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_regularbarrel.lua
================================================
local att = {}
att.name = "bg_regularbarrel"
att.displayName = "Regular barrel"
att.displayNameShort = "Regular"
att.isBG = true

att.statModifiers = {RecoilMult = 0.1,
AimSpreadMult = -0.15,
DrawSpeedMult = -0.10}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/regularbarrel_revolver")
end

function att:attachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.regular)
	self:updateSoundTo("CW_MR96_FIRE", CustomizableWeaponry.sounds.UNSUPPRESSED)
end

function att:detachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.short)
	self:restoreSound()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_retractablestock.lua
================================================
local att = {}
att.name = "bg_retractablestock"
att.displayName = "Retractable stock"
att.displayNameShort = "R. stock"
att.isBG = true
att.SpeedDec = -3

att.statModifiers = {DrawSpeedMult = 0.1,
OverallMouseSensMult = 0.1,
RecoilMult = 0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/retractablestock")
end

function att:attachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.retractable)
end

function att:detachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.regular)
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_ris.lua
================================================
local att = {}
att.name = "bg_ris"
att.displayName = "RIS"
att.displayNameShort = "RIS"
att.isBG = true

att.statModifiers = {RecoilMult = 0.05}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/ar15ris")
	att.description = {[1] = {t = "A rail interface.", c = CustomizableWeaponry.textColors.REGULAR},
	[2] = {t = "Allows additional attachments.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.ris)
end

function att:detachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.regular)
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/bg_sg1scope.lua
================================================
local att = {}
att.name = "bg_sg1scope"
att.displayName = "SG1 Scope"
att.displayNameShort = "SG1"
att.isBG = true
att.isSight = true
att.aimPos = {"SG1Pos", "SG1Ang"}
att.withoutRail = true
att.SpeedDec = 3

att.statModifiers = {OverallMouseSensMult = -0.2}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/sg1scope")
	att.description = {[1] = {t = "Provides 6x magnification.", c = CustomizableWeaponry.textColors.POSITIVE},
	[2] = {t = "Narrow scope greatly decreases awareness.", c = CustomizableWeaponry.textColors.NEGATIVE},
	[3] = {t = "Is disorienting at close range.", c = CustomizableWeaponry.textColors.NEGATIVE}}
	
	local old, x, y, ang
	local reticle = surface.GetTextureID("cw2/reticles/scope_leo")
	
	att.zoomTextures = {[1] = {tex = reticle, offset = {0, 1}}}

	att.shadowMaskConfig = {		
		w = 768, -- base width of the texture, should match the texture size
		h = 768, -- same, but height
		wOff = 352, -- width offset for the mask texture
		hOff = 352, -- height offset for the mask texture
		maxOffset = 164, -- maximum pixel offset for the 'shadow' effect
		maskMaxStrength = 1, -- at what point will the shadow mask reach peak strength?
		maxZoom = 352, -- how many pixels can we zoom in at most based on the difference between our base viewmodel position and aim position?
		posX = 1, -- shadow offset position multiplier, X
		posY = 1, -- shadow offset position multiplier, Y
		flipAngles = false -- whether we should swap pitch with yaw when calculating the shadow mask offset
	}

	local lens = surface.GetTextureID("cw2/gui/lense")
	local lensMat = Material("cw2/gui/lense")
	local cd, alpha = {}, 0.5
	local Ini = true
	
	-- render target var setup
	cd.x = 0
	cd.y = 0
	cd.w = 512
	cd.h = 512
	cd.fov = 7
	cd.drawviewmodel = false
	cd.drawhud = false
	cd.dopostprocess = false
	
	function att:drawRenderTarget()
		local complexTelescopics = self:canUseComplexTelescopics()
		
		-- if we don't have complex telescopics enabled, don't do anything complex, and just set the texture of the lens to a fallback 'lens' texture
		if not complexTelescopics then
			self.TSGlass:SetTexture("$basetexture", lensMat:GetTexture("$basetexture"))
			return
		end
		
		if self:canSeeThroughTelescopics(att.aimPos[1]) then
			alpha = math.Approach(alpha, 0, FrameTime() * 5)
		else
			alpha = math.Approach(alpha, 1, FrameTime() * 5)
		end
		
		x, y = ScrW(), ScrH()
		old = render.GetRenderTarget()
	
		ang = self:getTelescopeAnglesNew()
		
		if not self.TelescopeSkipRotate then
			if self.ViewModelFlip then
				ang.r = -self.BlendAng.z
			else
				ang.r = self.BlendAng.z
			end
		end
		
		--[[if not self.freeAimOn then
			ang.r = self.BlendAng.z
			ang:RotateAroundAxis(ang:Right(), self.ACOGAxisAlign.right)
			ang:RotateAroundAxis(ang:Up(), self.ACOGAxisAlign.up)
			ang:RotateAroundAxis(ang:Forward(), self.ACOGAxisAlign.forward)
		end]]
		
		local size = self:getRenderTargetSize()

		cd.w = size
		cd.h = size
		cd.angles = ang
		cd.origin = self.Owner:GetShootPos()
		render.SetRenderTarget(self.ScopeRT)
		render.SetViewPort(0, 0, size, size)
			if alpha < 1 or Ini then
				render.RenderView(cd)
				Ini = false
			end
			
			ang = self.Owner:EyeAngles()
			ang.p = ang.p + self.BlendAng.x
			ang.y = ang.y + self.BlendAng.y
			ang.r = ang.r + self.BlendAng.z
			ang = -ang:Forward()
			
			local light = render.ComputeLighting(self.Owner:GetShootPos(), ang)
			
			cam.Start2D()				
				surface.SetDrawColor(255, 255, 255, 255)
				surface.SetTexture(reticle)
				surface.DrawTexturedRect(0, 0, size, size)

				if alpha < 1 then
					self:drawLensShadow(size, size, att.shadowMaskConfig)
				end
				
				surface.SetDrawColor(150 * light[1], 150 * light[2], 150 * light[3], 255 * alpha)
				surface.SetTexture(lens)
				surface.DrawTexturedRectRotated(size * 0.5, size * 0.5, size, size, 90)
			cam.End2D()
		render.SetViewPort(0, 0, x, y)
		render.SetRenderTarget(old)
		
		if self.TSGlass then
			self.TSGlass:SetTexture("$basetexture", self.ScopeRT)
		end
	end
end

function att:attachFunc()
	self.OverrideAimMouseSens = 0.3
	self.SimpleTelescopicsFOV = 80
	self.BlurOnAim = true
	self.ZoomTextures = att.zoomTextures
	
	self:setBodygroup(self.SightBGs.main, self.SightBGs.sg1)
	self.AimBreathingEnabled = true
end

function att:detachFunc()
	self.OverrideAimMouseSens = nil
	self.SimpleTelescopicsFOV = nil
	self.BlurOnAim = false
	self.AimBreathingEnabled = false
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_acog.lua
================================================
local att = {}
att.name = "md_acog"
att.displayName = "Trijicon ACOG"
att.displayNameShort = "ACOG"
att.aimPos = {"ACOGPos", "ACOGAng"}
att.FOVModifier = 15
att.isSight = true
att.SpeedDec = 1

att.statModifiers = {OverallMouseSensMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/acog")
	att.description = {[1] = {t = "Provides 4x magnification.", c = CustomizableWeaponry.textColors.POSITIVE},
	[2] = {t = "Has back-up sights. Double-tap use key to toggle.", c = CustomizableWeaponry.textColors.POSITIVE},
	[3] = {t = "Narrow scope reduces spatial awareness.", c = CustomizableWeaponry.textColors.NEGATIVE}}

	local old, x, y, ang	
	local reticle = surface.GetTextureID("cw2/reticles/reticle_chevron_clean")
	
	att.newTelescopicsFOV = true
	-- default shadow mask config
	att.shadowMaskConfig = {		
		w = 768, -- base width of the texture, should match the texture size
		h = 768, -- same, but height
		wOff = 352, -- width offset for the mask texture
		hOff = 352, -- height offset for the mask texture
		maxOffset = 130, -- maximum pixel offset for the 'shadow' effect
		maskMaxStrength = 1, -- at what point will the shadow mask reach peak strength?
		maxZoom = 416, -- how many pixels can we zoom in at most based on the difference between our base viewmodel position and aim position?
		posX = 1, -- shadow offset position multiplier, X
		posY = 1, -- shadow offset position multiplier, Y
		flipAngles = false -- whether we should swap pitch with yaw when calculating the shadow mask offset
	}

	att.zoomTextures = {[1] = {tex = reticle, offset = {0, 1}}}
	
	local lens = surface.GetTextureID("cw2/gui/lense")
	local lensMat = Material("cw2/gui/lense")
	
	local cd, alpha = {}, 0.5
	local Ini = true
	
	-- render target var setup
	cd.x = 0
	cd.y = 0
	cd.w = 512
	cd.h = 512
	cd.fov = 10
	cd.drawviewmodel = false
	cd.drawhud = false
	cd.dopostprocess = false
	
	function att:drawRenderTarget()
		local complexTelescopics = self:canUseComplexTelescopics()
		
		-- if we don't have complex telescopics enabled, don't do anything complex, and just set the texture of the lens to a fallback 'lens' texture
		if not complexTelescopics then
			self.TSGlass:SetTexture("$basetexture", lensMat:GetTexture("$basetexture"))
			return
		end
		
		if self:canSeeThroughTelescopics(att.aimPos[1]) then
			alpha = math.Approach(alpha, 0, FrameTime() * 5)
		else
			alpha = math.Approach(alpha, 1, FrameTime() * 5)
		end
		
		x, y = ScrW(), ScrH()
		old = render.GetRenderTarget()
	
		ang = self:getTelescopeAnglesNew()
		
		if not self.TelescopeSkipRotate then
			if self.ViewModelFlip then
				ang.r = -self.BlendAng.z
			else
				ang.r = self.BlendAng.z
			end
		end
		
		if self.ACOGAxisAlignNew then
			ang:RotateAroundAxis(ang:Right(), self.ACOGAxisAlignNew.right)
			ang:RotateAroundAxis(ang:Up(), self.ACOGAxisAlignNew.up)
			ang:RotateAroundAxis(ang:Forward(), self.ACOGAxisAlignNew.forward)
		end
		
		local size = self:getRenderTargetSize()
		
		cd.w = size
		cd.h = size
		cd.angles = ang
		cd.origin = self.Owner:GetShootPos()
		render.SetRenderTarget(self.ScopeRT)
		render.SetViewPort(0, 0, size, size)
			if alpha < 1 or Ini then
				render.RenderView(cd)
				Ini = false
			end
			
			ang = self.Owner:EyeAngles()
			ang.p = ang.p + self.BlendAng.x
			ang.y = ang.y + self.BlendAng.y
			ang.r = ang.r + self.BlendAng.z
			ang = -ang:Forward()
			
			local light = render.ComputeLighting(self.Owner:GetShootPos(), ang)
			
			cam.Start2D()				
				surface.SetDrawColor(255, 255, 255, 255)
				surface.SetTexture(reticle)
				surface.DrawTexturedRect(size * 0.125, size * 0.125, size * 0.75, size * 0.75)
				
				if alpha < 1 then
					self:drawLensShadow(size, size, att.shadowMaskConfig)
				end
				
				surface.SetDrawColor(150 * light[1], 150 * light[2], 150 * light[3], 255 * alpha)
				surface.SetTexture(lens)
				surface.DrawTexturedRectRotated(size * 0.5, size * 0.5, size, size, 90)
			cam.End2D()
		render.SetViewPort(0, 0, x, y)
		render.SetRenderTarget(old)
		
		if self.TSGlass then
			self.TSGlass:SetTexture("$basetexture", self.ScopeRT)
		end
	end
end

function att:attachFunc()
	self.OverrideAimMouseSens = 0.35
	self.SimpleTelescopicsFOV = 12
	self.AimViewModelFOV = 50
	self.BlurOnAim = true
	self.ZoomTextures = att.zoomTextures
end

function att:detachFunc()
	self.OverrideAimMouseSens = nil
	self.SimpleTelescopicsFOV = nil
	self.AimViewModelFOV = self.AimViewModelFOV_Orig
	self.BlurOnAim = false
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_aimpoint.lua
================================================
local att = {}
att.name = "md_aimpoint"
att.displayName = "Aimpoint"
att.displayNameShort = "Aimpoint"
att.aimPos = {"AimpointPos", "AimpointAng"}
att.FOVModifier = 20
att.isSight = true
att.colorType = CustomizableWeaponry.colorableParts.COLOR_TYPE_SIGHT
att.statModifiers = {OverallMouseSensMult = -0.07}
att.SpeedDec = 1

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/compm4")
	att.description = {[1] = {t = "Provides a bright reticle to ease aiming.", c = CustomizableWeaponry.textColors.POSITIVE},
	[2] = {t = "Slightly increases aim zoom.", c = CustomizableWeaponry.textColors.POSITIVE},
	[3] = {t = "Narrow scope may decrease awareness.", c = CustomizableWeaponry.textColors.NEGATIVE}}
	
	att.reticle = "cw2/reticles/aim_reticule"
	att._reticleSize = 0.4
	
	function att:drawReticle()
		if not self:isAiming() or not self:isReticleActive() then
			return
		end
		
		diff = self:getDifferenceToAimPos(self.AimpointPos, self.AimpointAng, 1)
		
		-- draw the reticle only when it's close to center of the aiming position
		if diff > 0.9 and diff < 1.1 then
			cam.IgnoreZ(true)
				render.SetMaterial(att._reticle)
				dist = math.Clamp(math.Distance(1, 1, diff, diff), 0, 0.13)
				
				local EA = self:getReticleAngles()
				
				local renderColor = self:getSightColor(att.name)
				renderColor.a = (0.13 - dist) / 0.13 * 255
				
				local pos = EyePos() + EA:Forward() * 100
				
				for i = 1, 2 do
					render.DrawSprite(pos, att._reticleSize, att._reticleSize, renderColor)
				end
			cam.IgnoreZ(false)
		end
	end
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_anpeq15.lua
================================================
local att = {}
att.name = "md_anpeq15"
att.displayName = "AN/PEQ-15"
att.displayNameShort = "AN/PEQ"
att.laserRange = 4096
att.laserBeamRange = 75
att.colorType = CustomizableWeaponry.colorableParts.COLOR_TYPE_BEAM

att.statModifiers = {VelocitySensitivityMult = -0.2,
OverallMouseSensMult = -0.05,
HipSpreadMult = -0.2,
DrawSpeedMult = -0.1,
MaxSpreadIncMult = -0.25}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/anpeq15")
	local beam = Material("cw2/reticles/aim_reticule")
	local laserDot = Material("cw2/reticles/aim_reticule")
	
	att.reticle = "cw2/reticles/aim_reticule"
	local td = {}
	
	function att:elementRender()
		local model = self.AttachmentModelsVM.md_anpeq15.ent
		local pos = model:GetPos()
		local ang = self:getLaserAngles(model)
		local angs = nil
		
		if not self.freeAimOn then
			if self.dt.State == CW_AIMING then
				angs = self.LaserAngAdjustAim
			end
		end
		
		angs = angs or self.LaserAngAdjust
		
		-- rotate and prepare the position
		ang:RotateAroundAxis(ang:Right(), angs.p)
		ang:RotateAroundAxis(ang:Up(), angs.y)
		ang:RotateAroundAxis(ang:Forward(), angs.r)
		
		local dir = ang * 1
		
		if not self.freeAimOn then
			if self.dt.State == CW_AIMING then
				local vp = self.Owner:GetViewPunchAngles()
				
				dir.p = self.Owner:EyeAngles().p + vp.p
			end
		end
		
		local fw = dir:Forward()
		
		local laserPos = pos + ang:Right() * self.LaserPosAdjust.x + ang:Forward() * self.LaserPosAdjust.y + ang:Up() * self.LaserPosAdjust.z
		
		td.start = laserPos
		td.endpos = td.start + fw * att.laserRange
		td.filter = self.Owner
		
		local tr = util.TraceLine(td)
		
		if not self.lastLaserPos then
			self.lastLaserPos = tr.HitPos
		end
		
		local dist = math.Clamp(att.laserRange * tr.Fraction, 0, att.laserBeamRange)
		
		if util.PointContents(tr.HitPos) != CONTENTS_SOLID and not self.NearWall then
			local renderColor = self:getSightColor(att.name)
			local laserHQ = GetConVarNumber("cw_laser_quality") > 1
			
			-- draw the beam
			renderColor.a = 100
			render.SetMaterial(beam)
			
			render.DrawBeam(laserPos + fw, laserPos + fw * dist, 0.1, 0, 0.99, renderColor)
			
			if laserHQ then
				renderColor.a = 50
				render.DrawBeam(laserPos + fw, laserPos + fw * dist, 0.6, 0, 0.99, renderColor)
				
				renderColor.a = 25
				render.DrawBeam(laserPos + fw, laserPos + fw * dist, 1, 0, 0.99, renderColor)
			end
			
			-- draw the dot if the model is not out of world bounds
			renderColor.a = 255
			
			render.SetMaterial(laserDot)
			
			if GetConVarNumber("cw_laser_blur") >= 1 then
				render.DrawBeam(self.lastLaserPos, tr.HitPos, 1.5, 0, 0.99, renderColor)
				
				local dist = math.Clamp(self.lastLaserPos:Distance(tr.HitPos), 0, 2)

				dist = 1 - (dist / 2)
				
				if dist < 2 then
					renderColor.a = 255 * dist
					render.DrawSprite(tr.HitPos, 1.5, 1.5, renderColor)
					
					if laserHQ then
						renderColor.a = 33 * dist
						render.DrawSprite(tr.HitPos, 3, 3, renderColor)
					end
				end
			else
				render.DrawSprite(tr.HitPos, 1.5, 1.5, renderColor)
				
				if laserHQ then
					renderColor.a = 33
					render.DrawSprite(tr.HitPos, 3, 3, renderColor)
				end
			end
			
			self.lastLaserPos = tr.HitPos
		end
	end
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_bipod.lua
================================================
local att = {}
att.name = "md_bipod"
att.displayName = "Harris Bipod"
att.displayNameShort = "Bipod"

att.statModifiers = {OverallMouseSensMult = -0.1,
DrawSpeedMult = -0.15}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/bipod")
	att.description = {[1] = {t = "When deployed:", c = CustomizableWeaponry.textColors.REGULAR},
	[2] = {t = "Decreases recoil by 70%", c = CustomizableWeaponry.textColors.POSITIVE},
	[3] = {t = "Greatly increases hip fire accuracy", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self.BipodInstalled = true
end

function att:detachFunc()
	self.BipodInstalled = false
end

function att:elementRender()
	local model = self.AttachmentModelsVM.md_bipod.ent
	
	if self.dt.BipodDeployed then
		model:SetBodygroup(1, 1)
	else
		model:SetBodygroup(1, 0)
	end
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_cmag_556_official.lua
================================================
local att = {}
att.name = "md_cmag_556_official"
att.displayName = "Beta C-Mag 5.56x45MM"
att.displayNameShort = "C-Mag"
att.SpeedDec = 5

att.statModifiers = {ReloadSpeedMult = -0.25,
DrawSpeedMult = -0.1,
HipSpreadMult = 0.15,
VelocitySensitivityMult = 0.15,
OverallMouseSensMult = -0.1}


if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/cmag_official")
	att.description = {[1] = {t = "Increases mag size to 100 rounds.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self:unloadWeapon()
	self.canOffsetMagBone = true
	
	self.ForegripOverride = true
	self.ForegripParent = "md_cmag_556_official"
	
	self.Primary.ClipSize = 100
	self.Primary.ClipSize_Orig = 100
end

function att:detachFunc()
	self:unloadWeapon()
	self.canOffsetMagBone = false
	
	if CLIENT then
		self:offsetMagBone(true)
	end
	
	self.ForegripOverride = false
	self.ForegripParent = nil
	
	self.Primary.ClipSize = self.Primary.ClipSize_ORIG_REAL
	self.Primary.ClipSize_Orig = self.Primary.ClipSize_ORIG_REAL
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_cmag_9x19_official.lua
================================================
local att = {}
att.name = "md_cmag_9x19_official"
att.displayName = "Beta C-Mag 9x19MM"
att.displayNameShort = "C-Mag"
att.SpeedDec = 3

att.statModifiers = {ReloadSpeedMult = -0.25,
DrawSpeedMult = -0.1,
OverallMouseSensMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/cmag_official")
	att.description = {[1] = {t = "Increases mag size to 100 rounds.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self:unloadWeapon()
	self.canOffsetMagBone = true
	
	self.ForegripOverride = true
	self.ForegripParent = "md_cmag_556_official"
	
	self.Primary.ClipSize = 100
	self.Primary.ClipSize_Orig = 100
end

function att:detachFunc()
	self:unloadWeapon()
	self.canOffsetMagBone = false
	
	if CLIENT then
		self:offsetMagBone(true)
	end
	
	self.ForegripOverride = false
	self.ForegripParent = nil
	
	self.Primary.ClipSize = self.Primary.ClipSize_ORIG_REAL
	self.Primary.ClipSize_Orig = self.Primary.ClipSize_ORIG_REAL
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_cobram2.lua
================================================
local att = {}
att.name = "md_cobram2"
att.displayName = "Cobra M2"
att.displayNameShort = "M2"
att.isSuppressor = true
att.SpeedDec = 1

att.statModifiers = {OverallMouseSensMult = -0.1,
RecoilMult = -0.15,
DamageMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/cobra_m2")
	att.description = {[1] = {t = "Decreases firing noise.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self.dt.Suppressed = true
end

function att:detachFunc()
	self:resetSuppressorStatus()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_eotech.lua
================================================
local att = {}
att.name = "md_eotech"
att.displayName = "EoTech 552"
att.displayNameShort = "EoTech"
att.aimPos = {"EoTechPos", "EoTechAng"}
att.FOVModifier = 15
att.isSight = true
att.colorType = CustomizableWeaponry.colorableParts.COLOR_TYPE_SIGHT
att.statModifiers = {OverallMouseSensMult = -0.05}
att.SpeedDec = 1

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/eotech553")
	att.description = {[1] = {t = "Provides a bright reticle to ease aiming.", c = CustomizableWeaponry.textColors.POSITIVE}}
	
	att.reticle = "cw2/reticles/eotech_reddot"
	att._reticleSize = 3

	function att:drawReticle()
		if not self:isAiming() or not self:isReticleActive() then
			return
		end
		
		diff = self:getDifferenceToAimPos(self.EoTechPos, self.EoTechAng, att._reticleSize)
		
		-- draw the reticle only when it's close to center of the aiming position
		if diff > 0.9 and diff < 1.1 then
			cam.IgnoreZ(true)
				render.SetMaterial(att._reticle)
				dist = math.Clamp(math.Distance(1, 1, diff, diff), 0, 0.13)
				
				local EA = self:getReticleAngles()
				
				local renderColor = self:getSightColor(att.name)
				renderColor.a = (0.13 - dist) / 0.13 * 255
				
				local pos = EyePos() + EA:Forward() * 100
				
				for i = 1, 2 do
					render.DrawSprite(pos, att._reticleSize, att._reticleSize, renderColor)
				end
			cam.IgnoreZ(false)
		end
	end
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_foregrip.lua
================================================
local att = {}
att.name = "md_foregrip"
att.displayName = "Foregrip"
att.displayNameShort = "Grip"

att.statModifiers = {VelocitySensitivityMult = -0.15,
DrawSpeedMult = -0.1,
SpreadPerShotMult = -0.1,
RecoilMult = -0.125}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/foregrip")
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_insight_x2.lua
================================================
local att = {}
att.name = "md_insight_x2"
att.displayName = "Insight X2 LAM"
att.displayNameShort = "X2 LAM"
att.laserRange = 4096
att.laserBeamRange = 75
att.colorType = CustomizableWeaponry.colorableParts.COLOR_TYPE_BEAM

att.statModifiers = {VelocitySensitivityMult = -0.2,
OverallMouseSensMult = -0.05,
HipSpreadMult = -0.2,
DrawSpeedMult = -0.05,
MaxSpreadIncMult = -0.25}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/insight_x2")
	local beam = Material("cw2/reticles/aim_reticule")
	local laserDot = Material("cw2/reticles/aim_reticule")
	
	att.reticle = "cw2/reticles/aim_reticule"
	local td = {}
	
	function att:elementRender()
		local model = self.AttachmentModelsVM.md_insight_x2.ent
		local pos = model:GetPos()
		local ang = self:getLaserAngles(model)
		local angs = nil
		
		if not self.freeAimOn then
			if self.dt.State == CW_AIMING then
				angs = self.LaserAngAdjustAim
			end
		end
		
		angs = angs or self.LaserAngAdjust
		
		-- rotate and prepare the position
		ang:RotateAroundAxis(ang:Right(), angs.p)
		ang:RotateAroundAxis(ang:Up(), angs.y)
		ang:RotateAroundAxis(ang:Forward(), angs.r)
		
		local dir = ang * 1
		
		if not self.freeAimOn then
			if self.dt.State == CW_AIMING then
				dir.p = self.Owner:EyeAngles().p
			end
		end
		
		local fw = dir:Forward()
		local laserPos = pos + ang:Right() * self.LaserPosAdjust.x + ang:Forward() * self.LaserPosAdjust.y + ang:Up() * self.LaserPosAdjust.z
		
		td.start = laserPos
		td.endpos = td.start + fw * att.laserRange
		td.filter = self.Owner
		
		local tr = util.TraceLine(td)
		
		if not self.lastLaserPos then
			self.lastLaserPos = tr.HitPos
		end
		
		local dist = math.Clamp(att.laserRange * tr.Fraction, 0, att.laserBeamRange)
		
		if util.PointContents(tr.HitPos) != CONTENTS_SOLID and not self.NearWall then
			local renderColor = self:getSightColor(att.name)
			local laserHQ = GetConVarNumber("cw_laser_quality") > 1
			
			-- draw the beam
			renderColor.a = 100
			render.SetMaterial(beam)
			
			render.DrawBeam(laserPos + fw, laserPos + fw * dist, 0.1, 0, 0.99, renderColor)
			
			if laserHQ then
				renderColor.a = 50
				render.DrawBeam(laserPos + fw, laserPos + fw * dist, 0.6, 0, 0.99, renderColor)
				
				renderColor.a = 25
				render.DrawBeam(laserPos + fw, laserPos + fw * dist, 1, 0, 0.99, renderColor)
			end
			
			-- draw the dot if the model is not out of world bounds
			renderColor.a = 255
			
			render.SetMaterial(laserDot)
			
			if GetConVarNumber("cw_laser_blur") >= 1 then
				render.DrawBeam(self.lastLaserPos, tr.HitPos, 1.5, 0, 0.99, renderColor)
				
				local dist = math.Clamp(self.lastLaserPos:Distance(tr.HitPos), 0, 2)

				dist = 1 - (dist / 2)
				
				if dist < 2 then
					renderColor.a = 255 * dist
					render.DrawSprite(tr.HitPos, 1.5, 1.5, renderColor)
					
					if laserHQ then
						renderColor.a = 33 * dist
						render.DrawSprite(tr.HitPos, 3, 3, renderColor)
					end
				end
			else
				render.DrawSprite(tr.HitPos, 1.5, 1.5, renderColor)
				
				if laserHQ then
					renderColor.a = 33
					render.DrawSprite(tr.HitPos, 3, 3, renderColor)
				end
			end
			
			self.lastLaserPos = tr.HitPos
		end
	end
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_kobra.lua
================================================
local att = {}
att.name = "md_kobra"
att.displayName = "Kobra"
att.displayNameShort = "Kobra"
att.aimPos = {"KobraPos", "KobraAng"}
att.FOVModifier = 15
att.isSight = true
att.withoutRail = true
att.colorType = CustomizableWeaponry.colorableParts.COLOR_TYPE_SIGHT
att.statModifiers = {OverallMouseSensMult = -0.05}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/kobra")
	att.description = {[1] = {t = "Provides a bright reticle to ease aiming.", c = CustomizableWeaponry.textColors.POSITIVE}}
	
	att.reticle = "cw2/reticles/kobra_sight"
	att._reticleSize = 2.5

	function att:drawReticle()
		if not self:isAiming() or not self:isReticleActive() then
			return
		end
		
		diff = self:getDifferenceToAimPos(self.KobraPos, self.KobraAng, att._reticleSize)

		-- draw the reticle only when it's close to center of the aiming position
		if diff > 0.9 and diff < 1.1 then
			cam.IgnoreZ(true)
				render.SetMaterial(att._reticle)
				dist = math.Clamp(math.Distance(1, 1, diff, diff), 0, 0.13)
				
				local EA = self:getReticleAngles()
				
				local renderColor = self:getSightColor(att.name)
				renderColor.a = (0.13 - dist) / 0.13 * 255
				
				local pos = EyePos() + EA:Forward() * 100
				
				for i = 1, 2 do
					render.DrawSprite(pos, att._reticleSize, att._reticleSize, renderColor)
				end
			cam.IgnoreZ(false)
		end
	end
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_m203.lua
================================================
local att = {}
att.name = "md_m203"
att.displayName = "M203"
att.displayNameShort = "M203"
att.isGrenadeLauncher = true
att.SpeedDec = 3

att.statModifiers = {DrawSpeedMult = -0.2,
OverallMouseSensMult = -0.1,
RecoilMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/m203")
	att.description = {[1] = {t = "Allows the user to fire 40MM rounds.", c = CustomizableWeaponry.textColors.POSITIVE}}
	
	function att:attachFunc()
		self:resetM203Anim()
	end
	
	function att:detachFunc()
		self:resetM203Anim()
		self.dt.M203Active = false
		self.M203AngDiff = Angle(0, 0, 0)
	end
end

CustomizableWeaponry:registerAttachment(att)

CustomizableWeaponry:addReloadSound("CW_M203_OPEN", "weapons/cw_m203/open.wav")
CustomizableWeaponry:addReloadSound("CW_M203_CLOSE", "weapons/cw_m203/close.wav")
CustomizableWeaponry:addReloadSound("CW_M203_REMOVE", "weapons/cw_m203/remove.wav")
CustomizableWeaponry:addReloadSound("CW_M203_INSERT", "weapons/cw_m203/insert.wav")
CustomizableWeaponry:addFireSound("CW_M203_FIRE", "weapons/cw_m203/fire.wav", 1, 100, CHAN_STATIC)
CustomizableWeaponry:addFireSound("CW_M203_FIRE_BUCK", "weapons/cw_m203/fire_buck.wav", 1, 110, CHAN_STATIC)


================================================
FILE: cw2/lua/cw/shared/attachments/md_microt1.lua
================================================
local att = {}
att.name = "md_microt1"
att.displayName = "Micro T1"
att.displayNameShort = "M-T1"
att.aimPos = {"MicroT1Pos", "MicroT1Ang"}
att.FOVModifier = 15
att.isSight = true
att.colorType = CustomizableWeaponry.colorableParts.COLOR_TYPE_SIGHT

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/microt1")
	att.description = {[1] = {t = "Provides a bright reticle to ease aiming.", c = CustomizableWeaponry.textColors.POSITIVE},
	[3] = {t = "Narrow scope may decrease awareness.", c = CustomizableWeaponry.textColors.NEGATIVE}}
	
	att.reticle = "cw2/reticles/aim_reticule"
	att._reticleSize = 0.2
	
	function att:drawReticle()
		if not self:isAiming() or not self:isReticleActive() then
			return
		end
		
		diff = self:getDifferenceToAimPos(self.MicroT1Pos, self.MicroT1Ang, 1)
		
		-- draw the reticle only when it's close to center of the aiming position
		if diff > 0.9 and diff < 1.1 then
			cam.IgnoreZ(true)
				render.SetMaterial(att._reticle)
				dist = math.Clamp(math.Distance(1, 1, diff, diff), 0, 0.13)
				
				local EA = self:getReticleAngles()
				
				local renderColor = self:getSightColor(att.name)
				renderColor.a = (0.13 - dist) / 0.13 * 255
				
				local pos = EyePos() + EA:Forward() * 100
				
				for i = 1, 2 do
					render.DrawSprite(pos, att._reticleSize, att._reticleSize, renderColor)
				end
			cam.IgnoreZ(false)
		end
	end
	
	function att:attachFunc()
		self.AimViewModelFOV = 35
	end
	
	function att:detachFunc()
		self.AimViewModelFOV = self.AimViewModelFOV_Orig
	end
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_nightforce_nxs.lua
================================================
local att = {}
att.name = "md_nightforce_nxs"
att.displayName = "Nightforce NXS"
att.displayNameShort = "NXS"
att.aimPos = {"NXSPos", "NXSAng"}
att.FOVModifier = 15
att.isSight = true
att.SpeedDec = 3

att.statModifiers = {OverallMouseSensMult = -0.15}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/nightforce_nxs")
	att.description = {[1] = {t = "Provides 4-8x magnification.", c = CustomizableWeaponry.textColors.POSITIVE},
	[2] = {t = "Narrow scope reduces spatial awareness.", c = CustomizableWeaponry.textColors.NEGATIVE}}

	local old, x, y, ang
	local reticle = surface.GetTextureID("sprites/scope_leo")
	
	att.zoomTextures = {{tex = surface.GetTextureID("sprites/scope_leo"), offset = {0, 1}}}
	
	att.telescopicsFOVRange = {
		10,
		7.5,
		5
	}
	
	att.newTelescopicsFOV = true
	att.simpleTelescopicsFOVRange = {
		14,
		9,
		6.7
	}

	local lens = surface.GetTextureID("cw2/gui/lense")
	local lensMat = Material("cw2/gui/lense")
	local cd, alpha = {}, 0.5
	local Ini = true

	-- render target var setup
	cd.x = 0
	cd.y = 0
	cd.w = 512
	cd.h = 512
	cd.fov = 3
	cd.drawviewmodel = false
	cd.drawhud = false
	cd.dopostprocess = false

	function att:drawRenderTarget()
		local complexTelescopics = self:canUseComplexTelescopics()
		
		-- if we don't have complex telescopics enabled, don't do anything complex, and just set the texture of the lens to a fallback 'lens' texture
		if not complexTelescopics then
			self.TSGlass:SetTexture("$basetexture", lensMat:GetTexture("$basetexture"))
			return
		end
		
		if self.dt.State == CW_AIMING then
			alpha = math.Approach(alpha, 0, FrameTime() * 5)
		else
			alpha = math.Approach(alpha, 1, FrameTime() * 5)
		end
		
		x, y = ScrW(), ScrH()
		old = render.GetRenderTarget()

		ang = self:getTelescopeAnglesNew()
		
		if not self.TelescopeSkipRotate then
			if self.ViewModelFlip then
				ang.r = -self.BlendAng.z
			else
				ang.r = self.BlendAng.z
			end
		end
		
		if self.NXSAlignNew then
			local right, up, forward = ang:Right(), ang:Up(), ang:Forward()
			
			ang:RotateAroundAxis(right, self.NXSAlignNew.right)
			ang:RotateAroundAxis(up, self.NXSAlignNew.up)
			ang:RotateAroundAxis(forward, self.NXSAlignNew.forward)
		end
	
		local size = self:getRenderTargetSize()

		cd.w = size
		cd.h = size
		cd.angles = ang
		cd.origin = self.Owner:GetShootPos()
		
		self:adjustTelescopicsFOV(cd)
		
		render.SetRenderTarget(self.ScopeRT)
		render.SetViewPort(0, 0, size, size)
			if alpha < 1 or Ini then
				render.RenderView(cd)
				Ini = false
			end
					
			ang = self.Owner:EyeAngles()
			ang.p = ang.p + self.BlendAng.x
			ang.y = ang.y + self.BlendAng.y
			ang.r = ang.r + self.BlendAng.z
			ang = -ang:Forward()
			
			local light = render.ComputeLighting(self.Owner:GetShootPos(), ang)
			
			cam.Start2D()				
				surface.SetDrawColor(255, 255, 255, 255)
				surface.SetTexture(reticle)
				surface.DrawTexturedRect(0, 0, size, size)
				
				if alpha < 1 then
					self:drawLensShadow(size, size)
				end
				
				surface.SetDrawColor(150 * light[1], 150 * light[2], 150 * light[3], 255 * alpha)
				surface.SetTexture(lens)
				surface.DrawTexturedRectRotated(size * 0.5, size * 0.5, size, size, 90)
			cam.End2D()
		render.SetViewPort(0, 0, x, y)
		render.SetRenderTarget(old)
		
		if self.TSGlass then
			self.TSGlass:SetTexture("$basetexture", self.ScopeRT)
		end
	end
end

function att:attachFunc()
	self.OverrideAimMouseSens = 0.35
	self.SimpleTelescopicsFOV = 75
	self.AimViewModelFOV = 50
	self.BlurOnAim = true
	self.ZoomTextures = att.zoomTextures
	self.AimBreathingEnabled = true
end

function att:detachFunc()
	self.OverrideAimMouseSens = nil
	self.SimpleTelescopicsFOV = nil
	self.AimViewModelFOV = self.AimViewModelFOV_Orig
	self.BlurOnAim = false
	self:resetAimBreathingState()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_pbs1.lua
================================================
local att = {}
att.name = "md_pbs1"
att.displayName = "PBS-1"
att.displayNameShort = "PBS-1"
att.isSuppressor = true
att.SpeedDec = 2

att.statModifiers = {OverallMouseSensMult = -0.1,
RecoilMult = -0.15,
DamageMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/pbs1")
	att.description = {[1] = {t = "Decreases firing noise.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self.dt.Suppressed = true
end

function att:detachFunc()
	self:resetSuppressorStatus()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_pso1.lua
================================================
local att = {}
att.name = "md_pso1"
att.displayName = "PSO-1"
att.displayNameShort = "PSO-1"
att.aimPos = {"PSOPos", "PSOAng"}
att.FOVModifier = 15
att.isSight = true
att.withoutRail = true
att.SpeedDec = 2
att.statModifiers = {OverallMouseSensMult = -0.1}

if CLIENT then
	-- the UV on the pso-1 is fucked, so we got to adjust it manually lOL!!!
	
	att.shadowMaskConfig = {		
		w = 768,
		h = 768,
		wOff = 256, -- width offset for the mask texture
		hOff = 256, -- height offset for the mask texture
		maxOffset = 130, -- maximum pixel offset for the 'shadow' effect
		maskMaxStrength = 1, -- at what point will the shadow mask reach peak strength?
		maxZoom = 360,
		posX = -1,
		posY = 1,
		flipAngles = true
	}
	
	att.newTelescopicsFOV = true
	att.displayIcon = surface.GetTextureID("atts/pso1")
	att.description = {[1] = {t = "Provides 4x magnification.", c = CustomizableWeaponry.textColors.POSITIVE},
	[2] = {t = "Narrow scope reduces awareness.", c = CustomizableWeaponry.textColors.NEGATIVE},
	[3] = {t = "Can be disorienting at close range.", c = CustomizableWeaponry.textColors.NEGATIVE}}

	local old, x, y, ang
	local sight = surface.GetTextureID("cw2/reticles/scope_pso")
	local sightIllum = surface.GetTextureID("cw2/reticles/scope_pso_illum")
	att.zoomTextures = {[1] = {tex = sight, offset = {0, 1}},
		[2] = {tex = sightIllum, offset = {0, 0}}}
	
	local lens = surface.GetTextureID("cw2/gui/lense")
	local lensMat = Material("cw2/gui/lense")
	local cd, alpha = {}, 0.5
	local Ini = true
	
	-- render target var setup
	cd.x = 0
	cd.y = 0
	cd.w = 512
	cd.h = 512
	cd.fov = 10
	cd.drawviewmodel = false
	cd.drawhud = false
	cd.dopostprocess = false
	
	function att:drawRenderTarget()
		local complexTelescopics = self:canUseComplexTelescopics()
		
		-- if we don't have complex telescopics enabled, don't do anything complex, and just set the texture of the lens to a fallback 'lens' texture
		if not complexTelescopics then
			self.TSGlass:SetTexture("$basetexture", lensMat:GetTexture("$basetexture"))
			return
		end
		
		if self:canSeeThroughTelescopics(att.aimPos[1]) then
			alpha = math.Approach(alpha, 0, FrameTime() * 5)
		else
			alpha = math.Approach(alpha, 1, FrameTime() * 5)
		end
		
		x, y = ScrW(), ScrH()
		old = render.GetRenderTarget()
	
		ang = self:getTelescopeAnglesNew()
		
		--[[if not self.freeAimOn then
			ang:RotateAroundAxis(ang:Right(), self.PSO1AxisAlign.right)
			ang:RotateAroundAxis(ang:Up(), self.PSO1AxisAlign.up)
			ang:RotateAroundAxis(ang:Forward(), self.PSO1AxisAlign.forward)
		else
			ang:RotateAroundAxis(ang:Forward(), 90)
		end]]
		
		if not self.TelescopeSkipRotate then
			ang:RotateAroundAxis(ang:Forward(), 90 + self.BlendAng.z)
		else
			ang:RotateAroundAxis(ang:Forward(), 90)
		end
		
		if self.PSO1AxisAlignNew then
			ang:RotateAroundAxis(ang:Right(), self.PSO1AxisAlignNew.right)
			ang:RotateAroundAxis(ang:Up(), self.PSO1AxisAlignNew.up)
			ang:RotateAroundAxis(ang:Forward(), self.PSO1AxisAlignNew.forward)
		end
		
		local size = self:getRenderTargetSize()
		
		cd.w = size
		cd.h = size
		cd.angles = ang
		cd.origin = self.Owner:GetShootPos()
		render.SetRenderTarget(self.ScopeRT)
		render.SetViewPort(0, 0, size, size)
			if alpha < 1 or Ini then
				render.RenderView(cd)
				Ini = false
			end
			
			ang = self.Owner:EyeAngles()
			ang.p = ang.p + self.BlendAng.x
			ang.y = ang.y + self.BlendAng.y
			ang.r = ang.r + self.BlendAng.z
			ang = -ang:Forward()
			
			local light = render.ComputeLighting(self.Owner:GetShootPos(), ang)
			
			cam.Start2D()				
				surface.SetDrawColor(255, 255, 255, 255)
				surface.SetTexture(sight)
				surface.DrawTexturedRectRotated(size * 0.5, size * 0.5, size * 0.8, size * 0.8, 90)
				
				surface.SetDrawColor(255, 255, 255, 255)
				surface.SetTexture(sightIllum)
				surface.DrawTexturedRectRotated(size * 0.5, size * 0.5, size * 0.8, size * 0.8, 90)
				
				if alpha < 1 then
					self:drawLensShadow(size, size, att.shadowMaskConfig)
				end
				
				surface.SetDrawColor(150 * light[1], 150 * light[2], 150 * light[3], 255 * alpha)
				surface.SetTexture(lens)
				surface.DrawTexturedRectRotated(size * 0.5, size * 0.5, size, size, 90)
			cam.End2D()
		render.SetViewPort(0, 0, x, y)
		render.SetRenderTarget(old)
		
		if self.TSGlass then
			self.TSGlass:SetTexture("$basetexture", self.ScopeRT)
		end
	end
end

function att:attachFunc()
	self.OverrideAimMouseSens = 0.35
	self.SimpleTelescopicsFOV = 12
	self.AimViewModelFOV = 50
	self.BlurOnAim = true
	self.ZoomTextures = att.zoomTextures
end

function att:detachFunc()
	self.OverrideAimMouseSens = nil
	self.SimpleTelescopicsFOV = nil
	self.AimViewModelFOV = self.AimViewModelFOV_Orig
	self.BlurOnAim = false
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_rmr.lua
================================================
local att = {}
att.name = "md_rmr"
att.displayName = "Trijicon RMR"
att.displayNameShort = "RMR"
att.aimPos = {"RMRPos", "RMRAng"}
att.FOVModifier = 15
att.isSight = true
att.colorType = CustomizableWeaponry.colorableParts.COLOR_TYPE_SIGHT

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/rmr")
	att.description = {[1] = {t = "Provides a bright reticle to ease aiming.", c = CustomizableWeaponry.textColors.POSITIVE},
	[2] = {t = "Slightly increases aim zoom.", c = CustomizableWeaponry.textColors.POSITIVE},
	[3] = {t = "Narrow scope may decrease awareness.", c = CustomizableWeaponry.textColors.NEGATIVE}}
	
	att.reticle = "cw2/reticles/aim_reticule"
	att._reticleSize = 0.4
	
	function att:drawReticle()
		if not self:isAiming() or not self:isReticleActive() then
			return
		end
		
		diff = self:getDifferenceToAimPos(self.RMRPos, self.RMRAng, 1)
		
		-- draw the reticle only when it's close to center of the aiming position
		if diff > 0.9 and diff < 1.1 then
			cam.IgnoreZ(true)
				render.SetMaterial(att._reticle)
				dist = math.Clamp(math.Distance(1, 1, diff, diff), 0, 0.13)
				
				local EA = self:getReticleAngles()
				
				local renderColor = self:getSightColor(att.name)
				renderColor.a = (0.13 - dist) / 0.13 * 255
				
				local pos = EyePos() + EA:Forward() * 100
				
				for i = 1, 2 do
					render.DrawSprite(pos, att._reticleSize, att._reticleSize, renderColor)
				end
			cam.IgnoreZ(false)
		end
	end
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_saker.lua
================================================
local att = {}
att.name = "md_saker"
att.displayName = "SAKER"
att.displayNameShort = "SAKER"
att.isSuppressor = true
att.SpeedDec = 2

att.statModifiers = {OverallMouseSensMult = -0.1,
RecoilMult = -0.15,
DamageMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/saker")
	att.description = {[1] = {t = "Decreases firing noise.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self.dt.Suppressed = true
end

function att:detachFunc()
	self:resetSuppressorStatus()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_schmidt_shortdot.lua
================================================
local att = {}
att.name = "md_schmidt_shortdot"
att.displayName = "Schmidt&Bender Short dot"
att.displayNameShort = "Short dot"
att.aimPos = {"ShortDotPos", "ShortDotAng"}
att.FOVModifier = 15
att.isSight = true
att.SpeedDec = 2

att.statModifiers = {OverallMouseSensMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/shortdot")
	att.description = {[1] = {t = "Provides 1.5-3x magnification.", c = CustomizableWeaponry.textColors.POSITIVE},
	[2] = {t = "Narrow scope reduces spatial awareness.", c = CustomizableWeaponry.textColors.NEGATIVE}}

	att.telescopicsFOVRange = {
		22.5, 
		20, 
		15
	}
	
	-- note that the FOVs in this table are inverted, that's because the FOV setup in CalcView subtracts the simple telescopics value
	-- instead of over-writing it
	att.newTelescopicsFOV = true
	att.simpleTelescopicsFOVRange = {
		29,
		26,
		20
	}

	att.shadowMaskConfig = {		
		w = 768,
		h = 768,
		wOff = 384, -- width offset for the mask texture
		hOff = 384, -- height offset for the mask texture
		maxOffset = 100, -- maximum pixel offset for the 'shadow' effect
		maskMaxStrength = 1, -- at what point will the shadow mask reach peak strength?
		maxZoom = 460,
		posX = 1, -- shadow offset position multiplier, X
		posY = 1, -- shadow offset positionc multiplier, Y
		flipAngles = false -- whether we should swap pitch with yaw when calculating the shadow mask offset
	}

	local old, x, y, ang
	local reticle = surface.GetTextureID("cw2/reticles/aim_reticule")
	
	att.zoomTextures = {{tex = reticle, offset = {0, 1}, size = {16, 16}, color = Color(255, 0, 0, 150)},
		{tex = reticle, offset = {0, 1}, size = {8, 8}, color = Color(255, 0, 0, 255)}}
	
	local lens = surface.GetTextureID("cw2/gui/lense")
	local lensMat = Material("cw2/gui/lense")
	local cd, alpha = {}, 0.5
	local Ini = true
	
	-- render target var setup
	cd.x = 0
	cd.y = 0
	cd.w = 512
	cd.h = 512
	cd.fov = 20
	cd.drawviewmodel = false
	cd.drawhud = false
	cd.dopostprocess = false
	
	function att:drawRenderTarget()
		local complexTelescopics = self:canUseComplexTelescopics()
		
		-- if we don't have complex telescopics enabled, don't do anything complex, and just set the texture of the lens to a fallback 'lens' texture
		if not complexTelescopics then
			self.TSGlass:SetTexture("$basetexture", lensMat:GetTexture("$basetexture"))
			return
		end
		
		if self:canSeeThroughTelescopics(att.aimPos[1]) then
			alpha = math.Approach(alpha, 0, FrameTime() * 5)
		else
			alpha = math.Approach(alpha, 1, FrameTime() * 5)
		end
		
		x, y = ScrW(), ScrH()
		old = render.GetRenderTarget()
	
		ang = self:getTelescopeAnglesNew()
		
		if not self.TelescopeSkipRotate then
			if self.ViewModelFlip then
				ang.r = -self.BlendAng.z
			else
				ang.r = self.BlendAng.z
			end
		end
		
		if self.SchmidtShortDotAxisAlignNew then
			ang:RotateAroundAxis(ang:Right(), self.SchmidtShortDotAxisAlignNew.right)
			ang:RotateAroundAxis(ang:Up(), self.SchmidtShortDotAxisAlignNew.up)
			ang:RotateAroundAxis(ang:Forward(), self.SchmidtShortDotAxisAlignNew.forward)
		end
		
		local size = self:getRenderTargetSize()
		
		cd.w = size
		cd.h = size
		cd.angles = ang
		cd.origin = self.Owner:GetShootPos()
		
		self:adjustTelescopicsFOV(cd)
		
		render.SetRenderTarget(self.ScopeRT)
		render.SetViewPort(0, 0, size, size)
			if alpha < 1 or Ini then
				render.RenderView(cd)
				Ini = false
			end
			
			ang = self.Owner:EyeAngles()
			ang.p = ang.p + self.BlendAng.x
			ang.y = ang.y + self.BlendAng.y
			ang.r = ang.r + self.BlendAng.z
			ang = -ang:Forward()
			
			local light = render.ComputeLighting(self.Owner:GetShootPos(), ang)
			
			cam.Start2D()				
				surface.SetDrawColor(0, 0, 0, 200)
				surface.DrawRect(size * 0.5 - 1, 0, 2, size) -- middle top-bottom
				surface.DrawRect(0, size * 0.5 - 1, size, 2) -- middle left-right
				
				local retSize = size * 0.02
				
				surface.SetDrawColor(255, 0, 0, 255)
				surface.SetTexture(reticle)
				surface.DrawTexturedRect(size * 0.5 - retSize * 0.5, size * 0.5 - retSize * 0.5, retSize, retSize)
				
				if alpha < 1 then
					self:drawLensShadow(size, size, att.shadowMaskConfig)
				end
				
				surface.SetDrawColor(150 * light[1], 150 * light[2], 150 * light[3], 255 * alpha)
				surface.SetTexture(lens)
				surface.DrawTexturedRectRotated(size * 0.5, size * 0.5, size, size, 90)
			cam.End2D()
		render.SetViewPort(0, 0, x, y)
		render.SetRenderTarget(old)
		
		if self.TSGlass then
			self.TSGlass:SetTexture("$basetexture", self.ScopeRT)
		end
	end
end

function att:attachFunc()
	self.OverrideAimMouseSens = 0.5
	self.SimpleTelescopicsFOV = 55
	self.AimViewModelFOV = 50
	self.BlurOnAim = true
	self.ZoomTextures = att.zoomTextures
end

function att:detachFunc()
	self.OverrideAimMouseSens = nil
	self.SimpleTelescopicsFOV = nil
	self.AimViewModelFOV = self.AimViewModelFOV_Orig
	self.BlurOnAim = false
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/attachments/md_tundra9mm.lua
================================================
local att = {}
att.name = "md_tundra9mm"
att.displayName = "Tundra 9MM"
att.displayNameShort = "Tundra"
att.isSuppressor = true
att.SpeedDec = 1

att.statModifiers = {OverallMouseSensMult = -0.1,
RecoilMult = -0.15,
DamageMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/saker")
	att.description = {[1] = {t = "Decreases firing noise.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self.dt.Suppressed = true
end

function att:detachFunc()
	self:resetSuppressorStatus()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2/lua/cw/shared/colors/cw_lasercolors.lua
================================================
local clr = {}
clr.name = "laser_red"
clr.display = "Red"
clr.color = Color(255, 75, 75, 255)

CustomizableWeaponry.colorableParts:addLaserColor(clr)

local clr = {}
clr.name = "laser_green"
clr.display = "Green"
clr.color = Color(100, 255, 100, 255)

CustomizableWeaponry.colorableParts:addLaserColor(clr)

local clr = {}
clr.name = "laser_blue"
clr.display = "Blue"
clr.color = Color(150, 150, 255, 255)

CustomizableWeaponry.colorableParts:addLaserColor(clr)

local clr = {}
clr.name = "laser_gold"
clr.display = "Gold"
clr.color = Color(250, 255, 0, 255)

CustomizableWeaponry.colorableParts:addLaserColor(clr)

local clr = {}
clr.name = "laser_turquoise"
clr.display = "Turquoise"
clr.color = Color(48, 213, 200, 255)

CustomizableWeaponry.colorableParts:addLaserColor(clr)


================================================
FILE: cw2/lua/cw/shared/colors/cw_reticlecolors.lua
================================================
local clr = {}
clr.name = "ret_red"
clr.display = "Red"
clr.color = Color(255, 75, 75, 255)

CustomizableWeaponry.colorableParts:addReticleColor(clr)

local clr = {}
clr.name = "ret_green"
clr.display = "Green"
clr.color = Color(100, 255, 100, 255)

CustomizableWeaponry.colorableParts:addReticleColor(clr)

local clr = {}
clr.name = "ret_blue"
clr.display = "Blue"
clr.color = Color(75, 153, 255, 255)

CustomizableWeaponry.colorableParts:addReticleColor(clr)

local clr = {}
clr.name = "ret_gold"
clr.display = "Gold"
clr.color = Color(250, 255, 0, 255)

CustomizableWeaponry.colorableParts:addReticleColor(clr)

local clr = {}
clr.name = "ret_turquoise"
clr.display = "Turquoise"
clr.color = Color(48, 213, 200, 255)

CustomizableWeaponry.colorableParts:addReticleColor(clr)


================================================
FILE: cw2/lua/cw/shared/grenadetypes/40mm_buckshot.lua
================================================
local gren = {}
gren.name = "40mm_buckshot"
gren.display = " - 40MM BUCK"
gren.pelletCount = 20
gren.pelletDamage = 12
gren.spread = 0.03
gren.clumpSpread = 0.04
gren.fireSound = "CW_M203_FIRE_BUCK"
gren.allowSights = true

function gren:fireFunc()
	if self:filterPrediction() then
		self:FireBullet(gren.pelletDamage, gren.spread, gren.clumpSpread, gren.pelletCount)
	end
end

CustomizableWeaponry.grenadeTypes:addNew(gren)


================================================
FILE: cw2/lua/cw/shared/grenadetypes/40mm_smoke.lua
================================================
local gren = {}
gren.name = "40mm_smoke"
gren.display = " - 40MM SMOKE"
gren.grenadeEntity = "cw_40mm_smoke"

function gren:fireFunc()
	if SERVER then
		CustomizableWeaponry.grenadeTypes.createGrenadeEntity(self, gren.grenadeEntity)
	end
end

CustomizableWeaponry.grenadeTypes:addNew(gren)


================================================
FILE: cw2/lua/cw/shared/menutabs/customization.lua
================================================
local tab = {}
tab.name = "TAB_CUSTOMIZATION"
tab.id = 1
tab.text = "CUSTOMIZATION"
tab.switchToKey = "gm_showhelp"

if CLIENT then
	function tab:processKey(b, p)
		if self:processSlotKeyPress(b, p) then
			return true
		end
		
		return nil
	end
	
	local emptyString = ""
	local hud16 = "CW_HUD32"
	local hud18 = "CW_HUD38"
	local hud20 = "CW_HUD40"
	local hud36 = "CW_HUD48"
	local hud24 = "CW_HUD48"

	local greyGradient = surface.GetTextureID("cw2/gui/greygrad")
	local gradient = surface.GetTextureID("cw2/gui/gradient")
	local bgQuad = surface.GetTextureID("cw2/gui/attachment_bg_quad")
	
	tab.bgColor = Color(30, 32, 30, 150)
	tab.activeColor = Color(177, 216, 171, 200)
	
	function tab:drawFunc()
		local bgR, bgG, bgB = tab.bgColor.r, tab.bgColor.g, tab.bgColor.b
		
		for k, v in pairs(self.Attachments) do
			local meetsReqs = false
			
			-- check whether the current attachment category matches requirements for attaching
			meetsReqs = self:isCategoryEligible(v.dependencies, v.exclusions)
			
			if meetsReqs then
				self.HUDColors.white.a = 255 * self.CustomizeMenuAlpha
				self.HUDColors.black.a = 255 * self.CustomizeMenuAlpha
				
				-- first index of 'offset' table is X, second is Y
				local x, y = v.offset[1], v.offset[2]
				
				-- draw header and header gradient
				surface.SetDrawColor(bgR, bgG, bgB, 255 * self.CustomizeMenuAlpha)
				
				surface.SetTexture(gradient)
				surface.DrawTexturedRect(x - 3, y - 20, 200, 55)
				
				local found = emptyString
				local name = v.atts[v.last]
				local curAtt = CustomizableWeaponry.registeredAttachmentsSKey[name]
				
				if v.last then
					if curAtt then
						if curAtt.colorType then
							found = CustomizableWeaponry.colorableParts.colorText[curAtt.colorType]
						else
							if curAtt.isGrenadeLauncher then
								found = CustomizableWeaponry.grenadeTypes.cycleText
							end
						end
					end
				end
				
				draw.ShadowText(v.keyText .. v.header .. found, hud36, x, y + 6, self.HUDColors.white, self.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
				
				local curPos = 0
			
				for k2, v2 in ipairs(v.atts) do
					if self:isAttachmentEligible(v2) then -- todo: change this part to properly support callbacks and shit
						-- do another attachment eligibility check in here, because there might be some callbacks we want to call
						
						-- if the current attachment is the current iteration, draw stuff
						local foundAtt = CustomizableWeaponry.registeredAttachmentsSKey[v2]
						local baseXPos = x + curPos * 140
						
						if foundAtt then
							-- draw short display name along with it's icon
							draw.ShadowText(foundAtt.displayNameShort, hud16, baseXPos, y + 180, self.HUDColors.white, self.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
							
							--surface.SetDrawColor(bgR, bgG, bgB, 200 * self.CustomizeMenuAlpha)
							--surface.DrawOutlinedRect(baseXPos - 3, y + 50 - 3, 120, 120)
							--surface.DrawOutlinedRect(baseXPos - 2, y + 50 - 2, 118, 118)
							surface.SetTexture(bgQuad)
							local clr
							
							-- give the outline a different color if it's the current attachment
							if v.last == k2 then
								clr = tab.activeColor
								--surface.SetDrawColor(acR, acG, acB, acA * self.CustomizeMenuAlpha)
							else
								clr = tab.bgColor
								--[[if self:canAttachSpecificAttachment(v2, self.Owner, nil, nil, nil, categoryData) then
									surface.SetDrawColor(bgR, bgG, bgB, 200 * self.CustomizeMenuAlpha)
								else
									surface.SetDrawColor(255, 175, 175, 150 * self.CustomizeMenuAlpha)
								end]]
							end
							
							--draw.RoundedBoxEx(16, baseXPos - 3, y + 50 - 6, 120, 120, tab.bgColor, true, true, true, true)
							--draw.RoundedBoxEx(16, baseXPos, y + 50 - 3, 120, 120, clr, true, true, true, true)
							surface.SetDrawColor(tab.bgColor)
							surface.DrawTexturedRect(baseXPos - 6, y + 50 - 9, 120, 120)
							
							local prevA = clr.a
							clr.a = clr.a * self.CustomizeMenuAlpha
							surface.SetDrawColor(clr)
							clr.a = prevA
							surface.DrawTexturedRect(baseXPos, y + 50 - 3, 120, 120)
							
							--surface.DrawRect(baseXPos - 1, y + 50 - 1, 116, 116)
							
							surface.SetDrawColor(255, 255, 255, 255 * self.CustomizeMenuAlpha)
							
							surface.SetTexture(foundAtt.displayIcon)
							surface.DrawTexturedRect(baseXPos + 1, y + 50 - 1, 116, 116)
							
							-- draw the reticle/beam color icon
							if foundAtt.colorType then
								local colorEntry = self.SightColors[foundAtt.name]
								
								if colorEntry then
									colorEntry = colorEntry.color
									
									if v.last == k2 then
										surface.SetTexture(bgQuad)
									
										local prevA = tab.bgColor.a
										tab.bgColor.a = tab.bgColor.a * self.CustomizeMenuAlpha
										
										surface.SetDrawColor(tab.bgColor)
										tab.bgColor.a = prevA
										surface.DrawTexturedRect(baseXPos + 1, y + 50, 38, 38)
										
										--draw.RoundedBoxEx(16, baseXPos + 1, y + 50, 38, 38, tab.bgColor, true, true, true, true)
										--[[surface.SetDrawColor(bgR, bgG, bgB, 255 * self.CustomizeMenuAlpha)
										surface.DrawOutlinedRect(baseXPos + 1, y + 50, 38, 38)
										
										surface.SetDrawColor(bgR, bgG, bgB, 230 * self.CustomizeMenuAlpha)
										surface.DrawRect(baseXPos + 2, y + 51, 36, 36)]]
									end
									
									surface.SetDrawColor(colorEntry.r, colorEntry.g, colorEntry.b, 255 * self.CustomizeMenuAlpha)
									surface.SetTexture(foundAtt._reticleIcon)
									surface.DrawTexturedRect(baseXPos + 3, y + 51, 35, 35)
								end
							end
							
							if v.last == k2 then
								-- adjust gradient size to description line amount
								found = emptyString
								
								if self.SightColors[foundAtt.name] then
									found = self.SightColors[foundAtt.name].display
								else
									if curAtt then
										found = CustomizableWeaponry.formAdditionalText(self, curAtt)
									end
								end

								local size = #foundAtt.description
								surface.SetDrawColor(bgR, bgG, bgB, 200 * self.CustomizeMenuAlpha)
								surface.SetTexture(gradient)
								surface.DrawTexturedRect(x - 3, y + 200 - 3, 300, size * 30 + 50)
								
								for k3, v3 in ipairs(foundAtt.description) do
									draw.ShadowText(v3.t, hud18, x + 5, y + 210 - 3 + k3 * 30 + 17, v3.c, self.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
								end
								
								-- draw display name
								draw.ShadowText(foundAtt.displayName .. found, hud20, x, y + 218, self.HUDColors.white, self.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
							end
							
							curPos = curPos + 1
						else
							cam.IgnoreZ(false)
							cam.End3D2D()
							error("CW 2.0 - attempt to display non-existent weapon attachment '" .. v2 .. "' in category index '" .. k .. "' of weapon '" .. self:GetClass() .. "' AKA '" .. self.PrintName .. "'")
						end
					end
				end
			end
		end
		
		if self.Trivia then
			local text = self.Trivia.text
			
			if self.Trivia.textFormatFunc then
				text = self.Trivia:textFormatFunc(self)
			end
			
			if text then
				draw.ShadowText(text, hud36, self.Trivia.x, self.Trivia.y, self.HUDColors.white, self.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			end
		end
	end
end

CustomizableWeaponry.interactionMenu:addTab(tab)


================================================
FILE: cw2/lua/cw/shared/menutabs/presets.lua
================================================
local tab = {}
tab.name = "TAB_PRESETS"
tab.id = 3
tab.text = "PRESETS"
tab.switchToKey = "gm_showspare1"
tab.deletingPresets = false
tab.deletePos = nil

if CLIENT then
	tab.callback = function(self)
		CustomizableWeaponry.preset.updateList(self)
		tab.deletingPresets = false
		tab.deletePos = nil
	end

	function tab:processKey(b, p)
		if b == "+attack" then
			self:seekPresetPosition(1)
			return true
		elseif b == "+attack2" then
			self:seekPresetPosition(-1)
			return true
		elseif b == "+use" then
			if CustomizableWeaponry.preset.canSave(self) then
				CustomizableWeaponry.preset.makeSavePopup(self)
			end
			
			return true
		elseif b == "+reload" then
			tab.deletingPresets = !tab.deletingPresets
			tab.deletePos = nil
			
			return true
		elseif b:find("slot") then
			if not tab.deletingPresets then
				local pos = self:getDesiredPreset(b)
				
				self:attemptPresetLoad(pos)
				
				return true
			else
				local pos = self:getDesiredPreset(b)
				
				-- if there is no selected preset to delete, select one
				if not tab.deletePos then
					-- make sure we're trying to delete an existing preset
					
					if self.PresetResults[pos - 1] then
						tab.deletePos = pos
					end
				elseif pos ~= tab.deletePos then
					-- if we're selecting a preset that doesn't match the one we selected initially, reset the delete position
					tab.deletePos = nil
				else
					-- otherwise, it's time to delete (RIP preset ;_;)
					if CustomizableWeaponry.preset.attemptDelete(self, tab.deletePos) then
						CustomizableWeaponry.preset.updateList(self)
						tab.deletePos = nil
					end
				end
				
				return true
			end
		end
		
		return nil
	end
	
	local gradient = surface.GetTextureID("cw2/gui/gradient")
	
	local hud48 = "CW_HUD48"
	
	function tab:drawFunc()
		local baseX, baseY = -50, -50
		surface.SetDrawColor(0, 0, 0, 200)
		surface.SetTexture(gradient)
		
		surface.DrawTexturedRect(baseX, baseY - 120, 300, 250)
		
		local clrSave
		
		if not CustomizableWeaponry.preset.canSave(self) then
			clrSave = self.HUDColors.red
		else
			clrSave = self.HUDColors.white
		end
		
		local interactionText
		
		if tab.deletingPresets then
			if tab.deletePos then
				interactionText = "MODE: Deleting preset; tap again to DELETE"
				interactionColor = self.HUDColors.deepRed
			else
				interactionText = "MODE: Deleting preset; tap to SELECT"
				interactionColor = self.HUDColors.red
			end
		else
			interactionText = "MODE: Loading preset"
			interactionColor = self.HUDColors.green
		end
		
		draw.ShadowText(self:getKeyBind("+attack") .. " - cycle presets forward", hud48, baseX + 5, baseY - 95, self.HUDColors.white, self.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		draw.ShadowText(self:getKeyBind("+attack2") .. " - cycle presets back", hud48, baseX + 5, baseY - 45, self.HUDColors.white, self.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		draw.ShadowText(self:getKeyBind("+use") .. " - save new preset", hud48, baseX + 5, baseY + 5, clrSave, self.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			
		local modeText = nil
		
		if tab.deletingPresets then 
			modeText = " - switch to LOAD PRESET mode"
		else
			modeText = " - switch to DELETE PRESET mode"
		end
		
			draw.ShadowText(self:getKeyBind("+reload") .. modeText, hud48, baseX + 5, baseY + 55, self.HUDColors.white, self.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		draw.ShadowText(interactionText, hud48, baseX + 5, baseY + 105, interactionColor, self.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		
		local presetCount = #self.PresetResults
		
		if presetCount > 0 then
			-- we use this to determine the size of the gradient
			local existingPresets = math.Clamp(presetCount - self.PresetPosition + 1, 1, 10)
			
			surface.DrawTexturedRect(baseX, baseY + 140, 300, existingPresets * 50 + 10)
			
			local entry, targetColor
			
			local curEntry = 1
			
			for i = self.PresetPosition, self.PresetPosition + 9 do
				entry = self.PresetResults[i]
				
				if entry then
					targetColor = nil
					
					if tab.deletePos then
						if tab.deletePos - 1 == i then
							targetColor = self.HUDColors.deepRed
						end
					end
					
					if targetColor == nil then
						if self.LastPreset == entry.displayName then
							targetColor = CustomizableWeaponry.textColors.COSMETIC
						else
							targetColor = CustomizableWeaponry.textColors.REGULAR
						end
					end
					
					draw.ShadowText("[" .. curEntry .. "] - Preset #" .. i .. " '" .. entry.displayName .. "'", hud48, baseX + 5, baseY + 5 + (curEntry - 1) * 50 + 165, targetColor, self.HUDColors.black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
				end
				
				curEntry = curEntry + 1
			end
		end
		--end
	end
end

CustomizableWeaponry.interactionMenu:addTab(tab)


================================================
FILE: cw2/lua/cw/shared/menutabs/sight_adjustment.lua
================================================
local tab = {}
tab.name = "TAB_ATTACHMENT_ADJUSTMENT"
tab.id = 4
tab.text = "ATTACHMENT ADJUSTMENT"
tab.switchToKey = "gm_showspare2"

tab.selectedAttachment = nil

if CLIENT then
	function tab:processKey(key, isPressed)
		if not isPressed then
			return nil
		end
		
		if not CustomizableWeaponry.sightAdjustment:getCurrentAttachment() then -- attempt to select a category of sights to adjust in case we haven't selected one yet
			local category = nil
			
			if key:find("slot") then -- if it starts with 'slot', that means we're pressing 1-9 keys, therefore strip it of the 'slot' part and turn it into a number
				category = tonumber(string.Right(key, 1))
			else -- otherwise just use the key as the category
				category = key
			end
			
			-- attempt to find an attachment category with this name
			return CustomizableWeaponry.sightAdjustment:attemptSetAttachment(self, category)
		else
			if key == "+reload" then
				CustomizableWeaponry.sightAdjustment:setDefaultOffset(self)
				return true
			elseif key == "+attack2" then -- deselect category
				CustomizableWeaponry.sightAdjustment:setCurrentAttachment(nil, nil)
				return true
			end
		end
	end
	
	function tab:callback() -- when we open the tab, we deselect the current category
		CustomizableWeaponry.sightAdjustment:setCurrentAttachment(nil, nil)
	end
	
	function tab:drawFunc()
		CustomizableWeaponry.sightAdjustment:draw(self)
	end
end

CustomizableWeaponry.interactionMenu:addTab(tab)


================================================
FILE: cw2/lua/cw/shared/menutabs/weaponstats.lua
================================================
local tab = {}
tab.name = "TAB_WEPSTATS"
tab.id = 2
tab.text = "WEAPON STATS"
tab.switchToKey = "gm_showteam"
tab.descOfStat = 1

if CLIENT then
	tab.callback = function(self)
		tab.descOfStat = 1
	end
	
	function tab:processKey(key, press)
		if key == "+attack" then
			if tab.descOfStat >= CustomizableWeaponry.statDisplay.totalCount then
				tab.descOfStat = 1
			else
				tab.descOfStat = math.Clamp(tab.descOfStat + 1, 1, CustomizableWeaponry.statDisplay.totalCount)
			end
			return true
		elseif key == "+attack2" then
			if tab.descOfStat == 1 then
				tab.descOfStat = CustomizableWeaponry.statDisplay.totalCount
			else	
				tab.descOfStat = math.Clamp(tab.descOfStat - 1, 1, CustomizableWeaponry.statDisplay.totalCount)
			end
			
			return true
		end
		
		return nil
	end
	
	function tab:drawFunc()
		CustomizableWeaponry.statDisplay:draw(wep, tab)
	end
end

CustomizableWeaponry.interactionMenu:addTab(tab)


================================================
FILE: cw2/lua/effects/cw_muzzleflash.lua
================================================
AddCSLuaFile()

function EFFECT:Init(fx)
	local ent = fx:GetEntity()
	
	if not IsValid(ent) then
		return
	end
	
	if not IsValid(ent.Owner) then
		return
	end
	
	if not ent.Owner:ShouldDrawLocalPlayer() and ent.Owner == LocalPlayer() then -- don't create the effect if we're in first person
		return
	end
	
	local particleEffect = ent:getFireParticles()
	local attachModel = ent:getMuzzleModel()
	
	if not IsValid(attachModel) then
		return
	end
	
	local attachment = attachModel:GetAttachment(ent.WorldMuzzleAttachmentID)
	local shell = attachModel:GetAttachment(ent.WorldShellEjectionAttachmentID)
	
	local lightPos = nil
	
	if attachment then
		ParticleEffectAttach(particleEffect, PATTACH_POINT_FOLLOW, attachModel, ent.WorldMuzzleAttachmentID)
		lightPos = attachment.Pos
	else
		local aimVec = ent.Owner:EyeAngles()
		lightPos = ent.Owner:GetShootPos() + aimVec:Forward() * 30 - aimVec:Up() * 3 
	end
	
	if shell and ent.Shell then
		if ent.ShellDelay then
			timer.Simple(ent.ShellDelay, function()
				if IsValid(ent) then
					shell = attachModel:GetAttachment(ent.WorldShellEjectionAttachmentID)
					local ejectVelocity = shell.Ang:Forward() * 200
					shell.Ang:RotateAroundAxis(shell.Ang:Right(), 90)
					CustomizableWeaponry.shells.make(ent, shell.Pos, shell.Ang, ejectVelocity, 0.5, 10)
				end
			end)
		else
			local ejectVelocity = shell.Ang:Forward() * 200
			shell.Ang:RotateAroundAxis(shell.Ang:Right(), 90)
			CustomizableWeaponry.shells.make(ent, shell.Pos, shell.Ang, ejectVelocity, 0.5, 10)
		end
	end
	
	if not ent.dt.Suppressed then
		local dlight = DynamicLight(self:EntIndex())
		
		dlight.r = 255 
		dlight.g = 218
		dlight.b = 74
		dlight.Brightness = 4
		dlight.Pos = lightPos
		dlight.Size = 96
		dlight.Decay = 128
		dlight.DieTime = CurTime() + FrameTime()
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end



================================================
FILE: cw2/lua/entities/cw_40mm_explosive/cl_init.lua
================================================
include("shared.lua")

function ENT:Initialize()
	self.Emitter = ParticleEmitter(self:GetPos())
	self.ParticleDelay = 0
end

function ENT:Draw()
	self:DrawModel()
end

function ENT:Think()
	if not self.dt.Misfire then
		local part = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 9), self:GetPos())
		part:SetStartSize(12)
		part:SetEndSize(16)
		part:SetStartAlpha(255)
		part:SetEndAlpha(0)
		part:SetDieTime(1)
		part:SetRoll(math.random(0, 360))
		part:SetRollDelta(0.01)
		part:SetColor(120, 120, 120)
		part:SetLighting(false)
		part:SetVelocity(VectorRand() * 25)
	end
end 

function ENT:OnRemove()
	self.Emitter:Finish()
end


================================================
FILE: cw2/lua/entities/cw_40mm_explosive/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

ENT.BlastDamage = 100  -- Wyłączone obrażenia
ENT.BlastRadius = 384

function ENT:Initialize()
	self:SetModel("models/Items/AR2_Grenade.mdl") 
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetCollisionGroup(COLLISION_GROUP_NONE)
	local phys = self:GetPhysicsObject()

	if phys and phys:IsValid() then
		phys:Wake()
	end
	
	self:GetPhysicsObject():SetBuoyancyRatio(0)
	self.ArmTime = CurTime() + 0.2
	
	spd = physenv.GetPerformanceSettings()
    spd.MaxVelocity = 2996
	
    physenv.SetPerformanceSettings(spd)
end

function ENT:Use(activator, caller)
	return false
end

function ENT:OnRemove()
	return false
end 

local vel, len

function ENT:PhysicsCollide(data, physobj)
	if self.dt.Misfire then
		vel = physobj:GetVelocity()
		len = vel:Length()
		
		if len > 500 then
			physobj:SetVelocity(vel * 0.6)
		end
	
		return
	end
	
	if CurTime() > self.ArmTime then
		util.BlastDamage(self, self:GetOwner(), self:GetPos(), self.BlastRadius, self.BlastDamage)
		local ef = EffectData()
		ef:SetOrigin(self:GetPos())
		ef:SetMagnitude(1)
		util.Effect("Explosion", ef)
		self:Remove()
	else
		self:EmitSound("physics/metal/metal_grenade_impact_hard" .. math.random(1, 3) .. ".wav", 80, 100)
		self.dt.Misfire = true
		SafeRemoveEntityDelayed(self, 10)
		
		vel = physobj:GetVelocity()
		len = vel:Length()
		
		if len > 500 then
			physobj:SetVelocity(vel * 0.6)
		end
	end
end



================================================
FILE: cw2/lua/entities/cw_40mm_explosive/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "40MM HE grenade"
ENT.Author = "L337N008"
ENT.Information = "A 40MM grenade launched from an underslung grenade launcher M203"
ENT.Spawnable = false
ENT.AdminSpawnable = false 

function ENT:SetupDataTables()
	self:DTVar("Bool", 0, "Misfire")
end


================================================
FILE: cw2/lua/entities/cw_40mm_smoke/cl_init.lua
================================================
include("shared.lua")

function ENT:Initialize()
	self.Emitter = ParticleEmitter(self:GetPos())
	self.ParticleDelay = 0
end

function ENT:Draw()
	self:DrawModel()
end

function ENT:Think()
	//if CurTime() > self.ParticleDelay then
		local part = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 9), self:GetPos())
		part:SetStartSize(12)
		part:SetEndSize(16)
		part:SetStartAlpha(255)
		part:SetEndAlpha(0)
		part:SetDieTime(1)
		part:SetRoll(math.random(0, 360))
		part:SetRollDelta(0.01)
		part:SetColor(160, 160, 160)
		part:SetLighting(false)
		part:SetVelocity(VectorRand() * 25)
	//	self.ParticleDelay = CurTime() + 0.01
	//end
end 

function ENT:OnRemove()
	self.Emitter:Finish()
end


================================================
FILE: cw2/lua/entities/cw_40mm_smoke/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

local spd, ent

function ENT:Initialize()
	self:SetModel("models/Items/AR2_Grenade.mdl") 
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetCollisionGroup(COLLISION_GROUP_NONE)
	local phys = self:GetPhysicsObject()

	if phys and phys:IsValid() then
		phys:Wake()
	end
	
	self:GetPhysicsObject():SetBuoyancyRatio(0)
	
	spd = physenv.GetPerformanceSettings()
    spd.MaxVelocity = 2996
	
    physenv.SetPerformanceSettings(spd) -- set grenade's max. speed to it's real life muzzle velocity
end

function ENT:Use(activator, caller)
	return false
end

function ENT:OnRemove()
	return false
end 

function ENT:PhysicsCollide(data, physobj)
	local hitPos = self:GetPos()

	local smokeScreen = ents.Create("cw_smokescreen_impact")
	smokeScreen:SetPos(hitPos)
	smokeScreen:Spawn()
	smokeScreen:CreateParticles()

	self:Remove()
	
	self:Remove()
end



================================================
FILE: cw2/lua/entities/cw_40mm_smoke/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "40MM Smoke grenade"
ENT.Author = "Spy"
ENT.Spawnable = false
ENT.AdminSpawnable = false 



================================================
FILE: cw2/lua/entities/cw_ammo_338lapua/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 30)


================================================
FILE: cw2/lua/entities/cw_ammo_338lapua/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_ammo_338lapua/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = ".338 Lapua Ammo"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.CaliberSpecific = true
ENT.AmmoCapacity = 30
ENT.ResupplyAmount = 5
ENT.Caliber = ".338 Lapua"
ENT.Model = "models/Items/BoxMRounds.mdl"


================================================
FILE: cw2/lua/entities/cw_ammo_40mm/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 28)


================================================
FILE: cw2/lua/entities/cw_ammo_40mm/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_ammo_40mm/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = "40MM Rounds"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.CaliberSpecific = true
ENT.AmmoCapacity = 8
ENT.ResupplyAmount = 1
ENT.Caliber = "40MM"
ENT.Model = "models/Items/BoxMRounds.mdl"


================================================
FILE: cw2/lua/entities/cw_ammo_44magnum/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 28)


================================================
FILE: cw2/lua/entities/cw_ammo_44magnum/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_ammo_44magnum/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = ".44 Magnum Ammo"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.CaliberSpecific = true
ENT.AmmoCapacity = 30
ENT.ResupplyAmount = 6
ENT.Caliber = ".44 Magnum"
ENT.Model = "models/Items/BoxSRounds.mdl"


================================================
FILE: cw2/lua/entities/cw_ammo_50ae/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 28)


================================================
FILE: cw2/lua/entities/cw_ammo_50ae/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_ammo_50ae/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = ".50 AE Ammo"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.CaliberSpecific = true
ENT.AmmoCapacity = 28
ENT.ResupplyAmount = 7
ENT.Caliber = ".50 AE"
ENT.Model = "models/Items/BoxSRounds.mdl"


================================================
FILE: cw2/lua/entities/cw_ammo_545x39/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 30)


================================================
FILE: cw2/lua/entities/cw_ammo_545x39/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_ammo_545x39/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = "5.45x39MM Ammo"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.CaliberSpecific = true
ENT.AmmoCapacity = 90
ENT.ResupplyAmount = 30
ENT.Caliber = "5.45x39MM"
ENT.Model = "models/Items/BoxMRounds.mdl"


================================================
FILE: cw2/lua/entities/cw_ammo_556x45/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 30)


================================================
FILE: cw2/lua/entities/cw_ammo_556x45/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_ammo_556x45/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = "5.56x45MM Ammo"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.CaliberSpecific = true
ENT.AmmoCapacity = 90
ENT.ResupplyAmount = 30
ENT.Caliber = "5.56x45MM"
ENT.Model = "models/Items/BoxMRounds.mdl"


================================================
FILE: cw2/lua/entities/cw_ammo_762x51/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 30)


================================================
FILE: cw2/lua/entities/cw_ammo_762x51/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_ammo_762x51/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = "7.62x51MM Ammo"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.CaliberSpecific = true
ENT.AmmoCapacity = 60
ENT.ResupplyAmount = 20
ENT.Caliber = "7.62x51MM"
ENT.Model = "models/Items/BoxMRounds.mdl"


================================================
FILE: cw2/lua/entities/cw_ammo_9x19/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 28)


================================================
FILE: cw2/lua/entities/cw_ammo_9x19/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_ammo_9x19/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = "9x19MM Ammo"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.CaliberSpecific = true
ENT.AmmoCapacity = 120
ENT.ResupplyAmount = 30
ENT.Caliber = "9x19MM"
ENT.Model = "models/Items/BoxSRounds.mdl"


================================================
FILE: cw2/lua/entities/cw_ammo_crate_regular/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 35)


================================================
FILE: cw2/lua/entities/cw_ammo_crate_regular/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_ammo_crate_regular/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = "Ammo crate"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.ResupplyMultiplier = 12 -- max amount of mags the player can take from the ammo entity before it considers him as 'full'
ENT.AmmoCapacity = 36 -- max amount of resupplies before this entity dissapears
ENT.HealthAmount = 100 -- the health of this entity
ENT.ExplodeRadius = 512
ENT.ExplodeDamage = 100
ENT.ResupplyTime = 0.4 -- time in seconds between resupply sessions
ENT.Model = "models/Items/ammocrate_smg1.mdl"


================================================
FILE: cw2/lua/entities/cw_ammo_crate_small/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 40)


================================================
FILE: cw2/lua/entities/cw_ammo_crate_small/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_ammo_crate_small/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = "Small ammo crate"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.ResupplyMultiplier = 12 -- max amount of mags the player can take from the ammo entity before it considers him as 'full'
ENT.AmmoCapacity = 24 -- max amount of resupplies before this entity dissapears
ENT.HealthAmount = 85 -- the health of this entity
ENT.ExplodeRadius = 384
ENT.ExplodeDamage = 85
ENT.ResupplyTime = 0.4 -- time in seconds between resupply sessions
ENT.Model = "models/Items/item_item_crate.mdl"


================================================
FILE: cw2/lua/entities/cw_ammo_ent_base/cl_init.lua
================================================
include("shared.lua")

local baseFont = "CW_HUD72"
local ammoText = "CW_HUD60"

function ENT:Initialize()
	surface.SetFont(baseFont)
	self.baseHorSize, self.vertFontSize = surface.GetTextSize(self.PrintName)
	self.baseHorSize = self.baseHorSize < 600 and 600 or self.baseHorSize
	self.baseHorSize = self.baseHorSize + 20
	self.halfBaseHorSize = self.baseHorSize * 0.5
	self.halfVertFontSize = self.vertFontSize * 0.5
	self.resupplyAmountText = "+" .. self.ResupplyAmount .. " rounds per resupply"
end

function ENT:getTopPartColor()
	return CustomizableWeaponry.ITEM_PACKS_TOP_COLOR.r, CustomizableWeaponry.ITEM_PACKS_TOP_COLOR.g, CustomizableWeaponry.ITEM_PACKS_TOP_COLOR.b, CustomizableWeaponry.ITEM_PACKS_TOP_COLOR.a
end

ENT.displayDistance = 256 -- the distance within which the contents of the box will be displayed
ENT.upOffset = Vector(0, 0, 30)

local white, black = Color(255, 255, 255, 255), Color(0, 0, 0, 255)

function ENT:Draw()
	self:DrawModel()
	
	local ply = LocalPlayer()

	if ply:GetPos():Distance(self:GetPos()) > self.displayDistance then
		return
	end
	
	local eyeAng = EyeAngles()
	eyeAng.p = 0
	eyeAng.y = eyeAng.y - 90
	eyeAng.r = 90
	
	cam.Start3D2D(self:GetPos() + self.upOffset, eyeAng, 0.05)
		local r, g, b, a = self:getTopPartColor()
		surface.SetDrawColor(r, g, b, a)
		surface.DrawRect(-self.halfBaseHorSize, 0, self.baseHorSize, self.vertFontSize)
		
		surface.SetDrawColor(0, 0, 0, 150)
		surface.DrawRect(-self.halfBaseHorSize, self.vertFontSize, self.baseHorSize, self.vertFontSize * 2)
		
		if not self.CaliberSpecific then
			draw.ShadowText(self.PrintName, baseFont, 0, self.halfVertFontSize, white, black, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			draw.ShadowText(self.dt.ammoCharge .. (self.dt.ammoCharge == 1 and "x resupply left" or "x resupplies left"), ammoText, 0, self.vertFontSize + self.halfVertFontSize, white, black, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			
			local wep = ply:GetActiveWeapon()
			
			if IsValid(wep) and wep.CW20Weapon then
				draw.ShadowText("+" .. wep.Primary.ClipSize_Orig .. " rounds per resupply", ammoText, 0, self.vertFontSize * 2 + self.halfVertFontSize, white, black, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			else
				draw.ShadowText("Can't resupply", ammoText, 0, self.vertFontSize * 2 + self.halfVertFontSize, white, black, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end
		else
			draw.ShadowText(self.Caliber, baseFont, 0, self.halfVertFontSize, white, black, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			draw.ShadowText(self.dt.ammoCharge .. (self.dt.ammoCharge == 1 and " round left" or " rounds left"), ammoText, 0, self.vertFontSize + self.halfVertFontSize, white, black, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			
			draw.ShadowText(self.resupplyAmountText, ammoText, 0, self.vertFontSize * 2 + self.halfVertFontSize, white, black, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	cam.End3D2D()
end

function ENT:Think()
end 


================================================
FILE: cw2/lua/entities/cw_ammo_ent_base/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

ENT.CollisionGroup = COLLISION_GROUP_NONE

function ENT:Initialize()
	self:SetModel(self.Model) 
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetCollisionGroup(self.CollisionGroup)
	self.CanHurt = true
	local phys = self:GetPhysicsObject()

	if phys and phys:IsValid() then
		phys:Wake()
	end
	
	self.dt.ammoCharge = self.AmmoCapacity
	
	-- Set infinite HP for Breach gamemode
	self.HP = math.huge
	self.Exploded = true -- Prevent any explosion logic
end

local dmg, wep, am, cl, ammo, ED, pos, mag, amountToGive, maxAmmo

-- Completely disable damage handling for ammo kits in Breach
function ENT:OnTakeDamage(dmginfo)
	-- Do nothing - ammo kits are indestructible in Breach
end

function ENT:Use(activator, caller)
	if self.CaliberSpecific then
		if activator:IsPlayer() and activator:Alive() then
			if not activator.AmmoGiveDelay or CurTime() > activator.AmmoGiveDelay then
				activator:GiveAmmo(self.ResupplyAmount, self.Caliber)
				
				activator.AmmoGiveDelay = CurTime() + self.ResupplyTime
				self.dt.ammoCharge = self.dt.ammoCharge - self.ResupplyAmount
			end
			
			if self.dt.ammoCharge <= 0 then
				self:Remove()
			end
		end
	else
		if activator:IsPlayer() and activator:Alive() then
			if not activator.AmmoGiveDelay or CurTime() > activator.AmmoGiveDelay then
				if self.dt.ammoCharge > 0 then
					wep = activator:GetActiveWeapon()
					
					if IsValid(wep) then
						if wep.CW20Weapon then
							ammo = activator:GetAmmoCount(wep.Primary.Ammo)
							
							if ammo < wep.Primary.ClipSize_Orig * self.ResupplyMultiplier then
								-- check the amount of ammo that should be handed to the player
								amountToGive = math.Clamp(wep.Primary.ClipSize_Orig, 0, wep.Primary.ClipSize_Orig * self.ResupplyMultiplier)
								
								-- if it's greater than 0, give it to the player
								if amountToGive > 0 then
									activator:SetAmmo(math.Clamp(ammo + amountToGive, 0, wep.Primary.ClipSize_Orig * self.ResupplyMultiplier), wep.Primary.Ammo)
									activator:EmitSound("items/ammo_pickup.wav", 60, 100)
									self.dt.ammoCharge = self.dt.ammoCharge - 1
								end
							end
						end
					end
				end
				
				activator.AmmoGiveDelay = CurTime() + self.ResupplyTime
				
				if self.dt.ammoCharge <= 0 then
					SafeRemoveEntity(self)
				end
			end
		end
	end
end


================================================
FILE: cw2/lua/entities/cw_ammo_ent_base/shared.lua
================================================
-- use this entity as a base for your ammo entities
-- below you can see all the necessary variables that can be used for setting up an ammo entity
-- they must be defined shared (clientside and serverside, aka in this file)

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Ammo entity base"
ENT.Author = "Spy"
ENT.Spawnable = false
ENT.AdminSpawnable = false 
ENT.Category = "CW 2.0 Ammo"

ENT.ResupplyMultiplier = 12 -- max amount of mags the player can take from the ammo entity before it considers him as 'full'
ENT.AmmoCapacity = 24 -- max amount of resupplies before this entity dissapears
ENT.HealthAmount = 100 -- the health of this entity
ENT.ExplodeRadius = 512 -- the explosion radius when it reaches 0 health from taking damage, measured in units
ENT.ExplodeDamage = 100 -- the explosion damage
ENT.ResupplyTime = 0.4 -- time in seconds between resupply sessions
ENT.Model = "models/Items/ammocrate_smg1.mdl" -- what model to use

ENT.CaliberSpecific = false -- whether the entity will give a specific ammo caliber
ENT.ResupplyAmount = 40 -- how many rounds to give
ENT.Caliber = "7.62x51MM" -- which caliber to resupply

function ENT:SetupDataTables()
	self:DTVar("Int", 0, "ammoCharge")
end


================================================
FILE: cw2/lua/entities/cw_ammo_fraggrenades/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 28)


================================================
FILE: cw2/lua/entities/cw_ammo_fraggrenades/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_ammo_fraggrenades/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = "Frag Grenades"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.CaliberSpecific = true
ENT.AmmoCapacity = 8
ENT.ResupplyAmount = 1
ENT.Caliber = "Frag Grenades"
ENT.Model = "models/Items/BoxMRounds.mdl"


================================================
FILE: cw2/lua/entities/cw_ammo_kit_regular/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 30)


================================================
FILE: cw2/lua/entities/cw_ammo_kit_regular/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_ammo_kit_regular/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = "Ammo kit"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.ResupplyMultiplier = 12 -- max amount of mags the player can take from the ammo entity before it considers him as 'full'
ENT.AmmoCapacity = 10 -- max amount of resupplies before this entity dissapears
ENT.HealthAmount = 75 -- the health of this entity
ENT.ExplodeRadius = 256
ENT.ExplodeDamage = 75
ENT.ResupplyTime = 0.4 -- time in seconds between resupply sessions
ENT.Model = "models/Items/BoxMRounds.mdl"


================================================
FILE: cw2/lua/entities/cw_ammo_kit_small/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 28)


================================================
FILE: cw2/lua/entities/cw_ammo_kit_small/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_ammo_kit_small/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = "Small ammo kit"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.ResupplyMultiplier = 12 -- max amount of mags the player can take from the ammo entity before it considers him as 'full'
ENT.AmmoCapacity = 6 -- max amount of resupplies before this entity dissapears
ENT.HealthAmount = 50 -- the health of this entity
ENT.ExplodeRadius = 256
ENT.ExplodeDamage = 50
ENT.ResupplyTime = 0.4 -- time in seconds between resupply sessions
ENT.Model = "models/Items/BoxSRounds.mdl"


================================================
FILE: cw2/lua/entities/cw_attpack_ak74_barrels/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ak74_barrels/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ak74_barrels/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "AK-74 - barrel package"
ENT.PackageText = "AK-74 Barrels"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"bg_ak74_ubarrel", "bg_ak74_rpkbarrel"}


================================================
FILE: cw2/lua/entities/cw_attpack_ak74_misc/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ak74_misc/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ak74_misc/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "AK-74 - miscellaneous"
ENT.PackageText = "AK-74 Miscellaneous"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"md_pbs1", "bg_ak74rpkmag"}


================================================
FILE: cw2/lua/entities/cw_attpack_ak74_stocks/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ak74_stocks/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ak74_stocks/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "AK-74 - stocks package"
ENT.PackageText = "AK-74 Stocks"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"bg_ak74foldablestock", "bg_ak74heavystock"}


================================================
FILE: cw2/lua/entities/cw_attpack_ammotypes_rifles/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ammotypes_rifles/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ammotypes_rifles/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "Ammo types - rifles"
ENT.PackageText = "Rifle ammo types"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"am_magnum", "am_matchgrade"}


================================================
FILE: cw2/lua/entities/cw_attpack_ammotypes_shotguns/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ammotypes_shotguns/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ammotypes_shotguns/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "Ammo types - shotguns"
ENT.PackageText = "Shotgun ammo types"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"am_slugrounds", "am_flechetterounds"}


================================================
FILE: cw2/lua/entities/cw_attpack_ar15_barrels/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ar15_barrels/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ar15_barrels/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "AR-15 - barrels package"
ENT.PackageText = "AR-15 CQB barrels"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"bg_ris", "bg_magpulhandguard"}


================================================
FILE: cw2/lua/entities/cw_attpack_ar15_barrels_large/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ar15_barrels_large/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ar15_barrels_large/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "AR-15 - long barrels"
ENT.PackageText = "AR-15 Long barrels"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"bg_longbarrel", "bg_longris"}


================================================
FILE: cw2/lua/entities/cw_attpack_ar15_misc/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ar15_misc/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ar15_misc/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "AR-15 - miscellaneous"
ENT.PackageText = "AR-15 Miscellaneous"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"bg_foldsight", "md_anpeq15", "md_saker", "md_m203", "bg_ar1560rndmag"}


================================================
FILE: cw2/lua/entities/cw_attpack_ar15_stocks/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ar15_stocks/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_ar15_stocks/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "AR-15 - stocks package"
ENT.PackageText = "AR-15 Stocks"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"bg_ar15sturdystock", "bg_ar15heavystock"}


================================================
FILE: cw2/lua/entities/cw_attpack_base/cl_init.lua
================================================
include("shared.lua")

local baseFont = "CW_HUD72"

ENT.displayDistance = 256 -- the distance within which the contents of the box will be displayed

function ENT:Initialize()
	self:setupAttachmentDisplayData()
end

function ENT:getTopPartColor()
	return CustomizableWeaponry.ITEM_PACKS_TOP_COLOR.r, CustomizableWeaponry.ITEM_PACKS_TOP_COLOR.g, CustomizableWeaponry.ITEM_PACKS_TOP_COLOR.b, CustomizableWeaponry.ITEM_PACKS_TOP_COLOR.a
end

function ENT:setupAttachmentDisplayData()
	-- initialize everything in advance, to not do shit when we're drawing, since there may be lots of these packages and we want the best possible performance
	self.attachmentNames = CustomizableWeaponry:ent_buildAttachmentNameStrings(self:getAttachments())
	
	-- get the largest text size
	surface.SetFont(baseFont)
	
	self.horizontalSize, self.verticalFontSize = surface.GetTextSize(self:getMainText())
	
	for k, v in ipairs(self.attachmentNames) do
		local x = surface.GetTextSize(v.display)
		
		if x > self.horizontalSize then
			self.horizontalSize = x
		end
		
		v.vertPos = (k - 1) * -self.verticalFontSize + 5
	end
	
	-- figure out sizes to draw, positions to draw on
	self.horizontalSize = self.horizontalSize + 20
	self.halfHorizontalSize = self.horizontalSize * 0.5
	
	self.arraySize = #self.attachmentNames
	self.verticalSize = self.arraySize * self.verticalFontSize + 15
	
	self.basePos = (self.verticalSize + 1 * self.verticalFontSize) - self.verticalFontSize * 0.75
	self.blackBarPos = self.basePos - self.verticalFontSize
end

local up = Vector(0, 0, 15)
local white, black, green = Color(255, 255, 255, 255), Color(0, 0, 0, 255), Color(215, 255, 160, 255)
local gray = Color(180, 180, 180, 255)

function ENT:getNoAttachmentColor()
	return gray
end

function ENT:getAttachmentColor()
	return green
end

local drawShadowText = draw.ShadowText
local surfaceSetDrawColor = surface.SetDrawColor
local surfaceDrawRect = surface.DrawRect

function ENT:getMainText()
	return self.PackageText
end

function ENT:Draw()
	self:DrawModel()
	
	self.inRange = not (ply:GetPos():Distance(self:GetPos()) > self.displayDistance)
	
	if not self.halfHorizontalSize then
		return
	end
	
	local ply = LocalPlayer()
	
	if not self.inRange then
		return
	end
	
	local eyeAng = EyeAngles()
	eyeAng.p = 0
	eyeAng.y = eyeAng.y - 90
	eyeAng.r = 90
	
	cam.Start3D2D(self:GetPos() + up, eyeAng, 0.05)
		local r, g, b, a = self:getTopPartColor()
		surfaceSetDrawColor(r, g, b, a)
		surfaceDrawRect(-self.halfHorizontalSize, -self.basePos, self.horizontalSize, self.verticalFontSize)
		
		surfaceSetDrawColor(0, 0, 0, 150)
		surfaceDrawRect(-self.halfHorizontalSize, -self.blackBarPos, self.horizontalSize, self.verticalSize - 10)
		
		drawShadowText(self:getMainText(), baseFont, 0, self.arraySize * -self.verticalFontSize, white, black, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		
		for k, v in ipairs(self.attachmentNames) do
			if ply.CWAttachments[v.name] then
				drawShadowText(v.display, baseFont, 0, v.vertPos, self:getNoAttachmentColor(), black, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			else
				drawShadowText(v.display, baseFont, 0, v.vertPos, self:getAttachmentColor(), black, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end
		end
	cam.End3D2D()
end


================================================
FILE: cw2/lua/entities/cw_attpack_base/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

ENT.ExplodeRadius = 384
ENT.ExplodeDamage = 100

local phys, ef

function ENT:Initialize()
	self:SetModel("models/Items/BoxSRounds.mdl") 
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetCollisionGroup(COLLISION_GROUP_NONE)
	self.NextImpact = 0
	phys = self:GetPhysicsObject()

	if phys and phys:IsValid() then
		phys:Wake()
	end
	
	self:GetPhysicsObject():SetBuoyancyRatio(0)
end

function ENT:Use(activator, caller)
	if activator:IsPlayer() then
		local attachments = self:getAttachments()
		
		if not CustomizableWeaponry:hasSpecifiedAttachments(activator, attachments) then
			CustomizableWeaponry.giveAttachments(activator, attachments)
			self:Remove()
		end
	end
	
	return true
end

function ENT:OnRemove()
	return false
end 

local vel, len, CT


================================================
FILE: cw2/lua/entities/cw_attpack_base/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Attachment package base"
ENT.Author = "Spy"
ENT.Spawnable = false
ENT.AdminSpawnable = false 

function ENT:getAttachments()
	return self.attachments
end


================================================
FILE: cw2/lua/entities/cw_attpack_deagle_barrels/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_deagle_barrels/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_deagle_barrels/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "Deagle - barrels"
ENT.PackageText = "Deagle Barrels"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"bg_deagle_compensator", "bg_deagle_extendedbarrel"}


================================================
FILE: cw2/lua/entities/cw_attpack_g3_sg1package/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_g3_sg1package/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_g3_sg1package/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "G3 - SG1 package"
ENT.PackageText = "G3/SG1 Package"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"bg_sg1scope", "bg_bipod"}


================================================
FILE: cw2/lua/entities/cw_attpack_mp5_barrels/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_mp5_barrels/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_mp5_barrels/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "MP5 - barrels"
ENT.PackageText = "MP5 Barrels"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"bg_mp5_kbarrel", "bg_mp5_sdbarrel"}


================================================
FILE: cw2/lua/entities/cw_attpack_mp5_misc/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_mp5_misc/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_mp5_misc/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "MP5 - miscellaneous"
ENT.PackageText = "MP5 Miscellaneous"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"bg_mp530rndmag", "md_tundra9mm"}


================================================
FILE: cw2/lua/entities/cw_attpack_mp5_stocks/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_mp5_stocks/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_mp5_stocks/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "MP5 - stocks"
ENT.PackageText = "MP5 Stocks"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"bg_retractablestock", "bg_nostock"}


================================================
FILE: cw2/lua/entities/cw_attpack_mr96_barrels/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_mr96_barrels/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_mr96_barrels/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "MR96 - barrels"
ENT.PackageText = "MR96 Barrels"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"bg_regularbarrel", "bg_longbarrelmr96"}


================================================
FILE: cw2/lua/entities/cw_attpack_sights_cqb/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_sights_cqb/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_sights_cqb/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "Sights - CQB"
ENT.PackageText = "Close range sights"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"md_kobra", "md_aimpoint", "md_microt1", "md_eotech"}


================================================
FILE: cw2/lua/entities/cw_attpack_sights_longrange/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_sights_longrange/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_sights_longrange/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "Sights - long range"
ENT.PackageText = "Long range sights"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"md_acog", "bg_sg1scope", "md_pso1"}


================================================
FILE: cw2/lua/entities/cw_attpack_sights_midrange/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_sights_midrange/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_sights_midrange/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "Sights - mid range"
ENT.PackageText = "Mid range sights"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"md_schmidt_shortdot"}


================================================
FILE: cw2/lua/entities/cw_attpack_sights_sniper/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_sights_sniper/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_sights_sniper/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "Sights - sniper"
ENT.PackageText = "Sniper sights"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"md_nightforce_nxs"}


================================================
FILE: cw2/lua/entities/cw_attpack_suppressors/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_suppressors/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_suppressors/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "Various suppressors"
ENT.PackageText = "Suppressors"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"md_pbs1", "md_saker", "md_tundra9mm", "md_cobram2"}


================================================
FILE: cw2/lua/entities/cw_attpack_various/cl_init.lua
================================================
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_various/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2/lua/entities/cw_attpack_various/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "Various attachments"
ENT.PackageText = "Various"
ENT.Category = "CW 2.0 Attachments"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 

ENT.attachments = {"bg_foldsight", "md_foregrip", "md_anpeq15", "md_m203"}


================================================
FILE: cw2/lua/entities/cw_dropped_weapon/cl_init.lua
================================================
include("shared.lua")
ENT.dataRequestTime = 0

function ENT:Initialize()
end

function ENT:getMainText()
	return self.weaponName
end

function ENT:Think()
	if self.inRange and (not self.containedAttachments or not self.weaponName) then
		if CurTime() > self.dataRequestTime then
			RunConsoleCommand("cw_request_wep_data", self:EntIndex())
			self.dataRequestTime = CurTime() + 1
		end
	end
end

local green = Color(215, 255, 160, 255)

function ENT:getNoAttachmentColor()
	return green
end

function ENT:getAttachmentColor()
	return green
end

net.Receive("CW_DROPPED_WEAPON_ATTACHMENTS", function()
	local entity = net.ReadEntity()
	
	if IsValid(entity) and entity:GetClass() == "cw_dropped_weapon" then
		local attachments = net.ReadTable()
		entity.containedAttachments = attachments
		entity.weaponName = weapons.GetStored(entity:GetWepClass()).PrintName
		
		entity:setupAttachmentDisplayData()
	end
end)


================================================
FILE: cw2/lua/entities/cw_dropped_weapon/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

util.AddNetworkString("CW_DROPPED_WEAPON_ATTACHMENTS")

local attachmentPresetTable = {} -- this is where all the attachments will go to

function ENT:Initialize()
end

function ENT:Use(activator, caller)
	if hook.Call("CW20_PreventCWWeaponPickup", nil, self, activator) then
		return
	end
	
	local pos = self:GetPos() - activator:GetShootPos()
	local pickupDotProduct = activator:EyeAngles():Forward():Dot(pos) / pos:Length()
		
	if pickupDotProduct < self.pickupDotProduct then
		return
	end
	
	-- if use key is down we restrict picking the weapon up, because we might be wanting to throw a grenade, and if we throw + pick up the weapon - nothing will happen, because weapons will be switched
	if CurTime() < self.useDelay then
		return
	end
	
	local curWep = activator:GetActiveWeapon()
	
	-- can't pick up a weapon if we're performing an action of some kind
	if IsValid(curWep) and curWep.CW20Weapon and curWep.dt.State == CW_ACTION then
		return
	end
	
	local canGetWeapon, canGetAttachments = self:canPickup(activator)
	local wep = nil
	
	if canGetWeapon then -- give the weapon if possible
		wep = activator:Give(self:GetWepClass())
		hook.Call("CW20_PickedUpCW20Weapon", nil, activator, self, wep)
		wep.disableDropping = true -- we set this variable to true so that the player can not drop the weapon using the cw_dropweapon command until attachments are applied
	end
	
	if canGetAttachments then -- give attachments if possible
		CustomizableWeaponry.giveAttachments(activator, self.stringAttachmentIDs)
	end
	
	local attachments = self.containedAttachments
	local magSize = self.magSize
	local m203Chamber = self.M203Chamber
	
	if wep then -- if we were given a weapon, load up the attachments on it
		timer.Simple(0.3, function()
			if not IsValid(wep) then
				return
			end
			
			wep:SetClip1(0) -- set magsize to 0 before loading attachments, because some of them unload the mag and that way we can cheat ammo (by dropping and picking up again)
			
			CustomizableWeaponry.preset.load(wep, attachments, "DroppedWeaponPreset") -- the preset system is super flexible and can easily be used for such purposes
			
			wep:SetClip1(magSize) -- set the mag size only after we've attached everything
			wep:setM203Chamber(m203Chamber)
			wep.disableDropping = false -- set it to false, now we can drop it
			
			hook.Call("CW20_FinishedPickingUpCW20Weapon", nil, activator, wep)
		end)
	end
	
	if canGetWeapon or canGetAttachments then
		self:Remove()
	end
end

function ENT:setWeapon(wep)
	self:SetWepClass(wep:GetClass())
	self.magSize = wep:Clip1()
	self.containedAttachments = {} -- for shit like loading them onto a weapon
	self.stringAttachmentIDs = {} -- for shit like displaying the attachment names and giving them to the player upon pickup
	self.useDelay = CurTime() + 1
	
	self:SetModel(wep.WorldModel)
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	local phys = self:GetPhysicsObject()

	if phys and phys:IsValid() then
		phys:Wake()
	end
	
	for key, data in pairs(wep.Attachments) do
		if data.last then
			self.containedAttachments[key] = data.last
			self.stringAttachmentIDs[#self.stringAttachmentIDs + 1] = data.atts[data.last]
		end
	end
	
	self.M203Chamber = wep.M203Chamber
end

function ENT:sendWepData(target)
	target = target or player.GetAll()
	
	net.Start("CW_DROPPED_WEAPON_ATTACHMENTS")
		net.WriteEntity(self)
		net.WriteTable(self.stringAttachmentIDs)
	net.Send(target)
end

concommand.Add("cw_request_wep_data", function(ply, com, args)
	local entityID = args[1]
	
	if not entityID then
		return
	end
	
	entityID = tonumber(entityID)
	local entity = ents.GetByIndex(entityID)
	
	if IsValid(entity) and entity:GetClass() == "cw_dropped_weapon" then
		entity:sendWepData(ply)
	end
end)


================================================
FILE: cw2/lua/entities/cw_dropped_weapon/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_attpack_base"
ENT.PrintName = "Dropped CW 2.0 weapon"
ENT.Author = "Spy"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.pickupDotProduct = 0.98 -- closer to 1 - need to look in a more general direction towards the weapon
ENT.giveAttachmentsOnPickup = true -- whether the player should be given the attachments that are attached on the weapon upon pickup (if he is not given them, then upon pickup, the attachments the player does not have will not be attached)

function ENT:SetupDataTables()
	self:NetworkVar("String", 0, "WepClass")
end

function ENT:canPickup(activator)
	local canPickupWeapon = not activator:HasWeapon(self:GetWepClass())
	local canPickupAttachments = false
	
	if self.giveAttachmentsOnPickup then
		canPickupAttachments = not CustomizableWeaponry:hasSpecifiedAttachments(activator, self.stringAttachmentIDs)
	end
	
	return canPickupWeapon, canPickupAttachments
end

function ENT:getAttachments()
	return self.containedAttachments, self.stringAttachmentIDs
end


================================================
FILE: cw2/lua/entities/cw_flash_thrown/cl_init.lua
================================================
include("shared.lua")

function ENT:Initialize()
	self.Entity.Emitter = ParticleEmitter(self.Entity:GetPos())
	self.Entity.ParticleDelay = 0
end

function ENT:Draw()
	self.Entity:DrawModel()
end

function ENT:OnRemove()
	local dlight = DynamicLight(self:EntIndex())
	
	dlight.r = 255 
	dlight.g = 255
	dlight.b = 255
	dlight.Brightness = 4
	dlight.Pos = self:GetPos()
	dlight.Size = 256
	dlight.Decay = 128
	dlight.DieTime = CurTime() + 0.1
end


================================================
FILE: cw2/lua/entities/cw_flash_thrown/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

ENT.MaxIntensityDistance = 384 -- if an entity is THIS close to the grenade upon explosion, the intensity of the flashbang will be maximum
ENT.FlashDistance = 1024 -- will decay over this much distance
ENT.FlashDuration = 2
ENT.Model = "models/weapons/w_eq_flashbang_thrown.mdl"

local phys, ef

function ENT:Initialize()
	self:SetModel(self.Model) 
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetCollisionGroup(COLLISION_GROUP_NONE)
	self.NextImpact = 0
	phys = self:GetPhysicsObject()

	if phys and phys:IsValid() then
		phys:Wake()
	end
	
	self:GetPhysicsObject():SetBuoyancyRatio(0)
end

function ENT:Use(activator, caller)
	return false
end

function ENT:OnRemove()
	return false
end 

local vel, len, CT

function ENT:PhysicsCollide(data, physobj)
	vel = physobj:GetVelocity()
	len = vel:Length()
	
	if len > 500 then -- let it roll
		physobj:SetVelocity(vel * 0.6) -- cheap as fuck, but it works
	end
	
	if len > 100 then
		CT = CurTime()
		
		if CT > self.NextImpact then
			self:EmitSound("weapons/smokegrenade/grenade_hit1.wav", 75, 100)
			self.NextImpact = CT + 0.1
		end
	end
end

local traceData = {}
traceData.mask = bit.bor(CONTENTS_SOLID, CONTENTS_MOVEABLE, CONTENTS_DEBRIS, CONTENTS_MONSTER, CONTENTS_HITBOX, CONTENTS_WATER)

function ENT:Fuse(t)
	t = t or 2.5
	
	timer.Simple(2.5, function()
		if self:IsValid() then
			local hitPos = self:GetPos()
			
			-- trace up to check for impacts
			traceData.start = hitPos
			local finishPos = traceData.start + Vector(0, 0, 32)
			
			traceData.endpos = finishPos
			traceData.filter = self
			
			local trace = util.TraceLine(traceData)
			local traceZ = trace.HitPos.z
			finishPos.z = traceZ
			
			self:EmitSound("weapons/flashbang/flashbang_explode2.wav", 85, 100)
			
			for key, obj in ipairs(player.GetAll()) do
				if obj:Alive() then
					local bone = obj:LookupBone("ValveBiped.Bip01_Head1")
					
					if bone then
						local headPos, headAng = obj:GetBonePosition(bone)
						local objDist = headPos:Distance(finishPos)
						
						if objDist <= self.FlashDistance then
							traceData.filter = obj
							
							local ourAimVec = self.Owner:GetAimVector()
							
							local direction = (finishPos - headPos):GetNormal()
							local dotToGeneralDirection = ourAimVec:DotProduct(direction)
							
							traceData.start = headPos
							
							traceData.endpos = traceData.start + direction * math.min(objDist, self.FlashDistance)
							
							local trace = util.TraceLine(traceData)
							local ent = trace.Entity
							
							if not IsValid(ent) or (not ent:IsValid() and not ent:IsWorld()) or ent == self then
								local isMaxIntensity = (objDist - self.MaxIntensityDistance) < 0
								local decay = self.FlashDistance - self.MaxIntensityDistance
								local intensity = 0
								
								if isMaxIntensity then
									intensity = 1
								else
									local decayDistance = objDist - self.MaxIntensityDistance
									intensity = 1 - decayDistance / decay
								end
								
								intensity = math.min((intensity + 0.25) * dotToGeneralDirection, 1)
								local duration = intensity * self.FlashDuration
								
								umsg.Start("CW_FLASHBANGED", obj)
									umsg.Float(intensity)
									umsg.Float(duration)
								umsg.End()
							end
						end
					end
				end
			end
			
			self:Remove()
		end
	end)
end


================================================
FILE: cw2/lua/entities/cw_flash_thrown/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Thrown smoke grenade"
ENT.Author = "Spy"
ENT.Information = "Thrown smoke grenade"
ENT.Spawnable = false
ENT.AdminSpawnable = false 


================================================
FILE: cw2/lua/entities/cw_grenade_thrown/cl_init.lua
================================================
include("shared.lua")

function ENT:Initialize()
	self.Entity.Emitter = ParticleEmitter(self.Entity:GetPos())
	self.Entity.ParticleDelay = 0
end

function ENT:Draw()
	self.Entity:DrawModel()
end


================================================
FILE: cw2/lua/entities/cw_grenade_thrown/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

ENT.ExplodeRadius = 384
ENT.ExplodeDamage = 100
ENT.Model = "models/weapons/w_cw_fraggrenade_thrown.mdl"

local phys, ef

function ENT:Initialize()
	self:SetModel(self.Model) 
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetCollisionGroup(COLLISION_GROUP_NONE)
	self.NextImpact = 0
	phys = self:GetPhysicsObject()

	if phys and phys:IsValid() then
		phys:Wake()
	end
	
	self:GetPhysicsObject():SetBuoyancyRatio(0)
end

function ENT:Use(activator, caller)
	return false
end

function ENT:OnRemove()
	return false
end 

local vel, len, CT

function ENT:PhysicsCollide(data, physobj)
	vel = physobj:GetVelocity()
	len = vel:Length()
	
	if len > 500 then -- let it roll
		physobj:SetVelocity(vel * 0.6) -- cheap as fuck, but it works
	end
	
	if len > 100 then
		CT = CurTime()
		
		if CT > self.NextImpact then
			self:EmitSound("weapons/hegrenade/he_bounce-1.wav", 75, 100)
			self.NextImpact = CT + 0.1
		end
	end
end

function ENT:Fuse(t)
	t = t or 3
	
	timer.Simple(t, function()
		if self:IsValid() then
			util.BlastDamage(self, self:GetOwner(), self:GetPos(), self.ExplodeRadius, self.ExplodeDamage)
			
			ef = EffectData()
			ef:SetOrigin(self:GetPos())
			ef:SetMagnitude(1)
			
			util.Effect("Explosion", ef)
			
			self:Remove()
		end
	end)
end


================================================
FILE: cw2/lua/entities/cw_grenade_thrown/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Activated frag grenade"
ENT.Author = "Spy"
ENT.Information = "Activated frag grenade"
ENT.Spawnable = false
ENT.AdminSpawnable = false 


================================================
FILE: cw2/lua/entities/cw_grenade_unthrown/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 28)


================================================
FILE: cw2/lua/entities/cw_grenade_unthrown/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

ENT.CollisionGroup = COLLISION_GROUP_DEBRIS


================================================
FILE: cw2/lua/entities/cw_grenade_unthrown/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = "Unthrown Frag Grenade"
ENT.Author = "Spy"
ENT.Spawnable = false
ENT.AdminSpawnable = false 
ENT.Category = "CW 2.0 Ammo"

ENT.CaliberSpecific = true
ENT.AmmoCapacity = 1
ENT.ResupplyAmount = 1
ENT.Caliber = "Frag Grenades"
ENT.Model = "models/weapons/w_eq_fraggrenade.mdl"


================================================
FILE: cw2/lua/entities/cw_smoke_thrown/cl_init.lua
================================================
include("shared.lua")

function ENT:Initialize()
	self.Entity.Emitter = ParticleEmitter(self.Entity:GetPos())
	self.Entity.ParticleDelay = 0
end

function ENT:Draw()
	self.Entity:DrawModel()
end


================================================
FILE: cw2/lua/entities/cw_smoke_thrown/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

ENT.ExplodeRadius = 384
ENT.ExplodeDamage = 100
ENT.Model = "models/weapons/w_eq_smokegrenade_thrown.mdl"

local phys, ef

function ENT:Initialize()
	self:SetModel(self.Model) 
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetCollisionGroup(COLLISION_GROUP_NONE)
	self.NextImpact = 0
	phys = self:GetPhysicsObject()

	if phys and phys:IsValid() then
		phys:Wake()
	end
	
	self:GetPhysicsObject():SetBuoyancyRatio(0)
end

function ENT:Use(activator, caller)
	return false
end

function ENT:OnRemove()
	return false
end 

local vel, len, CT

function ENT:PhysicsCollide(data, physobj)
	vel = physobj:GetVelocity()
	len = vel:Length()
	
	if len > 500 then -- let it roll
		physobj:SetVelocity(vel * 0.6) -- cheap as fuck, but it works
	end
	
	if len > 100 then
		CT = CurTime()
		
		if CT > self.NextImpact then
			self:EmitSound("weapons/smokegrenade/grenade_hit1.wav", 75, 100)
			self.NextImpact = CT + 0.1
		end
	end
end

function ENT:Fuse(t)
	t = t or 3
	
	timer.Simple(t, function()
		if self:IsValid() then
			local hitPos = self:GetPos()
			
			local smokeScreen = ents.Create("cw_smokescreen_impact")
			smokeScreen:SetPos(hitPos)
			smokeScreen:Spawn()
			smokeScreen:CreateParticles()
			
			self:Remove()
		end
	end)
end


================================================
FILE: cw2/lua/entities/cw_smoke_thrown/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Thrown smoke grenade"
ENT.Author = "Spy"
ENT.Information = "Thrown smoke grenade"
ENT.Spawnable = false
ENT.AdminSpawnable = false 


================================================
FILE: cw2/lua/entities/cw_smokescreen_impact/cl_init.lua
================================================
include("shared.lua")

ENT.SmokeFadeTime = 2
ENT.SmokeFadeInTime = 1
ENT.SmokeIntensity = 0
ENT.SmokeStartDistance = 384
ENT.SmokeMaxIntensityDistance = 128

function ENT:Initialize()
	self.InitTime = self:GetCreationTime()
	self.SmokeMaxIntensityDuration = self.SmokeDuration - self.SmokeFadeTime
	self.SmokeEndTime = self.InitTime + self.SmokeDuration
	self.SmokeFadeInDuration = self.InitTime + self.SmokeFadeInTime
	self.PartialIntensityDistance = self.SmokeStartDistance - self.SmokeMaxIntensityDistance
end

function ENT:Draw()
end

function ENT:OnRemove()
	self:StopParticles()
end

function ENT:Think()
	local CT = CurTime()
	
	-- get the distance from the impact position to the player
	local distToPlayer = EyePos():Distance(self:GetPos())
	
	if distToPlayer > self.SmokeStartDistance then
		return
	end
	
	local overallIntensity = 0
	
	-- if the lifetime of the grenade is nearing it's end, fade it out based on time left
	if CT > self.InitTime + self.SmokeMaxIntensityDuration then
		local timeRel = self.SmokeEndTime - CT
		
		overallIntensity = math.Clamp(timeRel / self.SmokeFadeTime, 0, 1)
	else
		-- if it's fresh and is only fading in, scale the intensity based on time left until full intensity
		if CT < self.SmokeFadeInDuration then
			local timeRel = math.Clamp(1 - (self.SmokeFadeInDuration - CT) / self.SmokeFadeInTime, 0, 1)
			
			overallIntensity = timeRel
		else
			-- overall, give it full intensity
			overallIntensity = 1
		end
	end
	
	if overallIntensity == 0 then
		return
	end
	
	-- time to figure out position-based intensity

	if distToPlayer > self.SmokeMaxIntensityDistance then
		-- if we're within the smoke's partial intensity distance, scale it based on the distance
		local distanceRel = 1 - math.Clamp((distToPlayer - self.SmokeMaxIntensityDistance) / self.PartialIntensityDistance, 0, 1)
		
		overallIntensity = overallIntensity * distanceRel
		
		-- and if we aren't just don't change the intensity (since we're at max intensity)
	end
	
	if not ply.CW_SmokeScreenIntensity or overallIntensity > ply.CW_SmokeScreenIntensity then
		ply.CW_SmokeScreenIntensity = overallIntensity
	end
end 

net.Receive("CW_SMOKESCREEN", function(a, b)
	local vec = net.ReadVector()
	
	ParticleEffect("cstm_smoke", vec, Angle(0, 0, 0), nil)
end)


================================================
FILE: cw2/lua/entities/cw_smokescreen_impact/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

util.AddNetworkString("CW_SMOKESCREEN")

local spd, ent

function ENT:Initialize()
	self:SetModel("models/Items/AR2_Grenade.mdl") 
	self:PhysicsInit(SOLID_NONE)
	self:SetMoveType(MOVETYPE_NONE)
	self:SetSolid(SOLID_NONE)
	self:SetCollisionGroup(COLLISION_GROUP_NONE)
	
	timer.Simple(self.SmokeDuration, function()
		SafeRemoveEntity(self)
	end)
end

function ENT:CreateParticles()
	self:EmitSound("weapons/smokegrenade/sg_explode.wav", 100, 100)
	
	net.Start("CW_SMOKESCREEN")
		net.WriteVector(self:GetPos())
	net.Broadcast()
end

function ENT:Use(activator, caller)
	return false
end

function ENT:OnRemove()
	self:StopParticles()
	return false
end 


================================================
FILE: cw2/lua/entities/cw_smokescreen_impact/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Smoke impact position"
ENT.Author = "Spy"
ENT.Spawnable = false
ENT.AdminSpawnable = false 

ENT.SmokeDuration = 16


================================================
FILE: cw2/lua/weapons/cw_ak74/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_AK74_FIRE", "weapons/cw_ak74/fire.wav", 1, 120, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_AK74_FIRE_SUPPRESSED", "weapons/cw_ak74/fire_suppressed.wav", 1, 100, CHAN_WEAPON)

CustomizableWeaponry:addFireSound("CW_AK74_RPK_FIRE", "weapons/cw_ak74/rpk_fire.wav", 1, 122, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_AK74_RPK_FIRE_SUPPRESSED", "weapons/cw_ak74/rpk_fire_suppressed.wav", 1, 105, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_AK74_MAGOUT", "weapons/cw_ak74/magout.wav")
CustomizableWeaponry:addReloadSound("CW_AK74_MAGIN", "weapons/cw_ak74/magin.wav")
CustomizableWeaponry:addReloadSound("CW_AK74_CLOTH", "weapons/cw_ak74/foley1.wav")
CustomizableWeaponry:addReloadSound("CW_AK74_BOLTPULL", "weapons/cw_ak74/boltpull.wav")


================================================
FILE: cw2/lua/weapons/cw_ak74/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "AK-74"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.IronsightPos = Vector(-2.441, -3.83, 0.908)
	SWEP.IronsightAng = Vector(0.21, -0.401, 0)
	
	SWEP.AimpointPos = Vector(-2.371, -2.59, -0.925)
	SWEP.AimpointAng = Vector(0, 0, 0)
	
	SWEP.EoTechPos = Vector(-2.4, -3.493, -0.98)
	SWEP.EoTechAng = Vector(0, 0, 0)
	
	SWEP.KobraPos = Vector(-2.55, -3.224, -0.026)
	SWEP.KobraAng = Vector(0.717, -0.638, 0)
	
	SWEP.ShortenedPos = Vector(-2.428, -3.618, 0.842)
	SWEP.ShortenedAng = Vector(-0.098, -0.044, 0)

	SWEP.RPKPos = Vector(-2.418, -3.481, 0.93)
	SWEP.RPKAng = Vector(0.125, -0.25, 0)
	
	SWEP.PSOPos = Vector(-2.5, 0.65, -0.101)
	SWEP.PSOAng = Vector(0, 0, 0)
	
	SWEP.ACOGPos = Vector(-2.412, -4.18, -0.977)
	SWEP.ACOGAng = Vector(0, 0, 0)
	
	SWEP.AlternativePos = Vector(-0.24, 0, -0.48)
	SWEP.AlternativeAng = Vector(0, 0, 0)
	
	SWEP.BackupSights = {
		["md_schmidt_shortdot"] = {aimPosBackUp = true},
		["md_acog"] = {Vector(-2.435, -4.18, -1.874), Vector(0, -0.429, 0)},
		md_nightforce_nxs = {aimPosBackUp = true},
	}

	SWEP.ViewModelMovementScale = 1.15
	
	SWEP.IconLetter = "b"
	killicon.AddFont("cw_ak74", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_ak74"
	SWEP.PosBasedMuz = false
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = -2, y = 0, z = -3}
	SWEP.SightWithRail = true
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.65
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.9
	
	SWEP.BoltBone = "ak74_Bolt"
	SWEP.BoltShootOffset = Vector(-3.6, 0, 0)
	SWEP.OffsetBoltOnBipodShoot = true

	SWEP.NXSPos = Vector(-2.442, -2.941, -0.823)
	SWEP.NXSAng = Vector(0, -0.429, 0)

	SWEP.AttachmentModelsVM = {
		["md_rail"] = {model = "models/wystan/attachments/akrailmount.mdl", bone = "ak74_body", pos = Vector(-0.077, -0.245, 1.041), angle = Angle(0, -90, 0), size = Vector(1, 1, 1)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "ak74_body", pos = Vector(11.609, 0.275, -7.834), adjustment = {min = 9, max = 11.609, axis = "x", inverse = true, inverseDisplay = true}, angle = Angle(0, 180, 0), size = Vector(1, 1, 1)},
		["md_aimpoint"] = {model = "models/wystan/attachments/aimpoint.mdl", bone = "ak74_body", pos = Vector(6.6, -0.247, -2.79), adjustment = {min = 4, max = 6.6, axis = "x", inverse = true}, angle = Angle(0, -90, 0), size = Vector(1, 1, 1)},
		["md_foregrip"] = {model = "models/wystan/attachments/foregrip1.mdl", bone = "ak74_body", pos = Vector(4.151, -0.433, -2.721), angle = Angle(0, -90, 0), size = Vector(0.75, 0.75, 0.75)},
		["md_pbs1"] = {model = "models/cw2/attachments/pbs1.mdl", bone = "ak74_body", pos = Vector(-19.57, 0, -0.816), angle = Angle(0, 90, 0), size = Vector(1, 1, 1)},
		["md_kobra"] = {model = "models/cw2/attachments/kobra.mdl", bone = "ak74_body", pos = Vector(0.731, 0.388, -1.538), angle = Angle(0, 90, 0), size = Vector(0.6, 0.6, 0.6)},
		["md_pso1"] = {model = "models/cw2/attachments/pso.mdl", bone = "ak74_body", pos = Vector(5.521, -0.174, -1.107), angle = Angle(0, 90, 0), size = Vector(0.8, 0.8, 0.8)},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "ak74_body", pos = Vector(4.558, -0.302, -1.67), angle = Angle(0, 180, 0), size = Vector(0.8, 0.8, 0.8)},
		["md_acog"] = {model = "models/wystan/attachments/2cog.mdl", bone = "ak74_body", pos = Vector(4.315, -0.288, -1.663), angle = Angle(0, -90, 0), size = Vector(0.8, 0.8, 0.8)},
		["md_nightforce_nxs"] = {model = "models/cw2/attachments/l96_scope.mdl", bone = "ak74_body", pos = Vector(-1.152, -0.083, 3.95), angle = Angle(0, 180, 0), size = Vector(1, 1, 1)},
	}

	SWEP.ShortDotPos = Vector(-2.428, -4.107, -0.721)
	SWEP.ShortDotAng = Vector(0, 0, 0)

	SWEP.ForeGripHoldPos = {
		["Left12"] = {pos = Vector(0, 0, 0), angle = Angle(19.048, 0, 0) },
		["Left19"] = {pos = Vector(0, 0, 0), angle = Angle(7.56, -5.153, -33.453) },
		["Left3"] = {pos = Vector(0, 0, 0), angle = Angle(0, 98.859, 0) },
		["Left8"] = {pos = Vector(0, 0, 0), angle = Angle(28.447, 0, 0) },
		["Left18"] = {pos = Vector(0, 0, 0), angle = Angle(31.268, 8.871, -34.725) },
		["Left17"] = {pos = Vector(0, 0, 0), angle = Angle(4.524, 0.3, -39.885) },
		["Left11"] = {pos = Vector(0, 0, 0), angle = Angle(17.864, 0, 0) },
		["Left9"] = {pos = Vector(0, 0, 0), angle = Angle(8.972, 0, 0) },
		["Left_L_Arm"] = {pos = Vector(1.231, 2.617, -1.206), angle = Angle(0, 0, 84.377) },
		["Left24"] = {pos = Vector(0, 0, 0), angle = Angle(31.447, -4.021, -22.029) },
		["Left16"] = {pos = Vector(0, 0, 0), angle = Angle(7.047, 11.637, -22.139) },
		["Left14"] = {pos = Vector(0, 0, 0), angle = Angle(14.432, -4.611, 0) },
		["Left2"] = {pos = Vector(0, 0, 0), angle = Angle(0, 40.631, 0) },
		["Left_U_Arm"] = {pos = Vector(2.54, 0.004, 0), angle = Angle(0, 0, 0) }}
		
	SWEP.PSO1AxisAlign = {right = 0, up = 0.4, forward = -90}
	SWEP.SchmidtShortDotAxisAlign = {right = 0, up = -0.4, forward = 0}
	SWEP.ACOGAxisAlign = {right = 0, up = -0.4, forward = 0}
	SWEP.AttachmentPosDependency = {["md_pbs1"] = {["bg_ak74_rpkbarrel"] = Vector(-28, 0, -0.816), ["bg_ak74_ubarrel"] = Vector(-14, 0, -0.88)}}
end

SWEP.MuzzleVelocity = 880 -- in meter/s

SWEP.LuaViewmodelRecoil = true

--SWEP.Attachments = {[1] = {header = "Sight", offset = {300, -50},  atts = {"md_kobra", "md_eotech", "md_aimpoint"}},
--	[2] = {header = "Barrel", offset = {-175, -100}, atts = {"md_pbs1"}},
--	[3] = {header = "Handguard", offset = {-100, 200}, atts = {"md_foregrip"}}}

SWEP.BarrelBGs = {main = 2, rpk = 1, short = 4, regular = 0}
SWEP.StockBGs = {main = 1, regular = 0, heavy = 1, foldable = 2}
SWEP.ReceiverBGs = {main = 3, rpk = 1, regular = 0}
SWEP.MagBGs = {main = 4, regular = 0, rpk = 1}

SWEP.Attachments = {[1] = {header = "Sight", offset = {950, -500},  atts = {"md_kobra", "md_eotech", "md_aimpoint", "md_schmidt_shortdot", "md_pso1", "md_acog", "md_nightforce_nxs"}},
	[2] = {header = "Barrel", offset = {300, -500}, atts = {"md_pbs1"}},
	[3] = {header = "Receiver", offset = {-300, -500}, atts = {"bg_ak74_rpkbarrel", "bg_ak74_ubarrel"}},
	[4] = {header = "Handguard", offset = {-300, 0}, atts = {"md_foregrip"}, exclusions = {bg_ak74_rpkbarrel = true}},
	[5] = {header = "Magazine", offset = {-300, 500}, atts = {"bg_ak74rpkmag"}},
	[6] = {header = "Stock", offset = {700, 500}, atts = {"bg_ak74foldablestock", "bg_ak74heavystock"}},
	["+reload"] = {header = "Ammo", offset = {950, 0}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {fire = {"fire1", "fire2", "fire3"},
	reload = "reload",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {	draw = {{time = 0, sound = "CW_FOLEY_MEDIUM"}},

	reload = {
		{time = 0.15, sound = "CW_AKM_OFFICIAL_MAGOUT"},
		{time = 1.05, sound = "CW_AKM_OFFICIAL_MAGIN"},
		{time = 1.95, sound = "CW_AKM_OFFICIAL_BOLTPULL"},
		{time = 2.1, sound = "CW_AKM_OFFICIAL_BOLTRELEASE"}
	}
}

SWEP.SpeedDec = 30

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/rifles/ak74.mdl"
SWEP.WorldModel		= "models/weapons/w_rif_ak47.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 30
SWEP.Primary.DefaultClip	= 30
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "5.45x39MM"

SWEP.FireDelay = 0.092307692307692
SWEP.FireSound = "CW_AK74_FIRE"
SWEP.FireSoundSuppressed = "CW_AK74_FIRE_SUPPRESSED"
SWEP.Recoil = 0.9

SWEP.HipSpread = 0.043
SWEP.AimSpread = 0.005
SWEP.VelocitySensitivity = 1.6
SWEP.MaxSpreadInc = 0.05
SWEP.SpreadPerShot = 0.007
SWEP.SpreadCooldown = 0.13
SWEP.Shots = 1
SWEP.Damage = 31
SWEP.DeployTime = 0.6

SWEP.ReloadSpeed = 0.7
SWEP.ReloadTime = 1.5
SWEP.ReloadTime_Empty = 1.5
SWEP.ReloadHalt = 1.65
SWEP.ReloadHalt_Empty = 2.6
SWEP.SnapToIdlePostReload = true


================================================
FILE: cw2/lua/weapons/cw_akm_official/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_AKM_OFFICIAL_FIRE", "weapons/cw_akm_official/fire.wav", 1, 120, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_AKM_OFFICIAL_FIRE_SUPPRESSED", "weapons/cw_akm_official/fire_suppressed.wav", 1, 100, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_AKM_OFFICIAL_MAGRELEASE", "weapons/cw_akm_official/magrelease.wav")
CustomizableWeaponry:addReloadSound("CW_AKM_OFFICIAL_MAGOUT", "weapons/cw_akm_official/mag_out.ogg")
CustomizableWeaponry:addReloadSound("CW_AKM_OFFICIAL_MAGOUT_RATTLE", "weapons/cw_akm_official/magout_rattle.wav")
CustomizableWeaponry:addReloadSound("CW_AKM_OFFICIAL_MAGIN", "weapons/cw_akm_official/mag_in.ogg")

CustomizableWeaponry:addReloadSound("CW_AKM_OFFICIAL_CLOTH", "weapons/cw_akm_official/foley1.wav")
CustomizableWeaponry:addReloadSound("CW_AKM_OFFICIAL_RELOAD_GRAB", "weapons/cw_akm_official/grab_reload.wav")
CustomizableWeaponry:addReloadSound("CW_AKM_OFFICIAL_BOLTPULL", "weapons/cw_akm_official/bolt_back.ogg")
CustomizableWeaponry:addReloadSound("CW_AKM_OFFICIAL_BOLTRELEASE", "weapons/cw_akm_official/bolt_forward.ogg")


================================================
FILE: cw2/lua/weapons/cw_akm_official/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "AKM"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.IronsightPos = Vector(-3.846, -3.109, 1.1)
	SWEP.IronsightAng = Vector(0.577, 0.079, 0)

	SWEP.AimpointPos = Vector(-3.873, -6.683, 0.351)
	SWEP.AimpointAng = Vector(0, 0, 0)

	SWEP.EoTechPos = Vector(-3.875, -4.528, -0.16)
	SWEP.EoTechAng = Vector(0, 0, 0)

	SWEP.KobraPos = Vector(-2.55, -3.224, -0.026)
	SWEP.KobraAng = Vector(0.717, -0.638, 0)
	
	SWEP.ShortenedPos = Vector(-2.428, -3.618, 0.842)
	SWEP.ShortenedAng = Vector(-0.098, -0.044, 0)

	SWEP.RPKPos = Vector(-2.418, -3.481, 0.93)
	SWEP.RPKAng = Vector(0.125, -0.25, 0)
	
	SWEP.PSOPos = Vector(-2.5, 0.65, -0.101)
	SWEP.PSOAng = Vector(0, 0, 0)
	
	SWEP.ACOGPos = Vector(-3.866, -8.995, 0.229)
	SWEP.ACOGAng = Vector(0, 0, 0)

	SWEP.ShortDotPos = Vector(-3.859, -8.905, 0.476)
	SWEP.ShortDotAng = Vector(0, 0, 0)

	SWEP.AlternativePos = Vector(-1, -2, -0.6)
	SWEP.AlternativeAng = Vector(0, 0, 0)
	
	SWEP.BackupSights = {
		["md_acog"] = {Vector(-3.862, -8.995, -0.676), Vector(0, 0, 0)},
	}

	SWEP.ViewModelMovementScale = 1.15
	
	SWEP.IconLetter = "b"
	killicon.AddFont("cw_ak74", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_ak74"
	SWEP.PosBasedMuz = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = 0, y = 0, z = 3}
	SWEP.SightWithRail = true
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.52
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.76
	
	SWEP.BoltBone = "bolt"
	SWEP.BoltShootOffset = Vector(-4.81, 0, 0)
	SWEP.OffsetBoltOnBipodShoot = true

	SWEP.NXSPos = Vector(-2.442, -2.941, -0.823)
	SWEP.NXSAng = Vector(0, -0.429, 0)

	SWEP.AttachmentModelsVM = {
		["md_pbs1"] = { type = "Model", model = "models/cw2/attachments/pbs1.mdl", bone = "body", rel = "", pos = Vector(-0.031, 20.329, -0.635), angle = Angle(0, 180, 0), size = Vector(0.699, 0.699, 0.699), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
		["md_eotech"] = { type = "Model", model = "models/wystan/attachments/2otech557sight.mdl", bone = "body", rel = "", pos = Vector(0.319, -9.629, -11.506), angle = Angle(3.332, -90, 0), size = Vector(1.2, 1.2, 1.2), color = Color(255, 255, 255, 0), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
		["md_aimpoint"] = { type = "Model", model = "models/wystan/attachments/aimpoint.mdl", bone = "body", rel = "", pos = Vector(-0.232, -2.754, -3.096), angle = Angle(0, 0, 0), size = Vector(0.899, 0.899, 0.899), color = Color(255, 255, 255, 0), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
		["md_foregrip"] = { type = "Model", model = "models/wystan/attachments/foregrip1.mdl", bone = "body", rel = "", pos = Vector(-0.385, -3.379, -2.883), angle = Angle(0, 0, 0), size = Vector(0.699, 0.699, 0.699), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
		["md_schmidt_shortdot"] = { type = "Model", model = "models/cw2/attachments/schmidt.mdl", bone = "body", rel = "", pos = Vector(-0.292, -1.991, -2.57), angle = Angle(0, -90, 0), size = Vector(0.8, 0.8, 0.8), color = Color(255, 255, 255, 0), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
		["md_acog"] = { type = "Model", model = "models/wystan/attachments/2cog.mdl", bone = "body", rel = "", pos = Vector(-0.297, -2.053, -2.57), angle = Angle(0, 0, 0), size = Vector(0.8, 0.8, 0.8), color = Color(255, 255, 255, 0), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
	}

	SWEP.ForeGripHoldPos = {
		["Bip01 L Finger02"] = {pos = Vector(0, 0, 0), angle = Angle(0, 83.181, 0) },
		["Bip01 L Finger41"] = {pos = Vector(0, 0, 0), angle = Angle(0, 34.194, 0) },
		["Bip01 L UpperArm"] = {pos = Vector(0.907, -0.471, -2.847), angle = Angle(0, 0, 0) },
		["Bip01 L Finger31"] = {pos = Vector(0, 0, 0), angle = Angle(0, 53.886, 0) },
		["Bip01 L Finger12"] = {pos = Vector(0, 0, 0), angle = Angle(0, 21.756, 0) },
		["Bip01 L ForeTwist"] = {pos = Vector(0, 0, 0), angle = Angle(0, 0, 44.928) },
		["Bip01 L Finger0"] = {pos = Vector(0, 0, 0), angle = Angle(11.442, 0, 0) },
		["Bip01 L Forearm"] = {pos = Vector(0, 0, 0), angle = Angle(0, 0, 72.1) },
		["Bip01 L Finger21"] = {pos = Vector(0, 0, 0), angle = Angle(-7.89, 53.339, 0) },
		["Bip01 L Finger11"] = {pos = Vector(0, 0, 0), angle = Angle(0, 67.512, 0) },
		["Bip01 L Finger01"] = {pos = Vector(0, 0, 0), angle = Angle(13.019, 30.686, 0) },
		["Bip01 L Hand"] = {pos = Vector(0, 0, 0), angle = Angle(0, 33.571, -11.86) }
	}
		
	--SWEP.PSO1AxisAlign = {right = 0, up = 0.4, forward = -90}
	--SWEP.SchmidtShortDotAxisAlign = {right = 0, up = -0.4, forward = 0}
	--SWEP.ACOGAxisAlign = {right = 0, up = -0.4, forward = 0}
end

SWEP.MuzzleVelocity = 880 -- in meter/s

SWEP.LuaViewmodelRecoil = true

SWEP.BarrelBGs = {main = 2, rpk = 1, short = 4, regular = 0}
SWEP.StockBGs = {main = 1, regular = 0, heavy = 1, foldable = 2}
SWEP.ReceiverBGs = {main = 3, rpk = 1, regular = 0}
SWEP.MagBGs = {main = 4, regular = 0, rpk = 1}

SWEP.Attachments = {
	{header = "Sight", offset = {950, -500},  atts = {"md_eotech", "md_aimpoint", "md_schmidt_shortdot", "md_acog"}},
	{header = "Barrel", offset = {0, -500}, atts = {"md_pbs1"}},
	{header = "Handguard", offset = {-400, 100}, atts = {"md_foregrip"}, exclusions = {bg_ak74_rpkbarrel = true}},
	["+reload"] = {header = "Ammo", offset = {950, 300}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {fire = {"ak47_fire1", "ak47_fire2", "ak47_fire3"},
	reload = "ak47_reload",
	idle = "ak47_idle",
	draw = "ak47_draw"}
	
SWEP.Sounds = {	
	draw = {
		{time = 0, sound = "CW_FOLEY_MEDIUM"}
	},
	ak47_reload = {
		{time = 0.05, sound = "CW_FOLEY_MEDIUM"},
		{time = 0.3, sound = "CW_AKM_OFFICIAL_MAGOUT"},
		{time = 0.35, sound = "CW_AKM_OFFICIAL_MAGRELEASE"},
		{time = 0.8, sound = "CW_AKM_OFFICIAL_CLOTH"},
		{time = 1.15, sound = "CW_AKM_OFFICIAL_MAGIN"},
		{time = 1.92, sound = "CW_AKM_OFFICIAL_BOLTPULL"},
		{time = 2.08, sound = "CW_AKM_OFFICIAL_BOLTRELEASE"},
		{time = 2.2, sound = "CW_FOLEY_MEDIUM"}
	}
}

SWEP.SpeedDec = 30

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/rifles/akm_official_v.mdl"
SWEP.WorldModel		= "models/weapons/w_rif_ak47.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 30
SWEP.Primary.DefaultClip	= 30
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "7.62x39MM"

SWEP.FireDelay = 60/600
SWEP.FireSound = "CW_AKM_OFFICIAL_FIRE"
SWEP.FireSoundSuppressed = "CW_AKM_OFFICIAL_FIRE_SUPPRESSED"
SWEP.Recoil = 1.2

SWEP.HipSpread = 0.043
SWEP.AimSpread = 0.0055
SWEP.VelocitySensitivity = 1.6
SWEP.MaxSpreadInc = 0.055
SWEP.SpreadPerShot = 0.0095
SWEP.SpreadCooldown = 0.15
SWEP.Shots = 1
SWEP.Damage = 34
SWEP.DeployTime = 0.6

SWEP.ReloadSpeed = 0.85
SWEP.ReloadTime = 1.65
SWEP.ReloadTime_Empty = 2.1
SWEP.ReloadHalt = 1.65
SWEP.ReloadHalt_Empty = 2.6
SWEP.SnapToIdlePostReload = true


================================================
FILE: cw2/lua/weapons/cw_ar15/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_AR15_FIRE", "weapons/cw_ar15/fire.wav", 1, 115, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_AR15_FIRE_SUPPRESSED", "weapons/cw_ar15/fire_suppressed1.wav", 1, 90, CHAN_WEAPON)

CustomizableWeaponry:addFireSound("CW_AR15_LONGBARREL_FIRE", "weapons/cw_ar15/fire_longbarrel.wav", 1, 120, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_AR15_LONGBARREL_FIRE_SUPPRESSED", "weapons/cw_ar15/fire_longbarrel_suppressed.wav", 1, 95, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_AR15_MAGOUT", "weapons/cw_ar15/magout.wav")
CustomizableWeaponry:addReloadSound("CW_AR15_MAGIN", "weapons/cw_ar15/magin.wav")
CustomizableWeaponry:addReloadSound("CW_AR15_MAGDROP", "weapons/cw_ar15/magdrop.wav")
CustomizableWeaponry:addReloadSound("CW_AR15_BOLT", "weapons/cw_ar15/boltpull.wav")


================================================
FILE: cw2/lua/weapons/cw_ar15/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "AR-15"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1.15
	
	SWEP.IconLetter = "w"
	killicon.AddFont("cw_ar15", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_6"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = -2, y = 0, z = -3}
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.65
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.9
	
	SWEP.M203OffsetCycle_Reload = 0.65
	SWEP.M203OffsetCycle_Reload_Empty = 0.73
	SWEP.M203OffsetCycle_Draw = 0
	
	SWEP.IronsightPos = Vector(-2.208, -4.3, 0.143)
	SWEP.IronsightAng = Vector(0.605, 0, -0.217)
	
	SWEP.FoldSightPos = Vector(-2.208, -4.3, 0.143)
	SWEP.FoldSightAng = Vector(0.605, 0, -0.217)
		
	SWEP.EoTechPos = Vector(-2.21, -3.6, 0.239)
	SWEP.EoTechAng = Vector(0, 0, -0.217)
	
	SWEP.NXSPos = Vector(-2.191, -4.454, 0.439)
	SWEP.NXSAng = Vector(0, 0, 0)

	SWEP.AimpointPos = Vector(-2.194, -2.7, 0.57)
	SWEP.AimpointAng = Vector(-1.951, 0, -0.217)
	
	SWEP.MicroT1Pos = Vector(-2.208, 1, 0.83)
	SWEP.MicroT1Ang = Vector(-1.938, 0, -0.217)
	
	SWEP.ACOGPos = Vector(-2.211, -4, 0.146)
	SWEP.ACOGAng = Vector(-1.4, 0, 0)
	
	SWEP.ShortDotPos = Vector(-2.201, -4.148, 0.425)
	SWEP.ShortDotAng = Vector(0, 0, 0)
	
	SWEP.M203Pos = Vector(-0.562, -2.481, 0.24)
	SWEP.M203Ang = Vector(0, 0, 0)
	
	SWEP.AlternativePos = Vector(-0.32, 0, -0.64)
	SWEP.AlternativeAng = Vector(0, 0, 0)
	
	SWEP.BackupSights = {["md_acog"] = {[1] = Vector(-2.211, -4, -0.95), [2] = Vector(-2, 0, 0)}}

	SWEP.ACOGAxisAlign = {right = -0.58, up = -0.01, forward = 0}
	SWEP.SchmidtShortDotAxisAlign = {right = -2, up = 0, forward = 0}
	SWEP.M203CameraRotation = {p = -90, y = 0, r = -90}
	
	SWEP.ForegripOverridePos = {
		["md_cmag_556_official"] = {
			weakOverride = true, -- weak override - will not use these coords if any of the other (foregrip/m203) attachments are active
			["Bip01 L UpperArm"] = {pos = Vector(-0.732, -1.836, -4.113), angle = Angle(0, -12.549, 0) }
		}
	}
	
	SWEP.magBoneName = {"Magazine001", "Bullets001"}
	
	SWEP.BaseArm = "Bip01 L Clavicle"
	SWEP.BaseArmBoneOffset = Vector(-50, 0, 0)

	SWEP.NXSAlign = {right = -1.97, up = -0.01, forward = 0}
	
	SWEP.AttachmentModelsVM = {
		["md_aimpoint"] = {model = "models/wystan/attachments/aimpoint.mdl", bone = "smdimport001", rel = "", pos = Vector(-0.281, -4.55, -2.086), adjustment = {min = -4.3, max = -2.8, axis = "y", inverseOffsetCalc = true, preventedBy = {"md_anpeq15"}}, angle = Angle(0, 0, 1), size = Vector(1, 1, 1)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "smdimport001", rel = "", pos = Vector(0.238, -9.3, -7.223), adjustment = {min = -9.2, max = -7.6, axis = "y", inverseOffsetCalc = true, preventedBy = {"md_anpeq15"}}, angle = Angle(0, -90, 0), size = Vector(1, 1, 1)},
		["md_foregrip"] = {model = "models/wystan/attachments/foregrip1.mdl", bone = "smdimport001", rel = "", pos = Vector(-0.452, -2.556, -1.428), angle = Angle(0, 0, 0), size = Vector(0.75, 0.75, 0.75)},
		["md_saker"] = {model = "models/cw2/attachments/556suppressor.mdl", bone = "smdimport001", pos = Vector(-0.042, 4.362, 0.1), angle = Angle(0, 0, 2), size = Vector(0.75, 0.75, 0.75)},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "smdimport001", pos = Vector(-0.027, 1.25, 3.634), adjustment = {min = 1.25, max = 3.6, axis = "y", inverseOffsetCalc = true, preventedBy = {"md_anpeq15"}}, angle = Angle(0, 180, 0), size = Vector(0.4, 0.4, 0.4)},
		["md_acog"] = {model = "models/wystan/attachments/2cog.mdl", bone = "smdimport001", pos = Vector(-0.401, -3.291, -2.22), angle = Angle(0, 0, 0), size = Vector(1, 1, 1)},
		["md_anpeq15"] = {model = "models/cw2/attachments/anpeq15.mdl", bone = "smdimport001", pos = Vector(-0.225, 9.715, 3.15), angle = Angle(0, 90, 0), size = Vector(0.699, 0.699, 0.699)},
		["md_m203"] = {model = "models/cw2/attachments/m203.mdl", bone = "smdimport001", pos = Vector(2.299, -6.611, 4.138), angle = Angle(0, -90, 0), size = Vector(1, 1, 1), animated = true},
		["md_bipod"] = {model = "models/wystan/attachments/bipod.mdl", bone = "smdimport001", pos = Vector(-0.011, 14.541, 0.441), angle = Angle(0, 0, 0), size = Vector(0.699, 0.699, 0.699)},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "smdimport001", pos = Vector(-0.35, -2.554, -1.627), angle = Angle(0, -90, 0), size = Vector(0.899, 0.899, 0.899)},
		["md_nightforce_nxs"] = {model = "models/cw2/attachments/l96_scope.mdl", bone = "smdimport001", pos = Vector(-0.105, 3.852, 4.574), angle = Angle(0, -90, 0), size = Vector(1, 1, 1)},
		["md_cmag_556_official"] = {model = "models/wystan/Cmag.mdl", bone = "Magazine001", pos = Vector(-0.191, -3.323, -1.254), angle = Angle(0, -90, 0), size = Vector(0.6, 0.6, 0.6),}
	}
	
	SWEP.M203HoldPos = {
		["Bip01 L Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-2.76, 2.651, 1.386), angle = Angle(0, 0, 0) }
	}

	SWEP.ForeGripHoldPos = {
		["Bip01 L Finger3"] = {pos = Vector(0, 0, 0), angle = Angle(0, 42.713, 0) },
		["Bip01 L Clavicle"] = {pos = Vector(-3.299, 1.235, -1.79), angle = Angle(-55.446, 11.843, 0) },
		["Bip01 L Forearm"] = {pos = Vector(0, 0, 0), angle = Angle(0, 0, 42.41) },
		["Bip01 L Finger02"] = {pos = Vector(0, 0, 0), angle = Angle(0, 71.308, 0) },
		["Bip01 L Finger11"] = {pos = Vector(0, 0, 0), angle = Angle(0, 25.795, 0) },
		["Bip01 L Finger4"] = {pos = Vector(0, 0, 0), angle = Angle(0, 26.148, 0) },
		["Bip01 L Finger1"] = {pos = Vector(0, 0, 0), angle = Angle(6.522, 83.597, 0) },
		["Bip01 L Finger0"] = {pos = Vector(0, 0, 0), angle = Angle(23.2, 16.545, 0) },
		["Bip01 L Finger42"] = {pos = Vector(0, 0, 0), angle = Angle(0, 31.427, 0) },
		["Bip01 L Finger32"] = {pos = Vector(0, 0, 0), angle = Angle(0, 29.565, 0) },
		["Bip01 L Hand"] = {pos = Vector(0, 0, 0), angle = Angle(9.491, 14.793, -15.926) },
		["Bip01 L Finger12"] = {pos = Vector(0, 0, 0), angle = Angle(0, -9.195, 0) },
		["Bip01 L Finger21"] = {pos = Vector(0, 0, 0), angle = Angle(0, 10.164, 0) },
		["Bip01 L Finger01"] = {pos = Vector(0, 0, 0), angle = Angle(0, 18.395, 0) },
		["Bip01 L Finger2"] = {pos = Vector(0, 0, 0), angle = Angle(2.411, 57.007, 0) }
	}
	
	SWEP.AttachmentPosDependency = {
		["md_anpeq15"] = {
			["bg_longris"] = Vector(-0.225, 13, 3.15),
			["bg_ris"] = Vector(-0.225, 9.715, 3.15),
			["bg_foldsight"] = Vector(-0.225, 5.5, 3.15),
			["md_microt1"] = Vector(-0.225, 5.5, 3.15),
			["md_aimpoint"] = Vector(-0.225, 5.5, 3.15),
		},
		["md_saker"] = {["bg_longbarrel"] = Vector(-0.042, 9, -0.1), ["bg_longris"] = Vector(-0.042, 9, -0.1)},
		["md_bipod"] = {
			bg_longris = Vector(-0.011, 14.541, 0.441)
		}
	}
	
	SWEP.LaserPosAdjust = Vector(1, 0, 0)
	SWEP.LaserAngAdjust = Angle(2, 180, 0) 
end

SWEP.MuzzleVelocity = 880 -- in meter/s

SWEP.SightBGs = {main = 4, carryhandle = 0, foldsight = 1, none = 2}
SWEP.BarrelBGs = {main = 3, longris = 4, long = 3, magpul = 2, ris = 1, regular = 0}
SWEP.StockBGs = {main = 2, regular = 0, heavy = 1, sturdy = 2}
SWEP.MagBGs = {main = 5, regular = 0, round60 = 1}
SWEP.LuaViewmodelRecoil = true

SWEP.Attachments = {[1] = {header = "Sight", offset = {950, -600}, atts = {"bg_foldsight", "md_microt1", "md_eotech", "md_aimpoint", "md_schmidt_shortdot", "md_acog", "md_nightforce_nxs"}},
	[2] = {header = "Barrel", offset = {300, -600}, atts = {"md_saker"}},
	[3] = {header = "Receiver", offset = {-400, -600}, atts = {"bg_magpulhandguard", "bg_longbarrel", "bg_ris", "bg_longris"}},
	[4] = {header = "Handguard", offset = {-400, -100}, atts = {"md_foregrip", "md_bipod", "md_m203"}},
	[5] = {header = "Magazine", offset = {-400, 340}, atts = {"bg_ar1560rndmag", "md_cmag_556_official"}},
	[6] = {header = "Stock", offset = {1000, 300}, atts = {"bg_ar15sturdystock", "bg_ar15heavystock"}},
	[7] = {header = "Rail", offset = {250, 300}, atts = {"md_anpeq15"}, dependencies = {bg_ris = true, bg_longris = true, bg_foldsight = true, md_microt1 = true, md_aimpoint = true}},
	["+reload"] = {header = "Ammo", offset = {900, 0}, atts = {"am_magnum", "am_matchgrade"}}}
	
SWEP.AttachmentDependencies = {
	["md_m203"] = {"bg_longris"},
	md_bipod = {"bg_longris"}
} -- this is on a PER ATTACHMENT basis, NOTE: the exclusions and dependencies in the Attachments table is PER CATEGORY

SWEP.Animations = {fire = {"shoot1", "shoot2", "shoot3"},
	reload = "reload",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {draw = {{time = 0, sound = "CW_FOLEY_MEDIUM"}},

	reload = {[1] = {time = 0.35, sound = "CW_AR15_MAGOUT"},
	[2] = {time = 1.2, sound = "CW_AR15_MAGIN"},
	[3] = {time = 1.9, sound = "CW_AR15_BOLT"}}}

SWEP.SpeedDec = 30

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "3burst", "semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/rifles/ar15.mdl"
SWEP.WorldModel		= "models/weapons/w_rif_m4a1.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 30
SWEP.Primary.DefaultClip	= 30
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "5.56x45MM"

SWEP.FireDelay = 0.066666666666667
SWEP.FireSound = "CW_AR15_FIRE"
SWEP.FireSoundSuppressed = "CW_AR15_FIRE_SUPPRESSED"
SWEP.Recoil = 1.05

SWEP.HipSpread = 0.045
SWEP.AimSpread = 0.003
SWEP.VelocitySensitivity = 1.8
SWEP.MaxSpreadInc = 0.052
SWEP.SpreadPerShot = 0.007
SWEP.SpreadCooldown = 0.13
SWEP.Shots = 1
SWEP.Damage = 30
SWEP.DeployTime = 0.6

SWEP.ReloadSpeed = 1.15
SWEP.ReloadTime = 1.65
SWEP.ReloadTime_Empty = 1.65
SWEP.ReloadHalt = 1.9
SWEP.ReloadHalt_Empty = 3.1
SWEP.SnapToIdlePostReload = true


================================================
FILE: cw2/lua/weapons/cw_base/cl_calcview.lua
================================================
local FT, CT, cos1, cos2, ws, vel, att, ang
local Ang0, curang, curviewbob = Angle(0, 0, 0), Angle(0, 0, 0), Angle(0, 0, 0)
local reg = debug.getregistry()
local GetVelocity = reg.Entity.GetVelocity
local Length = reg.Vector.Length
local Right = reg.Angle.Right
local Up = reg.Angle.Up
local Forward = reg.Angle.Forward
local RotateAroundAxis = reg.Angle.RotateAroundAxis

SWEP.LerpBackSpeed = 10
SWEP.CurM203Angles = Angle(0, 0, 0)
SWEP.M203AngDiff = Angle(0, 0, 0)
SWEP.BreathFOVModifier = 0

-- free aim related vars start here
SWEP.lastEyeAngle = Angle(0, 0, 0)
SWEP.lastViewRoll = 0
SWEP.lastViewRollTime = 0
SWEP.forceFreeAimOffTime = false
SWEP.lastShotTime = 0
SWEP.curFOV = 90

SWEP.mouseX = 0
SWEP.mouseY = 0
SWEP.lastMouseActivity = 0

SWEP.autoCenterExclusions = {[CW_RUNNING] = true,
[CW_ACTION] = true,
[CW_HOLSTER_START] = true,
[CW_HOLSTER_END] = true} -- if the weapon's state is any of this, then we will force-auto-center if it is enabled
-- end here

local Ang0 = Angle(0, 0, 0)

function SWEP:getFreeAimToCenter()
	local ang = self.Owner:EyeAngles()
	
	return math.AngleDifference(self.lastEyeAngle.y, ang.y) + math.AngleDifference(self.lastEyeAngle.p, ang.p)
end

function SWEP:getFreeAimDotToCenter()
	local dist = self:getFreeAimToCenter()
	
	return dist / (GetConVarNumber("cw_freeaim_yawlimit") + GetConVarNumber("cw_freeaim_pitchlimit"))
end

SWEP.freeAimAutoCenterSpeed = 6


function SWEP:getZoomAmount()
	return self.ZoomAmount
end

function SWEP:CalcView(ply, pos, ang, fov)
	self.freeAimOn = self:isFreeAimOn()
	self.autoCenterFreeAim = GetConVarNumber("cw_freeaim_autocenter") > 0
	
	if self.dt.BipodDeployed then
		if not self.forceFreeAimOffTime then
			self.forceFreeAimOffTime = CurTime() + 0.5
		end
	else
		self.forceFreeAimOffTime = false
	end
		
	if self.freeAimOn then
		fov = 90 -- force FOV to 90 when in free aim mode, unfortunately, due to angles getting fucked up when FOV is not 90
		RunConsoleCommand("fov_desired", 90)
	end
	
	-- if we have free aim on, and we are not using a bipod, or we're using a bipod and we have not run out of "free aim time", then we should simulate free aim
	if self.freeAimOn and (not self.forceFreeAimOffTime or CurTime() < self.forceFreeAimOffTime) then
		local aiming = self.dt.State == CW_AIMING
		
		if self.shouldUpdateAngles then
			self.lastEyeAngle = self.Owner:EyeAngles()
			self.shouldUpdateAngles = false
		else
			local dot = math.Clamp(math.abs(self:getFreeAimDotToCenter()) + 0.3, 0.3, 1)
			
			local lazyAim = GetConVarNumber("cw_freeaim_lazyaim")
			self.lastEyeAngle.y = math.NormalizeAngle(self.lastEyeAngle.y - self.mouseX * lazyAim * dot)
			
			if not aiming and CurTime() > self.lastShotTime then -- we only want to modify pitch if we haven't shot lately
				self.lastEyeAngle.p = math.Clamp(self.lastEyeAngle.p + self.mouseY * lazyAim * dot, -89, 89)
			end
		end
		
		if self.autoCenterFreeAim then
			if self.mouseActive then
				self.lastMouseActivity = CurTime() + GetConVarNumber("cw_freeaim_autocenter_time")
			end
			
			local canAutoCenter = CurTime() > self.lastMouseActivity 
			local shouldAutoCenter = false
			local aimAutoCenter = GetConVarNumber("cw_freeaim_autocenter_aim") > 0
			
			if aiming then
				canAutoCenter = true
				shouldAutoCenter = true
			end
		
			if self.autoCenterExclusions[self.dt.State] then
				canAutoCenter = true
				shouldAutoCenter = true
			end
			
			if self.forceFreeAimOffTime then -- if we're being forced to turn free-aim off, do so
				canAutoCenter = true
				shouldAutoCenter = true
			end
		
			if canAutoCenter then
				local frameTime = FrameTime()
				
				self.freeAimAutoCenterSpeed = frameTime * 16
				
				if aiming then
					self.freeAimAutoCenterSpeed = frameTime * 25 --math.Approach(self.freeAimAutoCenterSpeed, frameTime * 40, frameTime * 6)
				end
				
				if self.autoCenterExclusions[self.dt.State] then
					shouldAutoCenter = true
				else
					if CurTime() > self.lastMouseActivity then
						shouldAutoCenter = true
						self.freeAimAutoCenterSpeed = frameTime * 6 --math.Approach(self.freeAimAutoCenterSpeed, frameTime * 6, frameTime * 6)
					end
				end
				
				self.freeAimAutoCenterSpeed = math.Clamp(self.freeAimAutoCenterSpeed, 0, 1)
					
				if shouldAutoCenter then
					self.lastEyeAngle = LerpAngle(self.freeAimAutoCenterSpeed, self.lastEyeAngle, self.Owner:EyeAngles())
				end
			end
		end
		
		local yawDiff = math.AngleDifference(self.lastEyeAngle.y, ang.y)
		local pitchDiff = math.AngleDifference(self.lastEyeAngle.p, ang.p)
		
		local yawLimit = GetConVarNumber("cw_freeaim_yawlimit")
		local pitchLimit = GetConVarNumber("cw_freeaim_pitchlimit")
		
		if yawDiff >= yawLimit then
			self.lastEyeAngle.y = math.NormalizeAngle(ang.y + yawLimit)
		elseif yawDiff <= -yawLimit then
			self.lastEyeAngle.y = math.NormalizeAngle(ang.y - yawLimit)
		end
		
		if pitchDiff >= pitchLimit then
			self.lastEyeAngle.p = math.NormalizeAngle(ang.p + pitchLimit)
		elseif pitchDiff <= -pitchLimit then
			self.lastEyeAngle.p = math.NormalizeAngle(ang.p - pitchLimit)
		end
		
		ang.y = self.lastEyeAngle.y
		ang.p = self.lastEyeAngle.p
		
		ang = ang
	else
		self.shouldUpdateAngles = true
	end
	
	FT, CT = FrameTime(), CurTime()
	
	local resetM203Angles = false
	
	self.M203CameraActive = false
	
	if self.AttachmentModelsVM then
		local m203 = self.AttachmentModelsVM.md_m203
		
		if m203 then
			if self.dt.State ~= CW_CUSTOMIZE then
				local CAMERA = m203.ent:GetAttachment(m203.ent:LookupAttachment("Camera")).Ang
				local modelAng = m203.ent:GetAngles()
				
				RotateAroundAxis(CAMERA, Right(CAMERA), self.M203CameraRotation.p)
				RotateAroundAxis(CAMERA, Up(CAMERA), self.M203CameraRotation.y)
				RotateAroundAxis(CAMERA, Forward(CAMERA), self.M203CameraRotation.r)

				local factor = math.abs(ang.p)
				local intensity = 1
				
				if factor >= 60 then
					factor = factor - 60
					intensity = math.Clamp(1 - math.abs(factor / 15), 0, 1)
				end
				
				self.M203AngDiff = math.NormalizeAngles((modelAng - CAMERA)) * 0.5 * intensity
			end
		end
	end
	
	ang = ang - self.M203AngDiff
	ang = ang - self.CurM203Angles * 0.5
	ang.r = ang.r + self.lastViewRoll
	
	if UnPredictedCurTime() > self.lastViewRollTime then
		self.lastViewRoll = LerpCW20(FrameTime() * 10, self.lastViewRoll, 0)
	end
	
	if UnPredictedCurTime() > self.FOVHoldTime or freeAimOn then
		self.FOVTarget = LerpCW20(FT * 10, self.FOVTarget, 0)
	end	
	
	if self.ReloadViewBobEnabled then
		if self.IsReloading and self.Cycle <= 0.9 then
			att = self.Owner:GetAttachment(1)
			
			if att then
				ang = ang * 1
				
				self.LerpBackSpeed = 1
				curang = LerpAngle(FT * 10, curang, (ang - att.Ang) * 0.1)
			else
				self.LerpBackSpeed = math.Approach(self.LerpBackSpeed, 10, FT * 50)
				curang = LerpAngle(FT * self.LerpBackSpeed, curang, Ang0)
			end
		else
			self.LerpBackSpeed = math.Approach(self.LerpBackSpeed, 10, FT * 50)
			curang = LerpAngle(FT * self.LerpBackSpeed, curang, Ang0)
		end
		
		local origAng = ang * 1
		RotateAroundAxis(ang, Right(origAng), curang.p * self.RVBPitchMod)
		RotateAroundAxis(ang, Up(origAng), curang.r * self.RVBYawMod)
		RotateAroundAxis(ang, Forward(origAng), curang.r * 0.15 * self.RVBRollMod)
	end
	
	local fovOverride = false
	
	if self.dt.State == CW_AIMING then
		if self.dt.M203Active and self.M203Chamber and not CustomizableWeaponry.grenadeTypes:canUseProperSights(self.Grenade40MM) then
			self.CurFOVMod = LerpCW20(FT * 10, self.CurFOVMod, 5)
		else
			local zoomAmount = self:getZoomAmount()
			local simpleTelescopics = not self:canUseComplexTelescopics()
			local shouldDelay = false
			
			if simpleTelescopics then
				if self.SimpleTelescopicsFOV then
					zoomAmount = self.SimpleTelescopicsFOV
					shouldDelay = true
				end
			end
			
			if self.DelayedZoom or shouldDelay then
				if CT > self.AimTime then
					if self.SnapZoom or (self.SimpleTelescopicsFOV and simpleTelescopics) then
						self.CurFOVMod = zoomAmount
						
						-- back-compat with old attachments
						-- new telescopics FOV sets the FOV instead of deducing it from the current FOV
						fovOverride = self.newTelescopicsFOV
					else
						self.CurFOVMod = LerpCW20(FT * 10, self.CurFOVMod, zoomAmount)
					end
				else
					self.CurFOVMod = LerpCW20(FT * 10, self.CurFOVMod, 0)
				end
			else
				if self.SnapZoom or (self.SimpleTelescopicsFOV and simpleTelescopics) then
					self.CurFOVMod = zoomAmount
				else
					self.CurFOVMod = LerpCW20(FT * 10, self.CurFOVMod, zoomAmount)
				end
			end
		end
	else
		self.CurFOVMod = LerpCW20(FT * 10, self.CurFOVMod, 0)
	end
	
	if self.holdingBreath then
		self.BreathFOVModifier = math.Approach(self.BreathFOVModifier, 7, FT * 12)
	else
		self.BreathFOVModifier = math.Approach(self.BreathFOVModifier, 0, FT * 10)
	end
	
	if self.SimpleTelescopicsFOV and fovOverride then
		fov = self.SimpleTelescopicsFOV
	else
		fov = math.max(5, fov - self.CurFOVMod - self.BreathFOVModifier)
	end
	
	if self.Owner then
		if self.ViewbobEnabled then
			ws = self.Owner:GetWalkSpeed()
			vel = Length(GetVelocity(self.Owner))
			
			local intensity = 1
			
			if self:isPlayerProne() and vel >= self.BusyProneVelocity then
				intensity = 7
				cos1 = math.cos(CT * 6)
				cos2 = math.cos(CT * 7)
				curviewbob.p = cos1 * 0.1 * intensity
				curviewbob.y = cos2 * 0.2 * intensity
			else			
				if self.Owner:OnGround() and vel > ws * 0.3 then
					if vel < ws * 1.2 then
						cos1 = math.cos(CT * 15)
						cos2 = math.cos(CT * 12)
						curviewbob.p = cos1 * 0.15 * intensity
						curviewbob.y = cos2 * 0.1 * intensity
					else
						cos1 = math.cos(CT * 20)
						cos2 = math.cos(CT * 15)
						curviewbob.p = cos1 * 0.25 * intensity
						curviewbob.y = cos2 * 0.15 * intensity
					end
				else
					curviewbob = LerpAngle(FT * 10, curviewbob, Ang0)
				end
			end
		end
	end
	
	fov = fov - self.FOVTarget
	self.curFOV = fov
	
	self.curViewBob = curviewbob * self.ViewbobIntensity
	return pos, ang + self.curViewBob, fov
end

function SWEP:reduceBreathAmount(recoilMod, regenTime)
	recoilMod = recoilMod or 0.2
	regenTime = regenTime or self.BreathRegenDelay
	
	self.breathRegenWait = CurTime() + regenTime
	self.BreathLeft = math.Clamp(self.BreathLeft - self.Recoil * recoilMod * 0.25, 0, 1)
end

function SWEP:stopHoldingBreath(time, regenTime, recoilMod)
	if self.holdingBreath then
		time = time or self.BreathDelay
		regenTime = regenTime or self.BreathRegenDelay
		
		self.holdingBreath = false
		self.breathWait = CurTime() + time
		self:reduceBreathAmount(recoilMod) -- if we're aiming, reduce it by using the recoilMod variable passed on to us
		surface.PlaySound("ins2/focus_inhale.wav")
	else
		self.breathRegenWait = CurTime() + 0.2
	end
end

function SWEP.CreateMove(move)
	ply = LocalPlayer()
	wep = ply:GetActiveWeapon()
	
	if IsValid(wep) and wep.CW20Weapon then
		local FT = FrameTime()
		local CT = CurTime()
		
		local shouldFreeze = false
		local mouseSensitivityMod = wep:AdjustMouseSensitivity() -- we should ignore mouse sensitivity into account when adjusting via mouse movement
		
		-- make sure we're: 1) customizing; 2) are in the adjustment tab; 3) have an active attachment
		if wep.dt.State == CW_CUSTOMIZE then
			shouldFreeze = CustomizableWeaponry.callbacks.processCategory(wep, "shouldFreezeView", move:GetMouseX() / mouseSensitivityMod)
			local canAdjustAttachment = false
			
			if type(shouldFreeze) == "boolean" then
				canAdjustAttachment = not shouldFreeze
			else
				canAdjustAttachment = true
			end
			
			if canAdjustAttachment then
				canAdjustAttachment = wep.CustomizationTab == CustomizableWeaponry.interactionMenu.TAB_ATTACHMENT_ADJUSTMENT and CustomizableWeaponry.sightAdjustment:getCurrentAttachment() and ply:KeyDown(IN_ATTACK)
			end
			
			if canAdjustAttachment then
				ply._holdAngles = ply._holdAngles or ply:EyeAngles()
					
				move:SetViewAngles(ply._holdAngles) -- prevent moving of the view area while adjusting attachment position
				CustomizableWeaponry.sightAdjustment:adjust(wep, move:GetMouseX() * 0.001 / mouseSensitivityMod)
				return
			else
				if not shouldFreeze then
					ply._holdAngles = nil
				end
			end
		end
				
		if shouldFreeze == false then
			ply._holdAngles = nil
		elseif shouldFreeze == true then
			ply._holdAngles = ply._holdAngles or ply:EyeAngles()
				
			move:SetViewAngles(ply._holdAngles) -- prevent moving of the view area while adjusting attachment position
			return
		end
		
		if wep.freeAimOn then
			wep.mouseX = move:GetMouseX()
			wep.mouseY = move:GetMouseY()
			
			wep.mouseActive = wep.mouseX ~= 0 or wep.mouseY ~= 0
		end
		
		local vel = ply:GetVelocity():Length()
		local aiming = wep.dt.State == CW_AIMING
		
		if wep.AimBreathingEnabled then
			if wep.holdingBreath then
				if vel > wep.BreathHoldVelocityMinimum and CT > wep.breathReleaseWait then
					wep:stopHoldingBreath(nil, nil, 0)
					wep.noBreathHoldingUntilKeyRelease = true
				else
					wep.CurBreatheIntensity = math.Approach(wep.CurBreatheIntensity, 0, FT * wep.BreathIntensityDrainRate)
					
					if CT > wep.breathReleaseWait then
						wep.BreathLeft = math.Approach(wep.BreathLeft, 0, FT * wep.BreathDrainRate)
					end
					
					if wep.BreathLeft <= 0 then
						wep:stopHoldingBreath(nil, nil, 0)
						wep.noBreathHoldingUntilKeyRelease = true
					end
				end
			else
				if CT > wep.breathRegenWait then
					wep.BreathLeft = math.Approach(wep.BreathLeft, 1, FT * wep.BreathRegenRate)
				end
				
				if aiming then
					if wep.dt.BipodDeployed then
						wep.CurBreatheIntensity = math.Approach(wep.CurBreatheIntensity, wep.BreathIntensityOnBipod, FT * wep.BreathIntensitySwitchRate)
					elseif not wep.BipodInstalled and wep:CanRestWeapon(wep.WeaponRestHeightRequirement) then
						wep.CurBreatheIntensity = math.Approach(wep.CurBreatheIntensity, wep.BreathIntensityOnRest, FT * wep.BreathIntensitySwitchRate)
					else
						wep.CurBreatheIntensity = math.Approach(wep.CurBreatheIntensity, 1, FT * wep.BreathIntensityRegenRate)
					end
				else
					wep.CurBreatheIntensity = math.Approach(wep.CurBreatheIntensity, 1, FT * wep.BreathIntensityRegenRate)
				end
			end
		end
		
		if wep.dt and aiming and wep.AimBreathingEnabled then
			if wep.AimBreathingEnabled then
				if wep.Owner:KeyDown(IN_SPEED) then
					if CT > wep.breathWait then
						if not wep.noBreathHoldingUntilKeyRelease and vel < wep.BreathHoldVelocityMinimum then
							-- can only start holding breath if we have at least 50% of our breath
							if not wep.holdingBreath and wep.BreathLeft >= wep.MinimumBreathPercentage then
								wep.holdingBreath = true
								wep.breathReleaseWait = CT + 0.5
								surface.PlaySound("ins2/focus_exhale.wav")
							end
						end
					end
				else
					if CT > wep.breathReleaseWait then
						if wep.holdingBreath then
							wep:stopHoldingBreath(nil, nil, 0)
						end
						
						wep.noBreathHoldingUntilKeyRelease = false
					end
				end
			end
		
			ang = move:GetViewAngles()
			ang.p = ang.p - math.cos(CT * 1.25) * 0.003 * wep.AimBreathingIntensity * wep.CurBreatheIntensity
			
			move:SetViewAngles(ang)
		end
		
		if wep.dt.BipodDeployed and wep.DeployAngle then
			ang = move:GetViewAngles()
			
			local EA = ply:EyeAngles()
			dif = math.AngleDifference(EA.y, wep.DeployAngle.y)
			
			if dif >= wep.BipodAngleLimitYaw then
				ang.y = wep.DeployAngle.y + wep.BipodAngleLimitYaw
			elseif dif <= -wep.BipodAngleLimitYaw then
				ang.y = wep.DeployAngle.y - wep.BipodAngleLimitYaw
			end
			
			dif = math.AngleDifference(EA.p, wep.DeployAngle.p)
			
			if dif >= wep.BipodAngleLimitPitch then
				ang.p = wep.DeployAngle.p + wep.BipodAngleLimitPitch
			elseif dif <= -wep.BipodAngleLimitPitch then
				ang.p = wep.DeployAngle.p - wep.BipodAngleLimitPitch
			end

			move:SetViewAngles(ang)
		end
	end
end

hook.Add("CreateMove", "CW20 CreateMove", SWEP.CreateMove)

SWEP.sensitivityAimContribution = 0.2 -- how much of mouse sensitivity from the OverrideAimMouseSens are we going to contribute to reducing the mouse sensitivity when aiming?
SWEP.minSensitivity = 0.2
SWEP.maxSensitivity = 1

function SWEP:AdjustMouseSensitivity()
	local sensitivity = 1
	local mod = math.Clamp(self.OverallMouseSens, self.minSensitivity, self.maxSensitivity) -- not lower than 20% and not higher than 100% (in case someone uses atts that increase handling)
	local freeAimMod = 1
	
	if self.freeAimOn and not self.dt.BipodDeployed then
		local dist = math.abs(self:getFreeAimDotToCenter())
		
		local mouseImpendance = GetConVarNumber("cw_freeaim_center_mouse_impendance")
		freeAimMod = 1 - (mouseImpendance - mouseImpendance * dist)
	end
	
	if self.dt.State == CW_RUNNING then
		if self.RunMouseSensMod then
			return self.RunMouseSensMod * mod
		end
		
		sensitivity = sensitivity * mod
	elseif self.dt.State == CW_AIMING then
		-- if we're aiming and our aiming position is that of the sight we have installed - decrease our mouse sensitivity
		if (self.OverrideAimMouseSens and self.AimPos == self.ActualSightPos) and (self.dt.M203Active and CustomizableWeaponry.grenadeTypes:canUseProperSights(self.Grenade40MM) or not self.dt.M203Active) then
			--return self.OvearrideAimMouseSens * mod
			sensitivity = self.OverrideAimMouseSens - mod * self.sensitivityAimContribution
		else
			sensitivity = sensitivity * mod
		end
		
		--return math.Clamp(1 - self:getZoomAmount() / 100, 0.1, 1) * mod 
		sensitivity = sensitivity - self:getZoomAmount() / 100
	else
		sensitivity = sensitivity * mod
	end
	
	local spreadRel = 1
	
	if self.scaleSensitivityToSpread then
		spreadRel = math.max(1 - self.HandlingMouseSensitivityRelation, 1 - (math.min(1, self.AddSpread / self.MaxSpreadInc) * self.HandlingMouseSensitivityRelation * (1 - mod) * self.HandlingMouseSensitivityMultiplier))
	end
	
	sensitivity = sensitivity * freeAimMod * spreadRel
	
	return math.Clamp(sensitivity, self.minSensitivity * spreadRel, self.maxSensitivity) --1 * self.OverallMouseSens
end


================================================
FILE: cw2/lua/weapons/cw_base/cl_cvars.lua
================================================
CreateClientConVar("cw_blur_reload", 0, true, true) -- reload blur
CreateClientConVar("cw_blur_customize", 0, true, true) -- customization menu blur
CreateClientConVar("cw_blur_aim_telescopic", 0, true, true)
CreateClientConVar("cw_simple_telescopics", 0, true, true) -- whether to use a scope overlay rather than RT-based scopes; used either for personal preferences or in case it's bugged for people
CreateClientConVar("cw_crosshair", 1, true, true)
CreateClientConVar("cw_customhud", 0, true, true)
CreateClientConVar("cw_customhud_ammo", 0, true, true)
CreateClientConVar("cw_laser_quality", 1, true, true)
CreateClientConVar("cw_laser_blur", 1, true, true)
CreateClientConVar("cw_alternative_vm_pos", 0, true, true)
CreateClientConVar("cw_freeaim", 0, true, true)
CreateClientConVar("cw_freeaim_autocenter", 0, true, true)
CreateClientConVar("cw_freeaim_autocenter_aim", 0, true, true)
CreateClientConVar("cw_freeaim_lazyaim", 0, true, true)

CreateClientConVar("cw_freeaim_yawlimit", 20, true, true)
CreateClientConVar("cw_freeaim_pitchlimit", 10, true, true)

CreateClientConVar("cw_freeaim_autocenter_time", 0.65, true, true)

CreateClientConVar("cw_freeaim_center_mouse_impendance", 0.7, true, true)

CreateClientConVar("cw_rt_scope_quality", 2, true, true)


================================================
FILE: cw2/lua/weapons/cw_base/cl_hooks.lua
================================================
local function CW20_RenderScene()
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()
	
	if IsValid(wep) and wep.CW20Weapon then
		-- this is the weapon's render target func
		if wep.RenderTargetFunc then
			wep:RenderTargetFunc()
		end
		
		-- this is some attachment's render target func
		if wep.renderTargetFunc then
			wep:renderTargetFunc()
		end
		
		-- ...amazing, isn't it?
	end
end

hook.Add("RenderScene", "CW20_RenderScene", CW20_RenderScene)

local function CW20_PostDrawViewModel()
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()
	
	if not IsValid(wep) or not wep.CW20Weapon then
		return
	end
	
	render.SetBlend(1)
	
	wep:processBlur()
	wep:performViewmodelMovement()
	wep:drawViewModel()
	wep:drawAttachmentsPost()
end

hook.Add("PostDrawViewModel", "CW20_PostDrawViewModel", CW20_PostDrawViewModel)

local function CW20_RenderScreenspaceEffects()
	local ply = LocalPlayer()
	
	-- apply the smoke screen when in a smoke grenade area
	if ply.CW_SmokeScreenIntensity then
		surface.SetDrawColor(100, 100, 100, 255 * ply.CW_SmokeScreenIntensity)
		surface.DrawRect(-1, -1, ScrW() + 2, ScrH() + 2)
	end
	
	-- reset it, no loops or any other dumb shit required this way
	ply.CW_SmokeScreenIntensity = nil
	
	local curTime = CurTime()
	local frameTime = FrameTime()
	
	if curTime > ply.cwFlashbangDuration then
		ply.cwFlashbangIntensity = math.Approach(ply.cwFlashbangIntensity, 0, frameTime)
	end
	
	ply.cwFlashbangDisplayIntensity = math.Approach(ply.cwFlashbangDisplayIntensity, ply.cwFlashbangIntensity, frameTime * 15)
	
	if curTime > ply.cwFlashDuration then
		ply.cwFlashIntensity = math.Approach(ply.cwFlashIntensity, 0, frameTime)
	end
	
	if ply.cwFlashbangDisplayIntensity > 0 then
		DrawMotionBlur(0.01 * (1 - ply.cwFlashbangDisplayIntensity), ply.cwFlashbangDisplayIntensity, 0)
		
		surface.SetDrawColor(255, 255, 255, 255 * ply.cwFlashIntensity * ply.cwFlashbangDisplayIntensity)
		surface.DrawRect(-1, -1, ScrW() + 2, ScrH() + 2)
	end
end

hook.Add("RenderScreenspaceEffects", "CW20_RenderScreenspaceEffects", CW20_RenderScreenspaceEffects)

-- gotta do the sound logic for the client in a different hook, since the Think hook on the weapon acts really fucking weird and is disabled for like a second on the second weapon deploy :/
local function CW20_Think()
	local ply = LocalPlayer()
	
	if ply:Alive() then
		local wep = ply:GetActiveWeapon()
		
		if IsValid(wep) and wep.CW20Weapon then
			if wep.CurSoundTable then
				local t = wep.CurSoundTable[wep.CurSoundEntry]
				local CT = UnPredictedCurTime()
				
				if CT >= wep.SoundTime + t.time / wep.SoundSpeed then
					if t.sound and t.sound ~= "" then
						wep:EmitSound(t.sound, 70, 100)
					end
					
					if t.callback then
						t.callback(wep)
					end
					
					if wep.CurSoundTable[wep.CurSoundEntry + 1] then
						wep.CurSoundEntry = wep.CurSoundEntry + 1
					else
						wep.CurSoundTable = nil
						wep.CurSoundEntry = nil
						wep.SoundTime = nil
					end
				end
			end
		end
	end
end

hook.Add("Think", "CW20_Think", CW20_Think)

local function CW20_Grenade_InitPostEntity()
	local ply = LocalPlayer()
	ply.cwFlashbangDuration = 0
	ply.cwFlashbangIntensity = 0
	ply.cwFlashbangDisplayIntensity = 0
	ply.cwFlashDuration = 0
	ply.cwFlashIntensity = 0
end

hook.Add("InitPostEntity", "CW20_Grenade_InitPostEntity", CW20_Grenade_InitPostEntity)


================================================
FILE: cw2/lua/weapons/cw_base/cl_hud.lua
================================================
surface.CreateFont("CW_HUD72", {font = "Prototype", size = 72, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_HUD60", {font = "Prototype", size = 60, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_HUD52", {font = "Prototype", size = 52, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_HUD48", {font = "Prototype", size = 48, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_HUD40", {font = "Prototype", size = 40, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_HUD38", {font = "Prototype", size = 38, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_HUD36", {font = "Prototype", size = 36, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_HUD32", {font = "Prototype", size = 32, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_HUD28", {font = "Prototype", size = 28, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_HUD24", {font = "Prototype", size = 24, weight = 500, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_HUD22", {font = "Prototype", size = 22, weight = 500, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_HUD20", {font = "Prototype", size = 20, weight = 500, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_HUD16", {font = "Prototype", size = 16, weight = 500, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_HUD14", {font = "Prototype", size = 14, weight = 500, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_HUD12", {font = "Prototype", size = 12, weight = 500, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_KillIcons", {font = "csd", size = ScreenScale(20), weight = 500, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_SelectIcons", {font = "csd", size = ScreenScale(60), weight = 500, blursize = 0, antialias = true, shadow = false})

surface.CreateFont("CW_KillIcons2", {font = "HalfLife2", size = ScreenScale(30), weight = 500, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("CW_SelectIcons2", {font = "HalfLife2", size = ScreenScale(60), weight = 500, blursize = 0, antialias = true, shadow = false})

local Deploy, UnDeploy = surface.GetTextureID("cw2/gui/bipod_deploy"), surface.GetTextureID("cw2/gui/bipod_undeploy")
local deployedOnObject = surface.GetTextureID("cw2/gui/deployonobject")
local scopeTemplate = surface.GetTextureID("cw2/gui/scope_template")

SWEP.CrossAmount = 0
SWEP.CrossAlpha = 255
SWEP.FadeAlpha = 0
SWEP.AimTime = 0

local ClumpSpread = surface.GetTextureID("cw2/gui/clumpspread_ring")
local Bullet = surface.GetTextureID("cw2/gui/bullet")
local GLCrosshair = surface.GetTextureID("cw2/gui/crosshair_gl")
local Vignette = surface.GetTextureID("cw2/effects/vignette")

local White, Black = Color(255, 255, 255, 255), Color(0, 0, 0, 255)
local x, y, x2, y2, lp, size, FT, CT, tr, x3, x4, y3, y4, UCT, sc1, sc2
local td = {}

local surface = surface
local math = math
local draw = draw
local dst = draw.SimpleText

SWEP.HUD_HealthTextColor = Color(255, 255, 255, 255)
SWEP.HUD_MagTextColor = Color(255, 255, 255, 255)
SWEP.HUD_ReserveTextColor = Color(255, 255, 255, 255)
SWEP.HUD_MagText = "MAG: "
SWEP.HUD_BreathAlpha = 1

function draw.ShadowText(text, font, x, y, colortext, colorshadow, dist, xalign, yalign)
	dst(text, font, x + dist, y + dist, colorshadow, xalign, yalign)
	dst(text, font, x, y, colortext, xalign, yalign)
end

-- pre-define strings to not generate them every frame and make life unbearable for gc
local cwhud24 = "CW_HUD24"
local cwhud22 = "CW_HUD22"
local cwhud20 = "CW_HUD20"
local cwhud16 =	"CW_HUD16"
local cwhud14 = "CW_HUD14"


function SWEP:crosshairVisible()
	-- not visible if we're aiming
	if self.dt.State == CW_AIMING and self.FadeCrosshairOnAim then
		return false
	end
	
	-- or are in an inactive state (action in progress/running)
	if self.InactiveWeaponStates[self.dt.State] then
		return false
	end

	-- or have safety turned on
	if self.dt.Safe then
		return false
	end
	
	-- or are in a vehicle
	if self.Owner:InVehicle() then
		return false 
	end
	
	-- or are near a wall
	if self.NearWall then
		return false
	end
	
	-- or are reloading the weapon
	if (self.IsReloading or self.IsFiddlingWithSuppressor) and self.Cycle <= 0.9 then
		return false
	end
	
	-- or are reloading the M203
	if self.reloadingM203 then
		return false
	end

	return true
end

function SWEP:drawClumpSpread(x, y, spread, alpha)
	if not spread then
		return
	end
	
	local size = math.ceil(spread * 2500 * self.hudScaler)
	surface.SetDrawColor(0, 0, 0, alpha)
	surface.SetTexture(ClumpSpread)
	surface.DrawTexturedRect(x - size * 0.5 - 1, y - size * 0.5 - 1, size + 2, size + 2)
			
	surface.SetDrawColor(255, 255, 255, alpha)
	surface.DrawTexturedRect(x - size * 0.5, y - size * 0.5, size, size)
end

SWEP.crossLength = 12
SWEP.crossThick = 3

function SWEP:getFragText(nadeCount)
	return nadeCount .. "x FRAG"
end

function SWEP:DrawHUD()
	FT, CT, x, y = FrameTime(), CurTime(), ScrW(), ScrH()
	UCT = UnPredictedCurTime()
	
	if self.dt.State == CW_AIMING then
		-- if we have M203 mode enabled, but have no rounds in it, OR if we don't have M203 enabled, let us draw the overlays
		if (self.dt.M203Active and (not self.M203Chamber or CustomizableWeaponry.grenadeTypes:canUseProperSights(self.Grenade40MM))) or not self.dt.M203Active then
			local simpleTelescopics = not self:canUseComplexTelescopics()
			
			local hasZoom = (self.SimpleTelescopicsFOV)
			local canUseSimpleTelescopics = (simpleTelescopics and hasZoom)
			
			if UCT > self.AimTime or self.InstantDissapearOnAim then
				if self.DrawBlackBarsOnAim or canUseSimpleTelescopics then
					surface.SetDrawColor(0, 0, 0, 255)
					
					if self.ScaleOverlayToScreenHeight then
						x3 = (x - y) / 2
						y3 = y / 2
						x4 = x - x3
						y4 = y - y3
						
						surface.DrawRect(0, 0, x3, y)
						surface.DrawRect(x4, 0, x3, y)
					else
						x3 = (x - 1024) / 2
						y3 = (y - 1024) / 2
						x4 = x - x3
						y4 = y - y3
						
						surface.DrawRect(0, 0, x3, y)
						surface.DrawRect(x4, 0, x3, y)
						surface.DrawRect(0, 0, x, y3)
						surface.DrawRect(0, y4, x, y3)
					end
				end
			end
			
			if self.AimOverlay or canUseSimpleTelescopics then
				if UCT > self.AimTime or self.InstantDissapearOnAim then
					surface.SetDrawColor(255, 255, 255, 255)
					
					if canUseSimpleTelescopics then
						surface.SetTexture(scopeTemplate)
						surface.DrawTexturedRect(x * 0.5 - 512, y * 0.5 - 512, 1024, 1024)
					else
						surface.SetTexture(self.AimOverlay)
					end
					
					if self.StretchOverlayToScreen then
						if canUseSimpleTelescopics then
							for k, v in ipairs(self.ZoomTextures) do
								if v.color then
									surface.SetDrawColor(v.color)
								else
									surface.SetDrawColor(255, 255, 255, 255)
								end
								
								surface.SetTexture(v.tex)
								surface.DrawTexturedRect(v.offset[1], v.offset[2], x, y)
							end
						else
							surface.DrawTexturedRect(0, 0, x, y)
						end
						
					elseif self.ScaleOverlayToScreenHeight then
						if canUseSimpleTelescopics then
							for k, v in ipairs(self.ZoomTextures) do
								surface.SetTexture(v.tex)
								surface.DrawTexturedRect(x * 0.5 - y * 0.5 + v.offset[1], y * 0.5 - y * 0.5 + v.offset[2], y, y)
							end
						else
							surface.DrawTexturedRect(x * 0.5 - y * 0.5, y * 0.5 - y * 0.5, y, y)
						end
					else
						if canUseSimpleTelescopics then
							for k, v in ipairs(self.ZoomTextures) do
								local xSize, ySize = 1024, 1024
								
								if v.size then
									xSize, ySize = v.size[1], v.size[2]
								end
								
								
								if v.color then
									surface.SetDrawColor(v.color)
								else
									surface.SetDrawColor(255, 255, 255, 255)
								end
								
								surface.SetTexture(v.tex)
								surface.DrawTexturedRect(x * 0.5 - xSize * 0.5 + v.offset[1], y * 0.5 - ySize * 0.5 + v.offset[2], xSize, ySize)
							end
						else
							surface.DrawTexturedRect(x * 0.5 - 512, y * 0.5 - 512, 1024, 1024)
						end
					end
				end
			end
			
			if self.FadeDuringAiming or canUseSimpleTelescopics then
				if UCT < self.AimTime then
					self.FadeAlpha = math.Approach(self.FadeAlpha, 255, FT * 1500)
				else
					self.FadeAlpha = LerpCW20(FT * 10, self.FadeAlpha, 0)
				end
				
				surface.SetDrawColor(0, 0, 0, self.FadeAlpha)
				surface.DrawRect(0, 0, x, y)
			end
		end
	else
		self.FadeAlpha = 0
	end
	
	if not self.dt.BipodDeployed then 
		if self.BipodInstalled then
			if self:CanRestWeapon(self.BipodDeployHeightRequirement) then
				draw.ShadowText("[USE KEY]", cwhud24, x / 2, y / 2 + 150, White, Black, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				
				surface.SetTexture(Deploy)
				
				surface.SetDrawColor(0, 0, 0, 255)
				surface.DrawTexturedRect(x / 2 - 47, y / 2 + 176, 96, 96)
				
				surface.SetDrawColor(255, 255, 255, 255)
				surface.DrawTexturedRect(x / 2 - 48, y / 2 + 175, 96, 96)
			end
		else
			if self.dt.State == CW_AIMING then
				if self.CanRestOnObjects then
					if self:CanRestWeapon(self.WeaponRestHeightRequirement) then
						surface.SetTexture(deployedOnObject)
						
						surface.SetDrawColor(0, 0, 0, 255)
						surface.DrawTexturedRect(x / 2 - 47, y / 2 + 156, 96, 96)
						
						surface.SetDrawColor(255, 255, 255, 255)
						surface.DrawTexturedRect(x / 2 - 48, y / 2 + 155, 96, 96)
					end
				end
			end
		end
	else
		draw.ShadowText("[USE KEY]", cwhud24, x / 2, y / 2 + 100, White, Black, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			
		surface.SetTexture(UnDeploy)
			
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawTexturedRect(x / 2 - 47, y / 2 + 156, 96, 96)
			
		surface.SetDrawColor(255, 255, 255, 255)
		surface.DrawTexturedRect(x / 2 - 48, y / 2 + 155, 96, 96)
	end
	
	if self.AimBreathingEnabled then
		self.HUD_BreathAlpha = LerpCW20(FT * 10, self.HUD_BreathAlpha, (1 - self.BreathLeft))

		if self.BreathLeft < 1 then
			surface.SetDrawColor(0, 0, 0, 255 * self.HUD_BreathAlpha)
			surface.SetTexture(Vignette)
			surface.DrawTexturedRect(0, 0, x, y)
		end
		
		if self.dt.State == CW_AIMING then
			if self.Owner:GetVelocity():Length() < self.BreathHoldVelocityMinimum then
				local finalColorMain = White
				local finalColorSecondary = White
				
				if self.noBreathHoldingUntilKeyRelease then
					finalColorMain = self.HUDColors.deepRed
				end
				
				if not self.holdingBreath and self.BreathLeft < 0.5 then
					finalColorSecondary = self.HUDColors.red
				end
				
				draw.ShadowText(self:getKeyBind("+speed") .. " - steady aim", cwhud24, x / 2, y / 2 + 100, finalColorMain, Black, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				draw.ShadowText(math.Round(self.BreathLeft * 100) .. "%", cwhud24, x / 2, y / 2 + 120, finalColorSecondary, Black, 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end
		else
			if self.holdingBreath then
				self:stopHoldingBreath(nil, nil, 0)
			end
		end
	end
	
	local disableCrosshair, disableCustomHUD, disableTabDisplay = CustomizableWeaponry.callbacks.processCategory(self, "suppressHUDElements", customHUD)
	
	if not disableCrosshair then
		if self.CrosshairEnabled and GetConVarNumber("cw_crosshair") > 0 then
			lp = self.Owner:ShouldDrawLocalPlayer()
			
			if lp or self.freeAimOn then
				td.start = self.Owner:GetShootPos()
				td.endpos = td.start + (self.Owner:EyeAngles() + self.Owner:GetPunchAngle()):Forward() * 16384
				td.filter = self.Owner
				
				tr = util.TraceLine(td)
				
				x2 = tr.HitPos:ToScreen()
				x2, y2 = x2.x, x2.y
			else
				x2, y2 = math.Round(x * 0.5), math.Round(y * 0.5)
			end
			
			self.hudScaler = ScrH() / 1080 -- 1080 is the base resolution 
			
			if not self:crosshairVisible() then
				self.CrossAlpha = LerpCW20(FT * 15, self.CrossAlpha, 0)
			else
				self.CrossAlpha = LerpCW20(FT * 15, self.CrossAlpha, 255)
			end
			
			if self.dt.M203Active and self.M203Chamber then
				local curGrenade = CustomizableWeaponry.grenadeTypes:get(self.Grenade40MM)
				
				if self.dt.State == CW_AIMING then
					if not curGrenade or not curGrenade.clumpSpread then
						surface.SetTexture(GLCrosshair)
						surface.SetDrawColor(255, 255, 255, 255 - self.CrossAlpha)
						surface.DrawTexturedRect(x2 - 16, y2, 32, 32)
					end
				end
				
				if curGrenade and curGrenade.clumpSpread and self.M203Chamber then
					self:drawClumpSpread(x2, y2, curGrenade.clumpSpread, self.CrossAlpha * 0.35)
				end
			end
			
			self:drawClumpSpread(x2, y2, self.ClumpSpread, self.CrossAlpha)
			self.CrossAmount = LerpCW20(FT * 10, self.CrossAmount, (self.CurCone * 350) * (90 / (math.Clamp(GetConVarNumber("fov_desired"), 75, 90) - self.CurFOVMod)))
			local crossLengthBg = math.floor(self.crossLength * self.hudScaler)
			local crossOffsetBg = crossLengthBg + 1
			local crossLength = crossLengthBg - 2
			local crossOffset = crossLength + 2
			
			local crossThickBg = math.max(3, math.floor(self.crossThick * self.hudScaler))
			local crossThick = crossThickBg - 2
			
			local crossAmt = self.CrossAmount * self.hudScaler
			surface.SetDrawColor(0, 0, 0, self.CrossAlpha * 0.75) -- BLACK crosshair parts
			
			if self.CrosshairParts.left then
				surface.DrawRect(x2 - crossOffsetBg - crossAmt, y2 - 1, crossLengthBg, crossThickBg) -- left cross
			end
			
			if self.CrosshairParts.right then
				surface.DrawRect(x2 + crossThickBg + crossAmt, y2 - 1, crossLengthBg, crossThickBg) -- right cross
			end
			
			if self.CrosshairParts.upper then
				surface.DrawRect(x2 - 1, y2 - crossOffsetBg - crossAmt, crossThickBg, crossLengthBg) -- upper cross
			end
			
			if self.CrosshairParts.lower then
				surface.DrawRect(x2 - 1, y2 + crossThickBg + crossAmt, crossThickBg, crossLengthBg) -- lower cross
			end
			
			surface.SetDrawColor(255, 255, 255, self.CrossAlpha) -- WHITE crosshair parts
			
			if self.CrosshairParts.left then
				surface.DrawRect(x2 - crossOffset - crossAmt, y2, crossLength, crossThick) -- left cross
			end
			
			if self.CrosshairParts.right then
				surface.DrawRect(x2 + crossThickBg + 1 + crossAmt, y2, crossLength, crossThick) -- right cross
			end
			
			if self.CrosshairParts.upper then
				surface.DrawRect(x2, y2 - crossOffset - crossAmt, crossThick, crossLength) -- upper cross
			end
			
			if self.CrosshairParts.lower then
				surface.DrawRect(x2, y2 + crossThickBg + 1 + crossAmt, crossThick, crossLength) -- lower cross
			end
		end
	end
	
	if not disableCustomHUD then
		local customHUD = GetConVarNumber("cw_customhud") >= 1
		
		if not customHUD and GetConVarNumber("cw_customhud_ammo") <= 0 then
			if self.FireModeDisplayPos == "right" then
				sc1, sc2 = ScreenScale(35), ScreenScale(44)
				draw.ShadowText(self.FireModeDisplay, cwhud16, x - sc1 - self.BulletDisplay * 20, y - sc2 - 20, White, Black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
				
				if self.BulletDisplay and self.BulletDisplay > 0 then
					surface.SetDrawColor(0, 0, 0, 255)
					surface.SetTexture(Bullet)
					
					for i = 1, self.BulletDisplay do
						surface.DrawTexturedRect(x - sc1 - (i - 1) * 20 - 5, y - sc2 - 25, 16, 16)
					end
					
					surface.SetDrawColor(255, 255, 255, 255)
					
					for i = 1, self.BulletDisplay do
						surface.DrawTexturedRect(x - sc1 - (i - 1) * 20 - 6, y - sc2 - 26, 16, 16)
					end
				end
			elseif self.FireModeDisplayPos == "middle" then
				draw.ShadowText(self.FireModeDisplay, cwhud16, x * 0.5, y - 100, White, Black, 1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				
				local grenades = self.Owner:GetAmmoCount("Frag Grenades")
				
				-- only display the frag ammo count if we have any grenades in reserve
				if grenades > 0 then
					draw.ShadowText(self:getFragText(grenades), cwhud16, x * 0.5, y - 120, self.HUD_ReserveTextColor, self.HUDColors.black, 1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				end
				
				if self.BulletDisplay and self.BulletDisplay > 0 then
					surface.SetDrawColor(0, 0, 0, 255)
					surface.SetTexture(Bullet)
					
					for i = 1, self.BulletDisplay do
						surface.DrawTexturedRect(x * 0.5 - 20 * i + self.BulletDisplay * 10 + 1, y - 89, 16, 16)
					end
					
					surface.SetDrawColor(255, 255, 255, 255)
					
					for i = 1, self.BulletDisplay do
						surface.DrawTexturedRect(x * 0.5 - 20 * i + self.BulletDisplay * 10, y - 90, 16, 16)
					end
				end
			elseif self.FireModeDisplayPos == "left" then
				sc1, sc2 = ScreenScale(35), ScreenScale(44)
				draw.ShadowText(self.FireModeDisplay, cwhud16, sc1, y - sc2 - 20, White, Black, 1, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
				
				if self.BulletDisplay and self.BulletDisplay > 0 then
					surface.SetDrawColor(0, 0, 0, 255)
					surface.SetTexture(Bullet)
					
					surface.SetFont(cwhud16)
					local size = surface.GetTextSize(self.FireModeDisplay)
					
					for i = 1, self.BulletDisplay do
						surface.DrawTexturedRect(sc1 + (i - 1) * 20 + size + 15, y - sc2 - 25, 16, 16)
					end
					
					surface.SetDrawColor(255, 255, 255, 255)
					
					for i = 1, self.BulletDisplay do
						surface.DrawTexturedRect(sc1 + (i - 1) * 20 - 1 + size + 15, y - sc2 - 26, 16, 16)
					end
				end
			end
			
			if self.dt.M203Active then
				self.HUDColors.red.a = 255
				self.HUDColors.black.a = 255
				self.HUDColors.white.a = 255
				
				if not self.M203Chamber then
					draw.ShadowText("M203 EMPTY", cwhud24, x * 0.5, y - 170, self.HUDColors.red, self.HUDColors.black, 1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				else
					draw.ShadowText("M203 READY", cwhud24, x * 0.5, y - 170, self.HUDColors.white, self.HUDColors.black, 1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				end
				
				local curGrenade = CustomizableWeaponry.grenadeTypes.getGrenadeText(self)
				
				draw.ShadowText(self.Owner:GetAmmoCount("40MM") .. "x RESERVE", cwhud22, x * 0.5, y - 150, self.HUDColors.white, self.HUDColors.black, 1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				draw.ShadowText("TYPE" .. curGrenade, cwhud22, x * 0.5, y - 130, self.HUDColors.white, self.HUDColors.black, 1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end
		end
	
		if customHUD then
			self:drawCustomHUD()
		end
	end
	
	if not disableTabDisplay then
		if self.dt.State == CW_CUSTOMIZE then
			self:drawTabDisplay()
		end
		
		CustomizableWeaponry.callbacks.processCategory(self, "drawToHUD", customHUD)
	end
end


SWEP.HUDColors = {white = Color(219, 223, 210, 255),
red = Color(255, 150, 150, 255),
deepRed = Color(255, 110, 110, 255),
black = Color(0, 0, 0, 255),
green = Color(200, 255, 200, 255)}

local gradient = surface.GetTextureID("cw2/gui/gradient")

function SWEP:drawTabDisplay()
	local x, y = ScrW(), ScrH()

	local entryCount = #CustomizableWeaponry.interactionMenu.tabs
	local baseHeight = entryCount * 22 + 10
	surface.SetDrawColor(0, 0, 0, 200)
	surface.SetTexture(gradient)
	surface.DrawTexturedRectRotated(x - 245, y - 175 - baseHeight * 0.5, 300, baseHeight, 180)
			
	for k, v in ipairs(CustomizableWeaponry.interactionMenu.tabs) do
		local clr
		
		if self.CustomizationTab == v.id then
			clr = self.HUDColors.green
		else
			clr = self.HUDColors.white
		end
		
		draw.ShadowText(self:getKeyBind(v.switchToKey) .. " - " .. v.text, cwhud24, x - 100, y - 202 - (k - 1) * 23, clr, self.HUDColors.black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_RIGHT)
	end
end

function SWEP:drawCustomHUD()
	local FT = FrameTime()
	
	local x, y = ScrW(), ScrH()
	
	self.HUDColors.white.a = 255
	self.HUDColors.black.a = 255
	local baseX, baseY = 100, y - 150
	
	surface.SetDrawColor(0, 0, 0, 200)
	surface.SetTexture(gradient)
	surface.DrawTexturedRect(baseX - 5, baseY - 15, 300, 90)
	
	-- draw the bottom-left part of the HUD; aka health and armor
	draw.ShadowText("HEALTH: ", cwhud24, baseX, baseY, self.HUD_HealthTextColor, self.HUDColors.black, 1, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	draw.ShadowText("ARMOR: ", cwhud24, baseX, baseY + 60, self.HUDColors.white, self.HUDColors.black, 1, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	
	local hp = self.Owner:Health()
	local arm = self.Owner:Armor()
	
	-- approach the health and armor values rather than snapping, so that the pips fill up gradually
	self.HUD_LastHealth = math.Approach(self.HUD_LastHealth, hp, FT * 100)
	self.HUD_LastArmor = math.Approach(self.HUD_LastArmor, arm, FT * 100)
	
	-- draw the health and armor text
	draw.ShadowText(hp .. "%", cwhud24, baseX + 100, baseY, self.HUD_HealthTextColor, self.HUDColors.black, 1, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	draw.ShadowText(arm .. "%", cwhud24, baseX + 100, baseY + 60, self.HUDColors.white, self.HUDColors.black, 1, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	
	local healthPips = math.Clamp(math.floor(self.HUD_LastHealth / 5), 1, 20)
	local armorPips = math.Clamp(math.floor(self.HUD_LastArmor / 5), 0, 20)
	
	-- black health and armor pips (to avoid unnecessary SetDrawColor calls)
	surface.SetDrawColor(0, 0, 0, 255)
	
	for i = 1, healthPips do
		surface.DrawRect(baseX + (i - 1) * 12 + 2, baseY + 16, 5, 10)
	end
	
	for i = 1, armorPips do
		surface.DrawRect(baseX + (i - 1) * 12 + 2, baseY + 36, 5, 10)
	end
	
	-- colored health pips
	for i = 1, healthPips do
		surface.SetDrawColor(240 - i * 10, i * 12.75, i * 4, 255)
		surface.DrawRect(baseX + (i - 1) * 12 + 1, baseY + 15, 5, 10)
	end
	
	-- colored armor pips
	for i = 1, armorPips do
		surface.SetDrawColor(0, 125 + i * 6.5, 200 + i * 2.75, 255)
		surface.DrawRect(baseX + (i - 1) * 12 + 1, baseY + 35, 5, 10)
	end
	
	-- draw the 2D variant of the custom HUD in case the 3D variant was disabled by the user
	if GetConVarNumber("cw_customhud_ammo") <= 0 then
		local baseXAMMO, baseYAMMO = x - 117, y - 150
		
		surface.SetDrawColor(0, 0, 0, 200)
		surface.SetTexture(gradient)
		surface.DrawTexturedRectRotated(baseXAMMO - 128, baseYAMMO + 30, 300, 90, 180)
		
		-- display the M203 section if we're in M203 mode
		if self.dt.M203Active then
			surface.DrawTexturedRectRotated(baseXAMMO - 128, baseYAMMO - 60, 300, 70, 180)
			
			if not self.M203Chamber then
				draw.ShadowText("M203 EMPTY", cwhud24, baseXAMMO + 15, baseY - 80, self.HUDColors.red, self.HUDColors.black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
			else
				draw.ShadowText("M203 READY", cwhud24, baseXAMMO + 15, baseY - 80, self.HUDColors.white, self.HUDColors.black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
			end
			
			local curGrenade = CustomizableWeaponry.grenadeTypes.getGrenadeText(self)
			
			draw.ShadowText(self.Owner:GetAmmoCount("40MM") .. "x RESERVE", cwhud22, baseXAMMO + 15, baseY - 60, self.HUDColors.white, self.HUDColors.black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
			
			draw.ShadowText("TYPE" .. curGrenade, cwhud22, baseXAMMO + 15, baseY - 40, self.HUDColors.white, self.HUDColors.black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
		end
	
		local mag = self:Clip1()
		local ammoCount, magCount, targetColor = self:getReserveAmmoText()
		
		if not targetColor then
			if ammoCount <= self.Primary.ClipSize then -- make the reserve text red if we only have 1 mag (or less) in reserve left
				self.HUD_ReserveTextColor = LerpColor(FT * 10, self.HUD_ReserveTextColor, self.HUDColors.deepRed)
			else
				self.HUD_ReserveTextColor = LerpColor(FT * 10, self.HUD_ReserveTextColor, White)
			end
		else
			self.HUD_ReserveTextColor = LerpColor(FT * 10, self.HUD_ReserveTextColor, targetColor)
		end
		
		local reloadProgress = self:getReloadProgress()
		
		-- if we're reloading or are low on ammo, make the text red
		if reloadProgress or mag <= self.Primary.ClipSize * 0.25 then
			self.HUD_MagTextColor = LerpColor(FT * 10, self.HUD_MagTextColor, self.HUDColors.red)
		else
			self.HUD_MagTextColor = LerpColor(FT * 10, self.HUD_MagTextColor, White)
		end
		
		-- display either the reload progress or the ammo in mag
		if reloadProgress then
			draw.ShadowText("RELOADING  " .. reloadProgress .. "%", "CW_HUD32", baseXAMMO + 15, baseYAMMO, self.HUD_MagTextColor, self.HUDColors.black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
		else
			draw.ShadowText(self.HUD_MagText .. self:getMagCapacity(), "CW_HUD32", baseXAMMO + 15, baseYAMMO, self.HUD_MagTextColor, self.HUDColors.black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
		end
		
		local grenades = self.Owner:GetAmmoCount("Frag Grenades")
		local ammoText = "RESERVE: " .. ammoCount
		
		-- display the amount of frag grenades only if we have some
		if grenades > 0 then
			surface.SetFont(cwhud24)
			
			local textSize = surface.GetTextSize(ammoText)
			
			draw.ShadowText(grenades .. "x FRAG, ", cwhud20, baseXAMMO - textSize + 15, baseYAMMO + 25, self.HUD_ReserveTextColor, self.HUDColors.black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
		end
		
		draw.ShadowText(ammoText, cwhud24, baseXAMMO + 15, baseYAMMO + 25, self.HUD_ReserveTextColor, self.HUDColors.black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
		draw.ShadowText(self.FireModeDisplay, cwhud22, baseXAMMO + 15, baseYAMMO + 45, White, Black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
		
		-- display the firemode section
		if self.BulletDisplay and self.BulletDisplay > 0 then
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(Bullet)
			
			surface.SetFont(cwhud24)
			local xSize = surface.GetTextSize(self.FireModeDisplay)
			
			-- draw the shadow of the bullets and the regular bullets in 2 separate loops, to do only (2 SetDrawColor) calls instead of (BulletDisplay * 2 SetDrawColor) calls
			for i = 1, self.BulletDisplay do
				surface.DrawTexturedRect(baseXAMMO - (i - 1) * 20 - xSize, baseYAMMO + 39, 16, 16)
			end
			
			surface.SetDrawColor(255, 255, 255, 255)
			
			for i = 1, self.BulletDisplay do
				surface.DrawTexturedRect(baseXAMMO - (i - 1) * 20 - 1 - xSize, baseYAMMO + 38, 16, 16)
			end
		end
		
		draw.ShadowText(self.Primary.Ammo, cwhud14, baseXAMMO + 15, baseYAMMO + 62, White, Black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
	end
end

function SWEP:DrawWeaponSelection(x, y, wide, tall, alpha)
	if self.SelectIcon then
		surface.SetDrawColor(255, 210, 0, 255)
		surface.SetTexture(self.SelectIcon)
		surface.DrawTexturedRect(x + tall * 0.2, y, tall, tall)
	else
		draw.SimpleText(self.IconLetter, self.SelectFont, x + wide / 2, y + tall * 0.2, Color(255, 210, 0, alpha), TEXT_ALIGN_CENTER)
	end
end


================================================
FILE: cw2/lua/weapons/cw_base/cl_model.lua
================================================
SWEP.BlendPos = Vector(0, 0, 0)
SWEP.BlendAng = Vector(0, 0, 0)
SWEP.OldDelta = Angle(0, 0, 0)
SWEP.AngleDelta = Angle(0, 0, 0)
SWEP.AngleDelta2 = Angle(0, 0, 0)
SWEP.AngDiff = Angle(0, 0, 0)
SWEP.BipodPos = Vector(0, 0, 0)
SWEP.BipodAng = Vector(0, 0, 0)
SWEP.RecoilPos = Vector(0, 0, 0)
SWEP.RecoilAng = Angle(0, 0, 0)
SWEP.RecoilPos2 = Vector(0, 0, 0)
SWEP.RecoilAng2 = Angle(0, 0, 0)
SWEP.RecoilPosDiff = Vector(0, 0, 0)
SWEP.RecoilAngDiff = Angle(0, 0, 0)
SWEP.GrenadePos = Vector(0, 0, -10)
SWEP.BipodMoveTime = 0
SWEP.BlurAmount = 0
SWEP.FireMove = 0
SWEP.ViewModelMovementScale = 1
SWEP.RecoilRestoreSpeed = 5
SWEP.Sequence = ""
SWEP.Cycle = 0
SWEP.NoStockShells = true
SWEP.NoStockMuzzle = true
SWEP.grenadeTime = 0
SWEP.HUD_3D2DAlpha = 255

-- TS means Telescopic Sight
SWEP.TSGlass = Material("cw2/attachments/lens/rt")

local Vec0, Ang0 = Vector(0, 0, 0), Angle(0, 0, 0)
local TargetPos, TargetAng, cos1, sin1, tan, ws, rs, mod, EA, delta, sin2, mul, vm, muz, muz2, tr, att, CT
local td = {}
local LerpVector, LerpAngle, Lerp = LerpVector, LerpAngle, Lerp

local reg = debug.getregistry()
local GetVelocity = reg.Entity.GetVelocity
local Length = reg.Vector.Length
local Right = reg.Angle.Right
local Up = reg.Angle.Up
local Forward = reg.Angle.Forward
local RotateAroundAxis = reg.Angle.RotateAroundAxis
local GetBonePosition = reg.Entity.GetBonePosition

-- since these are often-called functions (and somewhat expensive), we make local references to them to reduce the overhead as much as possible
local ManipulateBonePosition, ManipulateBoneAngles = reg.Entity.ManipulateBonePosition, reg.Entity.ManipulateBoneAngles

-- default GMod LerpVector/LerpAngle generate a new vector/angle object every time they're called (wtf garry ???), so I wrote my own to keep garbage generation low
function LerpVectorCW20(delta, start, finish)
	delta = delta > 1 and 1 or delta
	
	start.x = start.x + delta * (finish.x - start.x)
	start.y = start.y + delta * (finish.y - start.y)
	start.z = start.z + delta * (finish.z - start.z)
	
	return start
end

function LerpAngleCW20(delta, start, finish)
	delta = delta > 1 and 1 or delta

	start.p = start.p + delta * (finish.p - start.p)
	start.y = start.y + delta * (finish.y - start.y)
	start.r = start.r + delta * (finish.r - start.r)
	
	return start
end

function SWEP:initRenderTarget(size)
	self.ScopeRT = GetRenderTarget("cw2_scope_rt_" .. size, size, size, false)
end

function SWEP:getRenderTargetSize()
	return self.ScopeRT:GetMappingWidth()
end

function SWEP:GetTracerOrigin()
	if self.dt.State == CW_AIMING and self.SimulateCenterMuzzle then
		return self.CenterPos
	end
	
	return self:getMuzzlePosition().Pos
end

function SWEP:FireAnimationEvent(pos, ang, event, name)
	if event == 5003 then -- disable default muzzleflashes in third person
		return true
	end
end

function SWEP:getAnimSeek()
	return self.CW_VM:GetCycle() * self.CW_VM:SequenceDuration()
end

function SWEP:CreateShell(sh)
	if self.Owner:ShouldDrawLocalPlayer() or self.NoShells then
		return
	end
	
	sh = self.Shell or sh
	vm = self.CW_VM
	
	att = vm:GetAttachment(2)
	
	if att then
		if self.ShellDelay then
			CustomizableWeaponry.actionSequence.new(self, self.ShellDelay, nil, function()
				att = vm:GetAttachment(2)
				
				if self.InvertShellEjectAngle then
					dir = -att.Ang:Forward()
				else
					dir = att.Ang:Forward()
				end
				
				if self.ShellPosOffset then
					att.Pos = att.Pos + (self.ShellPosOffset.x) * att.Ang:Right()
					att.Pos = att.Pos + (self.ShellPosOffset.y) * att.Ang:Forward()
					att.Pos = att.Pos + (self.ShellPosOffset.z) * att.Ang:Up()
				end
		
				CustomizableWeaponry.shells.make(self, att.Pos + dir * self.ShellOffsetMul, EyeAngles(), dir * 200, 0.6, 10)
			end)
		else
			att = vm:GetAttachment(2)
			
			if self.InvertShellEjectAngle then
				dir = -att.Ang:Forward()
			else
				dir = att.Ang:Forward()
			end
			
			if self.ShellPosOffset then
				att.Pos = att.Pos + (self.ShellPosOffset.x) * att.Ang:Right()
				att.Pos = att.Pos + (self.ShellPosOffset.y) * att.Ang:Forward()
				att.Pos = att.Pos + (self.ShellPosOffset.z) * att.Ang:Up()
			end
			
			CustomizableWeaponry.shells.make(self, att.Pos + dir * self.ShellOffsetMul, EyeAngles(), dir * 200, 0.6, 10)
		end
	end
end

function SWEP:offsetBoltBone()
	if self.DontMoveBoltOnHipFire and self.dt.State ~= CW_AIMING then
		return
	end
	
	self.CurBoltBonePos = self.BoltShootOffset * 1
	ManipulateBonePosition(self.CW_VM, self.BoltBoneID, self.CurBoltBonePos)
end

local Vec50 = Vector(-50, 0, 0)

function SWEP:offsetM203ArmBone(restore)
	if not self.M203ArmBone then
		self.M203ArmBone = self.AttachmentModelsVM.md_m203.ent:LookupBone("Bip01 L Clavicle")
	end
	
	if restore then
		ManipulateBonePosition(self.AttachmentModelsVM.md_m203.ent, self.M203ArmBone, Vec0)
	else
		ManipulateBonePosition(self.AttachmentModelsVM.md_m203.ent, self.M203ArmBone, Vec50)
	end
end

SWEP.minimalScale = Vector(0.01, 0.01, 0.01)
SWEP.maxScale = Vector(1, 1, 1)

function SWEP:offsetMagBone(restore)
	if not self.magBoneName then
		return
	end
	
	if not self.magBonesSetup then
		for i = 1, #self.magBoneName do
			self.magBoneList[i] = self.CW_VM:LookupBone(self.magBoneName[i])
		end
		
		self.magBonesSetup = true
	end
	
	local targetScale
	
	if restore then
		targetScale = self.maxScale
	else
		targetScale = self.minimalScale
	end
	
	for i = 1, #self.magBoneList do
		self.CW_VM:ManipulateBoneScale(self.magBoneList[i], targetScale)
	end
end

function SWEP:setBoltBonePosition(pos)
	self.CurBoltBonePos = pos
	ManipulateBonePosition(self.CW_VM, self.BoltBoneID, pos)
end

function SWEP:buildBoneTable()
	local vm = self.CW_VM
	
	for i = 0, vm:GetBoneCount() - 1 do
		local boneName = vm:GetBoneName(i)
		local bone
		
		if boneName then
			bone = vm:LookupBone(boneName)
		end
		
		-- save the bone indexes and bone names so that we don't have to get it again when we're offsetting them
		self.vmBones[i + 1] = {boneName = boneName, bone = bone, curPos = Vector(0, 0, 0), curAng = Angle(0, 0, 0), targetPos = Vector(0, 0, 0), targetAng = Angle(0, 0, 0)}
	end
end

function SWEP:setupBoneTable()
	self.vmBones = {}
	
	-- this sets up a table for things like bone position/angle manipulation
	-- we do everything in advance to avoid expensive function calls (such as LookupBone) later on
	self:buildBoneTable()
	
	self:setupBoltBone()
	
	if self.BaseArm then
		self.BaseArmBone = self.CW_VM:LookupBone(self.BaseArm)
	end
end

function SWEP:setupBoltBone(boltName)
	boltName = boltName or self.BoltBone
	
	if boltName then
		self.BoltBoneID = self.CW_VM:LookupBone(boltName)
		self.CurBoltBonePos = Vector(0, 0, 0)
	end
end

function SWEP:resetM203Anim()
	local vm = self.AttachmentModelsVM.md_m203.ent
	vm:ResetSequence(self.M203Anims.ready_to_idle)
	vm:SetCycle(0)
	
	self.curM203Anim = self.M203Anims.ready_to_idle
end

function SWEP:setM203Anim(animName, cycle, speed)
	cycle = cycle or 0
	speed = speed or 1
	
	local vm = self.AttachmentModelsVM.md_m203.ent
	vm:ResetSequence(animName)
	vm:SetCycle(cycle)
	vm:SetPlaybackRate(speed)
	
	self.curM203Anim = animName
end

function SWEP:offsetBones()
	local vm = self.CW_VM
	
	-- if the animation cycle is past reload/draw no offset time of bones, then it falls within the bone offset timeline
	local FT = FrameTime()
	
	if self.AttachmentModelsVM then
		local can = false
		local canModifyBones = self.AttachmentModelsVM.md_foregrip or self.AttachmentModelsVM.md_m203 or self.ForegripOverride
		
		local foregrip = (self.AttachmentModelsVM.md_foregrip and self.AttachmentModelsVM.md_foregrip.active)
		local m203 = (self.AttachmentModelsVM.md_m203 and self.AttachmentModelsVM.md_m203.active)
		local otherOffsets = foregrip or m203
		
		if foregrip or self.ForegripOverride then
			if self.Sequence == self.Animations.reload or self.Sequence == self.Animations.reload_empty or self.Sequence == self.Animations.reload then
				if self.wasEmpty then 
					if self.Cycle >= self.ForeGripOffsetCycle_Reload_Empty then
						can = true
					end
				else
					if self.Cycle >= self.ForeGripOffsetCycle_Reload then
						can = true
					end
				end
			elseif self.Sequence == self.Animations.reload_start then
				if self.Cycle >= self.ForeGripOffsetCycle_ReloadStart then
					can = true
				end
			elseif self.Sequence == self.Animations.insert then
				if self.Cycle >= self.ForeGripOffsetCycle_ReloadInsert then
					can = true
				end
			elseif self.Sequence == self.Animations.reload_end then
				if self.Cycle >= self.ForeGripOffsetCycle_ReloadEnd then
					can = true
				end
			elseif self.Sequence == self.Animations.draw then
				if self.Cycle >= self.ForeGripOffsetCycle_Draw then
					can = true
				end
			else
				can = true
			end
		end
		
		if m203 and not self.dt.M203Active then
			if self.Sequence == self.Animations.reload or self.Sequence == self.Animations.reload_empty then
				if self.wasEmpty then 
					if self.Cycle >= self.M203OffsetCycle_Reload_Empty then
						can = true
					end
				else
					if self.Cycle >= self.M203OffsetCycle_Reload then
						can = true
					end
				end
			elseif self.Sequence == self.Animations.draw then
				if self.Cycle >= self.M203OffsetCycle_Draw then
					can = true
				end
			elseif self.Sequence == self.Animations.reload_start then
				if self.Cycle >= self.M203OffsetCycle_ReloadStart then
					can = true
				end
			elseif self.Sequence == self.Animations.insert then
				if self.Cycle >= self.M203OffsetCycle_ReloadInsert then
					can = true
				end
			elseif self.Sequence == self.Animations.reload_end then
				if self.Cycle >= self.M203OffsetCycle_ReloadEnd then
					can = true
				end
			elseif self.Sequence == self.Animations.draw then
				if self.Cycle >= self.ForeGripOffsetCycle_Draw then
					can = true
				end
			else
				can = true
			end
		end
		
		local targetTbl = false
		
		-- select the desired offset table
		if can then
			local fallback = true
			
			if self.ForegripOverride then
				if self.ForegripOverridePos then
					local desiredTarget = self.ForegripOverridePos[self.ForegripParent]
					
					if desiredTarget then
						if not desiredTarget.weakOverride or (desiredTarget.weakOverride and not otherOffsets) then
							targetTbl = desiredTarget
							canModifyBones = true
						else
							fallback = true
						end
					else
						canModifyBones = false
					end
				end
			end
			
			if fallback then
				if foregrip then
					targetTbl = self.ForeGripHoldPos
				elseif m203 then
					targetTbl = self.M203HoldPos
				end
			end
		end
		
		if not targetTbl then
			can = false
		end
			
		if m203 then
			if self.dt.M203Active or UnPredictedCurTime() < self.M203Time then
				self:offsetM203ArmBone(true)
				ManipulateBonePosition(vm, self.BaseArmBone, self.BaseArmBoneOffset)
				
				return
			else
				if self.curM203Anim ~= self.M203Anims.ready_to_idle then
					self:resetM203Anim()
				end
				
				self:offsetM203ArmBone(false)
			end
		end
		
		if self.canOffsetMagBone then
			self:offsetMagBone(false)
		end
		
		if canModifyBones then
			for k, v in pairs(self.vmBones) do
				if can then
					local index = targetTbl[v.boneName]

					v.curPos = LerpVectorCW20(FT * 15, v.curPos, (index and index.pos or Vec0))
					v.curAng = LerpAngleCW20(FT * 15, v.curAng, (index and index.angle or Ang0))
				else
					v.curPos = LerpVectorCW20(FT * 15, v.curPos, Vec0)
					v.curAng = LerpAngleCW20(FT * 15, v.curAng, Ang0)
				end
				
				ManipulateBonePosition(vm, v.bone, v.curPos)
				ManipulateBoneAngles(vm, v.bone, v.curAng)
			end
		end
	end
	
	if self.BoltBoneID then
		local can = true
		local recoverySpeed = self.BoltBonePositionRecoverySpeed
		
		if self.BoltShootOffset then
			if self.HoldBoltWhileEmpty then
				if self:Clip1() == 0 then
					if self.Sequence ~= self.EmptyBoltHoldAnimExclusion then
						if (self.IsReloading and self.Cycle > 0.98) or not self.IsReloading then
							can = false
							self.CurBoltBonePos = self.BoltShootOffset * 1
						end
					end
				end
			end
			
			ManipulateBonePosition(vm, self.BoltBoneID, self.CurBoltBonePos)
		end
		
		if self.OffsetBoltDuringNonEmptyReload then
			if self.IsReloading and self.Cycle <= self.StopReloadBoneOffset and self:Clip1() > 0 then
				self.CurBoltBonePos = math.ApproachVector(self.CurBoltBonePos, self.BoltReloadOffset, FT * self.ReloadBoltBonePositionMoveSpeed)
				can = false
			else
				if can then
					recoverySpeed = self.ReloadBoltBonePositionRecoverySpeed
				end
			end
			
			ManipulateBonePosition(vm, self.BoltBoneID, self.CurBoltBonePos)
		end

		if can then
			self.CurBoltBonePos = math.ApproachVector(self.CurBoltBonePos, Vec0, FT * recoverySpeed)
		end
	end
end

function SWEP:CreateMuzzle()
	if self.Owner:ShouldDrawLocalPlayer() then
		return
	end

	vm = self.CW_VM
	
	if IsValid(vm) then
		vm:StopParticles()

		muz = vm:LookupAttachment(self.MuzzleAttachmentName)
		
		if muz then
			muz2 = vm:GetAttachment(muz)
			
			if muz2 then
				EA = EyeAngles()
				
				local pos = muz2.Pos
				local ang = EA
				
				if self.MuzzlePosMod then
					pos = muz2.Pos + EA:Right() * self.MuzzlePosMod.x + EA:Forward() * self.MuzzlePosMod.y + EA:Up() * self.MuzzlePosMod.z
				end
				
				if self.dt.Suppressed then
					if self.MuzzleEffectSupp then
						if not self.NoSilMuz then
							if (self.dt.State == CW_AIMING and self.SimulateCenterMuzzle) or (self.dt.State == CW_AIMING and self:canUseSimpleTelescopics()) then
								ParticleEffect(self.MuzzleEffectSupp, pos + self.Owner:GetVelocity() * 0.03 + EA:Forward() * 70 - EA:Up() * 3, EA, vm)
							else
								if self.PosBasedMuz then
									ParticleEffect(self.MuzzleEffectSupp, pos + self.Owner:GetVelocity() * 0.03, EA, vm) -- using velocity to add to the position 'simulates' attaching it to a control point
								else
									ParticleEffectAttach(self.MuzzleEffectSupp, PATTACH_POINT_FOLLOW, vm, muz)
								end
							end
						end
					end
				else
					if self.MuzzleEffect then
						if (self.dt.State == CW_AIMING and self.SimulateCenterMuzzle) or (self.dt.State == CW_AIMING and self:canUseSimpleTelescopics()) then
							ParticleEffect(self.MuzzleEffect, pos + self.Owner:GetVelocity() * 0.03 + EA:Forward() * 70 - EA:Up() * 3, EA, vm)
						else
							if self.PosBasedMuz then
								ParticleEffect(self.MuzzleEffect, pos + self.Owner:GetVelocity() * 0.03, EA, vm)
							else
								ParticleEffectAttach(self.MuzzleEffect, PATTACH_POINT_FOLLOW, vm, muz)
							end
						end
					end
					
					dlight = DynamicLight(self:EntIndex())
					
					dlight.r = 255 
					dlight.g = 218
					dlight.b = 74
					dlight.Brightness = 4
					dlight.Pos = pos + self.Owner:GetAimVector() * 3
					dlight.Size = 96
					dlight.Decay = 128
					dlight.DieTime = CurTime() + FrameTime()
				end
			end
		end
	end
end

function SWEP:getMuzzleModel()
	return self.WMEnt and self.WMEnt or self
end

function SWEP:getWorldAttachments() -- used for third person
	return self.WorldMuzzleAttachmentID, self.WorldShellEjectionAttachmentID
end

SWEP.shellBoundBox = {Vector(-0.5, -0.15, -0.5), Vector(0.5, 0.15, 0.5)}

function CW_MakeFakeShell(ent, shell, pos, ang, vel, time, removetime, shellscale)
	if not shell or not pos or not ang then
		return
	end

	local t = ent._shellTable
	
	if not t then
		return
	end
	
	vel = vel or Vector(0, 0, -100)
	vel = vel + VectorRand() * 5
	time = time or 0.5
	removetime = removetime or 5
	shellscale = shellscale or 1
	
	local ent = ClientsideModel(t.m, RENDERGROUP_BOTH) 
	ent:SetPos(pos)
	ent:PhysicsInitBox(ent.shellBoundBox[1], ent.shellBoundBox[2])
	ent:SetAngles(ang)
	ent:SetModelScale(shellscale, 0)
	ent:SetMoveType(MOVETYPE_VPHYSICS) 
	ent:SetSolid(SOLID_VPHYSICS) 
	ent:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	
	local phys = ent:GetPhysicsObject()
	phys:SetMaterial("gmod_silent")
	phys:SetMass(10)
	phys:SetVelocity(vel)

	timer.Simple(time, function()
		if t.s then
			ent:EmitSound(table.Random(t.s), 35, 100)
		end
	end)
	
	SafeRemoveEntityDelayed(ent, removetime)
end

function SWEP:createManagedCModel(...)
	local ent = ClientsideModel(...)
	CustomizableWeaponry.cmodels:add(ent, self)
	
	return ent
end

function SWEP:_setupAttachmentModel(data)
	data.origPos = data.pos
	data.origAng = data.angle
	
	-- create the attachment model
	data.ent = self:createManagedCModel(data.model, RENDERGROUP_BOTH)
	data.ent:SetNoDraw(true)
	
	-- make it active if it's supposed to be active, or not, if nothing is defined
	data.active = data.active or false
	
	-- scale the model if there is a scaling vector
	-- keep in mind that I scale it once upon creation, in order to not call Matrix and EnableMatrix over and over again each frame
	if data.size then
		data.matrix = Matrix()
		
		data.matrix:Scale(data.size)
		data.ent:EnableMatrix("RenderMultiply", data.matrix)
	end
	
	-- get the bone ID in advance so that we don't have to look it up every frame for every attachment that's active on the weapon
	data._bone = self.CW_VM:LookupBone(data.bone)
	
	-- set bodygroups in case they are defined
	if data.bodygroups then
		for main, sec in pairs(data.bodygroups) do
			data.ent:SetBodygroup(main, sec)
		end
	end
	
	data.ent:SetupBones()
end

function SWEP:setupAttachmentModels()
	if self.AttachmentModelsVM then
		for k, v in pairs(self.AttachmentModelsVM) do
			if v.models then
				for key, data in ipairs(v.models) do
					self:_setupAttachmentModel(data)
				end
			else
				self:_setupAttachmentModel(v)
			end
		end
	end
end

SWEP.ApproachSpeed = 10
SWEP.RunTime = 0
local SP = game.SinglePlayer() 
local PosMod, AngMod = Vector(0, 0, 0), Vector(0, 0, 0)
local CurPosMod, CurAngMod = Vector(0, 0, 0), Vector(0, 0, 0)
local veldepend = {pitch = 0, yaw = 0, roll = 0}
local mod2 = 0
local EA2

function SWEP:scaleMovement(val, mod)
	return val * self.ViewModelMovementScale * mod
end

function SWEP:createCustomVM(mdl)
	self.CW_VM = self:createManagedCModel(mdl, RENDERGROUP_BOTH)
	self.CW_VM:SetNoDraw(true)
	self.CW_VM:SetupBones()
	
	if self.ViewModelFlip then
		local mtr = Matrix()
		mtr:Scale(Vector(1, -1, 1))
		
		self.CW_VM:EnableMatrix("RenderMultiply", mtr)
	end
end

function SWEP:createGrenadeModel()
	self.CW_GREN = self:createManagedCModel("models/weapons/v_cw_fraggrenade.mdl", RENDERGROUP_BOTH)
	self.CW_GREN:SetNoDraw(true)
	self.CW_GREN:SetupBones()
end

function SWEP:PreDrawViewModel()
	-- this will make the 'default' viewmodel invisible, since we're using a custom VM entity
	--render.SetBlend(0)
end

-- this draws the custom viewmodel
function SWEP:drawViewModel()
	if not self.CW_VM then
		return
	end
	
	--if self.offsetFunc then
		--self.offsetFunc(self) -- :)
	--end
		
	self:offsetBones()
	
	local FT = FrameTime()
	
	self.LuaVMRecoilIntensity = math.Approach(self.LuaVMRecoilIntensity, 0, FT * 10 * self.LuaVMRecoilLowerSpeed)
	self.LuaVMRecoilLowerSpeed = math.Approach(self.LuaVMRecoilLowerSpeed, 1, FT * 2)
	
	self:applyOffsetToVM()
	self:_drawViewModel()
	self:drawGrenade()
end

function SWEP:drawGrenade()
	if CurTime() > self.grenadeTime then
		return
	end
	
	if self.CW_GREN:GetCycle() >= 0.98 then
		return
	end
	
	local pos, ang = EyePos(), EyeAngles()
	
	self.GrenadePos.z = LerpCW20(FrameTime() * 10, self.GrenadePos.z, 0)
	
	pos = pos + ang:Up() * self.GrenadePos.z
	pos = pos + ang:Forward() * 2
	
	self.CW_GREN:SetPos(pos)
	self.CW_GREN:SetAngles(ang)
	self.CW_GREN:FrameAdvance(FrameTime())
	
	cam.IgnoreZ(true)
		self.CW_GREN:DrawModel()
	cam.IgnoreZ(false)
end

function SWEP:applyOffsetToVM()
	local CT = UnPredictedCurTime()
	
	local pos = EyePos()
	local ang
	
	if self.freeAimOn and (self.freeAimOn and not self.dt.BipodDeployed) then
		-- take FOV changes into account (including the breath FOV modifier, but excluding the 'continuous fire' FOV modifier)
		local fovDiff = math.Clamp(60 / (self.ViewModelFOV - self.BreathFOVModifier * 0.5), -math.huge, math.huge)
		
		if self.ViewModelFOV < 60 then
			fovDiff = fovDiff * 1.1
		end
		
		local eyeAngles = self.Owner:EyeAngles()
		local actualEyeAngles = EyeAngles()
		
		--local fovDiffNonWep = 1 + (1 - GetConVarNumber("fov_desired") / 90)
		
		-- get the difference between the real eye angles and the 'virtual' eye angles
		local pitchDiff = math.AngleDifference(eyeAngles.p, actualEyeAngles.p) * 0.45 * fovDiff
		local yawDiff = math.AngleDifference(eyeAngles.y, actualEyeAngles.y) * 0.45 * fovDiff
		
		-- normalize the angles after subtracting the difference in both axes
		local normalizedPitch = math.NormalizeAngle(eyeAngles.p - pitchDiff)
		local normalizedYaw = math.NormalizeAngle(eyeAngles.y - yawDiff)
		
		-- apply the angles
		eyeAngles.p = normalizedPitch
		eyeAngles.y = normalizedYaw
		
		ang = eyeAngles
	else -- if we're not using free aim, fall back to 'virtual' eye angles
		ang = EyeAngles()
	end
	
	if self.InstantDissapearOnAim and self.dt.State == CW_AIMING then
		self.ViewModelFOV = 90
		pos = pos - ang:Forward() * 100
		--return pos, ang
	end

	if CT > self.AimTime then
		if ((self.MoveWepAwayWhenAiming and self.dt.State == CW_AIMING) or (self:canUseSimpleTelescopics() and self.dt.State == CW_AIMING)) and (self.dt.M203Active and (not self.M203Chamber or CustomizableWeaponry.grenadeTypes:canUseProperSights(self.Grenade40MM))  or not self.dt.M203Active) then
			self.ViewModelFOV = 90
			pos = pos - ang:Forward() * 100
			--return pos, ang
		end
	end
	
	RotateAroundAxis(ang, Right(ang), self.BlendAng.x + self.RecoilAng.p)
	
	local swayIntensity = self.dt.State == CW_AIMING and self.AimSwayIntensity or self.SwayIntensity
	
	-- first we offset the viewmodel position
	if not self.ViewModelFlip then
		RotateAroundAxis(ang, Up(ang), self.BlendAng.y + self.RecoilAng.y - self.AngleDelta.y * 0.4 * swayIntensity)
		RotateAroundAxis(ang, Forward(ang), self.BlendAng.z + self.RecoilAng.r + self.AngleDelta.y * 0.4 * swayIntensity)
	else
		RotateAroundAxis(ang, Up(ang), -self.BlendAng.y + self.RecoilAng.y - self.AngleDelta.y * 0.4 * swayIntensity)
		RotateAroundAxis(ang, Forward(ang), -self.BlendAng.z + self.RecoilAng.r + self.AngleDelta.y * 0.4 * swayIntensity)
	end

	if not self.ViewModelFlip then
		pos = pos + (self.BlendPos.x + self.AngleDelta.y * 0.05 * swayIntensity + self.RecoilPos.z) * Right(ang)
	else
		pos = pos - (self.BlendPos.x - self.AngleDelta.y * 0.05 * swayIntensity - self.RecoilPos.z) * Right(ang)
	end
	
	pos = pos + (self.BlendPos.y - self.FireMove - self.RecoilPos.y) * Forward(ang)
	pos = pos + (self.BlendPos.z - self.AngleDelta.p * 0.1 * swayIntensity - self.RecoilPos.z) * Up(ang)
	
	-- then we apply the viewmodel movement
	RotateAroundAxis(ang, Right(ang), CurAngMod.x + self.BipodAng[1])
	
	if not self.ViewModelFlip then
		RotateAroundAxis(ang, Up(ang), CurAngMod.y + self.BipodAng[2])
		RotateAroundAxis(ang, Forward(ang), CurAngMod.z + self.BipodAng[3])
	else
		RotateAroundAxis(ang, Up(ang), CurAngMod.y + self.BipodAng[2])
		RotateAroundAxis(ang, Forward(ang), CurAngMod.z + self.BipodAng[3])
	end
	
	if not self.ViewModelFlip then
		pos = pos + (CurPosMod.x + self.BipodPos[1] + self.RecoilAng.y) * Right(ang)
	else
		pos = pos + (CurPosMod.x + self.BipodPos[1] + self.RecoilAng.y) * Right(ang)
	end
	
	pos = pos + (CurPosMod.y + self.BipodPos[2]) * Forward(ang)
	pos = pos + (CurPosMod.z + self.BipodPos[3]) * Up(ang)
	
	self.CW_VM:SetPos(pos)
	self.CW_VM:SetAngles(ang)
end

function SWEP:_drawViewModel()
	-- draw the viewmodel
	
	if self.ViewModelFlip then
		render.CullMode(MATERIAL_CULLMODE_CW)
	end
	
	local POS = EyePos() - self.CW_VM:GetPos()
	
	self.CW_VM:FrameAdvance(FrameTime())
	self.CW_VM:SetupBones()
	self.CW_VM:DrawModel()
	
	if self.UseHands then -- bonemerge da shiz
		local hands = self.Owner:GetHands()
		
		if IsValid(hands) then
			hands:SetParent(self.CW_VM)
			hands:AddEffects(EF_BONEMERGE)
			hands:DrawModel()
		end
	end
	
	if self.ViewModelFlip then
		render.CullMode(MATERIAL_CULLMODE_CCW)
	end
	
	-- draw the attachments
	self:drawAttachments()
	
	-- draw the customization menu
	self:drawInteractionMenu()
	
	-- draw the unique scope behavior if it is defined
	if self.reticleFunc then
		self.reticleFunc(self)
	end
	
	-- and lastly, draw the custom hud if the player has it enabled
	if GetConVarNumber("cw_customhud_ammo") >= 1 then
		self:draw3D2DHUD()
	end
end

SWEP.HUD_3D2D_MagColor = Color(255, 255, 255, 255)
SWEP.HUD_3D2d_ReserveColor = Color(255, 255, 255, 255)

local bullet = surface.GetTextureID("cw2/gui/bullet")

function SWEP:getReserveAmmoText()
	local shouldOverride, text, targetColor = CustomizableWeaponry.callbacks.processCategory(self, "overrideReserveAmmoText")
	
	if shouldOverride then
		return text, shouldOverride, targetColor
	end
	
	return self.Owner:GetAmmoCount(self.Primary.Ammo), shouldOverride, targetColor
end

function SWEP:getShouldDrawAmmoText()
	if CustomizableWeaponry.callbacks.processCategory(self, "shouldBlockAmmoText") then
		return false
	end
	
	return self.ammoTextTime > 0 or self.Owner:KeyDown(IN_RELOAD)
end

function SWEP:draw3D2DHUD()
	local att = self:getMuzzlePosition()
	
	if not att then
		return
	end
	
	local ang = EyeAngles()
	ang:RotateAroundAxis(ang:Right(), 90)
	ang:RotateAroundAxis(ang:Up(), -90)
	
	cam.Start3D2D(att.Pos + ang:Forward() * 4, ang, self.HUD_3D2DScale)
		cam.IgnoreZ(true)
			local FT = FrameTime()
			
			if self.dt.State == CW_AIMING or (self.InactiveWeaponStates[self.dt.State] and not (self.IsReloading and self.Cycle <= 0.98)) then
				self.HUD_3D2DAlpha = math.Approach(self.HUD_3D2DAlpha, 0, FT * 1000)
			else
				self.HUD_3D2DAlpha = math.Approach(self.HUD_3D2DAlpha, 255, FT * 1000)
			end
			
			self.HUDColors.white.a = self.HUD_3D2DAlpha
			self.HUDColors.black.a = self.HUD_3D2DAlpha
			
			local mag = self:Clip1()
			
			self.HUDColors.black.a = self.HUD_3D2DAlpha
			
			local reloadProgress = self:getReloadProgress()
			local canDrawCaliberText = false
			
			-- if our mag has not much ammo or we're reloading, make the text red
			if mag <= self.Primary.ClipSize * 0.25 or reloadProgress then
				self.HUD_3D2D_MagColor = LerpColor(FT * 10, self.HUD_3D2D_MagColor, self.HUDColors.red)
				canDrawCaliberText = true
			else
				self.HUD_3D2D_MagColor = LerpColor(FT * 10, self.HUD_3D2D_MagColor, self.HUDColors.white)
			end
			
			self.HUD_3D2D_MagColor.a = self.HUD_3D2DAlpha
			
			-- only show the reload progress if we're reloading
			if reloadProgress then
				draw.ShadowText("RELOADING " .. reloadProgress .. "%", "CW_HUD60", 90, 50, self.HUD_3D2D_MagColor, self.HUDColors.black, 2, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
			else
				draw.ShadowText(self:getMagCapacity() .. " / " .. self:getReserveAmmoText(), "CW_HUD60", 90, 50, self.HUD_3D2D_MagColor, self.HUDColors.black, 2, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
			end
			
			if self.BulletDisplay and self.BulletDisplay > 0 then
				local bulletDisplayAlpha = self.HUD_3D2DAlpha
				local bulletDisplayOffset = 0
				
				if #self.FireModes > 1 then -- if we have more than 1 firemode for the current weapon, we don't let the firemode display fade and instead reposition it a bit to let the player see what firemode he's using while aiming
					local aiming = self.dt.State == CW_AIMING
				
					bulletDisplayAlpha = aiming and 255 or self.HUD_3D2DAlpha
					bulletDisplayOffset = aiming and -255 or 0
				end
				
				surface.SetTexture(bullet)
				surface.SetDrawColor(0, 0, 0, bulletDisplayAlpha)
				
				for i = 1, self.BulletDisplay do
					surface.DrawTexturedRectRotated(115 + bulletDisplayOffset, 38 + (i - 1) * 18, 30, 30, 180)
				end
				
				surface.SetTexture(bullet)
				surface.SetDrawColor(255, 255, 255, bulletDisplayAlpha)
				
				for i = 1, self.BulletDisplay do
					surface.DrawTexturedRectRotated(113 + bulletDisplayOffset, 38 + (i - 1) * 18 - 2, 30, 30, 180)
				end
			end
			
			local grenades = self.Owner:GetAmmoCount("Frag Grenades")
			local y = 100
			
			if grenades > 0 then
				draw.ShadowText(self:getFragText(grenades), "CW_HUD48", 90, 100, self.HUDColors.white, self.HUDColors.black, 2, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
				y = y + 48
			end
			
			if canDrawCaliberText or self:getShouldDrawAmmoText() then
				self.ammoTextAlpha = math.min(255, self.ammoTextAlpha + FT * 1000)
				self.ammoTextTime = math.max(0, self.ammoTextTime - FT)
			else
				self.ammoTextAlpha = math.max(0, self.ammoTextAlpha - FT * 1500)
			end
			
			if self.ammoTextAlpha > 0 then
				local alphaValue = math.min(self.HUD_3D2DAlpha, self.ammoTextAlpha)
				self.HUDColors.white.a = alphaValue
				self.HUDColors.black.a = alphaValue
				draw.ShadowText(self.Primary.Ammo, "CW_HUD40", 90, y, self.HUDColors.white, self.HUDColors.black, 2, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
			end
			
			self.HUDColors.white.a = 255
			self.HUDColors.black.a = 255
			
			if self.dt.M203Active then
				-- display the text when we either have a round in, or have no rounds but aren't aiming
				if (not self.M203Chamber and self.dt.State ~= CW_AIMING) or self.M203Chamber then
					if not self.M203Chamber then
						draw.ShadowText("M203 EMPTY", "CW_HUD40", 90, -70, self.HUDColors.red, self.HUDColors.black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
					else
						draw.ShadowText("M203 READY", "CW_HUD40", 90, -70, self.HUDColors.white, self.HUDColors.black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
					end
					
					local curGrenade = CustomizableWeaponry.grenadeTypes.getGrenadeText(self)
					
					draw.ShadowText(self.Owner:GetAmmoCount("40MM") .. "x RESERVE", "CW_HUD32", 90, -40, self.HUDColors.white, self.HUDColors.black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
					draw.ShadowText("TYPE" .. curGrenade, "CW_HUD32", 90, -10, self.HUDColors.white, self.HUDColors.black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
				end
			end
			
			CustomizableWeaponry.callbacks.processCategory(self, "drawTo3D2DHUD")
		cam.IgnoreZ(false)
	cam.End3D2D()
end
	
function SWEP:lengthAngle(ang)
	ang.p, ang.y, ang.r = math.abs(ang.p), math.abs(ang.y), math.abs(ang.r)
	return ang
end

function SWEP:getDifferenceToAimPos(pos, ang, vertDependance, horDependance, dependMod)
	dependMod = dependMod or 1
	vertDependance = vertDependance or 1
	horDependance = horDependance or 1
	
	local sway = (self.AngleDelta.p * 0.65 * vertDependance + self.AngleDelta.y * 0.75 * horDependance) * 0.05 * dependMod
	local pos = self.BlendPos - pos
	local ang = self.BlendAng - ang
	ang.z = 0
	
	pos = pos:Length()
	ang = ang:Length() - sway
	
	local dependance = pos + ang
	
	return 1 - dependance
end

local blurMaterial = Material("pp/toytown-top")
blurMaterial:SetTexture("$fbtexture", render.GetScreenEffectTexture())

function SWEP:drawBlur()
	local x, y = ScrW(), ScrH()

	cam.Start2D()
		surface.SetMaterial(blurMaterial)
		surface.SetDrawColor(255, 255, 255, 255)
		
		for i = 1, self.BlurAmount do
			render.UpdateScreenEffectTexture()
			surface.DrawTexturedRect(0, 0, x, y * 2)
		end

	cam.End2D()
end

function SWEP:processBlur()
	-- if we're aiming and have enabled telescopic sight aim blur, blur our stuff
	local FT = FrameTime()
	
	local can = false
	
	if self.IsReloading and self.Cycle <= 0.9 and GetConVarNumber("cw_blur_reload") >= 1 then
		can = true
	elseif self.dt.State == CW_CUSTOMIZE and GetConVarNumber("cw_blur_customize") >= 1 then
		can = true
	elseif self.dt.State == CW_AIMING and self.BlurOnAim and GetConVarNumber("cw_blur_aim_telescopic") >= 1 and GetConVarNumber("cw_simple_telescopics") <= 0 then
		if self.dt.M203Active and self.M203Chamber then
			can = false
		else
			if self.ActualSightPos then
				if self.AimPos == self.ActualSightPos then
					can = true
				end
			else
				can = true
			end
		end
	end
	
	if can then
		self.BlurAmount = math.Approach(self.BlurAmount, 10, FT * 15)
	else
		self.BlurAmount = math.Approach(self.BlurAmount, 0, FT * 30)
	end
	
	if self.BlurAmount > 0 then
		self:drawBlur()
	end
end

function SWEP:PostDrawViewModel()
	render.SetBlend(1)
end

function SWEP:getMuzzlePosition()
	return self.CW_VM:GetAttachment(self.MuzzleAttachment)
end

-- interaction menu, AKA weapon interaction menu
function SWEP:drawInteractionMenu()
	FT = FrameTime()
	
	if self.dt.State == CW_CUSTOMIZE then
		self.CustomizeMenuAlpha = math.Approach(self.CustomizeMenuAlpha, 1, FT * 5)
	else
		self.CustomizeMenuAlpha = math.Approach(self.CustomizeMenuAlpha, 0, FT * 15)
	end
	
	if self.CustomizeMenuAlpha > 0 then
		local att = self:getMuzzlePosition()
		local ang = EyeAngles()
		ang:RotateAroundAxis(ang:Right(), 90)
		ang:RotateAroundAxis(ang:Up(), -90)
		ang:RotateAroundAxis(ang:Right(), -10)
		
		cam.Start3D2D(att.Pos, ang, self.CustomizationMenuScale)
			-- disable depth checks
			
			cam.IgnoreZ(true)
				CustomizableWeaponry.interactionMenu.draw(self)
			cam.IgnoreZ(false)
		cam.End3D2D()
	end
end

function SWEP:getBoneOrientation(boneId)
	local m = self.CW_VM:GetBoneMatrix(boneId)
	
	if m then
		local pos, ang = m:GetTranslation(), m:GetAngles()
		
		-- fix model inversion
		if self.ViewModelFlip then
			ang.r = -ang.r
		end
		
		return pos, ang
	end
end

function SWEP:_drawAttachmentModel(data)
	local model = data.ent
	local pos, ang = self:getBoneOrientation(data._bone) --self.CW_VM:GetBonePosition(data.bone)

	model:SetPos(pos + ang:Forward() * data.pos.x + ang:Right() * data.pos.y + ang:Up() * data.pos.z)
	ang:RotateAroundAxis(ang:Up(), data.angle.y)
	ang:RotateAroundAxis(ang:Right(), data.angle.p)
	ang:RotateAroundAxis(ang:Forward(), data.angle.r)

	model:SetAngles(ang)
	
	if data.animated then
		model:FrameAdvance(FrameTime())
		model:SetupBones()
	end
	
	model:DrawModel()
end

function SWEP:_drawAttachmentModels(data)
	if data.models then
		for key, modelData in ipairs(data.models) do
			self:_drawAttachmentModels(modelData)
		end
	else
		self:_drawAttachmentModel(data)
	end
end

function SWEP:drawAttachments()
	if not self.AttachmentModelsVM then
		return false
	end
	
	local FT = FrameTime()
	
	for k, v in ipairs(self.activeRenderAttachments) do
		-- no point in drawing/positioning models that are not visible
		self:_drawAttachmentModels(v)
	end
	
	-- call various functions that attachments may (or may not) add (such as laser sights)
	for k, v in pairs(self.elementRender) do
		v(self)
	end
	
	return true
end

function SWEP:setAttachmentModelState(attName, state)
	local attData = self.AttachmentModelsVM[attName]
	
	if not attData then
		return
	end
	
	local prev = attData.active
	attData.active = state	
	
	if state then
		if not prev then
			table.insert(self.activeRenderAttachments, attData)
		end
	else
		if prev then
			table.RemoveByValue(self.activeRenderAttachments, attData)
		end
	end
end

function SWEP:drawAttachmentsPost()
	for k, v in pairs(self.elementRenderPost) do
		v(self)
	end	
end

function SWEP:processSwayDelta(deltaTime, eyeAngles)
	if self:isBipodIdle() then
		self.AngleDelta = LerpAngle(math.Clamp(deltaTime * 10, 0, 1), self.AngleDelta, Ang0)
	else
		delta = Angle(eyeAngles.p, eyeAngles.y, 0) - self.OldDelta
		delta.p = math.Clamp(delta.p, -10, 10)
		local FT = FrameTime()
		
		if self.SwayInterpolation == "linear" then
			self.AngleDelta = LerpAngle(math.Clamp(FT * 15, 0, 1), self.AngleDelta, delta)
			self.AngleDelta.y = math.Clamp(self.AngleDelta.y, -15, 15)
		else
			delta.p = math.Clamp(delta.p, -5, 5)
			self.AngleDelta2 = LerpAngle(math.Clamp(FT * 12, 0, 1), self.AngleDelta2, self.AngleDelta)
			self.AngDiff.p = (self.AngleDelta.p - self.AngleDelta2.p)
			self.AngDiff.y = (self.AngleDelta.y - self.AngleDelta2.y)
			self.AngleDelta = LerpAngle(math.Clamp(FT * 10, 0, 1), self.AngleDelta, delta + self.AngDiff)
			self.AngleDelta.y = math.Clamp(self.AngleDelta.y, -25, 25)
		end
		
		self.OldDelta.p = eyeAngles.p
		self.OldDelta.y = eyeAngles.y
	end
end

function SWEP:processFOVChanges(deltaTime)
	if self.dt.State == CW_AIMING then
		if self.dt.M203Active and self.M203Chamber then
			self.CurVMFOV = LerpCW20(deltaTime * 10, self.CurVMFOV, 60)
		else
			self.CurVMFOV = LerpCW20(deltaTime * 10, self.CurVMFOV, self.AimViewModelFOV)
		end
	else
		self.CurVMFOV = LerpCW20(deltaTime * 10, self.CurVMFOV, self.ViewModelFOV_Orig)
	end
	
	self.ViewModelFOV = self.CurVMFOV
end

function SWEP:getBaseViewModelPos()
	if GetConVarNumber("cw_alternative_vm_pos") > 0 and self.AlternativePos then
		return self.AlternativePos, self.AlternativeAng
	end
	
	return Vec0, Vec0
end

function SWEP:addRunTime()
	self.RunTime = self.RunTime + self.RunTimeBuf
	self.RunTimeBuf = math.pi
end

SWEP.RunTimeBuf = 0

function SWEP:performViewmodelMovement()
	CT = UnPredictedCurTime()
	vm = self.CW_VM
	
	self.Cycle = vm:GetCycle()
	self.Sequence = vm:GetSequenceName(vm:GetSequence())
	self.IsReloading = (self.Sequence == self.Animations.reload or self.Sequence == self.Animations.reload_empty or self.Sequence == self.Animations.reload_start or self.Sequence == self.Animations.reload_end)
	
	if not self.IsReloading then
		self.IsReloading = self.Sequence:find("insert")
	end
	
	if not self.IsReloading then
		self.IsFiddlingWithSuppressor = self.Sequence:find("silencer")
	end
	
	local FT = RealFrameTime()
	local EA = EyeAngles()
	
	self:processSwayDelta(FT, EA)
	
	EA = EyeAngles()
	self:processFOVChanges(FT)
	
	vel = GetVelocity(self.Owner)
	len = Length(vel)
	ws = self.Owner:GetWalkSpeed()
	
	PosMod, AngMod = Vec0 * 1, Vec0 * 1
	mod2 = 1
	
	veldepend.roll = math.Clamp((vel:DotProduct(EA:Right()) * 0.04) * len / ws, -5, 5)
	
	self.reloadingM203 = self:isReloadingM203()
	
	if self.dt.State == CW_AIMING then
		-- aim VM movement modifiers
		mod2 = 1
		
		-- check if we can use regular sights with the current grenade type, and if we can, let us do so
		-- also check for existing ammo in the M203, if there is none, resort to regular ironsights
		self.properM203Sights = CustomizableWeaponry.grenadeTypes:canUseProperSights(self.Grenade40MM)
		
		if self.dt.M203Active and not self.properM203Sights and self.M203Chamber then
			TargetPos, TargetAng = self.M203Pos * 1, self.M203Ang * 1
		else
			TargetPos, TargetAng = self.AimPos * 1, self.AimAng * 1
		end
		
		self.ApproachSpeed = math.Approach(self.ApproachSpeed, 10, FT * 300)
		CurPosMod, CurAngMod = Vec0 * 1, Vec0 * 1
	elseif self.dt.State == CW_ACTION or self.dt.State == CW_HOLSTER_START or self.dt.State == CW_HOLSTER_END then
		-- ladder climb/swim movement modifiers
		TargetPos, TargetAng = self.SwimPos * 1, self.SwimAng * 1
		self.ApproachSpeed = math.Approach(self.ApproachSpeed, 5, FT * 100)
	elseif self.dt.State == CW_RUNNING or (((len > ws * self.RunStateVelocity and self.Owner:KeyDown(IN_SPEED)) or len > ws * 3 or (self.ForceRunStateVelocity and len > self.ForceRunStateVelocity)) and self.Owner:OnGround()) then
		local runMod = 1
		
		-- if we're running and our movement speed is fit for run movement speed
		
		if ((self.IsReloading or self.IsFiddlingWithSuppressor) and self.Cycle < 0.9) or self.reloadingM203 then
			-- if we're reloading, then go back to the 'gun forward' position
			TargetPos, TargetAng = Vec0 * 1, Vec0 * 1
			self.ApproachSpeed = math.Approach(self.ApproachSpeed, 4, FT * 100)
			runMod = 0.25
		else
			-- check whether sprinting is enabled or not, in the case it isn't, don't use any running positions
			
			if self.SprintingEnabled then
				TargetPos, TargetAng = self.SprintPos * 1, self.SprintAng * 1
			else
				TargetPos, TargetAng = Vec0 * 1, Vec0 * 1
			end
			
			self.ApproachSpeed = math.Approach(self.ApproachSpeed, 5, FT * 200)
		end
		
		-- move the weapon away if the player is looking up/down while sprinting
		
		if not self.DisableSprintViewSimulation then
			local verticalOffset = EyeAngles().p * 0.4 * runMod
			TargetAng.x = TargetAng.x - math.Clamp(verticalOffset, 0, 10) * self.SprintViewNormals.x
			TargetAng.y = TargetAng.y - verticalOffset * 0.5 * self.SprintViewNormals.y
			TargetAng.z = TargetAng.z - verticalOffset * 0.2 * self.SprintViewNormals.z
			--TargetAng.z = TargetAng.z - verticalOffset * 0.2]]--
			TargetPos.z = TargetPos.z + math.Clamp(verticalOffset * 0.2, -10, 3)
		end
		
		rs = self.Owner:GetRunSpeed()
		mul = math.Clamp(len / rs, 0, 1)
		
		if self:isReloading() then
			mul = mul * 0.95
		end
		
		--self.RunTime = self.RunTime + FT * (7.5 + math.Clamp(len / 120, 0, 5))
		local change = math.min(self.RunTimeBuf, FT * (7.5 + len / 80))
		self.RunTimeBuf = math.max(0, self.RunTimeBuf - change)
		self.RunTime = self.RunTime + change
		
		local runTime = self.RunTime
		sin1 = math.sin(runTime) * mul
		cos1 = math.cos(runTime) * mul
		tan1 = math.atan(cos1 * sin1, cos1 * sin1) * mul
		
		if self.MoveType == 1 then -- pistol VM movement
			AngMod.x = AngMod.x + tan1 * 0.2 * self.ViewModelMovementScale * mul
			AngMod.y = AngMod.y - cos1 * 3 * self.ViewModelMovementScale * mul
			AngMod.z = AngMod.z + cos1 * 3 * self.ViewModelMovementScale * mul
			PosMod.x = PosMod.x - sin1 * 0.8 * self.ViewModelMovementScale * mul
			PosMod.y = PosMod.y + tan1 * 1.8 * self.ViewModelMovementScale * mul
			PosMod.z = PosMod.z + tan1 * 1.5 * self.ViewModelMovementScale * mul
		else
			AngMod.x = AngMod.x + tan1 * self.ViewModelMovementScale * mul
			AngMod.y = AngMod.y - sin1 * -10 * self.ViewModelMovementScale * mul
			AngMod.z = AngMod.z + cos1 * 4 * self.ViewModelMovementScale * mul
			
			PosMod.x = PosMod.x - cos1 * 0.6 * self.ViewModelMovementScale * mul
			PosMod.y = PosMod.y + sin1 * 0.6 * self.ViewModelMovementScale * mul
			PosMod.z = PosMod.z + tan1 * 2 * self.ViewModelMovementScale * mul
		end
	elseif self.dt.State == CW_PRONE_BUSY then
		TargetPos, TargetAng = Vec0 * 1, Vec0 * 1
		
		local mul = 1
		
		self.RunTime = self.RunTime + FT * 5
		local runTime = self.RunTime
		sin1 = math.sin(runTime) * mul
		cos1 = math.cos(runTime) * mul
		tan1 = math.atan(cos1 * sin1, cos1 * sin1) * mul
		
		AngMod.x = AngMod.x + tan1 * 5 * self.ViewModelMovementScale * mul
		AngMod.y = AngMod.y - cos1 * -3 * self.ViewModelMovementScale * mul
		AngMod.z = AngMod.z + sin1 * 4 * self.ViewModelMovementScale * mul
		
		PosMod.x = PosMod.x - sin1 * 0.25 * self.ViewModelMovementScale * mul
		PosMod.y = PosMod.y + cos1 * self.ViewModelMovementScale * mul
		PosMod.z = PosMod.z + tan1 * 0.25 * self.ViewModelMovementScale * mul
	elseif self.dt.State == CW_PRONE_MOVING then
		local modifier = self.ViewModelFlip and -1 or 1
		
		TargetPos, TargetAng = self.PronePos * 1, self.ProneAng * 1
		
		local proneVelMul = len / self.BusyProneVelocity * self.ViewmodelProneVelocityMultiplier
		local mul = math.Clamp(len / ws, 0, 1) * proneVelMul
		
	-- SWEP.PronePos = Vector(6.717, -6.273, -6.577)
	-- SWEP.ProneAng = Vector(5.618, 49.055, -15.311)
	
	-- SWEP.PronePos = Vector(-7.397, -2.497, -1.551)
	-- SWEP.ProneAng = Vector(5.618, -49.056, -15.311)
		
		self.RunTime = self.RunTime + FT * (6 + math.Clamp(len / 120, 0, 5))
		local runTime = self.RunTime
		sin1 = math.sin(runTime) * mul
		cos1 = math.cos(runTime) * mul
		tan1 = math.atan(cos1 * sin1, cos1 * sin1) * mul
		
		AngMod.x = AngMod.x - tan1 * 30 * self.ViewModelMovementScale * mul * modifier
		AngMod.y = AngMod.y + cos1 * -30 * self.ViewModelMovementScale * mul * modifier
		AngMod.z = AngMod.z - sin1 * 20 * self.ViewModelMovementScale * mul
		
		PosMod.x = PosMod.x + cos1 * -5 * self.ViewModelMovementScale * mul * modifier
		PosMod.y = PosMod.y - cos1 * 3 * self.ViewModelMovementScale * mul
		PosMod.z = PosMod.z + tan1 * 20 * self.ViewModelMovementScale * mul * modifier
		
		local runMod = 1
		
		local verticalOffset = EyeAngles().p * 0.4 * runMod
		TargetAng.x = TargetAng.x - math.min(0, math.Clamp(verticalOffset, 0, 10) * self.SprintViewNormals.x)
		TargetAng.y = TargetAng.y - math.min(0, verticalOffset * 0.5 * self.SprintViewNormals.y)
		TargetAng.z = TargetAng.z - math.min(0, verticalOffset * 0.2 * self.SprintViewNormals.z)
		--TargetAng.z = TargetAng.z - verticalOffset * 0.2]]--
		TargetPos.z = TargetPos.z + math.min(0,math.Clamp(verticalOffset * 0.2, -10, 3))
	else
		if self.dt.State == CW_CUSTOMIZE then
			TargetPos, TargetAng = self.CustomizePos * 1, self.CustomizeAng * 1
		else
			if self.dt.Safe then
				TargetPos, TargetAng = self.SprintPos * 1, self.SprintAng * 1
			else
				TargetPos, TargetAng = self:getBaseViewModelPos()
				TargetPos, TargetAng = TargetPos * 1, TargetAng * 1
			end
			
			self.NearWall = false
			
			if self.NearWallEnabled then
				-- get anything in front of us, if there is something, enable near wall
				td.start = self.Owner:GetShootPos()
				td.endpos = td.start + self.Owner:EyeAngles():Forward() * self.NearWallDistance
				td.filter = self.Owner
				
				tr = util.TraceLine(td)
				
				if tr.Hit or (IsValid(tr.Entity) and not tr.Entity:IsPlayer()) then
					--TargetPos.y = TargetPos.y - math.Clamp(30 * (1 - tr.Fraction), 0, 15)
					--TargetPos.y = TargetPos.y - math.Clamp(30 * (1 - tr.Fraction), 0, 15)
					
					TargetPos = self.SprintPos * (1 - tr.Fraction)
					TargetAng = self.SprintAng * (1 - tr.Fraction)
					self.NearWall = true
				end
			end
		end
		
		self.ApproachSpeed = math.Approach(self.ApproachSpeed, 10, FT * 100)
		
		--if tr.Hit then
			--self.NearWall = true
			
		--end
	end
	
	if self.M203AngDiff then
		TargetPos.x = TargetPos.x + self.M203AngDiff.y * 0.3
		TargetPos.y = TargetPos.y + self.M203AngDiff.p * -0.5
		TargetPos.z = TargetPos.z - self.M203AngDiff.p * 0.5
		
		TargetAng.x = TargetAng.x - self.M203AngDiff.y * 2
		TargetAng.y = TargetAng.y - self.M203AngDiff.p * 2
	end
	
	if len < 10 or not self.Owner:OnGround() then
		-- idle viewmodel movement

		if self.dt.State != CW_AIMING and not self:isBipodIdle() then
			cos1, sin1 = math.cos(CT), math.sin(CT)
			tan = math.atan(cos1 * sin1, cos1 * sin1)
			
			AngMod.x = AngMod.x + tan * 1.15
			AngMod.y = AngMod.y + cos1 * 0.4
			AngMod.z = AngMod.z + tan
			
			PosMod.y = PosMod.y + tan * 0.2 * mod2
		end
	elseif len > 10 and len < ws * 1.2 then
		-- walk viewmodel movement
		mul = math.Clamp(len / ws, 0, 1)
		
		local change = math.min(self.RunTimeBuf, FT * (6 + len / 40))
		self.RunTimeBuf = math.max(0, self.RunTimeBuf - change)
		self.RunTime = self.RunTime + change
		
		if self.dt.State == CW_AIMING then
			mul = mul * self.AimMobilitySpreadMod * 0.666
		end
		
		sin1 = math.sin(self.RunTime) * mul
		cos1 = math.cos(self.RunTime) * mul
		tan1 = math.atan(cos1 * sin1, cos1 * sin1) * mul
		
		AngMod.x = AngMod.x + self:scaleMovement(tan1 * 2, mod2) -- up/down
		AngMod.y = AngMod.y + self:scaleMovement(cos1, mod2) -- left/right
		AngMod.z = AngMod.z + self:scaleMovement(sin1, mod2) -- rotation left/right
		PosMod.x = PosMod.x + self:scaleMovement(sin1 * 0.1, mod2) -- left/right
		
		if self.MoveType == 1 and self.FireMode == "safe" then
			PosMod.y = PosMod.y + self:scaleMovement(tan1 * 0.6, mod2) -- forward/backwards
		else
			PosMod.y = PosMod.y + self:scaleMovement(tan1 * 0.4, mod2) -- forward/backwards
		end
		
		PosMod.z = PosMod.z - self:scaleMovement(tan1 * 0.1, mod2) -- up/down
		
		-- apply viewmodel tilt when moving and not aiming based on velocity dot product relative to aim direction
		local norm = math.Clamp(vel:GetNormal():DotProduct(self.Owner:EyeAngles():Forward()), 0, 1)
		
		if self.dt.State ~= CW_AIMING then
			TargetPos[2] = TargetPos[2] - mul * 0.8 * norm
			TargetPos[3] = TargetPos[3] - mul * 0.5 * norm
		end
	end
	
	if (self.dt.BipodDeployed and self.DeployAngle and self.dt.State == CW_IDLE) and not self:isReloading() then
		local dif1 = math.AngleDifference(self.DeployAngle.y, EA.y)
		local dif2 = math.AngleDifference(self.DeployAngle.p, EA.p)
		TargetPos[3] = TargetPos[3] - 2
		TargetPos[2] = TargetPos[2] + 2
		
		if CT < self.BipodMoveTime then
			self.BipodPos[1] = math.Approach(self.BipodPos[1], dif1 * self.BipodSensitivity.x, FT * 50)
			self.BipodPos[3] = math.Approach(self.BipodPos[3], dif2 * self.BipodSensitivity.z, FT * 50)
			
			self.BipodAng[1] = math.Approach(self.BipodAng[1], dif2 * self.BipodSensitivity.p, FT * 50)
			self.BipodAng[3] = math.Approach(self.BipodAng[3], dif2 * self.BipodSensitivity.r, FT * 50)
		else
			self.BipodPos[1] = dif1 * self.BipodSensitivity.x
			self.BipodPos[3] = dif2 * self.BipodSensitivity.z
			
			self.BipodAng[1] = dif2 * self.BipodSensitivity.p
			--self.BipodAng[2] = dif1 * -0.1
			self.BipodAng[3] = dif2 * self.BipodSensitivity.r
		end
	else
		self.BipodPos = LerpVectorCW20(FT * 10, self.BipodPos, Vec0)
		self.BipodAng = LerpVectorCW20(FT * 10, self.BipodAng, Vec0)
		self.BipodMoveTime = CT + 0.2
	end
	
	FT = FrameTime()
	
	if self.ViewModelFlip then
		TargetAng.z = TargetAng.z - veldepend.roll
	else
		TargetAng.z = TargetAng.z + veldepend.roll
	end
	
	local newTargetPos, newTargetAng = CustomizableWeaponry.callbacks.processCategory(self, "adjustViewmodelPosition", TargetPos, TargetAng)
	
	TargetPos = newTargetPos or TargetPos
	TargetAng = newTargetAng or TargetAng
	
	-- the position of the weapon (running/walking/aiming)
	self.BlendPos = LerpVectorCW20(FT * self.ApproachSpeed, self.BlendPos, TargetPos)
	self.BlendAng = LerpVectorCW20(FT * self.ApproachSpeed, self.BlendAng, TargetAng)
	
	-- the viewmodel movement position of the weapon
	CurPosMod = LerpVectorCW20(FT * 10, CurPosMod, PosMod)
	CurAngMod = LerpVectorCW20(FT * 10, CurAngMod, AngMod)
	
	-- the 'fake' weapon recoil
	if self.LuaViewmodelRecoil then
		-- the 'fake' viewmodel weapon recoil should only be reset if the weapon in question is using it 
		self.RecoilRestoreSpeed = math.Approach(self.RecoilRestoreSpeed, 10, FT * 10)
		self.RecoilPos2 = LerpVectorCW20(FT * self.RecoilRestoreSpeed * 0.9, self.RecoilPos2, self.RecoilPos)
		self.RecoilAng2 = LerpAngleCW20(FT * self.RecoilRestoreSpeed * 0.9, self.RecoilAng2, self.RecoilAng)
		
		self.RecoilPosDiff.x = self.RecoilPos.x - self.RecoilPos2.x
		self.RecoilPosDiff.y = self.RecoilPos.y - self.RecoilPos2.y
		self.RecoilPosDiff.z = self.RecoilPos.z - self.RecoilPos2.z
		
		self.RecoilAngDiff.x = self.RecoilAng.x - self.RecoilAng2.x
		self.RecoilAngDiff.y = self.RecoilAng.y - self.RecoilAng2.y
		self.RecoilAngDiff.z = self.RecoilAng.z - self.RecoilAng2.z
		
		self.RecoilPos = LerpVectorCW20(FT * self.RecoilRestoreSpeed, self.RecoilPos, Vec0 + self.RecoilPosDiff)
		self.RecoilAng = LerpAngleCW20(FT * self.RecoilRestoreSpeed, self.RecoilAng, Ang0 + self.RecoilAngDiff)
	end
	
	-- the 'fake' viewmodel recoil from shooting while aiming
	self.FireMove = LerpCW20(FT * 15, self.FireMove, 0)
end

function SWEP:makeVMRecoil(mod)
	mod = mod or 1
	
	-- make the recoil get stronger as the player spends more time firing the weapon non-stop
	local overallMul = 0.25 + 0.75 * self.LuaVMRecoilIntensity * self.LuaVMRecoilMod
	
	-- get the offset multipliers
	local vertMul = math.Rand(0.3, 0.4) * overallMul * 2 * mod
	local forwardMul = math.Rand(0.75, 0.85) * overallMul  * mod
	local sideMul = math.Rand(-0.2, 0.2) * overallMul * 0.5 * mod
	local rollMul = math.Rand(-0.25, 0.25) * overallMul * 5 * mod
	
	-- clamp the maximum kick
	local strength = math.Clamp(self.Recoil, 0.3, 1.8)
	
	self.RecoilRestoreSpeed = 5
	self.RecoilPos.x = strength * sideMul * self.LuaVMRecoilAxisMod.hor
	self.RecoilPos.y = strength * forwardMul * 2 * self.LuaVMRecoilAxisMod.forward --math.Rand(self.Recoil * 0.75, self.Recoil)
	self.RecoilPos.z = strength * vertMul * self.LuaVMRecoilAxisMod.vert
	
	self.RecoilAng.p = strength * vertMul * 5 * self.LuaVMRecoilAxisMod.pitch
	self.RecoilAng.y = strength * sideMul * self.LuaVMRecoilAxisMod.hor --math.Rand(-self.Recoil, self.Recoil) * 0.1
	self.RecoilAng.r = strength * rollMul * self.LuaVMRecoilAxisMod.roll --math.Rand(-self.Recoil, self.Recoil) * 0.1
end

function SWEP:GetViewModelPosition(pos, ang)
	pos = pos + ang:Forward() * -100 -- move the default viewmodel away
	return pos, ang
end

local wm, pos, ang

function SWEP:DrawWorldModel()
	if self.dt.Safe then
		if self.CHoldType != self.RunHoldType then
			self:SetHoldType(self.RunHoldType)
			self.CHoldType = self.RunHoldType
		end
	else
		if self.dt.State == CW_RUNNING or self.dt.State == CW_ACTION then
			if self.CHoldType != self.RunHoldType then
				self:SetHoldType(self.RunHoldType)
				self.CHoldType = self.RunHoldType
			end
		else
			if self.CHoldType != self.NormalHoldType then
				self:SetHoldType(self.NormalHoldType)
				self.CHoldType = self.NormalHoldType
			end
		end
	end
				
	if self.DrawTraditionalWorldModel then
		self:DrawModel()
	else
		wm = self.WMEnt
		
		if IsValid(wm) then
			if IsValid(self.Owner) then
				pos, ang = GetBonePosition(self.Owner, self.Owner:LookupBone("ValveBiped.Bip01_R_Hand"))
				
				if pos and ang then
					RotateAroundAxis(ang, Right(ang), self.WMAng[1])
					RotateAroundAxis(ang, Up(ang), self.WMAng[2])
					RotateAroundAxis(ang, Forward(ang), self.WMAng[3])

					pos = pos + self.WMPos[1] * Right(ang) 
					pos = pos + self.WMPos[2] * Forward(ang)
					pos = pos + self.WMPos[3] * Up(ang)
					
					wm:SetRenderOrigin(pos)
					wm:SetRenderAngles(ang)
					wm:DrawModel()
				end
			else
				wm:SetRenderOrigin(self:GetPos())
				wm:SetRenderAngles(self:GetAngles())
				wm:DrawModel()
				wm:DrawShadow()
			end
		else
			self:DrawModel()
		end
	end
end


================================================
FILE: cw2/lua/weapons/cw_base/cl_playerbindpress.lua
================================================
SWEP.DoubleUseKeyTime = 0
SWEP.DoubleUseKeyPresses = 0
SWEP.SubCustomizationCycleTime = nil
SWEP.AntiAttachmentSwitchSpam = 0
SWEP.InteractionMenuInteractWait = 0
SWEP.SubCustomizationTriggerTime = 0.25

SWEP.magnificationIncreaseButton = "invnext"
SWEP.magnificationDecreaseButton = "invprev"

local wep, CT

function SWEP.PlayerBindPress(ply, b, p)
	if p then
		wep = ply:GetActiveWeapon()
		
		if IsValid(wep) and wep.CW20Weapon then
			if wep.dt then
				if wep.dt.State == CW_AIMING then
					if wep:_changeTelescopicsFOVIndex(b) then
						return true
					end
					
					if wep.AdjustableZoom then
						CT = CurTime()
						
						if b == self.magnificationIncreaseButton then
							CT = CurTime()
							
							if CT > wep.ZoomWait then
								if wep.ZoomAmount > wep.MinZoom then
									wep.ZoomAmount = math.Clamp(wep.ZoomAmount - 15, wep.MinZoom, wep.MaxZoom)
									surface.PlaySound("weapons/zoom.wav")
									wep.ZoomWait = CT + 0.15
								end
							end
							
							return true
						elseif b == self.magnificationDecreaseButton then
							CT = CurTime()
							
							if CT > wep.ZoomWait then
								if wep.ZoomAmount < wep.MaxZoom then
									wep.ZoomAmount = math.Clamp(wep.ZoomAmount + 15, wep.MinZoom, wep.MaxZoom)
									surface.PlaySound("weapons/zoom.wav")
									wep.ZoomWait = CT + 0.15
								end
							end
							
							return true
						end
					end
				
					if wep.SightBackUpPos or wep.aimPosBackUp then
						if b == "+use" then							
							CT = CurTime()
							
							if CT > wep.DoubleUseKeyTime then
								wep.DoubleUseKeyPresses = 1
							else
								wep.DoubleUseKeyPresses = wep.DoubleUseKeyPresses + 1
							end
							
							-- if we press our use key twice quickly, let us use sights
							if wep.DoubleUseKeyPresses >= 2 then
								local backupPos, backupAng
								
								if wep.aimPosBackUp then
									-- backup sights should use regular ironsights? OK - switch to them
									backupPos = wep.CurIronsightPos
									backupAng = wep.CurIronsightAng
								else
									backupPos = wep.SightBackUpPos
									backupAng = wep.SightBackUpAng
								end
								
								if wep.AimPos == backupPos then
									-- swap back to the sights in case we were already using backup sights
									wep.AimPos = wep.ActualSightPos
									wep.AimAng = wep.ActualSightAng
								else
									-- swap to backup sights
									wep.AimPos = backupPos
									wep.AimAng = backupAng
									
									wep.DoubleUseKeyPresses = 0
								end
							end
							
							wep.DoubleUseKeyTime = CT + 0.2
						end
					end
				else
					if wep.dt.State == CW_CUSTOMIZE then
						--[[if wep.CustomizationTab == CustomizableWeaponry.interactionMenu.CUSTOMIZATION_TAB then
							if wep.processSlotKeyPress(wep, b, p) then
								return true
							end
							
						elseif wep.CustomizationTab == CustomizableWeaponry.interactionMenu.PRESET_TAB then
							if b == "+attack" then
								wep:seekPresetPosition(1)
								return true
							elseif b == "+attack2" then
								wep:seekPresetPosition(-1)
								return true
							elseif b == "+use" then
								if CustomizableWeaponry.preset.canSave(wep) then
									CustomizableWeaponry.preset.makeSavePopup(wep)
								end
								
								return true
							elseif b:find("slot") then
								local pos = wep:getDesiredPreset(b)
								
								if wep:attemptPresetLoad(pos) then
									return true
								end
							end
						end]]--
						
						local result = CustomizableWeaponry.interactionMenu.keyPressed(wep, b, p)
						
						-- if it's true, that means we need to suppress the current key bind
						-- if it's false, that means that we don't need to suppress the current key bind, but we have to stop the key bind processing
						-- if it's nil, that means we shouldn't stop processing nor suppress the key bind here

						if result ~= nil then
							return result
						end
					end
					
					if b == CustomizableWeaponry.customizationMenuKey then
						if CustomizableWeaponry.canOpenInteractionMenu then
							return wep.attemptToggleInteractionMenu(wep)
						end
					end
				end
			end
		end
	else
		wep = ply:GetActiveWeapon()
		
		if IsValid(wep) and wep.CW20Weapon then
			if wep.dt then
				if wep.dt.State == CW_CUSTOMIZE then
					return wep.processSlotKeyPress(wep, b, p)
				end
			end
		end
	end
end

hook.Add("PlayerBindPress", "SWEP.PlayerBindPress (CW 2.0)", SWEP.PlayerBindPress)

function SWEP:processSlotKeyPress(bind, pressed)
	-- figure out which key was pressed

	local num = bind
	local category
	
	if bind:find("slot") then
		num = tonumber(string.Right(bind, 1))
		category = self.Attachments[num]
	else
		category = self.Attachments[num]
	end
	
	if category then
		if pressed then
			local lastAtt = category.last
			
			-- if the key was pressed and there is a sight that can have it's sight color changed, attempt to do so
			if lastAtt then
				local attName = category.atts[category.last]
				local sightColor = self.SightColors[attName]
				
				if sightColor then
					self.SightColorTarget = sightColor
					self.SubCustomizationCycleTime = UnPredictedCurTime() + self.SubCustomizationTriggerTime
				else
					local att = CustomizableWeaponry.registeredAttachmentsSKey[attName]
					
					if att and att.isGrenadeLauncher then
						self.GrenadeTarget = true
						self.SubCustomizationCycleTime = UnPredictedCurTime() + self.SubCustomizationTriggerTime
					else
						self:attemptAttach(num)
					end
				end
			else
				self:attemptAttach(num)
			end
		else
			if self.SubCustomizationCycleTime then
				if UnPredictedCurTime() < self.SubCustomizationCycleTime then
					self:attemptAttach(num)
					self.SubCustomizationCycleTime = nil
					self.SightColorTarget = nil
				end
			end
		end
		
		-- prevent key presses
		return true
	end
	
	-- or not, if it's not a 'slot' key
	return false
end

function SWEP:attemptToggleInteractionMenu()
	if CurTime() < self.InteractionMenuInteractWait then
		return nil
	end
	
	if self:canOpenInteractionMenu() then
		if self.dt.State ~= CW_CUSTOMIZE then
			self.CustomizationTab = CustomizableWeaponry.interactionMenu.CUSTOMIZATION_TAB
			self:setPresetPosition(1, true)
		end
		
		RunConsoleCommand("cw_customize")
		self:delayEverything(self.CUSTOMIZATION_MENU_TOGGLE_WAIT)
		self.InteractionMenuInteractWait = CurTime() + 0.2
		return true
	end
	
	return nil
end

function SWEP:attemptAttach(num)
	if CurTime() < self.AntiAttachmentSwitchSpam then
		return
	end
	
	if self.Attachments[num] then
		RunConsoleCommand("cw_attach", num)
		
		self.AntiAttachmentSwitchSpam = CurTime() + 0.1
		self.JustAttached = true
	end
end


================================================
FILE: cw2/lua/weapons/cw_base/cl_render.lua
================================================
-- fallback texture config
SWEP.shadowMask = "cw2/effects/scope_shadowmask"
SWEP.shadowMaskTextureID = surface.GetTextureID(SWEP.shadowMask)

-- default shadow mask config
SWEP.shadowMaskConfig = {
	textureID = SWEP.shadowMaskTextureID,
	
	w = 768, -- base width of the texture, should match the texture size
	h = 768, -- same, but height
	wOff = 512, -- width offset for the mask texture
	hOff = 512, -- height offset for the mask texture
	maxOffset = 164, -- maximum pixel offset for the 'shadow' effect
	maskMaxStrength = 1, -- at what point will the shadow mask reach peak strength?
	maxZoom = 512, -- how many pixels can we zoom in at most based on the difference between our base viewmodel position and aim position?
	posX = 1, -- shadow offset position multiplier, X
	posY = 1, -- shadow offset position multiplier, Y
	flipAngles = false -- whether we should swap pitch with yaw when calculating the shadow mask offset
}

-- this should only be called inside the scope's RT render method
-- otherwise enjoy problems
-- w, h - RT dimensions
-- shadowMaskConfig is the config of the shadow mask (LOL!!!)
function SWEP:drawLensShadow(w, h, shadowMaskConfig)
	shadowMaskConfig = shadowMaskConfig or self.shadowMaskConfig
	maskTextureID = shadowMaskConfig.textureID or self.shadowMaskTextureID
	local texW, texH = shadowMaskConfig.w, shadowMaskConfig.h
	local wScale, hScale = texW / w, texH / h
	
	local p, y = self.AngleDelta.p, self.AngleDelta.y
	-- also take the delta of blend and aim position into account
		
	-- swap pitch with yaw if needed
	if shadowMaskConfig.flipAngles then
		p, y = y, p
	end
	
	-- calculate mask offset strength, clamp to [-1, 1]
	local deltaX, deltaY = math.min(1, math.max(-1, y / shadowMaskConfig.maskMaxStrength)), math.min(1, math.max(-1, p / shadowMaskConfig.maskMaxStrength))
	
	-- calculate the size diff between the RT size and the mask texture
	local wOff, hOff = shadowMaskConfig.wOff, shadowMaskConfig.hOff
	
	-- grab the base VM pos and aim pos
	local basePos = self:getBaseViewModelPos()
	
	-- normalize the Y value (zoom) between the aim position and the base position
	local aimPos = self.AimPos
	local normY = math.abs(aimPos.y - basePos.y)
	-- normalize Y between aim and blend
	local normYBlend = math.abs(aimPos.y - self.BlendPos.y)
	-- get linear distance between the aim pos Y and base weapon position Y
	-- also clamp to the range of [0, 1]
	-- multiply by two, while keeping it clamped, so that we accentuate the zoom shadow when we just start aiming
	local zoomRel = math.max(0, math.min(1, normYBlend / normY * 2))
	local zoomRelInverse = 1 - zoomRel

	local maxZoom = shadowMaskConfig.maxZoom
	local halfZoom = maxZoom * 0.5
		
	surface.SetDrawColor(255, 255, 255, 255)
	surface.SetTexture(maskTextureID)
	
	-- draw my HUGE ASS into the FRAMEBUFFER!!! yeah. I'm going to CUM. HARD.
	surface.DrawTexturedRect(
		-deltaX * shadowMaskConfig.posX * shadowMaskConfig.maxOffset / wScale * zoomRelInverse + (halfZoom * zoomRel / wScale) - wOff * 0.5 / wScale,
		deltaY * shadowMaskConfig.posY * shadowMaskConfig.maxOffset / hScale * zoomRelInverse + (halfZoom * zoomRel / hScale) - hOff * 0.5 / hScale,
		w + wOff / wScale - (maxZoom * zoomRel / wScale), 
		h + hOff / hScale - (maxZoom * zoomRel / hScale)
	)
	-- OH NO, I COVERED THE SCREEN WITH CUM! sorry bro, but you asked for this anyway! =)
end

function SWEP:setTelescopicsFOVRange(range, rangeSimple)
	if range then
		self.telescopicsFOVRange = range
		self.telescopicsFOVIndex = #range
		
		self.simpleTelescopicsFOVRange = rangeSimple
		
		self:changeTelescopicsFOVIndex(0)
	else
		self.telescopicsFOVRange = nil
		self.telescopicsFOVIndex = nil
		self.telescopicsFOV = nil
	end
end

function SWEP:adjustTelescopicsFOV(renderData)
	-- adjusts telescopics FOV based on the current zoom settings
	if self.telescopicsFOV then
		renderData.fov = self.telescopicsFOV
	end
end

function SWEP:_changeTelescopicsFOVIndex(bind)
	if bind == self.magnificationIncreaseButton then
		if self:changeTelescopicsFOVIndex(1) then
			surface.PlaySound("cw/switch3.wav")
		end
		
		return true
	elseif bind == self.magnificationDecreaseButton then
		if self:changeTelescopicsFOVIndex(-1) then
			surface.PlaySound("cw/switch1.wav")
		end
		
		return true
	end
	
	return false
end

function SWEP:changeTelescopicsFOVIndex(direction)
	if self.telescopicsFOVRange then
		local newIndex = math.max(1, math.min(#self.telescopicsFOVRange, self.telescopicsFOVIndex + direction))
		local prevIndex = self.telescopicsFOVIndex
		self.telescopicsFOVIndex = newIndex
		self.telescopicsFOV = self.telescopicsFOVRange[newIndex]
		
		self.SimpleTelescopicsFOV = self.simpleTelescopicsFOVRange[newIndex]
		
		return newIndex ~= prevIndex
	end
	
	return false
end


================================================
FILE: cw2/lua/weapons/cw_base/cl_umsgs.lua
================================================
local function CW20_DEPLOYANGLE(um)
	local ang = um:ReadAngle()
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()

	if IsValid(wep) and wep.CW20Weapon then
		wep.DeployAngle = ang
	end
end

usermessage.Hook("CW20_DEPLOYANGLE", CW20_DEPLOYANGLE)

local function CW20_DEPLOY()
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()

	if IsValid(wep) and wep.CW20Weapon then
		wep:Deploy()
	end
end

usermessage.Hook("CW20_DEPLOY", CW20_DEPLOY)

local function CW20_THROWGRENADE()
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()

	if IsValid(wep) and wep.CW20Weapon then
		CustomizableWeaponry.quickGrenade.throw(wep)
	end
end

usermessage.Hook("CW20_THROWGRENADE", CW20_THROWGRENADE)

local function CW20_GLOBALDELAY(um)
	local delay = um:ReadFloat()
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()

	if IsValid(wep) and wep.CW20Weapon then
		wep:delayEverything(delay)
		wep:setGlobalDelay(delay)
	end
end

usermessage.Hook("CW20_GLOBALDELAY", CW20_GLOBALDELAY)

local function CW20_FOOTSTEP(um)
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()

	if IsValid(wep) and wep.CW20Weapon then
		wep:addRunTime()
	end
end

usermessage.Hook("CW20_FOOTSTEP", CW20_FOOTSTEP)

local function CW20_FORCESTATE(um)
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()

	if IsValid(wep) and wep.CW20Weapon then
		wep:forceState(um:ReadShort(), um:ReadFloat())
	end
end

usermessage.Hook("CW20_FORCESTATE", CW20_FORCESTATE)

local function CW20_M203ON()
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()

	if IsValid(wep) and wep.CW20Weapon then
		wep:enableM203()
	end
end

usermessage.Hook("CW20_M203ON", CW20_M203ON)

local function CW20_M203OFF()
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()

	if IsValid(wep) and wep.CW20Weapon then
		wep:disableM203(true)
	end
end

usermessage.Hook("CW20_M203OFF", CW20_M203OFF)

local function CW20_M203OFF_RELOAD()
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()

	if IsValid(wep) and wep.CW20Weapon then
		wep:disableM203(false)
	end
end

usermessage.Hook("CW20_M203OFF_RELOAD", CW20_M203OFF_RELOAD)

local function CW20_FIREM203()
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()

	if IsValid(wep) and wep.CW20Weapon then
		wep:fireM203()
	end
end

usermessage.Hook("CW20_FIREM203", CW20_FIREM203)

local function CW20_RELOADM203()
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()

	if IsValid(wep) and wep.CW20Weapon then
		wep:reloadM203()
	end
end

usermessage.Hook("CW20_RELOADM203", CW20_RELOADM203)

local function CW20_GRENADETYPE()
	local grenType = net.ReadUInt(8)
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()

	if IsValid(wep) and wep.CW20Weapon then
		wep.Grenade40MM = grenType
		
		if CustomizableWeaponry.playSoundsOnInteract then
			wep:EmitSound("CW_M203_OPEN")
		end
	end
end

net.Receive("CW20_GRENADETYPE", CW20_GRENADETYPE)

local function CW20_M203CHAMBER()
	local wep = net.ReadEntity()--um:ReadEntity()
	local state = net.ReadBool() --um:ReadBool()
	
	wep.M203Chamber = state
end

net.Receive("CW20_M203CHAMBER", CW20_M203CHAMBER)


================================================
FILE: cw2/lua/weapons/cw_base/sh_ammotypes.lua
================================================
function CW_AddAmmoType(name)
	game.AddAmmoType({name = name,
	dmgtype = DMG_BULLET})
	
	if CLIENT then
		language.Add(name .. "_ammo", name .. " Ammo")
	end
end


================================================
FILE: cw2/lua/weapons/cw_base/sh_anims.lua
================================================
local SP = game.SinglePlayer()

-- lol
function SWEP:sendWeaponAnim(anim, speed, cycle)
	-- what the fuck are you doing without an anim name
	if not anim then
		return
	end
	
	-- make sure we don't set/send nil args
	speed = speed or 1
	cycle = cycle or 0
	
	-- prediction is disabled in SP, so just send the anim via UMSG
	if SP and SERVER then
		umsg.Start("CW20_ANIMATE", self.Owner)
			umsg.String(anim)
			umsg.Float(speed)
			umsg.Float(cycle)
		umsg.End()
		
		return
	end
	
	if self.animCallbacks and self.animCallbacks[anim] then
		self.animCallbacks[anim](self)
	end
	
	-- in MP just play the anim on the player, clientside
	
	if CLIENT then
		if anim:find("reload") then
			if self:Clip1() == 0 then
				self.wasEmpty = true
				
				if self.BoltBoneID and self.DontHoldWhenReloading then
					self:setBoltBonePosition(Vector(0, 0, 0))
				end
			else
				self.wasEmpty = false
			end
		end
	end
	
	self:playAnim(anim, speed, cycle)
end

function SWEP:playAnim(anim, speed, cycle, ent)
	ent = ent or self.CW_VM
	cycle = cycle or 0
	speed = speed or 1
	
	local foundAnim = anim
	self.lastPlayedAnim = anim
	
	if ent == self.CW_VM then
		foundAnim = self.Animations[anim]
		
		if not foundAnim then
			return
		end
		
		if type(foundAnim) == "table" then
			foundAnim = table.Random(foundAnim)
		end
		
		if self.Sounds[foundAnim] then
			self:setCurSoundTable(self.Sounds[foundAnim], speed, cycle, foundAnim)
		else
			self:removeCurSoundTable()
		end
	end
	
	if SERVER then
		return
	end
	
	ent:ResetSequence(foundAnim)
	
	if cycle > 0 then
		ent:SetCycle(cycle)
	else
		ent:SetCycle(0)
	end
	
	ent:SetPlaybackRate(speed)
end

function SWEP:getLastPlayedAnim()
	if self.lastPlayedAnim then
		return self.Animations[self.lastPlayedAnim]
	end
end

function SWEP:setCurSoundTable(animTable, speed, cycle, origAnim)
	local found = 1
	
	if cycle ~= 0 then
		-- get the length of the animation and relative time to animation
		local animLen = self.CW_VM:SequenceDuration()
		local timeRel = animLen * cycle
		local foundInTable = false
		
		-- loop through the table, and find the entry which the cycle has not passed yet
		for k, v in ipairs(animTable) do
			if timeRel < v.time then
				found = k
				foundInTable = true
				break
			end
		end
		
		if not foundInTable then
			found = false
		end
	end
	
	if found then
		self.CurSoundTable = animTable
		self.CurSoundEntry = found
		self.SoundTime = (CLIENT and UnPredictedCurTime() or CurTime())
		self.SoundSpeed = speed
		
		if CLIENT then
			if origAnim == self.Animations.draw then
				if self.drawnFirstTime then
					self.SoundTime = self.SoundTime - 0.22
				end
			
				self.drawnFirstTime = true
			end
		end
	else
		self:removeCurSoundTable()
	end
end

function SWEP:removeCurSoundTable()
	-- wipes all current animation sound table information to turn it off
	self.CurSoundTable = nil
	self.CurSoundEntry = nil
	self.SoundTime = nil
	self.SoundSpeed = nil
end

if CLIENT then
	local function CW20_ANIMATE(um)
		local anim = um:ReadString()
		local speed = um:ReadFloat()
		local cycle = um:ReadFloat()
		
		local ply = LocalPlayer()
		local wep = ply:GetActiveWeapon()
		
		if not IsValid(wep) then
			return
		end
		
		if wep.sendWeaponAnim then
			wep:sendWeaponAnim(anim, speed, cycle)
		end
	end
	
	usermessage.Hook("CW20_ANIMATE", CW20_ANIMATE)
	
	local function CW20_EFFECTS()
		local ply = LocalPlayer()
		local wep = ply:GetActiveWeapon()
		
		if not IsValid(wep) or not  wep.CW20Weapon then
			return
		end
		
		wep:makeFireEffects()
	end
	
	usermessage.Hook("CW20_EFFECTS", CW20_EFFECTS)
end


================================================
FILE: cw2/lua/weapons/cw_base/sh_attachments.lua
================================================
--[[ attachment table structure:
1st index - table, which contains 1 table and 1 var: atts - the attachments table, last - the integer which indicates the last attachment which was attached
]]--
SWEP.AttachSoundDelay = 0

if SERVER then
	util.AddNetworkString("CW20_ATTACH")
	util.AddNetworkString("CW20_DETACH")
	util.AddNetworkString("CW20_DETACHALL")
	util.AddNetworkString("CW20_PRESETSUCCESS")
	util.AddNetworkString("CW20_PRESETDETACH")
end

function SWEP:_attach(cur, curPos, inherit)
	self.LastPreset = nil
	local attTable = self.Attachments[cur]
	
	if SERVER then
		net.Start("CW20_ATTACH")
			net.WriteEntity(self)
			net.WriteString(cur)
			net.WriteUInt(curPos, 8)
		net.Send(self.Owner)
	end
	
	local att = inherit or CustomizableWeaponry:findAttachment(attTable.atts[curPos])
	
	if not att then
		return false
	end
	
	CustomizableWeaponry.callbacks.processCategory(self, "preAttachAttachment", cur, curPos)
	
	local lastIsSight = false
	
	if attTable.last then
		local last = attTable.atts[attTable.last]
		
		if CLIENT then
			local prevAttachmentData = CustomizableWeaponry:findAttachment(last)
			
			-- remove telescopics FOV range if the detached attachment is a sight
			if prevAttachmentData.isSight then
				self.newTelescopicsFOV = nil
				
				if prevAttachmentData.telescopicsFOVRange then
					self:setTelescopicsFOVRange(nil)
				end
			end
			
			if self.AttachmentModelsVM then
				self:setAttachmentModelState(last, false)
			end
		end
		
		self:_detach(cur, attTable.last, true)
	end
	
	self:addStatModifiers(att.statModifiers)
	self.ActiveAttachments[att.name] = true
	self:checkAttachmentDependency()
	
	for varName, data in pairs(CustomizableWeaponry.knownVariableTexts) do
		if att[varName] then
			data.attachCallback(self, att)
		end
	end
	
	if att.attachFunc then
		att.attachFunc(self)
	end

	if CLIENT then
		-- if there is a model with the provided name, make it visible
		
		if self.AttachmentModelsVM then
			local attName = attTable.atts[curPos]
			local model = self.AttachmentModelsVM[attName]

			self:setAttachmentModelState(attName, true)
			
			-- if we're using a rail in conjunction with sights, make it visible upon attachment
			if att.isSight then
				self.newTelescopicsFOV = att.newTelescopicsFOV
				
				if att.telescopicsFOVRange then
					self:setTelescopicsFOVRange(att.telescopicsFOVRange, att.simpleTelescopicsFOVRange)
				end
			
				self.AimPos = self[att.aimPos[1]]
				self.AimAng = self[att.aimPos[2]]
				self.ZoomAmount = att.FOVModifier or self.ZoomAmount
				
				--if the current attachment has backup sights, we can swap to them
				
				self.ActualSightPos = self.AimPos
				self.ActualSightAng = self.AimAng
				
				if self.BackupSights then
					local backUp = self.BackupSights[att.name]
					
					if backUp then						
						self.SightBackUpPos = backUp[1]
						self.SightBackUpAng = backUp[2]
						
						self.aimPosBackUp = backUp.aimPosBackUp
					else
						self.SightBackUpPos = nil
						self.SightBackUpAng = nil
						
						self.aimPosBackUp = nil
					end
				end
				
				if self.SightWithRail then
					-- if the attachment disallows display of a rail, turn it off, otherwise, turn it on
					local state
					
					if att.withoutRail or (model and model.norail) then
						state = false
					else
						state = true
					end

					self:setAttachmentModelState("md_rail", state)

					if state then
						if self.RailBGs then
							self.CW_VM:SetBodygroup(self.RailBGs.main, self.RailBGs.on)
						end
					else
						if self.RailBGs then
							self.CW_VM:SetBodygroup(self.RailBGs.main, self.RailBGs.off)
						end
					end
				end
				
				-- apply this attachment's reticle draw function, if it has it
				self.reticleFunc = att.drawReticle
				self.renderTargetFunc = att.drawRenderTarget
				
				if not att.isBG then
					if self.SightBGs and self.SightBGs.none then
						self:setBodygroup(self.SightBGs.main, self.SightBGs.none)
					end
				end
			end
			
			if self.AttachmentModelCombos and att.AttachmentModelCombos[att.name] then
				for key, attName in ipairs(att.AttachmentModelCombos[att.name]) do
					self:setAttachmentModelState(attName, true)
				end
			end
			
			if att.elementRender then
				self.elementRender[att.name] = att.elementRender
			end
			
			if att.elementRenderPost then
				self.elementRenderPost[att.name] = att.elementRenderPost
			end
		end
	end

	attTable.last = curPos
	
	if CLIENT then
		self:updateAttachmentPositions()
	end
	
	self:recalculateStats()
	
	CustomizableWeaponry.callbacks.processCategory(self, "postAttachAttachment", cur, curPos)
	
	return true
end

function SWEP:resetPostDetach(att, attCategory)
	-- reset things like aim FOV and reticle functions in case the detached attachment is a sight
	local attName = attCategory.atts[attCategory.last]
	
	CustomizableWeaponry.callbacks.processCategory(self, "preDetachAttachment", att, attCategory)
	
	if att.isSight then
		self.ZoomAmount = self.ZoomAmount_Orig
		self.reticleFunc = nil
		
		if self.SightWithRail then
			-- make the rail inactive in case the weapon uses it for the sights
			self:setAttachmentModelState("md_rail", false)
			
			if self.RailBGs then
				self.CW_VM:SetBodygroup(self.RailBGs.main, self.RailBGs.off)
			end
		end
		
		if self.SightBGs and self.SightBGs.none then
			self:setBodygroup(self.SightBGs.main, 0)
		end
		
		if CLIENT then
			self:resetAimToIronsights()
		end
	end
	
	self.ActiveAttachments[att.name] = false
	attCategory.last = nil
	
	if CLIENT then
		-- make attachment models inactive
		if self.AttachmentModelsVM then			
			self:setAttachmentModelState(attName, false)
		
			if self.AttachmentModelCombos and self.AttachmentModelCombos[att.name] then
				for key, attName in ipairs(self.AttachmentModelCombos[att.name]) do
					self:setAttachmentModelState(attName, false)
				end
			end
		end
		
		-- remove any rendering functions it might have had
		self.elementRender[att.name] = nil
		self.elementRenderPost[att.name] = nil
	end
	
	CustomizableWeaponry.callbacks.processCategory(self, "postDetachAttachment", att, attCategory)
end

function SWEP:_detach(category, pos, skipDependencyCheck)
	self.LastPreset = nil
	local att = self.Attachments[category]
	
	local foundAtt = CustomizableWeaponry:findAttachment(att.atts[pos])
	
	self:removeStatModifiers(foundAtt.statModifiers)

	for varName, data in pairs(CustomizableWeaponry.knownVariableTexts) do
		if foundAtt[varName] then
			data.detachCallback(self, foundAtt)
		end
	end

	if foundAtt.detachFunc then
		foundAtt.detachFunc(self)
	end
	
	self:resetPostDetach(foundAtt, att)
	
	-- only skip the dependency check if we're told to do so
	if not skipDependencyCheck then
		self:checkAttachmentDependency()
	end
	
	self:recalculateStats()
	
	if CLIENT then
		self:updateAttachmentPositions()
	end
end

function SWEP:detachAll()
	for k, v in pairs(self.Attachments) do
		if v.last then
			self:_detach(k, v.last)
		end
	end
	
	if SERVER then
		net.Start("CW20_DETACHALL")
			net.WriteEntity(self)
		net.Send(self.Owner)
		
		--SendUserMessage("CW20_DETACHALL", self.Owner)
	end
end

function SWEP:countActiveAttachments()
	local amount = 0
	
	for k, v in pairs(self.ActiveAttachments) do
		if v then
			amount = amount + 1
		end
	end
	
	return amount
end

-- this function is used when you just want to check whether an attachment of some kind can be attached
-- honestly this is some spaghetti point at this point, rip
-- ideally I should rewrite the entire base AGAIN, but fuck that lmao
function SWEP:canAttachSpecificAttachment(attachmentName, ply, imaginaryAttachments, imaginaryActiveAttachments, lookIn, attachmentCategoryData)
	local state, failureId, extraData = self:_canAttachSpecificAttachment(attachmentName, ply, imaginaryAttachments, imaginaryActiveAttachments, lookIn, attachmentCategoryData)
	local newState, newResult, newFailureId = CustomizableWeaponry.callbacks.processCategory(self, "canAttachSpecificAttachment", ply, attachmentName, state, result, failureId)
	
	if newState ~= nil then
		state = newState
	end
	
	if newResult ~= nil then
		result = newResult
	end
	
	if newFailureId ~= nil then
		failureId = newFailureId
	end
	
	return state, result, failureId
end

function SWEP:_canAttachSpecificAttachment(attachmentName, ply, imaginaryAttachments, imaginaryActiveAttachments, lookIn, attachmentCategoryData)
	ply = ply or self.Owner
	
	local result, failureID = nil
	
	if not attachmentCategoryData then
		for category, data in pairs(self.Attachments) do
			for key, attachment in ipairs(data.atts) do
				if attachment == attachmentName then
					attachmentCategoryData = data
					break
				end
			end
		end
	end
	
	result, failureID = self:performAttachmentEligibilityCheck(attachmentCategoryData, attachmentName, ply, imaginaryAttachments, imaginaryActiveAttachments, lookIn)
	
	return result, failureID
end

function SWEP:performAttachmentEligibilityCheck(attachmentCategoryData, attachmentName, playerObject, attachmentList, activeAttachmentList, playerOwnedAttachmentList)
	local att = CustomizableWeaponry.registeredAttachmentsSKey[attachmentName]
	
	if att.dependencies then
		local can, dependency = CustomizableWeaponry.canBeAttached(self, att, attachmentList)
		
		if not can then
			return false, self.UnavailableAttachmentEnum.NEED_ATTACHMENTS, dependency
		end
	end
	
	if attachmentCategoryData.exclusions then
		local has, exclusion = self:hasExcludedAttachment(attachmentCategoryData.exclusions, activeAttachmentList)
		
		if has then
			return true, self.UnavailableAttachmentEnum.INCOMPATIBILITY, exclusion
		end
	end
	
	-- checking whether it has dependencies or not saves us a loop
	if CustomizableWeaponry:hasAttachment(playerObject, att.name, playerOwnedAttachmentList) then
		local can, result, returnData = self:isAttachmentEligible(att.name, activeAttachmentList)

		if not can then
			return false, (result == self.AttachmentEligibilityEnum.ACTIVE_ATTACHMENT_EXCLUSION and self.UnavailableAttachmentEnum.INCOMPATIBLE_ATTACHMENT_PRESENT or self.UnavailableAttachmentEnum.DEPENDENT_ATTACHMENT_NOT_PRESENT), returnData -- -3 exclusion; -4 dependency
		end

		local can, result, returnData = self:isCategoryEligible(attachmentCategoryData.dependencies, attachmentCategoryData.exclusions, activeAttachmentList)
		
		if not can then
			return false, (result == self.AttachmentEligibilityEnum.ACTIVE_ATTACHMENT_EXCLUSION and self.UnavailableAttachmentEnum.INCOMPATIBLE_CATEGORY_PRESENT or self.UnavailableAttachmentEnum.DEPENDENT_CATEGORY_NOT_PRESENT), returnData -- -5 exclusion; -6 dependency
		end
		
		return true
	else
		return false, self.UnavailableAttachmentEnum.PLAYER_DOES_NOT_HAVE_ATTACHMENT
	end
	
	return false, self.UnavailableAttachmentEnum.MISC_FAILURE
end

if CLIENT then
	local function CW20_ATTACH(um)
		local wep = net.ReadEntity() --um:ReadEntity()
		local category = net.ReadString() --um:ReadString()
		local pos = net.ReadUInt(8) --um:ReadShort()
		
		local numberCategory = tonumber(category)
		
		if numberCategory then
			category = numberCategory
		end
		
		local ply = LocalPlayer()
		
		if not IsValid(wep) or not wep.CW20Weapon then
			return
		end
		
		if wep:_attach(category, pos) then
			if wep:canPlayCustomizeSound() and CurTime() > wep.AttachSoundDelay then
				surface.PlaySound("cw/attach.wav")
				wep.AttachSoundDelay = CurTime() + FrameTime() * 3
			end
		end
	end
	
	net.Receive("CW20_ATTACH", CW20_ATTACH)
	
	local function CW20_DETACH()
		local wep = net.ReadEntity() --um:ReadEntity()
		local category = net.ReadString() --um:ReadString()
		local pos = net.ReadUInt(8) --um:ReadShort()
		
		local numberCategory = tonumber(category)
		
		if numberCategory then
			category = numberCategory
		end
		
		local ply = LocalPlayer()
		
		if not IsValid(wep) or not wep.CW20Weapon then
			return
		end
		
		wep:_detach(category, pos)
		
		if CustomizableWeaponry.playSoundsOnInteract then
			if wep:canPlayCustomizeSound() and CurTime() > wep.AttachSoundDelay then
				surface.PlaySound("cw/detach.wav")
				wep.AttachSoundDelay = CurTime() + FrameTime() * 3
			end
		end
	end
	
	net.Receive("CW20_DETACH", CW20_DETACH)
	
	local function CW20_DETACHALL(data)
		local ply = LocalPlayer()
		local wep = net.ReadEntity() --data:ReadEntity()
		
		if not IsValid(wep) or not wep.CW20Weapon then
			return
		end
		
		CustomizableWeaponry.colorableParts.resetColors(wep)
		wep:detachAll(category, pos)
	end
	
	net.Receive("CW20_DETACHALL", CW20_DETACHALL)
	
	local function CW20_PRESETSUCCESS()
		local presetName = net.ReadString()
		
		local ply = LocalPlayer()
		local wep = ply:GetActiveWeapon()
		
		if not IsValid(wep) or not wep.CW20Weapon then
			return
		end
		
		CustomizableWeaponry.preset.postLoad(wep, presetName)
		wep.LastPreset = presetName
	end
	
	net.Receive("CW20_PRESETSUCCESS", CW20_PRESETSUCCESS)
	
	local function CW20_PRESETDETACH()
		if CustomizableWeaponry.playSoundsOnInteract then
			surface.PlaySound("cw/detach.wav")
		end
	end
	
	net.Receive("CW20_PRESETDETACH", CW20_PRESETDETACH)
end


================================================
FILE: cw2/lua/weapons/cw_base/sh_bullets.lua
================================================
local Dir, Dir2, dot, sp, ent, trace, seed, hm

SWEP.NormalTraceMask = bit.bor(CONTENTS_SOLID, CONTENTS_OPAQUE, CONTENTS_MOVEABLE, CONTENTS_DEBRIS, CONTENTS_MONSTER, CONTENTS_HITBOX, 402653442, CONTENTS_WATER)
SWEP.WallTraceMask = bit.bor(CONTENTS_TESTFOGVOLUME, CONTENTS_EMPTY, CONTENTS_MONSTER, CONTENTS_HITBOX)

SWEP.NoPenetration = {[MAT_SLOSH] = true}
SWEP.NoRicochet = {[MAT_FLESH] = true, [MAT_ANTLION] = true, [MAT_BLOODYFLESH] = true, [MAT_DIRT] = true, [MAT_SAND] = true, [MAT_GLASS] = true, [MAT_ALIENFLESH] = true, [MAT_GRASS] = true}
SWEP.PenetrationMaterialInteraction = {[MAT_SAND] = 0.5, [MAT_DIRT] = 0.8, [MAT_METAL] = 1.1, [MAT_TILE] = 0.9, [MAT_WOOD] = 1.2}
local bul, tr = {}, {}
local SP = game.SinglePlayer()
local zeroVec = Vector(0, 0, 0)

local reg = debug.getregistry()
local GetShootPos = reg.Player.GetShootPos

SWEP.bulletCallback = function(ply, traceResult, dmgInfo) -- create the callback function once, to avoid function spam
	CustomizableWeaponry.callbacks.processCategory(ply:GetActiveWeapon(), "bulletCallback", ply, traceResult, dmgInfo)
end

function SWEP:canPenetrate(traceData, direction)
	local dot = nil
	
	if not self.NoPenetration[traceData.MatType] then
		dot = self:getSurfaceReflectionDotProduct(traceData, direction)
		ent = traceData.Entity
	
		if not ent:IsNPC() and not ent:IsPlayer() then
			if dot > 0.26 and self.CanPenetrate then
				return true, dot
			end
		end
	end
	
	return false, dot
end

function SWEP:getSurfaceReflectionDotProduct(traceData, dir)
	return -dir:DotProduct(traceData.HitNormal)
end

function SWEP:canRicochet(traceData, penetrativeRange)
	penetrativeRange = penetrativeRange or self.PenetrativeRange

	if self.CanRicochet and not self.NoRicochet[traceData.MatType] and penetrativeRange * traceData.Fraction < penetrativeRange then
		return true
	end
	
	return false
end

function SWEP:FireBullet(damage, cone, clumpSpread, bullets)
	sp = GetShootPos(self.Owner)
	local commandNumber = self.Owner:GetCurrentCommand():CommandNumber()
	math.randomseed(commandNumber)
	
	if self.Owner:Crouching() then
		cone = cone * 0.85
	end
	
	Dir = (self.Owner:EyeAngles() + self.Owner:GetViewPunchAngles() + Angle(math.Rand(-cone, cone), math.Rand(-cone, cone), 0) * 25):Forward()
	clumpSpread = clumpSpread or self.ClumpSpread
	
	CustomizableWeaponry.callbacks.processCategory(self, "adjustBulletStructure", bul)
	
	for i = 1, bullets do
		Dir2 = Dir
		
		if clumpSpread and clumpSpread > 0 then
			Dir2 = Dir + Vector(math.Rand(-1, 1), math.Rand(-1, 1), math.Rand(-1, 1)) * clumpSpread
		end
		
		if not CustomizableWeaponry.callbacks.processCategory(self, "suppressDefaultBullet", sp, Dir2, commandNumber) then
			bul.Num = 1
			bul.Src = sp
			bul.Dir = Dir2
			bul.Spread 	= zeroVec --Vector(0, 0, 0)
			bul.Tracer	= 3
			bul.Force	= damage * 0.3
			bul.Damage = math.Round(damage)
			bul.Callback = self.bulletCallback
			bul.wep = self
			
			self.Owner:FireBullets(bul)
			
			tr.start = sp
			tr.endpos = tr.start + Dir2 * self.PenetrativeRange
			tr.filter = self.Owner
			tr.mask = self.NormalTraceMask
			
			trace = util.TraceLine(tr)
				
			if trace.Hit and not trace.HitSky then
				local canPenetrate, dot = self:canPenetrate(trace, Dir2)
				
				if canPenetrate and dot > 0.26 then
					tr.start = trace.HitPos
					tr.endpos = tr.start + Dir2 * self.PenStr * (self.PenetrationMaterialInteraction[trace.MatType] and self.PenetrationMaterialInteraction[trace.MatType] or 1) * self.PenMod
					tr.filter = self.Owner
					tr.mask = self.WallTraceMask
					
					trace = util.TraceLine(tr)
					
					tr.start = trace.HitPos
					tr.endpos = tr.start + Dir2 * 0.1
					tr.filter = self.Owner
					tr.mask = self.NormalTraceMask
					
					trace = util.TraceLine(tr) -- run ANOTHER trace to check whether we've penetrated a surface or not
					
					if not trace.Hit then
						bul.Num = 1
						bul.Src = trace.HitPos
						bul.Dir = Dir2
						bul.Spread 	= Vec0
						bul.Tracer	= 4
						bul.Force	= damage * 0.15
						bul.Damage = bul.Damage * 0.5
						
						self.Owner:FireBullets(bul)
						
						bul.Num = 1
						bul.Src = trace.HitPos
						bul.Dir = -Dir2
						bul.Spread 	= Vec0
						bul.Tracer	= 4
						bul.Force	= damage * 0.15
						bul.Damage = bul.Damage * 0.5
						
						self.Owner:FireBullets(bul)
					end
				else
					if self:canRicochet(trace) then
						dot = dot or self:getSurfaceReflectionDotProduct(trace, Dir2)
						Dir2 = Dir2 + (trace.HitNormal * dot) * 3
						math.randomizeVector(Dir2, 0.06)
						
						bul.Num = 1
						bul.Src = trace.HitPos
						bul.Dir = Dir2
						bul.Spread 	= Vec0
						bul.Tracer	= 0
						bul.Force	= damage * 0.225
						bul.Damage = bul.Damage * 0.75
						
						self.Owner:FireBullets(bul)
					end
				end
			end
		end
	end
		
	tr.mask = self.NormalTraceMask
end



================================================
FILE: cw2/lua/weapons/cw_base/sh_general.lua
================================================
-- various convenience functions related to the weapon

local reg = debug.getregistry()
local GetVelocity = reg.Entity.GetVelocity
local Length = reg.Vector.Length
local GetAimVector = reg.Player.GetAimVector

-- no reason to get it over and over again, since if it's singleplayer, it's singleplayer
local SP = game.SinglePlayer()

--[[attachment inter-dependency logic:
requires a table, ie SWEP.AttachmentPosDependency
first index a string containing attachments that it depends on
second index is a string which contains the vector position
]]--

if SERVER then
	util.AddNetworkString("CW20_M203CHAMBER")
end

function LerpCW20(val, min, max) -- basically a wrapper that limits 'val' (aka progress) to a max of 1
	val = val > 1 and 1 or val
	return Lerp(val, min, max)
end

function SWEP:canPlayCustomizeSound()
	return CustomizableWeaponry.playSoundsOnInteract or (CustomizableWeaponry.playSoundsOnModify and self.dt.State == CW_CUSTOMIZE)
end

function SWEP:canCustomize()
	if not self.CanCustomize then
		return false
	end
	
	if self.ReloadDelay then
		return false
	end
	
	if self.NoCustomizeStates[self.dt.State] then
		return false
	end
	
	if not self.Owner:OnGround() then
		return false
	end
	
	return true
end

function SWEP:revertToOriginalIronsights()
	if SERVER then
		return
	end
	
	self.CurIronsightPos = self.AimPos_Orig
	self.CurIronsightAng = self.AimAng_Orig
	
	if not self:isAttachmentActive("sights") then
		self.AimPos = self.CurIronsightPos
		self.AimAng = self.CurIronsightAng
	end
end

function SWEP:isAttachmentCategoryActive()
	
end

function SWEP:isLowOnMagAmmo()
	if self:Clip1() <= self.Primary.ClipSize * 0.25 or self:getReloadProgress() then
		return true
	end
end

function SWEP:isLowOnAmmo()
	if self.Owner:GetAmmoCount(self.Primary.Ammo) <= self.Primary.ClipSize then
		return true
	end
	
	return false
end

function SWEP:isLowOnTotalAmmo()
	if self.Owner:GetAmmoCount(self.Primary.Ammo) + self:Clip1() <= self.Primary.ClipSize * 2 then
		return true
	end
	
	return false
end

function SWEP:setM203Chamber(state)
	self.M203Chamber = state
	self:networkM203Chamber()
end

function SWEP:networkM203Chamber()
	net.Start("CW20_M203CHAMBER")
		net.WriteEntity(self)
		net.WriteBool(self.M203Chamber)
	net.Send(self.Owner)
end

function SWEP:resetAimBreathingState()
	self.AimBreathingEnabled = self.AimBreathingEnabled_Orig
end

function SWEP:maxOutWeaponAmmo(desiredAmmo)
	self:SetClip1(desiredAmmo + (self.Chamberable and 1 or 0))
end

function SWEP:isAiming()
	return self.dt.State == CW_AIMING
end

function SWEP:setupSuppressorPositions()
	self.SuppressorPositions = self.SuppressorPositions or {}
	
	if self.AttachmentModelsVM then
		for k, v in pairs(self.AttachmentModelsVM) do
			-- easy way to find all suppressor attachments, 'silencer' is there in case someone is gun-illiterate enough and calls them incorrectly
			if k:find("suppress") or k:find("silencer") then
				self.SuppressorPositions[k] = v.pos
				v.origPos = v.pos
			end
		end
	end
end

function SWEP:updateAttachmentPositions()
	--[[if not self.AttachmentPosDependency and not self.AttachmentAngDependency then
		return
	end]]
	
	if not self.AttachmentModelsVM then
		return
	end
	
	-- loop through the VM attachment table
	for k, v in pairs(self.AttachmentModelsVM) do
		-- iterate through active attachments only
		if v.active then
			-- check for inter-dependencies of this attachment
			
			if self.AttachmentPosDependency then
				local inter = self.AttachmentPosDependency[k]
				
				if inter then
					-- loop through the attachment table, find active attachments
					local found = false
					
					for k2, v2 in pairs(inter) do
						if self.ActiveAttachments[k2] then
							v.pos = inter[k2]
							found = true
						end
					end
					
					-- reset the position in case none are active
					if not found then
						v.pos = v.origPos
					end
				end
			end
			
			if self.AttachmentAngDependency then
				local inter = self.AttachmentAngDependency[k]
				
				if inter then
					-- loop through the attachment table, find active attachments
					local found = false
					
					for k2, v2 in pairs(inter) do
						if self.ActiveAttachments[k2] then
							v.angle = inter[k2]
							found = true
						end
					end
					
					-- reset the position in case none are active
					if not found then
						v.angle = v.origAng
					end
				end
			end
			
			if self:getPreventedAdjustment(v) then
				v.pos = v.origPos * 1
			end
		end
	end
end

-- returns whether adjustment of this attachment's position is prevented by another active attachment
-- attData is the attachment entry in AttachmentModelsVM
-- there are no checks related to AttachmentPosDependency/AttachmentAngDependency
-- because in most cases if something is adjustable it's likely not to depend on other attachments position-wise
function SWEP:getPreventedAdjustment(attData)
	-- check whether the attachment has adjustment and should be prevented in some cases
	if attData.adjustment and attData.adjustment.preventedBy then
		-- check whether any of the attachments should be reset
		local list = attData.adjustment.preventedBy
		local activeMap = self.ActiveAttachments
		
		for i = 1, #list do
			if activeMap[list[i]] then
				return true
			end
		end
	end
	
	return false
end

function SWEP:updateSuppressorPosition(suppressor)
	if not self.SuppressorPositions then
		return
	end
	
	if not self.AttachmentModelsVM then
		return
	end
	
	local found = false
	
	-- loop through the table
	for k, v in pairs(self.Attachments) do
		if v.last then -- check active attachments
			-- if there is one and it is in the SuppressorPositions table
			local suppressorPos = self.SuppressorPositions[v.atts[v.last]]
			
			if suppressorPos then
				--find every single VM element with part of the name "suppress" or "silencer" and update it's pos to what it is
				
				for k2, v2 in pairs(self.AttachmentModelsVM) do
					if CustomizableWeaponry.suppressors[k2] then
					--if k2:find("suppress") or k2:find("silencer") then
						v2.pos = suppressorPos
						found = true
						break
					end
				end
			end
		end
	end
	
	-- if nothing is found, revert the position back to origPos
	
	if not found then
		for k, v in pairs(self.AttachmentModelsVM) do
			if CustomizableWeaponry.suppressors[k] then
				v.pos = v.origPos
			end
		end
	end
end

function SWEP:canSeeThroughTelescopics(aimPosName)
	if self.dt.State == CW_AIMING and not self.Peeking and self.AimPos == self[aimPosName] then
		local canUseSights = CustomizableWeaponry.grenadeTypes:canUseProperSights(self.Grenade40MM)
		
		if self.dt.M203Active then
			if self.M203Chamber then
				if canUseSights then
					return true
				end
			else
				return true
			end
		else
			return true
		end
	end
	
	return false
end

function SWEP:hasExcludedAttachment(tbl, targetTable)
	targetTable = targetTable or self.ActiveAttachments
	
	for k, v in pairs(tbl) do
		if targetTable[v] then
			return true, targetTable[v]
		end
	end
	
	return false
end

function SWEP:isCategoryEligible(depend, exclude, activeAttachments)
	local state = false
	
	activeAttachments = activeAttachments or self.ActiveAttachments
	
	-- if there are dependencies, make sure we have at least one of them for this category
	if depend then
		for k, v in pairs(depend) do
			if activeAttachments[k] then
				return true
			end
		end
	else
		state = true -- if there are none, assume no exclusions
	end
	
	-- if there are exclusions, loop through, if there are any attachments that exclude the current category, don't allow us to attach it
	if exclude then
		for k, v in pairs(exclude) do
			if activeAttachments[k] then
				return false, -1, k -- active attachment that excludes this category
			end
		end
	end
	
	-- otherwise, return the final verdict
	return state, -2, depend -- either true or false, in case of false - attachment(s) we depend on is (are) not active
end

-- this function checks whether a certain attachment can be attached
-- it's different from the 'dependencies' and 'exclusions' tables in the Attachments table in the way that it checks eligibility on a per-attachment basis
-- keep in mind that the 'dependencies' and 'exclusions' you specify in the Attachments table are on a category basis

function SWEP:isAttachmentEligible(name, activeAttachments)
	local found = nil
	
	activeAttachments = activeAttachments or self.ActiveAttachments
	
	if self.AttachmentDependencies then
		local depend = self.AttachmentDependencies[name]
		
		-- loop through the active attachments, see if any of them are active
		if depend then
			found = false
			
			for k, v in pairs(depend) do
				-- if they are, that means we can proceed
				if activeAttachments[v] then
					found = true
					break
				end
			end
		end
	end
	
	if self.AttachmentExclusions then
		-- loop through the exclusions for this particular attachment, if there are any, let us know that we can't proceed
		local excl = self.AttachmentExclusions[name]
		
		if excl then
			for k, v in pairs(excl) do
				if activeAttachments[v] then
					return false, self.AttachmentEligibilityEnum.ACTIVE_ATTACHMENT_EXCLUSION, activeAttachments[v] -- active attachment excludes
				end
			end
		end
	end
	
	-- nil indicates that we can attach
	if found == nil then
		return true
	end
	
	-- or just return the result
	return found, self.AttachmentEligibilityEnum.NEED_ATTACHMENTS, self.AttachmentDependencies[name] -- in case of false - attachment we depend on is not attached
end

-- this function is ran every time an attachment is detached (or swapped, which is basically the same thing)
-- what it does is it checks every attachment for dependencies, and detaches everything that can't be on the weapon without a 'parent' attachment
function SWEP:checkAttachmentDependency()
	for k, v in ipairs(self.Attachments) do
		if v.last then
			local curAtt = v.atts[v.last]
			local foundAtt = CustomizableWeaponry.registeredAttachmentsSKey[curAtt]
			
			-- we've found an attachment that's currently on the weapon, check if it depends on anything
			if foundAtt then
				-- check if the category and the attachment are eligible
				if not self:isAttachmentEligible(foundAtt.name) or not self:isCategoryEligible(v.dependencies, v.exclusions) then
					-- they aren't eligible, time to detach them
					self:_detach(k, v.last)
				end
			end
		end
	end
end

-- restores the current firing sounds back to their original variants
function SWEP:restoreSound()
	self.FireSound = self.FireSound_Orig
	self.FireSoundSuppressed = self.FireSoundSuppressed_Orig
end

function SWEP:updateSoundTo(snd, var)
	if not snd then
		return
	end
	
	var = var or 0
	
	-- var 0 is the unsuppressed fire sound, var 1 is the suppressed
	if var == 0 then
		self.FireSound = Sound(snd)
		
		return self.FireSound
	elseif var == 1 then
		self.FireSoundSuppressed = Sound(snd)
		
		return self.FireSoundSuppressed
	end
end

function SWEP:setupCurrentIronsights(pos, ang)
	if SERVER then
		return
	end
	
	self.CurIronsightPos = pos
	self.CurIronsightAng = ang
end

function SWEP:resetSuppressorStatus()
	if self.SuppressedOnEquip ~= nil then
		self.dt.Suppressed = self.SuppressedOnEquip
	else
		-- default to false
		self.dt.Suppressed = false
	end
end

function SWEP:resetAimToIronsights()
	if SERVER then
		return
	end
	
	self.AimPos = self.CurIronsightPos
	self.AimAng = self.CurIronsightAng
	
	self.ActualSightPos = nil
	self.ActualSightAng = nil
	
	self.SightBackUpPos = nil
	self.SightBackUpAng = nil
end

function SWEP:updateIronsights(index)
	if SERVER then
		return
	end
	
	self.AimPos = self[index .. "Pos"]
	self.AimAng = self[index .. "Ang"]
end

-- check whether the given attachment category is active
function SWEP:isAttachmentActive(category)	
	if not category then
		return false
	end
	
	if not CustomizableWeaponry[category] then
		return false
	end
	
	for k, v in ipairs(self.Attachments) do
		if v.last then
			local curAtt = v.atts[v.last]
			
			if CustomizableWeaponry[category][curAtt] then
				return true
			end
		end
	end
	
	return false
end

-- check whether the given ATTACHMENT (not category) is active
function SWEP:isAttachmentActiveReal(attachmentID)	
	if not attachmentID then
		return false
	end
	
	if not CustomizableWeaponry.registeredAttachmentsSKey[attachmentID] then
		return false
	end
	
	return self.ActiveAttachments[attachmentID]
end

local mins, maxs = Vector(-8, -8, -1), Vector(8, 8, 1)

local td = {}
td.mins = mins
td.maxs = maxs

function SWEP:CanRestWeapon(height)
	height = height or -1
	local vel = Length(GetVelocity(self.Owner))
	local pitch = self.Owner:EyeAngles().p
	
	if vel == 0 and pitch <= 60 and pitch >= -20 then
		local sp = self.Owner:GetShootPos()
		local aim = self.Owner:GetAimVector()
		
		td.start = sp
		td.endpos = td.start + aim * 35
		td.filter = self.Owner
				
		local tr = util.TraceHull(td)

		-- fire first trace to check whether there is anything IN FRONT OF US
		if tr.Hit then
			-- if there is, don't allow us to deploy
			return false
		end
		
		aim.z = height
		
		td.start = sp
		td.endpos = td.start + aim * 25
		td.filter = self.Owner
				
		tr = util.TraceHull(td)
		
		if tr.Hit then
			local ent = tr.Entity
			
			-- if the second trace passes, we can deploy
			if not ent:IsPlayer() and not ent:IsNPC() then
				return true
			end
		end
		
		return false
	end
	
	return false
end

function SWEP:getSpreadModifiers()
	local mul = 1
	local mulMax = 1

	-- decrease spread increase when aiming
	if self.Owner:Crouching() then
		mul = mul * 0.75
	end
	
	-- and when a bipod is deployed
	if self.dt.BipodDeployed then
		mul = mul * 0.5
		mulMax = 0.5 -- decrease maximum spread increase
	end
	
	return mul, mulMax
end

function SWEP:getFinalSpread(vel, maxMultiplier)
	maxMultiplier = maxMultiplier or 1
	
	local final = self.BaseCone
	local aiming = self.dt.State == CW_AIMING
	-- take the continuous fire spread into account
	final = final + self.AddSpread
	
	-- and the player's velocity * mobility factor
	
	if aiming then
		-- irl the accuracy of your weapon goes to shit when you start moving even if you aim down the sights, so when aiming, player movement will impact the spread even more than it does during hip fire
		-- but we're gonna clamp it to a maximum of the weapon's hip fire spread, so that even if you aim down the sights and move, your accuracy won't be worse than your hip fire spread
		final = math.min(final + (vel / 10000 * self.VelocitySensitivity) * self.AimMobilitySpreadMod, self.HipSpread)
	else
		final = final + (vel / 10000 * self.VelocitySensitivity)
	end
	
	if self.ShootWhileProne and self:isPlayerProne() then
		final = final + vel / 1000
	end
	
	-- as well as the spread caused by rapid mouse movement
	final = final + self.Owner.ViewAff
	
	-- lastly, return the final clamped value
	return math.Clamp(final, 0, 0.09 + self:getMaxSpreadIncrease(maxMultiplier))
end

function SWEP:isNearWall()
	if not self.NearWallEnabled then
		return false
	end
	
	td.start = self.Owner:GetShootPos()
	td.endpos = td.start + self.Owner:EyeAngles():Forward() * self.NearWallDistance
	td.filter = self.Owner
	
	local tr = util.TraceLine(td)
	
	if tr.Hit or (IsValid(tr.Entity) and not tr.Entity:IsPlayer()) then
		return true
	end
	
	return false
end

function SWEP:performBipodDelay(time)
	time = time or self.BipodDeployTime
	local CT = CurTime()
	
	self.BipodDelay = CT + time
	self:SetNextPrimaryFire(CT + time)
	self:SetNextSecondaryFire(CT + time)
	self.ReloadWait = CT + time
end

function SWEP:delayEverything(time)
	time = time or 0.15
	local CT = CurTime()
	
	self.BipodDelay = CT + time
	self:SetNextPrimaryFire(CT + time)
	self:SetNextSecondaryFire(CT + time)
	self.ReloadWait = CT + time
	self.HolsterWait = CT + time
end

function SWEP:isBipodIdle()
	if self.dt.BipodDeployed and self.DeployAngle and self.dt.State == CW_IDLE then 
		return true
	end
	
	return false
end

function SWEP:isBipodDeployed()
	if self.dt.BipodDeployed then
		return true
	end
	
	return false
end

function SWEP:isReloading()
	if self.ReloadDelay then
		return true
	end
	
	if (SP and CLIENT) then
		if self.IsReloading then
			if self.Cycle < 0.98 then
				return true
			end
		end
	end
	
	return false
end

function SWEP:canOpenInteractionMenu()
	if self.dt.State == CW_CUSTOMIZE then
		return true
	end
	
	if CustomizableWeaponry.callbacks.processCategory(self, "disableInteractionMenu") then
		return false
	end
	
	if table.Count(self.Attachments) == 0 then
		return false
	end
	
	if self.ReloadDelay then
		return false
	end
	
	local CT = CurTime()
	
	if CT < self.ReloadWait or CT < self.BipodDelay or self.dt.BipodDeployed then
		return false
	end
	
	if Length(GetVelocity(self.Owner)) >= self.Owner:GetWalkSpeed() * self.RunStateVelocity then
		return false
	end
	
	if not self.Owner:OnGround() then
		return false
	end
	
	return true
end

function SWEP:setupBipodVars()
	-- network/predict bipod angles
	
	if SP and SERVER then
		umsg.Start("CW20_DEPLOYANGLE", self.Owner)
			umsg.Angle(self.Owner:EyeAngles())
		umsg.End()
	else
		self.DeployAngle = self.Owner:EyeAngles()
	end
	
	-- delay all actions
	self:performBipodDelay()
end

function SWEP:canUseComplexTelescopics()
	if SERVER then
		return true
	end

	if CustomizableWeaponry.callbacks.processCategory(self, "forceComplexTelescopics") then
		return true
	end
	
	return GetConVarNumber("cw_simple_telescopics") <= 0
end

function SWEP:canUseSimpleTelescopics()
	if not self:canUseComplexTelescopics() and self.SimpleTelescopicsFOV then
		return true
	end
	
	return false
end

function SWEP:setGlobalDelay(delay, forceNetwork, forceState, forceTime)
	if SERVER then
		if (SP or forceNetwork) then
			umsg.Start("CW20_GLOBALDELAY", self.Owner)
				umsg.Float(delay)
			umsg.End()
		end
		
		if forceState and forceTime then
			self:forceState(forceState, forceTime, true)
		end
	end
	
	self.GlobalDelay = CurTime() + delay
end

function SWEP:forceState(state, time, network)
	self.forcedState = state
	self.ForcedStateTime = CurTime() + time
	
	if SERVER and network then
		umsg.Start("CW20_FORCESTATE", self.Owner)
			umsg.Short(state)
			umsg.Float(time)
		umsg.End()
	end
end

function SWEP:setupBallisticsInformation()
	local info = CustomizableWeaponry.ammoTypes[self.Primary.Ammo]
	
	if not info then
		return
	end
	
	self.BulletDiameter = info.bulletDiameter
	self.CaseLength = info.caseLength
end

function SWEP:seekPresetPosition(offset)
	offset = offset or 0
	local count = #self.PresetResults
	
	if offset > 0 and self.PresetPosition + 10 > count then
		return
	end
	
	self.PresetPosition = math.Clamp(self.PresetPosition + offset, 1, count)
end

function SWEP:setPresetPosition(offset, force)
	offset = offset or 0
	
	if force then
		self.PresetPosition = math.max(self.PresetPosition, 1)
		return
	end
	
	local count = #self.PresetResults
	
	-- clamp the maximum and minimum position
	self.PresetPosition = math.Clamp(offset, 1, count)
end

function SWEP:getDesiredPreset(bind)
	local desired = bind == "slot0" and 10 or tonumber(string.Right(bind, 1))
	local pos = self.PresetPosition + desired
	
	return pos
end

function SWEP:attemptPresetLoad(entry)
	if not self.PresetResults then
		return false
	end
	
	entry = entry - 1
	
	local result = self.PresetResults[entry]
	
	if not result then
		return false
	end
	
	CustomizableWeaponry.preset.load(self, result.displayName)
	return true
end

function SWEP:getActiveAttachmentInCategory(cat)
	local category = self.Attachments[cat]
	
	if category then
		if category.last then
			return category.atts[category.last]
		end
	end
	
	return nil
end


function SWEP:getSightColor(data)
	-- why are you passing nil :(
	if not data then
		-- assume it's a sight we're trying to get the color for
		return CustomizableWeaponry.defaultColors[CustomizableWeaponry.COLOR_TYPE_SIGHT]
	end
	
	local found = self.SightColors[data]
	
	if found then
		return found.color
	end
end

-- this function sets up reticle and laser beam colors for all sights/laser sights
function SWEP:setupReticleColors()
	self.SightColors = {}
	
	for k, v in ipairs(self.Attachments) do
		for k2, v2 in ipairs(v.atts) do
			local foundAtt = CustomizableWeaponry.registeredAttachmentsSKey[v2]
			
			if foundAtt then
				-- if the found attachment has a color type enum, that means it is colorable (wow!)
				-- therefore, we need to add it to the color table
				if foundAtt.colorType then
					local def = CustomizableWeaponry.colorableParts.defaultColors[foundAtt.colorType]
					self.SightColors[foundAtt.name] = {type = foundAtt.colorType, color = def.color, last = 1, display = CustomizableWeaponry.colorableParts:makeColorDisplayText(def.display)}
				end
			end
		end
	end
end

function SWEP:isReloadingM203()
	if not self.AttachmentModelsVM then
		return false
	end
	
	local m203 = self.AttachmentModelsVM.md_m203
	
	if m203 and m203.active then
		if self.curM203Anim == self.M203Anims.reload then
			if m203.ent:GetCycle() <= 0.9 then
				return true
			end
		end
	end
	
	return false
end

function SWEP:filterPrediction()
	if (SP and SERVER) or not SP then
		return true
	end
	
	return false
end

function SWEP:getMagCapacity()
	local mag = self:Clip1()
	
	if mag > self.Primary.ClipSize_Orig then
		return self.Primary.ClipSize_Orig .. " + " .. mag - self.Primary.ClipSize_Orig
	end
	
	return mag
end

function SWEP:getReloadProgress()
	if self.IsReloading and self.Cycle <= 0.98 then
		if self.ShotgunReload then
			return math.Clamp(math.ceil(self:getAnimSeek() / self.InsertShellTime * 100), 0, 100)
		else
			if self.wasEmpty then
				return math.Clamp(math.ceil(self:getAnimSeek() / self.ReloadHalt_Empty * 100), 0, 100)
			else
				return math.Clamp(math.ceil(self:getAnimSeek() / self.ReloadHalt * 100), 0, 100)
			end
		end
	end
	
	return nil
end

function SWEP:isReticleActive()
	if self.reticleInactivity and UnPredictedCurTime() < self.reticleInactivity then
		return false
	end
	
	return true
end

if CLIENT then
	function SWEP:getReticleAngles()
		if self.freeAimOn then
			local ang = self.CW_VM:GetAngles()
			ang.p = ang.p + self.AimAng.x
			ang.y = ang.y - self.AimAng.y
			ang.r = ang.r - self.AimAng.z
			
			return ang
		end
		
		return self.Owner:EyeAngles() + self.Owner:GetPunchAngle()
	end
	
	function SWEP:getTelescopeAngles()
		if self.freeAimOn then
			return self.Owner:EyeAngles()
		end
		
		return self:getMuzzlePosition().Ang
	end
	
	function SWEP:getTelescopeAnglesNew()
		if self.freeAimOn then
			return self.Owner:EyeAngles()
		end
		
		local ang = self.Owner:EyeAngles() + self.Owner:GetViewPunchAngles()
		ang.y = ang.y + self.curViewBob.y
		ang.p = ang.p + self.curViewBob.p
		--ang.r = ang.r - self.curViewBob.r
		
		return ang
		
		--return self:getMuzzlePosition().Ang
	end
	
	function SWEP:getLaserAngles(model)
		--if self.freeAimOn then
		--	return self.Owner:EyeAngles()
		--end
		
		return model:GetAngles()
	end
end

local trans = {["MOUSE1"] = "LEFT MOUSE BUTTON",
	["MOUSE2"] = "RIGHT MOUSE BUTTON"}
	
local b, e

function SWEP:getKeyBind(bind)
	b = input.LookupBinding(bind)
	e = trans[b]
	
	return b and ("[" .. (e and e or string.upper(b)) .. "]") or "[\"" .. bind .. "\" not bound]"
end

-- GENERAL MATH FUNCS

function math.ApproachVector(startValue, endValue, amount)
	startValue.x = math.Approach(startValue.x, endValue.x, amount)
	startValue.y = math.Approach(startValue.y, endValue.y, amount)
	startValue.z = math.Approach(startValue.z, endValue.z, amount)
	
	return startValue
end

function math.NormalizeAngles(ang)
	ang.p = math.NormalizeAngle(ang.p)
	ang.y = math.NormalizeAngle(ang.y)
	ang.r = math.NormalizeAngle(ang.r)
	
	return ang
end


================================================
FILE: cw2/lua/weapons/cw_base/sh_hooks.lua
================================================
local function CW20_PlayerEnteredVehicle(ply, vehicle, role)
	local wep = ply:GetActiveWeapon()
	
	if IsValid(wep) then
		if wep.CW20Weapon then
			wep.dt.State = CW_ACTION -- set the state to 'action' so that the player 'holsters' it
		end
	end
end

hook.Add("PlayerEnteredVehicle", "CW20_PlayerEnteredVehicle", CW20_PlayerEnteredVehicle)

local SP = game.SinglePlayer()

if SP and SERVER then	
	hook.Add("PlayerFootstep", "CW20_Footstep", function(ply, pos, foot, sound, volume)
		local wep = ply:GetActiveWeapon()
		
		if IsValid(wep) and wep.CW20Weapon then
			SendUserMessage("CW20_FOOTSTEP", wep.Owner)
		end
	end)
elseif CLIENT then
	hook.Add("PlayerFootstep", "CW20_Footstep", function(ply, pos, foot, sound, volume)
		if ply == LocalPlayer() then
			local wep = ply:GetActiveWeapon()
			
			if IsValid(wep) and wep.CW20Weapon then
				wep:addRunTime()
			end
		end
	end)
end


================================================
FILE: cw2/lua/weapons/cw_base/sh_mixins.lua
================================================
-- various metamethod utility mixins, mainly made to write less

-- VECTOR MIXINS

local vec = debug.getregistry("Vector")

-- if there is no vector division method, define one, as it's very useful

local VEC = "Vector" -- make the 'Vector' string once, since it's an object

if not vec.__div then
	vec.__div = function(a, b)
		-- make sure both A and B are vectors
		if a == VEC and b == VEC then
			a.x = a.x / b.x
			a.y = a.y / b.y
			a.z = a.z / b.z
			
			return a
		end
		
		-- if they aren't, just return the first vector
		return a
	end
end

-- if there is no subtraction method, define one

if not vec.__sub then
	vec.__sub = function(a, b)
		-- make sure both A and B are vectors
		
		if a == VEC and b == VEC then
			a.x = a.x - b.x
			a.y = a.y - b.y
			a.z = a.z - b.z
			
			return a
		end
		
		-- if they aren't, just return the first vector
		return a
	end
end

-- ANGLE MIXINS

local ang = debug.getregistry("Angle")

local ANG = "Angle"

if not ang.__sub then
	ang.__sub = function(a, b)
		if a == ANG and b == ANG then
			a.p = a.p - b.p
			a.y = a.y - b.y
			a.r = a.r - a.r
			
			return a
		end
		
		return a
	end
end

-- Length method for angles

--if not ang.Length then

	function ang:Length()
		local p, y, r = math.abs(p), math.abs(y), math.abs(r)
		
		return p + y + r
	end
--end

function LerpColor(dt, a, b)
	a.r = LerpCW20(dt, a.r, b.r)
	a.g = LerpCW20(dt, a.g, b.g)
	a.b = LerpCW20(dt, a.b, b.b)
	a.a = LerpCW20(dt, a.a, b.a)
	
	return a
end

function math.randomizeVector(vecObj, offset)
	vecObj.x = vecObj.x + math.Rand(-offset, offset)
	vecObj.y = vecObj.y + math.Rand(-offset, offset)
	vecObj.z = vecObj.z + math.Rand(-offset, offset)
	
	return vecObj
end


================================================
FILE: cw2/lua/weapons/cw_base/sh_move.lua
================================================
local reg = debug.getregistry()
local GetActiveWeapon = reg.Player.GetActiveWeapon
local GetDTFloat = reg.Entity.GetDTFloat
local GetRunSpeed = reg.Player.GetRunSpeed
local GetWalkSpeed = reg.Player.GetWalkSpeed
local GetCrouchedWalkSpeed = reg.Player.GetCrouchedWalkSpeed
local Crouching = reg.Player.Crouching

local wep

function CW_Move(ply, m)
	if Crouching(ply) then
		wep = GetActiveWeapon(ply)
		
		if IsValid(wep) and wep.CW20Weapon then
			if wep.dt and wep.dt.State == CW_AIMING then
				m:SetMaxSpeed((GetWalkSpeed(ply) * GetCrouchedWalkSpeed(ply) - wep.SpeedDec * 0.5))
			end
		end
	else
		wep = GetActiveWeapon(ply)
		
		if IsValid(wep) and wep.CW20Weapon then
			if wep.dt and wep.dt.State == CW_AIMING then
				m:SetMaxSpeed((GetWalkSpeed(ply) - wep.SpeedDec) * 0.75)
			else
				m:SetMaxSpeed(GetRunSpeed(ply) - wep.SpeedDec)
			end
		else
			m:SetMaxSpeed(GetRunSpeed(ply))
		end
	end
end

hook.Add("Move", "CW_Move", CW_Move)

function CW_StartCommand(ply, ucmd)
	local wep = GetActiveWeapon(ply)
	
	if IsValid(wep) and wep.CW20Weapon then
        if wep == wep.SwitchWep then
            wep.SwitchWep = nil
        end
		
		local switchTo = wep.SwitchWep
		
		if IsValid(switchTo) then
			ucmd:SelectWeapon(switchTo)
		else
			wep.SwitchWep = nil
		end
	end
end

hook.Add("StartCommand", "CW_StartCommand", CW_StartCommand)


================================================
FILE: cw2/lua/weapons/cw_base/sh_plugininit.lua
================================================
CustomizableWeaponry.quickGrenade:initializeQuickGrenade()


================================================
FILE: cw2/lua/weapons/cw_base/sh_sounds.lua
================================================
CustomizableWeaponry:addRegularSound("CW_HOLSTER", {"cw/holster1.wav", "cw/holster2.wav", "cw/holster3.wav", "cw/holster4.wav"})
CustomizableWeaponry:addRegularSound("CW_EMPTY", "weapons/shotgun/shotgun_empty.wav")
CustomizableWeaponry:addRegularSound("CW_TAKEAIM", {"cw/sightraise1.wav", "cw/sightraise2.wav"})
CustomizableWeaponry:addRegularSound("CW_LOWERAIM", {"cw/sightlower1.wav", "cw/sightlower2.wav"})

CustomizableWeaponry:addRegularSound("CW_FOLEY_1", "weapons/cw_foley/foley1.wav")
CustomizableWeaponry:addRegularSound("CW_FOLEY_2", "weapons/cw_foley/foley2.wav")
CustomizableWeaponry:addRegularSound("CW_FOLEY_3", "weapons/cw_foley/foley3.wav")
CustomizableWeaponry:addRegularSound("CW_FOLEY_4", "weapons/cw_foley/foley4.wav")
CustomizableWeaponry:addRegularSound("CW_FOLEY_5", "weapons/cw_foley/foley5.wav")
CustomizableWeaponry:addRegularSound("CW_FOLEY_6", "weapons/cw_foley/foley6.wav")

-- all-in-one
CustomizableWeaponry:addRegularSound("CW_GENERIC_FOLEY", {"weapons/cw_foley/foley2.wav", "weapons/cw_foley/foley3.wav", "weapons/cw_foley/foley4.wav", "weapons/cw_foley/foley5.wav", "weapons/cw_foley/foley6.wav"})

-- categorised
CustomizableWeaponry:addRegularSound("CW_FOLEY_LIGHT", {"weapons/cw_foley/foley_light1.wav", "weapons/cw_foley/foley_light2.wav", "weapons/cw_foley/foley_light3.wav", "weapons/cw_foley/foley_light4.wav"})
CustomizableWeaponry:addRegularSound("CW_FOLEY_MEDIUM", {"weapons/cw_foley/foley_medium1.wav", "weapons/cw_foley/foley_medium2.wav", "weapons/cw_foley/foley_medium3.wav"})
CustomizableWeaponry:addRegularSound("CW_FOLEY_HEAVY", {"weapons/cw_foley/foley_heavy1.wav", "weapons/cw_foley/foley_heavy2.wav"})

CustomizableWeaponry:addRegularSound("CW_FOLEY_CLOTH", {"weapons/cw_foley/cloth_1.wav", "weapons/cw_foley/cloth_2.wav", "weapons/cw_foley/cloth_3.wav"})


================================================
FILE: cw2/lua/weapons/cw_base/sh_stats.lua
================================================
-- various weapon stat related convenience functions

function SWEP:addStatModifiers(tbl)
	if tbl then
		-- loop through the table and modify multipliers
		for k, v in pairs(tbl) do
			if self[k] then
				self[k] = self[k] + v
			end
		end
	end
end

function SWEP:removeStatModifiers(tbl)
	if tbl then
		for k, v in pairs(tbl) do
			if self[k] then
				self[k] = self[k] - v
			end
		end
	end
end


function SWEP:recalculateDamage()
	self.Damage = self.Damage_Orig * self.DamageMult
end

function SWEP:recalculateRecoil()
	self.Recoil = self.Recoil_Orig * self.RecoilMult
end

function SWEP:recalculateFirerate()
	self.FireDelay = self.FireDelay_Orig * self.FireDelayMult
end

function SWEP:recalculateVelocitySensitivity()
	self.VelocitySensitivity = self.VelocitySensitivity_Orig * self.VelocitySensitivityMult
end

function SWEP:recalculateAimSpread()
	self.AimSpread = self.AimSpread_Orig * self.AimSpreadMult
end

function SWEP:recalculateHipSpread()
	self.HipSpread = self.HipSpread_Orig * self.HipSpreadMult
end

function SWEP:recalculateDeployTime()
	self.DrawSpeed = self.DrawSpeed_Orig * self.DrawSpeedMult
end

function SWEP:recalculateReloadSpeed()
	self.ReloadSpeed = self.ReloadSpeed_Orig * self.ReloadSpeedMult
end

function SWEP:recalculateMouseSens()
	self.OverallMouseSens = self.OverallMouseSens_Orig * self.OverallMouseSensMult
end

function SWEP:recalculateMaxSpreadInc()
	self.MaxSpreadInc = self.MaxSpreadInc_Orig * self.MaxSpreadIncMult
end

function SWEP:recalculateClumpSpread()
	if not self.ClumpSpread then
		return
	end
	
	self.ClumpSpread = self.ClumpSpread_Orig * self.DamageMult
end

function SWEP:recalculateStats()
	-- recalculates all stats
	self:recalculateDamage()
	self:recalculateRecoil()
	self:recalculateFirerate()
	self:recalculateVelocitySensitivity()
	self:recalculateAimSpread()
	self:recalculateHipSpread()
	self:recalculateDeployTime()
	self:recalculateReloadSpeed()
	self:recalculateClumpSpread()
	
	if CLIENT then
		self:recalculateMouseSens()
	end
	
	self:recalculateMaxSpreadInc()
end


================================================
FILE: cw2/lua/weapons/cw_base/shared.lua
================================================
--[[ You'll see a mish-mash of CamelCase and camelBack in here, since I used my SWB as the base for this and built on top of it
This is since when I coded SWB I was using CamelCase, over time I got used to camelBack, which is the reason for this inconsistency
But hey, as long as it's OOP, it shouldn't be that big of a problem
]]--

CW_IDLE = 0
CW_RUNNING = 1
CW_AIMING = 2
CW_ACTION = 3
CW_CUSTOMIZE = 4
CW_HOLSTER_START = 5
CW_HOLSTER_END = 6
CW_PRONE_BUSY = 7 -- entering/leaving prone state
CW_PRONE_MOVING = 8 -- crawling while prone

-- rather than a lot of 'or' statements, just make a table containing numeric indexes as keys that dictate when the weapon cannot be used
SWEP.InactiveWeaponStates = {[CW_RUNNING] = true,
	[CW_ACTION] = true,
	[CW_CUSTOMIZE] = true,
	[CW_HOLSTER_START] = true,
	[CW_HOLSTER_END] = true,
	[CW_PRONE_BUSY] = true,
	[CW_PRONE_MOVING] = true}
	
-- conditions in which the player can't customize his weapon
SWEP.NoCustomizeStates = {[CW_RUNNING] = true,
	[CW_ACTION] = true,
	[CW_HOLSTER_START] = true,
	[CW_HOLSTER_END] = true,
	[CW_PRONE_BUSY] = true,
	[CW_PRONE_MOVING] = true}
	
SWEP.ToggleM203States = {[CW_IDLE] = true,
	[CW_RUNNING] = true}
	
SWEP.M203ReloadSounds = {[1] = {time = 0.3, sound = "CW_M203_OPEN"},
	[2] = {time = 0.4, sound = "CW_M203_REMOVE"},
	[3] = {time = 1.4, sound = "CW_M203_INSERT"},
	[4] = {time = 1.9, sound = "CW_M203_CLOSE"}}
	
SWEP.AttachmentEligibilityEnum = {
	ACTIVE_ATTACHMENT_EXCLUSION = -1,
	NEED_ATTACHMENTS = -2
}

SWEP.UnavailableAttachmentEnum = {
	NEED_ATTACHMENTS = -1,
	INCOMPATIBILITY = -2,
	INCOMPATIBLE_ATTACHMENT_PRESENT = -3,
	DEPENDENT_ATTACHMENT_NOT_PRESENT = -4,
	INCOMPATIBLE_CATEGORY_PRESENT = -5,
	DEPENDENT_CATEGORY_NOT_PRESENT = -6,
	PLAYER_DOES_NOT_HAVE_ATTACHMENT = -7,
	MISC_FAILURE = -8
}

SWEP.M203Anims = {idle_to_ready = "Idle2Fire",
ready_to_idle = "Fire2Idle",
reload = "reload"}

if SERVER then
	include("sv_filestodownload.lua")
end

AddCSLuaFile()
AddCSLuaFile("sh_bullets.lua")
AddCSLuaFile("cl_model.lua")
AddCSLuaFile("cl_hud.lua")
AddCSLuaFile("cl_hooks.lua")
AddCSLuaFile("cl_calcview.lua")
AddCSLuaFile("sh_ammotypes.lua")
AddCSLuaFile("sh_move.lua")
AddCSLuaFile("sh_sounds.lua")
AddCSLuaFile("sh_anims.lua")
AddCSLuaFile("cl_playerbindpress.lua")
AddCSLuaFile("sh_attachments.lua")
AddCSLuaFile("sh_general.lua")
AddCSLuaFile("cl_umsgs.lua")
AddCSLuaFile("cl_cvars.lua")
AddCSLuaFile("cl_render.lua")
AddCSLuaFile("sh_mixins.lua")
AddCSLuaFile("sh_stats.lua")
AddCSLuaFile("sh_plugininit.lua")
AddCSLuaFile("sh_hooks.lua")

include("sh_bullets.lua")
include("sh_ammotypes.lua")
include("sh_move.lua")
include("sh_sounds.lua")
include("sh_anims.lua")
include("sh_attachments.lua")
include("sh_general.lua")
include("sh_mixins.lua")
include("sh_stats.lua")
include("sh_plugininit.lua")
include("sh_hooks.lua")

if CLIENT then
	include("cl_calcview.lua")
	include("cl_playerbindpress.lua")
	include("cl_model.lua")
	include("cl_hud.lua")
	include("cl_hooks.lua")
	include("cl_umsgs.lua")
	include("cl_cvars.lua")
	include("cl_render.lua")
	
	SWEP.CustomizePos = Vector(5.488, -1.627, -1.821)
	SWEP.CustomizeAng = Vector(17.009, 29.971, 16.669)

	SWEP.SprintPos = Vector(1.786, 0, 0)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.PronePos = Vector(6.717, -6.273, -6.577)
	SWEP.ProneAng = Vector(5.618, 49.055, -15.311)
	
	SWEP.DrawCrosshair = false
	SWEP.BounceWeaponIcon = false
	SWEP.DrawWeaponInfoBox = false
	SWEP.CurFOVMod = 0
	SWEP.BobScale = 0
	SWEP.SwayScale = 0
	SWEP.ZoomAmount = 15
	SWEP.FadeCrosshairOnAim = true
	SWEP.DrawAmmo = true
	SWEP.DrawTraditionalWorldModel = true
	SWEP.CrosshairEnabled = true
	SWEP.ViewbobEnabled = true
	SWEP.ViewbobIntensity = 1
	SWEP.ReloadViewBobEnabled = true
	SWEP.RVBPitchMod = 1
	SWEP.RVBYawMod = 1
	SWEP.RVBRollMod = 1
	SWEP.BulletDisplay = 0
	SWEP.Shell = "mainshell"
	SWEP.ShellScale = 1
	SWEP.CSMuzzleFlashes  = true
	SWEP.ZoomWait = 0
	SWEP.CrosshairParts = {left = true, right = true, upper = true, lower = true}
	SWEP.FireModeDisplayPos = "middle"
	SWEP.SelectFont = "CW_SelectIcons"
	SWEP.SwimPos = Vector(0, 0, -3)
	SWEP.SwimAng = Vector(-29.921, 38.909, 0)
	SWEP.ShellOffsetMul = 1
	SWEP.MuzzleAttachment = 1
	SWEP.CustomizeMenuAlpha = 0
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.6
	SWEP.ForeGripOffsetCycle_Reload = 0.6
	SWEP.ForeGripOffsetCycle_Draw = 0.5
	SWEP.MuzzleEffectSupp = "muzzleflash_suppressed"
	SWEP.BipodAngleLimitYaw = 30
	SWEP.BipodAngleLimitPitch = 10
	SWEP.BipodSensitivity = {x = -0.3, z = -0.3, p = 0.1, r = 0.1}
	SWEP.LuaVMRecoilIntensity = 0
	SWEP.LuaVMRecoilLowerSpeed = 0
	SWEP.LuaVMRecoilMod = 1 -- modifier of overall intensity for the code based recoil
	SWEP.LuaVMRecoilAxisMod = {vert = 1, hor = 1, roll = 1, forward = 1, pitch = 1} -- modifier for intensity of the recoil on varying axes
	SWEP.OffsetBoltOnBipodShoot = true
	SWEP.AimViewModelFOV = 60
	SWEP.CustomizationTab = 1
	SWEP.PresetPosition = 1
	SWEP.CustomizationMenuScale = 0.015
	SWEP.CanRestOnObjects = true
	SWEP.FireMoveMod = 1
	SWEP.M203Time = 0
	SWEP.FOVPerShot = 1
	SWEP.WorldMuzzleAttachmentID = 1
	SWEP.WorldShellEjectionAttachmentID = 2
	SWEP.HipFireFOVIncrease = true
	
	SWEP.MuzzleAttachmentName = "1"
	
	SWEP.AimBreathingIntensity = 1
	SWEP.CurBreatheIntensity = 1
	SWEP.BreathLeft = 1
	SWEP.BreathRegenRate = 0.2
	SWEP.BreathDrainRate = 0.1
	SWEP.BreathIntensityDrainRate = 1
	SWEP.BreathIntensityRegenRate = 2
	SWEP.BreathHoldVelocityMinimum = 30 -- if our velocity surpasses this, we can't hold our breath
	SWEP.BreathDelay = 0.8
	SWEP.BreathRegenDelay = 0.5
	SWEP.MinimumBreathPercentage = 0.5 -- we can only hold our breath if our breath meter surpasses this
	SWEP.BreathIntensityOnRest = 0.5
	SWEP.BreathIntensityOnBipod = 0.2
	SWEP.BreathIntensitySwitchRate = 2 -- speed at which it switches from regular state to resting-weapon-on-something state (resting weapon/deployed bipod)
	SWEP.ReloadBoltBonePositionRecoverySpeed = 1
	SWEP.ReloadBoltBonePositionMoveSpeed = 25
	
	SWEP.SprintViewNormals = {x = 1, y = 1, z = 1}
	
	SWEP.breathWait = 0
	SWEP.breathRegenWait = 0
	SWEP.breathReleaseWait = 0
	
	SWEP.SwayIntensity = 1
	SWEP.AimSwayIntensity = 0.6
	SWEP.HUD_3D2DScale = 0.015
	
	SWEP.PresetResults = {}
	SWEP.elementRender = {}
	SWEP.elementRenderPost = {}
	SWEP.activeRenderAttachments = {}
	
	SWEP.UseHands = false
	
	SWEP.ACOGAxisAlign = {right = 0, up = 0, forward = 0}
end

SWEP.scaleSensitivityToSpread = true

SWEP.FadeCrosshairOnAim = true
SWEP.CUSTOMIZATION_MENU_TOGGLE_WAIT = 0.2 -- the time to delay every action by when opening/closing the customization menu
SWEP.LoseAimVelocity = 0.8
SWEP.RunStateVelocity = 1.2
SWEP.ActiveAttachments = {}
SWEP._activeSequences = {}
SWEP.GlobalDelay = 0
SWEP.PresetLoadDelay = 0
SWEP.ForcedStateTime = 0
SWEP.BoltBonePositionRecoverySpeed = 40 -- how fast does the bolt bone move back into it's initial position after the weapon has fired

-- default values are 9x19MM, because we don't know what the user wants
SWEP.CaseLength = 19
SWEP.BulletDiameter = 9
SWEP.M203Chamber = true
SWEP.Grenade40MM = 0

SWEP.HandlingMouseSensitivityRelation = 0.85 -- how much handling impacts mouse sensitivity when firing non-stop for a long while?
SWEP.HandlingMouseSensitivityMultiplier = 1.5 -- multiply the relation of handling-to-fire-sensitivity by this much
SWEP.QuickScopeSpreadIncrease = 0.05

if SERVER then
	include("sv_hooks.lua")
	include("sv_attachments.lua")
end

SWEP.OverallMouseSens = 1
SWEP.AimMobilitySpreadMod = 3
SWEP.PenMod = 1
SWEP.AmmoPerShot = 1
SWEP.CW20Weapon = true
SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 50
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= ""
SWEP.WorldModel		= ""
SWEP.AnimPrefix		= "fist"

SWEP.Spawnable			= false
SWEP.AdminSpawnable		= false

SWEP.Primary.ClipSize		= -1					// Size of a clip
SWEP.Primary.DefaultClip	= -1				// Default number of bullets in a clip
SWEP.Primary.Automatic		= false				// Automatic/Semi Auto
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1				// Size of a clip
SWEP.Secondary.DefaultClip	= -1				// Default number of bullets in a clip
SWEP.Secondary.Automatic	= true				// Automatic/Semi Auto
SWEP.Secondary.Ammo			= "none"

SWEP.AddSpread = 0
SWEP.SpreadWait = 0
SWEP.AddSpreadSpeed = 1
SWEP.ReloadWait = 0
SWEP.ReloadSpeed = 1
SWEP.DrawSpeed = 1

SWEP.Chamberable = true
SWEP.CanPenetrate = true
SWEP.CanRicochet = true
SWEP.AddSafeMode = true
SWEP.SprintingEnabled = true
SWEP.NearWallEnabled = true
SWEP.NearWallDistance = 30
SWEP.AimingEnabled = true
SWEP.AccuracyEnabled = true
SWEP.HolsterUnderwater = true
SWEP.HolsterOnLadder = true
SWEP.HoldToAim = true
SWEP.FiremodesEnabled = true
SWEP.SuppressedOnEquip = false
SWEP.CanCustomize = true

-- bipod-related
SWEP.BipodRecoilModifier = 0.3
SWEP.BipodInstalled = false

SWEP.BurstCooldownMul = 1.75
SWEP.BurstSpreadIncMul = 0.5
SWEP.BurstRecoilMul = 0.85
SWEP.DeployTime = 1
SWEP.Shots = 1
SWEP.FromActionToNormalWait = 0
SWEP.ShotgunReloadState = 0
SWEP.ReloadSpeed = 1
SWEP.ReloadSpeed_Suppressed = 1
SWEP.FireAnimSpeed = 1
SWEP.FOVHoldTime = 0
SWEP.FOVTarget = 0
SWEP.BipodDeployTime = 0.25
SWEP.BipodUndeployTime = 0.25
SWEP.HolsterTime = 0.4
SWEP.BipodDelay = 0
SWEP.HolsterWait = 0
SWEP.recoilRestoreWait = 0
SWEP.ForcedHipWaitTime = 0.25 -- this is how much time the player will have to wait before being able to aim again after shooting with SWEP.ForceBackToHipAfterAimedShot set to true

-- height necessary to be able to deploy a bipod/rest a weapon on something
-- negative values to trace downwards
SWEP.BipodDeployHeightRequirement = -1
SWEP.WeaponRestHeightRequirement = -0.6

SWEP.RecoilToSpread = 0.5
SWEP.BusyProneVelocity = 30 -- max velocity after which we're considering the player to be crawling while prone
SWEP.ViewmodelProneVelocityMultiplier = 1

local math = math

function SWEP:CalculateEffectiveRange()
	self.EffectiveRange = self.CaseLength * 10 - self.BulletDiameter * 5 -- setup realistic base effective range
	self.EffectiveRange = self.EffectiveRange * 39.37 -- convert meters to units
	-- for the sake of authenticity and realism I decided to keep the quarter/half decrease of the effective range off
	--self.EffectiveRange = self.EffectiveRange * 0.5
	self.DamageFallOff = (100 - (self.CaseLength - self.BulletDiameter)) / 200
	self.PenStr = (self.BulletDiameter * 0.5 + self.CaseLength * 0.35) * (self.PenAdd and self.PenAdd or 1)
	self.PenetrativeRange = self.EffectiveRange * 0.5
	
	-- we need to save it once
	if not self.EffectiveRange_Orig then
		self.EffectiveRange_Orig = self.EffectiveRange
		self.DamageFallOff_Orig = self.DamageFallOff
		self.PenetrativeRange_Orig = self.PenetrativeRange
	end
end

function SWEP:getEffectiveRange()
	local EffectiveRange = self.CaseLength * 10 - self.BulletDiameter * 5 -- setup realistic base effective range
	EffectiveRange = EffectiveRange * 39.37 -- convert meters to units

	local DamageFallOff = (100 - (self.CaseLength - self.BulletDiameter)) / 200
	local PenStr = (self.BulletDiameter * 0.5 + self.CaseLength * 0.35) * (self.PenAdd and self.PenAdd or 1)
	local PenetrativeRange = EffectiveRange * 0.5
	
	return EffectiveRange, DamageFallOff, PenStr, PenetrativeRange
end

local SP = game.SinglePlayer()
local tbl, tbl2

function SWEP:IndividualInitialize()
end

local validPlayerProneFunction = function(self)
	return self.Owner:IsProne()
end

local invalidPlayerProneFunction = function(self)
	return false
end

local validPlayerBusyProneFunction = function(self)
	return self.Owner:ProneIsGettingUp() or self.Owner:ProneIsGettingDown()
end

local invalidPlayerBusyProneFunction = function(self)
	return false
end

function SWEP:Initialize()
	self:SetHoldType(self.NormalHoldType)
	self:setupBallisticsInformation()
	self:CalculateEffectiveRange()
	self.CHoldType = self.NormalHoldType
	
	if CLIENT then
		self.ammoTextAlpha = 0
		self.ammoTextTime = 3
		
		if not self.ScopeRT then
			local base = weapons.GetStored("cw_base") -- we only need to init the render target on the base
			base:initRenderTarget(CustomizableWeaponry:getRenderTargetSize(GetConVarNumber("cw_rt_scope_quality")))
			self.ScopeRT = base.ScopeRT
		end
		
		if self.magBoneName then
			self.magBoneList = {}
		end
	end
	
	-- a global that will surely never be misnamed
	if PRONE_GETTINGDOWN then -- we check whether prone mod exists this way, and then assign a valid prone check function to avoid a ton of ifs
		self.isPlayerProne = validPlayerProneFunction
		self.isPlayerEnteringProne = validPlayerBusyProneFunction
	else
		self.isPlayerProne = invalidPlayerProneFunction
		self.isPlayerEnteringProne = invalidPlayerBusyProneFunction
	end
	
	if not self.HoldToAim then
		self.Secondary.Automatic = false
	end
	
	if self.AddSafeMode then
		table.insert(self.FireModes, #self.FireModes + 1, "safe")
	end
	
	t = self.FireModes[1]
	self.FireMode = t
	t = CustomizableWeaponry.firemodes.registeredByID[t]
	
	self.Primary.Auto = t.auto
	self.BurstAmount = t.burstamt
	
	self.CurCone = self.HipSpread
	
	-- set up original weapon stats
	CustomizableWeaponry.originalValue.assign(self)
	
	self.Primary.ClipSize_Orig = self.Primary.ClipSize
	self.Primary.ClipSize_ORIG_REAL = self.Primary.ClipSize -- this is the 'real' real original mag size, it is necessary for mag-size changing attachments
	
	if self.MuzzleVelocity then -- ENTER ONLY IN METER/S
		self.MuzzleVelocityConverted = self.MuzzleVelocity * 39.37
	end
	
	if self.FireSound then
		self.FireSound = Sound(CustomizableWeaponry:findFireSound(self.FireSound))
		self.FireSound_Orig = self.FireSound
	end
	
	if self.FireSoundSuppressed then
		self.FireSoundSuppressed = Sound(CustomizableWeaponry:findFireSound(self.FireSoundSuppressed))
		self.FireSoundSuppressed_Orig = self.FireSoundSuppressed
	end

	if CLIENT then
		self.RunTime = 0
		self.curViewBob = Angle(0, 0, 0)
		self.shouldUpdateAngles = true
		self.lastEyeAngle = EyeAngles()
		self.CurVMFOV = self.ViewModelFOV
		self.ViewModelFOV_Orig = self.ViewModelFOV
		self.ZoomAmount_Orig = self.ZoomAmount
		self.AimViewModelFOV = self.AimViewModelFOV and self.AimViewModelFOV or self.ViewModelFOV
		self.AimViewModelFOV_Orig = self.AimViewModelFOV
		self.BulletDisplay = t.buldis
		self.FireModeDisplay = t.display
		self.OverallMouseSens_Orig = self.OverallMouseSens
		self.AimBreathingEnabled_Orig = self.AimBreathingEnabled
		
		self.AimPos = self.IronsightPos
		self.AimAng = self.IronsightAng
		
		self.AimPos_Orig = self.AimPos
		self.AimAng_Orig = self.AimAng
		
		if self.WM then
			self.WMEnt = self:createManagedCModel(self.WM, RENDERGROUP_BOTH)
			self.WMEnt:SetNoDraw(true)
		end
		
		if self.Owner and IsValid(self.Owner) then
			self.HUD_LastHealth = self.Owner:Health()
			self.HUD_LastArmor = self.Owner:Armor()
		else
			self.HUD_LastHealth = 0
			self.HUD_LastArmor = 0
		end
		
		for k, v in pairs(self.Attachments) do
			v.keyText = type(k) == "number" and "[" .. k .. "] " or self:getKeyBind(k) .. " "
		end
		
		self._shellTable = CustomizableWeaponry.shells:getShell(self.Shell)
		self:createCustomVM(self.ViewModel)
		self:createGrenadeModel()
		self:setupAttachmentModels()
		self:setupBoneTable()
		self:setupReticleColors()
		self:playAnim("draw", self.DrawSpeed)
		self:setupCurrentIronsights(self.IronsightPos, self.IronsightAng)
		
		CustomizableWeaponry.cmodels:validate()
		
		CustomizableWeaponry.sightAdjustment:loadDefaultOffsets(self)
		
		self.ActualSightPos = self.IronsightPos
		self.ActualSightAng = self.IronsightAng
	end
	
	CustomizableWeaponry.callbacks.processCategory(self, "initialize")
	
	self.holsterSound = true
	self.dt.Suppressed = self.SuppressedOnEquip
	
	self:IndividualInitialize()
end

function SWEP:Equip()
	if self.equipFunc then
		self:equipFunc()
	end
end

function SWEP:unloadWeapon()
	-- remove all ammo from mag and transfer to reserve
	
	local amt = self:Clip1()
	
	self.Owner:SetAmmo(self.Owner:GetAmmoCount(self.Primary.Ammo) + amt, self.Primary.Ammo)
	self:SetClip1(0)
end

function SWEP:setBodygroup(main, sub)
	if SERVER then
		return
	end

	if self.CW_VM then
		self.CW_VM:SetBodygroup(main, sub)
	end
end

function SWEP:SetupDataTables()
	self:DTVar("Int", 0, "State")
	self:DTVar("Int", 1, "Shots")
	self:DTVar("Float", 0, "HolsterDelay")
	self:DTVar("Bool", 0, "Suppressed")
	self:DTVar("Bool", 1, "Safe")
	self:DTVar("Bool", 2, "BipodDeployed")
	self:DTVar("Bool", 3, "M203Active")
	self:DTVar("Angle", 0, "ViewOffset")
end

-- we have to do THIS fucking garbage because there is no distinction between DTVars and NWVars (look above) and therefore upon duplication of a spawned weapon object
-- it errors the fuck out because it ASSUMES that the weapon uses ONLY NWVars and calls non-existent Set<varName> functions
-- THANKS TO WHOEVER DECIDED THAT THERE SHOULD BE NO DISTINCTION BETWEEN DT AND NW VARS, IT REALLY IS SOME GOOD CODE PRACTICE RIGHT THERE
function SWEP:SetState(val)
	self.dt.State = val
end

function SWEP:SetShots(val)
	self.dt.Shots = val
end

function SWEP:SetHolsterDelay(val)
	self.dt.HolsterDelay = val
end

function SWEP:SetSuppressed(val)
	self.dt.Suppressed = val
end

function SWEP:SetSafe(val)
	self.dt.Safe = val
end

function SWEP:SetBipodDeployed(val)
	self.dt.BipodDeployed = val
end

function SWEP:SetM203Active(val)
	self.dt.M203Active = val
end

function SWEP:SetViewOffset(val)
	self.dt.ViewOffset = val
end

local vm, CT, aim, cone, vel, CT, tr
local td = {}

function SWEP:GetDeployTime()
	return self.DeployTime
end

function SWEP:Deploy()
	self.holsterSound = true
	self.dt.State = CW_IDLE
	self.dt.HolsterDelay = 0
	CT = CurTime()
	
	local deployTime = CT + self:GetDeployTime() / self.DrawSpeed

	self:SetNextSecondaryFire(deployTime)
	self:SetNextPrimaryFire(deployTime)
	self.ReloadWait = deployTime
	self.HolsterWait = deployTime
	
	if IsFirstTimePredicted() then
		if CLIENT then
			self.CurSoundTable = nil
			self.CurSoundEntry = nil
			self.SoundTime = nil
			self.SoundSpeed = 1
			
			self.ammoTextTime = 3 -- time to display the caliber thingy for
		end

		if self.drawAnimFunc then
			self:drawAnimFunc()
		else
			self:sendWeaponAnim("draw", self.DrawSpeed)
		end
	end
	
	if (SP and SERVER) then
		SendUserMessage("CW20_DEPLOY", self.Owner)
	end
	
	if self.dt.M203Active then
		if SERVER and SP then
			SendUserMessage("CW20_M203OFF", self.Owner)
		end
		
		if CLIENT then
			self:resetM203Anim()
		end
	end
	
	-- extra setup just in case
	--if SERVER then
	--	self.Owner:SetupHands(self.Owner)
	--end
	
	if CLIENT then
		self.lastEyeAngle = self.Owner:EyeAngles()
	end
	
	CustomizableWeaponry.callbacks.processCategory(self, "deployWeapon")
	
	self.SwitchWep = nil
	self.dt.M203Active = false
	return true
end

function SWEP:Holster(wep)
	-- can't switch if neither the weapon we want to switch to or the wep we're trying to switch to are not valid
	if not IsValid(wep) and not IsValid(self.SwitchWep) then
		self.SwitchWep = nil
		return false
	end
	
	local CT = CurTime()
	
	-- can't holster if we have a global delay on the weapon
	if CT < self.GlobalDelay or CT < self.HolsterWait then
		return false
	end
	
	if self.dt.HolsterDelay ~= 0 and CT < self.dt.HolsterDelay then
		return false
	end
	
	-- can't holster if there are sequenced actions
	if #self._activeSequences > 0 then
		return false
	end
	
	if self.ReloadDelay then
		return false
	end
	
	if self.dt.State ~= CW_HOLSTER_START then
		self.dt.HolsterDelay = CurTime() + self.HolsterTime
	end
	
	self.dt.State = CW_HOLSTER_START
	
	-- if holster sequence is over, let us select the desired weapon
	if self.SwitchWep and self.dt.State == CW_HOLSTER_START and CurTime() > self.dt.HolsterDelay then
		self.dt.State = CW_IDLE
		self.dt.HolsterDelay = 0
		
		return true
	end
	
	-- if it isn't, make preparations for it
	self.ShotgunReloadState = 0
	self.ReloadDelay = nil
	
	if self:filterPrediction() then
		if self.holsterSound then -- quick'n'dirty prediction fix
			self:EmitSound("CW_HOLSTER", 70, 100)
			self.holsterSound = false
			
			if IsFirstTimePredicted() then
				if self.holsterAnimFunc then
					self:holsterAnimFunc()
				else
					if self.Animations.holster then
						self:sendWeaponAnim("holster")
					end
				end
			end
		end
	end
	
	self.SwitchWep = wep
	self.SuppressTime = nil
	
	if self.dt.M203Active then
		if SERVER and SP then
			SendUserMessage("CW20_M203OFF", self.Owner)
		end
		
		if CLIENT then
			self:resetM203Anim()
		end
	end

	self.dt.M203Active = false
end

local mag, ammo

function SWEP:Reload()
	CT = CurTime()
	
	if self.ReloadDelay or CT < self.ReloadWait or self.dt.State == CW_ACTION or self.ShotgunReloadState != 0 then
		return
	end
	
	if CT < self.GlobalDelay then
		return
	end
	
	if self.FiremodesEnabled and self.Owner:KeyDown(IN_USE) and self.dt.State != CW_RUNNING then
		self:CycleFiremodes()
		return
	end	
	
	if self.dt.M203Active then
		if not self.M203Chamber and self.Owner:GetAmmoCount("40MM") > 0 then
			if IsFirstTimePredicted() then
				self:reloadM203()
			end
			
			self.dt.State = CW_IDLE
			return
		end
	end
	
	mag = self:Clip1()
	
	local cantReload, overrideMagCheck, overrideAmmoCheck = CustomizableWeaponry.callbacks.processCategory(self, "canReload", mag == 0)
	
	if cantReload then
		return
	end
	
	if not overrideMagCheck then
		if (self.Chamberable and mag >= self.Primary.ClipSize_Orig + 1) then
			return
		end
	end
	
	if not overrideAmmoCheck then
		if self.Owner:GetAmmoCount(self.Primary.Ammo) == 0 then
			return
		end
	end
	
	if not self.Chamberable and mag >= self.Primary.ClipSize then
		return
	end
	
	if self.dt.M203Active then
		if SERVER and SP then
			SendUserMessage("CW20_M203OFF_RELOAD", self.Owner)
		end
		
		if CLIENT then
			self:resetM203Anim()
		end
	end
	
	self.dt.State = CW_IDLE
	self.dt.M203Active = false
	
	self:beginReload()
end

function SWEP:beginReload()
	mag = self:Clip1()
	
	if self.ShotgunReload then
		local time = CT + self.ReloadStartTime / self.ReloadSpeed
		
		self.WasEmpty = mag == 0
		self.ReloadDelay = time
		self:SetNextPrimaryFire(time)
		self:SetNextSecondaryFire(time)
		self.GlobalDelay = time
		self.ShotgunReloadState = 1
		self.ForcedReloadStop = false
		
		self:sendWeaponAnim("reload_start", self.ReloadSpeed)
	else	
		local reloadTime = nil
		local reloadHalt = nil
		
		if mag == 0 then
			if self.Chamberable then
				self.Primary.ClipSize = self.Primary.ClipSize_Orig
			end
			
			reloadTime = self.ReloadTime_Empty
			reloadHalt = self.ReloadHalt_Empty
		else
			reloadTime = self.ReloadTime
			reloadHalt = self.ReloadHalt
			
			if self.Chamberable then
				self.Primary.ClipSize = self.Primary.ClipSize_Orig + 1
			end
		end
		
		reloadTime = reloadTime / self.ReloadSpeed
		reloadHalt = reloadHalt / self.ReloadSpeed
		
		self.ReloadDelay = CT + reloadTime
		self:SetNextPrimaryFire(CT + reloadHalt)
		self:SetNextSecondaryFire(CT + reloadHalt)
		self.GlobalDelay = CT + reloadHalt
				
		if self.reloadAnimFunc then
			self:reloadAnimFunc(mag)
		else
			if self.Animations.reload_empty and mag == 0 then
				self:sendWeaponAnim("reload_empty", self.ReloadSpeed)
			else
				self:sendWeaponAnim("reload", self.ReloadSpeed)
			end
		end
	end
	
	CustomizableWeaponry.callbacks.processCategory(self, "beginReload", mag == 0)
	
	self.Owner:SetAnimation(PLAYER_RELOAD)
end

function SWEP:finishReload()
	mag, ammo = self:Clip1(), self.Owner:GetAmmoCount(self.Primary.Ammo)

	if mag > 0 then
		if self.SnapToIdlePostReload then
			self:sendWeaponAnim("idle", 1, 1)
		end
	end
	
	local suppressReloadLogic = CustomizableWeaponry.callbacks.processCategory(self, "defaultReloadLogic", mag == 0)
	
	if not suppressReloadLogic then
		if self.ReloadAmount then
			if SERVER then
				self:SetClip1(math.Clamp(mag + self.ReloadAmount, 0, self.Primary.ClipSize))
				self.Owner:RemoveAmmo(self.ReloadAmount, self.Primary.Ammo)
			end
		else
			if mag > 0 then
				if ammo >= self.Primary.ClipSize - mag then
					if SERVER then
						self:SetClip1(math.Clamp(self.Primary.ClipSize, 0, self.Primary.ClipSize))
						self.Owner:RemoveAmmo(self.Primary.ClipSize - mag, self.Primary.Ammo)
					end
				else
					if SERVER then
						self:SetClip1(math.Clamp(mag + ammo, 0, self.Primary.ClipSize))
						self.Owner:RemoveAmmo(ammo, self.Primary.Ammo)
					end
				end
			else
				if ammo >= self.Primary.ClipSize then
					if SERVER then
						self:SetClip1(math.Clamp(self.Primary.ClipSize, 0, self.Primary.ClipSize))
						self.Owner:RemoveAmmo(self.Primary.ClipSize, self.Primary.Ammo)
					end
				else
					if SERVER then
						self:SetClip1(math.Clamp(ammo, 0, self.Primary.ClipSize))
						self.Owner:RemoveAmmo(ammo, self.Primary.Ammo)
					end
				end
			end
		end
	end
	
	CustomizableWeaponry.callbacks.processCategory(self, "finishReload")
	
	self.ReloadDelay = nil
end

function SWEP:CycleFiremodes()
	t = self.FireModes
	
	if not t.last then
		t.last = 2
	else
		if not t[t.last + 1] then
			t.last = 1
		else
			t.last = t.last + 1
		end
	end
	
	if self.dt.State == CW_AIMING or self:isBipodDeployed() then
		if self.FireModes[t.last] == "safe" then
			t.last = 1
		end
	end
	
	if self.FireMode != self.FireModes[t.last] and self.FireModes[t.last] then
		CT = CurTime()
		
		if IsFirstTimePredicted() then
			self:SelectFiremode(self.FireModes[t.last])
		end
		
		self:SetNextPrimaryFire(CT + 0.25)
		self:SetNextSecondaryFire(CT + 0.25)
		self.ReloadWait = CT + 0.25
	end
end

-- utility funcs

function SWEP:isAiming()
	return self.dt.State == CW_AIMING
end

function SWEP:isRunning()
	return self.dt.State == CW_RUNNING
end

function SWEP:SelectFiremode(n)
	if CLIENT then
		return
	end
	
	t = CustomizableWeaponry.firemodes.registeredByID[n]
	self.Primary.Automatic = t.auto
	self.FireMode = n
	self.BurstAmount = t.burstamt
	
	if self.FireMode == "safe" then
		self.dt.Safe = true -- more reliable than umsgs
	else
		self.dt.Safe = false
	end
	
	if SERVER then
		umsg.Start("CW_FIREMODE")
			umsg.Entity(self.Owner)
			umsg.String(n)
		umsg.End()
	end
end

local reg = debug.getregistry()
local GetVelocity = reg.Entity.GetVelocity
local Length = reg.Vector.Length
local GetAimVector = reg.Player.GetAimVector

local calculateAccuracy = "calculateAccuracy"

function SWEP:getBipodHipSpread()
	return self.AimSpread * 1.2
end

function SWEP:getBaseCone()
	-- call callbacks for the aim/hip spread calculation
	local aimSpreadMod, hipSpreadMod, maxSpreadMod = CustomizableWeaponry.callbacks.processCategory(self, calculateAccuracy)
	maxSpreadMod = maxSpreadMod or 1
	local finalSpread = nil
	
	if self.dt.State == CW_AIMING then
		finalSpread = self.AimSpread * (aimSpreadMod or 1)
	else
		if self.dt.BipodDeployed then
			finalSpread = self:getBipodHipSpread() * (aimSpreadMod or 1)
		else
			finalSpread = self.HipSpread * (hipSpreadMod or 1)
		end
	end
	
	return finalSpread, maxSpreadMod
end

function SWEP:getMaxSpreadIncrease(maxSpreadMod)
	return self.MaxSpreadInc * maxSpreadMod
end

function SWEP:getCrouchSpreadModifier()
	return self.dt.State == CW_AIMING and 0.9 or 0.75
end

function SWEP:CalculateSpread(vel, dt)
	if not self.AccuracyEnabled then
		return
	end
	
	aim = GetAimVector(self.Owner)
	CT = CurTime()
	
	if not self.Owner.LastView then
		self.Owner.LastView = aim
		self.Owner.ViewAff = 0
	else
		self.Owner.ViewAff = LerpCW20(dt * 10, self.Owner.ViewAff, (aim - self.Owner.LastView):Length() * 0.5)
		self.Owner.LastView = aim
	end
	
	local baseCone, maxSpreadMod = self:getBaseCone()
	self.BaseCone = baseCone
	
	if self.Owner:Crouching() then
		self.BaseCone = self.BaseCone * self:getCrouchSpreadModifier()
	end
	
	self.CurCone = self:getFinalSpread(vel, maxSpreadMod)
	
	if CT > self.SpreadWait then
		self.AddSpread = math.Clamp(self.AddSpread - 0.5 * self.AddSpreadSpeed * dt, 0, self:getMaxSpreadIncrease(maxSpreadMod))
		self.AddSpreadSpeed = math.Clamp(self.AddSpreadSpeed + 5 * dt, 0, 1)
	end
end

local mag, ammo

local IFTP
local wl, ws

function SWEP:Think()
	-- in vehicle? can't do anything, also prevent needless calculations of stuff
	if self.Owner:InVehicle() and not self.Owner:GetAllowWeaponsInVehicle() then
		self.dt.State = CW_ACTION
		return
	end
	
	CustomizableWeaponry.actionSequence.process(self)
	
	if self.dt.State == CW_HOLSTER_START then
		return
	end
	
	CT = CurTime()
	
	if CLIENT then
		if self.SubCustomizationCycleTime then
			if UnPredictedCurTime() > self.SubCustomizationCycleTime then
				CustomizableWeaponry.cycleSubCustomization(self)
			end
		end
	end
	
	if self.HoldToAim then
		if (SP and SERVER) or not SP then
			if self.dt.State == CW_AIMING then
				if not self.Owner:OnGround() or Length(GetVelocity(self.Owner)) >= self.Owner:GetRunSpeed() * self.LoseAimVelocity or not self.Owner:KeyDown(IN_ATTACK2) then
					self.dt.State = CW_IDLE
					self:SetNextSecondaryFire(CT + 0.2)
					self:EmitSound("CW_LOWERAIM")
				end
			end
		end
	end
	
	if self.IndividualThink then
		self:IndividualThink()
		
		if not IsValid(self) or not IsValid(self.Owner) then
			return
		end
	end
	
	vel = Length(GetVelocity(self.Owner))
	IFTP = IsFirstTimePredicted()
	
	if (not SP and IFTP) or SP then
		self:CalculateSpread(vel, FrameTime())
	end
	
	if CT > self.GlobalDelay then
		wl = self.Owner:WaterLevel()

		if self.Owner:OnGround() then
			-- prone mod compatibility starts
			if self:isPlayerEnteringProne() then
				self.dt.State = CW_PRONE_BUSY
			elseif self:isPlayerProne() and vel >= self.BusyProneVelocity and not self.ShootWhileProne then
				self.dt.State = CW_PRONE_MOVING
			else
				-- prone mod compatibility ends
				if wl >= 3 and self.HolsterUnderwater then
					if self.ShotgunReloadState == 1 then
						self.ShotgunReloadState = 2
					end
					
					self.dt.State = CW_ACTION
					self.FromActionToNormalWait = CT + 0.3
				else
					ws = self.Owner:GetWalkSpeed()
					
					if ((vel > ws * self.RunStateVelocity and self.Owner:KeyDown(IN_SPEED)) or vel > ws * 3 or (self.ForceRunStateVelocity and vel > self.ForceRunStateVelocity)) and self.SprintingEnabled then
						self.dt.State = CW_RUNNING
					else
						if self.dt.State != CW_AIMING and self.dt.State != CW_CUSTOMIZE then
							if CT > self.FromActionToNormalWait then
								if self.dt.State != CW_IDLE then
									self.dt.State = CW_IDLE
									
									if not self.ReloadDelay then
										self:SetNextPrimaryFire(CT + 0.3)
										self:SetNextSecondaryFire(CT + 0.3)
										self.ReloadWait = CT + 0.3
									end
								end
							end
						end
					end
				end
			end
		else
			if (wl > 1 and self.HolsterUnderwater) or (self.Owner:GetMoveType() == MOVETYPE_LADDER and self.HolsterOnLadder) then
				if self.ShotgunReloadState == 1 then
					self.ShotgunReloadState = 2
				end
				
				self.dt.State = CW_ACTION
				self.FromActionToNormalWait = CT + 0.3
			else
				if CT > self.FromActionToNormalWait then
					if self.dt.State != CW_IDLE then
						self.dt.State = CW_IDLE
						self:SetNextPrimaryFire(CT + 0.3)
						self:SetNextSecondaryFire(CT + 0.3)
						self.ReloadWait = CT + 0.3
					end
				end
			end
		end
	end
	
	if SERVER then
		if self.CurSoundTable then
			local t = self.CurSoundTable[self.CurSoundEntry]
			
			--[[if CLIENT then
				if CT >= self.SoundTime + t.time / self.SoundSpeed then
					self:EmitSound(t.sound, 70, 100)
					if self.CurSoundTable[self.CurSoundEntry + 1] then
						self.CurSoundEntry = self.CurSoundEntry + 1
					else
						self.CurSoundTable = nil
						self.CurSoundEntry = nil
						self.SoundTime = nil
					end
				end
			else]]--
			if CT >= self.SoundTime + t.time / self.SoundSpeed then
				if t.sound and t.sound ~= "" then
					self:EmitSound(t.sound, 70, 100)
				end
				
				if t.callback then
					t.callback(self)
				end
				
				if self.CurSoundTable[self.CurSoundEntry + 1] then
					self.CurSoundEntry = self.CurSoundEntry + 1
				else
					self.CurSoundTable = nil
					self.CurSoundEntry = nil
					self.SoundTime = nil
				end
			end
			--end
		end
	end
	
	if self.dt.Shots > 0 then
		if not self.Owner:KeyDown(IN_ATTACK) then
			if self.BurstAmount and self.BurstAmount > 0 then
				self.dt.Shots = 0
				self:SetNextPrimaryFire(CT + self.FireDelay * self.BurstCooldownMul)
				self.ReloadWait = CT + self.FireDelay * self.BurstCooldownMul
			end
		end
	end
	
	if not self.ShotgunReload then
		if self.ReloadDelay and CT >= self.ReloadDelay then
			self:finishReload() -- more like finnishReload ;0
		end
	end
	
	if IFTP then
	--[[SWEP.AimBreathingIntensity = 1
	SWEP.CurBreatheIntensity = 1
	SWEP.BreathLeft = 1
	SWEP.BreathRegenRate = 10
	SWEP.BreathDrainRate = 5
	SWEP.BreathIntensityDrainRate = 10
	SWEP.BreathIntensityRegenRate = 10]]--
		
		if self.ShotgunReloadState == 1 then
			if self.Owner:KeyPressed(IN_ATTACK) and self:Clip1() ~= 0 then
				self.ShotgunReloadState = 2
				self.ForcedReloadStop = true
			end
			
			if CT > self.ReloadDelay then
				self:sendWeaponAnim("insert", self.ReloadSpeed)
				
				if SERVER and not SP then
					self.Owner:SetAnimation(PLAYER_RELOAD)
				end
				
				mag, ammo = self:Clip1(), self.Owner:GetAmmoCount(self.Primary.Ammo)
				
				if SERVER then
					self:SetClip1(mag + 1)
					self.Owner:SetAmmo(ammo - 1, self.Primary.Ammo)
				end
				
				self.ReloadDelay = CT + self.InsertShellTime / self.ReloadSpeed
				
				local maxReloadAmount = self.Primary.ClipSize 
				
				if self.Chamberable and not self.WasEmpty then  -- if the weapon is chamberable + we've cocked it - we can add another shell in there
					maxReloadAmount = self.Primary.ClipSize + 1
				end
				
				-- if we've filled up the weapon (or we have no ammo left), we go to the "end reload" state
				if mag + 1 == maxReloadAmount or ammo - 1 == 0 then
					self.ShotgunReloadState = 2
				end
			end
		elseif self.ShotgunReloadState == 2 then
			if self.Owner:KeyPressed(IN_ATTACK) then
				self.ShotgunReloadState = 2
				self.ForcedReloadStop = true
			end
			
			if CT > self.ReloadDelay then
				if not self.WasEmpty then
					self:sendWeaponAnim("idle", self.ReloadSpeed)
					self.ShotgunReloadState = 0
					
					local time = 0.25 / self.ReloadSpeed
					self:SetNextPrimaryFire(time)
					self:SetNextSecondaryFire(time)
					self.ReloadWait = time
					self.ReloadDelay = nil
				else
					local canInsertMore = false
					local waitTime = self.ReloadFinishWait
					
					if not self.ForcedReloadStop and self.Chamberable and self:Clip1() < self.Primary.ClipSize + 1 and self.Owner:GetAmmoCount(self.Primary.Ammo) > 0 then
						waitTime = self.PumpMidReloadWait or waitTime
						canInsertMore = true
					end
					
					self:sendWeaponAnim("reload_end", self.ReloadSpeed)
					self.ShotgunReloadState = 0
					
					local time = CT + waitTime / self.ReloadSpeed
					self:SetNextPrimaryFire(time)
					self:SetNextSecondaryFire(time)
					self.ReloadWait = time
					
					if not canInsertMore then
						self.ReloadDelay = nil
					else
						self.ReloadDelay = time
					end
					
					if canInsertMore then -- if we can chamber and we haven't chambered up fully + we have some ammo to spare
						self.ShotgunReloadState = 1 -- we add another shell in there
						self.WasEmpty = false
					
					end
				end
			end
		end
	end
	
	if SERVER then
		if self.dt.Safe then
			if self.CHoldType != self.RunHoldType then
				self:SetHoldType(self.RunHoldType)
				self.CHoldType = self.RunHoldType
			end
		else
			if self.dt.State == CW_RUNNING or self.dt.State == CW_ACTION then
				if self.CHoldType != self.RunHoldType then
					self:SetHoldType(self.RunHoldType)
					self.CHoldType = self.RunHoldType
				end
			else
				if self.CHoldType != self.NormalHoldType then
					self:SetHoldType(self.NormalHoldType)
					self.CHoldType = self.NormalHoldType
				end
			end
		end
	end
	
	if (SP and SERVER) or not SP then -- if it's SP, then we run it only on the server (otherwise shit gets fucked); if it's MP we predict it
		-- if the bipod DT var is true, or if we have a bipod deploy angle
		if self.dt.BipodDeployed or self.DeployAngle then
			-- check whether the bipod can be placed on the current surface (so we don't end up placing on nothing)
			
			if not self:CanRestWeapon(self.BipodDeployHeightRequirement) then
				self.dt.BipodDeployed = false
				self.DeployAngle = nil

				if not self.ReloadDelay then
					if CT > self.BipodDelay then
						self:performBipodDelay(self.BipodUndeployTime)
					else
						self.BipodUnDeployPost = true
					end
				else
					self.BipodUnDeployPost = true
				end
			end
		end
			
		if not self.ReloadDelay then
			if self.BipodUnDeployPost then
				if CT > self.BipodDelay then
					if not self:CanRestWeapon(self.BipodDeployHeightRequirement) then
						self:performBipodDelay(self.BipodUndeployTime)
						self.BipodUnDeployPost = false
					else
						self.dt.BipodDeployed = true
						
						self:setupBipodVars()
						self.BipodUnDeployPost = false
					end
				end
			end
			
			if self.Owner:KeyPressed(IN_USE) then
				if CT > self.BipodDelay and CT > self.ReloadWait then
					if self.BipodInstalled then
						if self.dt.BipodDeployed then
							self.dt.BipodDeployed = false
							self.DeployAngle = nil

							self:performBipodDelay(self.BipodUndeployTime)
						else
							self.dt.BipodDeployed = self:CanRestWeapon(self.BipodDeployHeightRequirement)
							
							if self.dt.BipodDeployed then
								self:performBipodDelay(self.BipodDeployTime)
								self:setupBipodVars()
							end
						end
					end
				end
			end
		end
	end
	
	if self.forcedState then
		if CT < self.ForcedStateTime then
			self.dt.State = self.forcedState
		else
			self.forcedState = nil
		end
	end
end

function SWEP:simulateRecoil()
	if self.dt.State == CW_AIMING or self.dt.BipodDeployed then
		self.FireMove = math.Clamp(self.Recoil * self.FireMoveMod, 1, 3)
	else
		self.FireMove = 0.4
	end
	
	if self.dt.State ~= CW_AIMING and not self.freeAimOn then
		self.FOVHoldTime = UnPredictedCurTime() + self.FireDelay * 2
		
		if self.HipFireFOVIncrease then
			self.FOVTarget = math.Clamp(self.FOVTarget + 8 / (self.Primary.ClipSize_Orig * 0.75) * self.FOVPerShot, 0, 7)
		end
	end
	
	if self.freeAimOn and not self.dt.BipodDeployed then -- we only want to add the 'roll' view shake when we're not using a bipod in free-aim mode
		self.lastViewRoll = math.Clamp(self.lastViewRoll + self.Recoil * 0.5, 0, 15)
		self.lastViewRollTime = UnPredictedCurTime() + FrameTime() * 3
	end
	
	self.lastShotTime = CurTime() + math.Clamp(self.FireDelay * 3, 0, 0.3) -- save the last time we shot
	
	if self.BoltBone then
		self:offsetBoltBone()
	end
	
	if self.LuaViewmodelRecoil then
		if (self.dt.State ~= CW_AIMING and not self.FullAimViewmodelRecoil) or self.FullAimViewmodelRecoil then
			-- increase intensity of the viewmodel recoil with each shot
			self.LuaVMRecoilIntensity = math.Approach(self.LuaVMRecoilIntensity, 1, self.Recoil * 0.15)
			self.LuaVMRecoilLowerSpeed = 0
			
			if not self.dt.BipodDeployed then
				self:makeVMRecoil()
			end
		end
	end
	
	if self.ReticleInactivityPostFire then
		self.reticleInactivity = UnPredictedCurTime() + self.ReticleInactivityPostFire
	end
end

function SWEP:addFireSpread(CT)
	self.SpreadWait = CT + self.SpreadCooldown
	local mul, mulMax = self:getSpreadModifiers()
	
	if self.BurstAmount > 0 then
		self.AddSpread = math.Clamp(self.AddSpread + self.SpreadPerShot * self.BurstSpreadIncMul * mul, 0, self.MaxSpreadInc * mulMax)
	else
		self.AddSpread = math.Clamp(self.AddSpread + self.SpreadPerShot * mul, 0, self.MaxSpreadInc * mulMax)
	end
	
	-- decrease spread restore speed per each shot
	self.AddSpreadSpeed = math.Clamp(self.AddSpreadSpeed - 0.2, 0, 1)
end

function SWEP:playFireAnim()
	if (self.dt.State == CW_AIMING and not self.ADSFireAnim) or (self.dt.BipodDeployed and not self.BipodFireAnim) then
		return
	end
	
	if self.dt.State ~= CW_AIMING and (not self.LuaViewmodelRecoilOverride and self.LuaViewmodelRecoil) then
		return
	end
	
	if self:Clip1() - self.AmmoPerShot <= 0 and self.Animations.fire_dry then
		self:sendWeaponAnim("fire_dry")
	else
		self:sendWeaponAnim("fire", self.FireAnimSpeed)
	end
end

function SWEP:getFireSound()
	return self.dt.Suppressed and self.FireSoundSuppressed or self.FireSound
end

function SWEP:getFireParticles()
	return self.dt.Suppressed and self.MuzzleEffectSupp or self.MuzzleEffect
end

local mul

function SWEP:canFireWeapon(checkType)
	if checkType == 1 then
		if self.ShotgunReloadState != 0 then
			return
		end
		
		if self.ReloadDelay then
			return
		end
		
		local preFireResult = CustomizableWeaponry.callbacks.processCategory(self, "preFire")
		
		if preFireResult then
			return
		end
	elseif checkType == 2 then
		if CurTime() < self.GlobalDelay then
			return false
		end
	elseif checkType == 3 then
		if self:isNearWall() then
			return
		end
		
		if self.InactiveWeaponStates[self.dt.State] then
			return
		end
	
	end
	
	return true
end

function SWEP:postPrimaryAttack()
	
end

function SWEP:PrimaryAttack()
	if not self:canFireWeapon(1) then
		return
	end
	
	if self.Owner:KeyDown(IN_USE) then
		if CustomizableWeaponry.quickGrenade.canThrow(self) then
			CustomizableWeaponry.quickGrenade.throw(self)
			return
		end
	end
	
	if self.dt.State == CW_AIMING and self.dt.M203Active then
		if self.M203Chamber then
			self:fireM203(IsFirstTimePredicted())
	
			return
		end
	end
	
	if not self:canFireWeapon(2) then
		return
	end
	
	if self.dt.Safe then
		self:CycleFiremodes()
		return
	end
	
	if not self:canFireWeapon(3) then
		return
	end
	
	mag = self:Clip1()
	CT = CurTime()
	
	if mag == 0 then
		self:EmitSound("CW_EMPTY", 100, 100)
		self:SetNextPrimaryFire(CT + 0.25)
		return
	end
	
	if self.BurstAmount and self.BurstAmount > 0 then
		if self.dt.Shots >= self.BurstAmount then
			return
		end
		
		self.dt.Shots = self.dt.Shots + 1
	end
	
	self.Owner:SetAnimation(PLAYER_ATTACK1)
	
	if IsFirstTimePredicted() then
		local muzzleData = EffectData()
		muzzleData:SetEntity(self)
		util.Effect("cw_muzzleflash", muzzleData)
		
		if self.dt.Suppressed then
			self:EmitSound(self.FireSoundSuppressed, 105, 100)
		else
			self:EmitSound(self.FireSound, 105, 100)
		end
		
		if self.fireAnimFunc then
			self:fireAnimFunc()
		else
			if self.dt.State == CW_AIMING then
				if self.ADSFireAnim then
					self:playFireAnim()
				end
			else
				self:playFireAnim()
			end
		end
		
		self:FireBullet(self.Damage, self.CurCone, self.ClumpSpread, self.Shots)
		self:makeFireEffects()
		
		if CLIENT then
			self:simulateRecoil()
		end
		
		self:addFireSpread(CT)
		
		if SP and SERVER then
			SendUserMessage("CW_Recoil", self.Owner)
		end
		
		-- apply a global delay after shooting, if there is one
		if self.GlobalDelayOnShoot then
			self.GlobalDelay = CT + self.GlobalDelayOnShoot
		end
	end
	
	self:MakeRecoil()
	
	CustomizableWeaponry.callbacks.processCategory(self, "postFire")
	
	local suppressAmmoUsage = CustomizableWeaponry.callbacks.processCategory(self, "shouldSuppressAmmoUsage")
	
	if not suppressAmmoUsage then
		self:TakePrimaryAmmo(self.AmmoPerShot)
	end
	
	self:SetNextPrimaryFire(CT + self.FireDelay)
	
	-- either force the weapon back to hip after firing, or don't
	if self.ForceBackToHipAfterAimedShot then
		self.dt.State = CW_IDLE
		self:SetNextSecondaryFire(CT + self.ForcedHipWaitTime)
	else
		self:SetNextSecondaryFire(CT + self.FireDelay)
	end
	
	self.ReloadWait = CT + (self.WaitForReloadAfterFiring and self.WaitForReloadAfterFiring or self.FireDelay)
	
	self:postPrimaryAttack()
	CustomizableWeaponry.callbacks.processCategory(self, "postConsumeAmmo")
	
	if SP and SERVER then
		SendUserMessage("CW_PostFire", self.Owner)
	end
end

function SWEP:fireM203(firstTimePrediction)
	if SERVER and SP then
		SendUserMessage("CW20_FIREM203", self.Owner)
	end
	
	CustomizableWeaponry.grenadeTypes.selectFireFunc(self, IsFirstTimePredicted())
	
	self.Owner:ViewPunch(Angle(math.Rand(-5, -4), math.Rand(-2, 2), math.Rand(-1, 1)))
	
	self.M203Chamber = false
	
	if CLIENT then
		self:makeVMRecoil(5)
		
		--local vm = self.AttachmentModelsVM.md_m203.ent
		--ParticleEffectAttach("muzzleflash_m79", PATTACH_POINT_FOLLOW, vm, vm:LookupAttachment("1"))
	end
	
	self:delayEverything(0.4)
	self:setGlobalDelay(0.4)
end

function SWEP:reloadM203()
	if SERVER and SP then
		SendUserMessage("CW20_RELOADM203", self.Owner)
	end
	
	if self:filterPrediction() then
		self:setCurSoundTable(self.M203ReloadSounds, 1, 0)
	end
	
	if CLIENT then
		self:setM203Anim(self.M203Anims.reload)
	end
	
	self:setGlobalDelay(2.6)
	
	CustomizableWeaponry.actionSequence.new(self, 2, nil, function()
		if SERVER then
			self.Owner:RemoveAmmo(1, "40MM")
		end
		
		self.M203Chamber = true
	end)
end

function SWEP:makeFireEffects()
	if SP and SERVER then
		-- god damn prediction disabled in SP
		SendUserMessage("CW20_EFFECTS")
		return
	end
	
	if CLIENT then
		if self.MuzzleEffect then
			self:CreateMuzzle()
		end
		
		if self.Shell then
			self:CreateShell()
		end
	end
end

local ang

function SWEP:GetRecoilModifier(mod)
	mod = mod and mod or 1
	
	if self.Owner:Crouching() then
		mod = mod * 0.75
	end
	
	if self.dt.State == CW_AIMING then
		mod = mod * 0.85
	end
	
	if self.dt.Suppressed then
		mod = mod * 0.85
	end
	
	if self:isPlayerProne() then
		mod = mod * 0.65
	end
	
	-- increase recoil by 20% if we're in M203 mode
	if self.dt.M203Active then
		mod = mod * 1.2
	end
	
	if self.dt.BipodDeployed then
		mod = mod * self.BipodRecoilModifier
	else
		-- if we don't have a bipod deployed, but we can rest our weapon on a surface, reduce recoil by a bit
		if self.dt.State == CW_AIMING then
			if self.CanRestOnObjects then
				if self:CanRestWeapon(self.WeaponRestHeightRequirement) then
					mod = mod * 0.85
				end
			end
		end
		
		if self.freeAimOn then -- compensate for the lack of ViewPunch by increasing the recoil modifier by 50%
			mod = mod * 1.5
		end
	end
	
	-- multiply recoil in case we have a burst fire firemode enabled
	if self.BurstAmount > 0 then
		mod = mod * self.BurstRecoilMul
	end
	
	-- pass the recoil to possible callbacks
	local finalMod = CustomizableWeaponry.callbacks.processCategory(self, "calculateRecoil", mod)
	
	mod = finalMod or mod
	
	-- increase recoil as weapon spread increases
	mod = mod * 1 + (self.AddSpread / self.MaxSpreadInc) * self.RecoilToSpread
	
	return mod
end

function SWEP:isFreeAimOn()
	if self.NoFreeAim then
		return false
	end
	
	local result = CustomizableWeaponry.callbacks.processCategory(self, "forceFreeAim")

	if result or self.Owner:GetInfoNum("cw_freeaim", 0) > 0 then
		return true
	end
	
	return false
end

function SWEP:MakeRecoil(mod)
	local mod = self:GetRecoilModifier(mod)
	local IFTP = IsFirstTimePredicted()
	
	if (SP and SERVER) or (not SP and CLIENT and IFTP) then
		ang = self.Owner:EyeAngles()
		ang.p = ang.p - self.Recoil * 0.5 * mod
		ang.y = ang.y + math.Rand(-1, 1) * self.Recoil * 0.5 * mod
	
		self.Owner:SetEyeAngles(ang)
	end

	local freeAimOn = self:isFreeAimOn()
	
	if not freeAimOn or (freeAimOn and self.dt.BipodDeployed) then
		self.Owner:ViewPunch(Angle(-self.Recoil * 1.25 * mod, 0, 0))
	end
	
	if CLIENT and IFTP then
		if self.AimBreathingEnabled then
			if self.holdingBreath then
				self:reduceBreathAmount(mod)
			else
				self:reduceBreathAmount(0)
			end
		end
	end
end

function SWEP:SecondaryAttack()
	if self.ShotgunReloadState != 0 then
		return
	end
	
	if self.ReloadDelay then
		return
	end
	
	if CurTime() < self.GlobalDelay then
		return false
	end
	
	if self.dt.Safe then
		self:CycleFiremodes()
		return
	end
	
	if self.InactiveWeaponStates[self.dt.State] or (self.dt.State == CW_AIMING and self.HoldToAim) then
		return
	end
	
	if self:isNearWall() then
		return
	end
	
	local IFTP = IsFirstTimePredicted()
	
	if self.Owner:KeyDown(IN_USE) then
		if self.ActiveAttachments.md_m203 then
			if self.ToggleM203States[self.dt.State] then
				if self.dt.M203Active then
					self.dt.M203Active = false
					
					if CLIENT and IFTP then
						self:disableM203(IFTP)
					end
					if SERVER and SP then
						SendUserMessage("CW20_M203OFF", self.Owner)
					end
				else
					self.dt.M203Active = true
					
					if IFTP then
						if CLIENT then
							self:enableM203()
						end
					end
					
					if SERVER and SP then
						SendUserMessage("CW20_M203ON", self.Owner)
					end
				end
				
				self:delayEverything(0.4)
				
				return
			end
		end
	end
	
	if not self.Owner:OnGround() or Length(GetVelocity(self.Owner)) >= self.Owner:GetWalkSpeed() * self.RunStateVelocity then
		return
	end
	
	CT = CurTime()
	
	if self.dt.State ~= CW_AIMING then
		self.dt.State = CW_AIMING
		
		if self:filterPrediction() then
			self:EmitSound("CW_TAKEAIM")
		end
	else
		self.dt.State = CW_IDLE
		
		if self:filterPrediction() then
			self:EmitSound("CW_LOWERAIM")
		end
	end
	
	if IFTP then
		self.AimTime = UnPredictedCurTime() + 0.25
		
		if self.PreventQuickScoping then
			self.AddSpread = math.Clamp(self.AddSpread + self.QuickScopeSpreadIncrease, 0, self.MaxSpreadInc)
			self.SpreadWait = CT + 0.3
		end
	end
	
	if SP and SERVER then
		SendUserMessage("CW_AimTime", self.Owner)
	end
	
	self:SetNextSecondaryFire(CT + 0.1)
end

function SWEP:enableM203()
	self:resetM203Anim()
	self:setM203Anim(self.M203Anims.idle_to_ready, 0.1)
	self:offsetM203ArmBone(false) -- move the arm bone away
end

function SWEP:disableM203(firstTimePrediction)
	self:resetM203Anim()
	self:offsetM203ArmBone(true) -- restore it

	if firstTimePrediction then
		self.M203Time = UnPredictedCurTime() + 0.25
	end
end

function SWEP:DoImpactEffect(traceData, damageType)
	local shouldSuppress, realm = CustomizableWeaponry.callbacks.processCategory(self, "suppressDefaultImpactEffect")
	
	if shouldSuppress then
		if CLIENT and realm == CLIENT then
			return true
		elseif SERVER and realm == SERVER then
			return true
		end
	end
end

if CLIENT then
	local EP, EA2, FT
	
	function SWEP:ViewModelDrawn()
		EP, EA2, FT = EyePos(), EyeAngles(), FrameTime()
		
		if IsValid(self.Hands) then
			self.Hands:SetRenderOrigin(EP)
			self.Hands:SetRenderAngles(EA2)
			self.Hands:FrameAdvance(FT)
			self.Hands:SetupBones()
			self.Hands:SetParent(self.Owner:GetViewModel())
			self.Hands:DrawModel()
		end
	end
	
	local wm, pos, ang
	local GetBonePosition = debug.getregistry().Entity.GetBonePosition
	
	local ply, wep
	
	local function GetRecoil()
		ply = LocalPlayer()
		
		if not ply:Alive() then
			return
		end
		
		wep = ply:GetActiveWeapon()
		
		if IsValid(wep) and wep.CW20Weapon then
			CT = CurTime()
			wep.SpreadWait = CT + wep.SpreadCooldown
			
			wep:MakeRecoil()
			wep:simulateRecoil()
			wep:addFireSpread(CT)
		end
	end
	
	usermessage.Hook("CW_Recoil", GetRecoil)
	
	local function PostFire()
		ply = LocalPlayer()
		
		if not ply:Alive() then
			return
		end
		
		wep = ply:GetActiveWeapon()
		
		if IsValid(wep) and wep.CW20Weapon then
			wep:postPrimaryAttack()
		end
	end
	
	usermessage.Hook("CW_PostFire", PostFire)
	
	local function AimTime()
		ply = LocalPlayer()
		
		if not ply:Alive() then
			return
		end
		
		wep = ply:GetActiveWeapon()
		
		if IsValid(wep) and wep.CW20Weapon then
			wep.AimTime = UnPredictedCurTime() + 0.25
			
			if wep.PreventQuickScoping then
				wep.AddSpread = math.Clamp(wep.AddSpread + wep.QuickScopeSpreadIncrease, 0, wep.MaxSpreadInc)
				wep.SpreadWait = CurTime() + 0.3
			end
		end
	end
	
	usermessage.Hook("CW_AimTime", AimTime)

	local function CW_ReceiveFireMode(um)
		ply = um:ReadEntity()
		Mode = um:ReadString()
		
		if IsValid(ply) then
			wep = ply:GetActiveWeapon()
			wep.FireMode = Mode
			
			if IsValid(ply) and IsValid(wep) and wep.CW20Weapon then
				if CustomizableWeaponry.firemodes.registeredByID[Mode] then
					t = CustomizableWeaponry.firemodes.registeredByID[Mode]
					
					wep.Primary.Automatic = t.auto
					wep.BurstAmount = t.burstamt
					wep.FireModeDisplay = t.display
					wep.BulletDisplay = t.buldis
					wep.CheckTime = CurTime() + 2
					
					if ply == LocalPlayer() then
						ply:EmitSound("weapons/smg1/switch_single.wav", 70, math.random(92, 112))
					end
				end
			end
		end
	end

	usermessage.Hook("CW_FIREMODE", CW_ReceiveFireMode)
end


================================================
FILE: cw2/lua/weapons/cw_base/sv_attachments.lua
================================================
util.AddNetworkString("CW20_GRENADETYPE")

function SWEP:attachSpecificAttachment(attachmentName)
	-- since we don't know the category, we'll just have to iterate over all attachments, find the one we want, and attach it there
	for category, data in pairs(self.Attachments) do
		for key, attachment in ipairs(data.atts) do
			if attachment == attachmentName then
				self:attach(category, key - 1, false)
			end
		end
	end
end

function SWEP:attach(category, desiredPos, isPreset)
	-- reset the last preset entry in case what we're attaching isn't a preset
	if not isPreset then
		self.LastPreset = nil
	end
	
	desiredPos = desiredPos or nil

	if not category then
		return
	end
	
	local cur = self.Attachments[category]
	
	if not cur then
		return
	end
	
	-- check whether we've reached the end of the category
	
	if cur.last and cur.last == #cur.atts then
		-- if we have, detach what's currently attached
		
		self:detach(category)
	else
		-- if we haven't, attach the next attachment in the category
		local amt = #cur.atts
		local curPos = desiredPos and desiredPos or (cur.last or 0)
		
		-- loop forward until we find the end of the category
		-- we need this 'while true do' loop to loop through from current position to end position to switch attachments consistently, in case we didn't have some attachment in this category before
		
		while true do
			curPos = curPos + 1
			local targetAtt = cur.atts[curPos]
			
			if targetAtt then
				-- once we've found it, attach it, if we can
				local canAttach = self:canAttachSpecificAttachment(targetAtt, self.Owner, nil, nil, nil, cur)
				
				if canAttach then
					-- yes, preventAttachment is separate from canAttachSpecificAttachment, this is because attaching and prevention are two different things
					if CustomizableWeaponry.callbacks.processCategory(self, "preventAttachment", self.Attachments, curPos, cur, targetAtt) then
						return
					end
					
					self:_attach(category, curPos, CustomizableWeaponry.registeredAttachmentsSKey[cur.atts[curPos]])
					break
				end
				
				-- local att = CustomizableWeaponry.registeredAttachmentsSKey[cur.atts[curPos]]

				-- local can = true
	
				-- can = CustomizableWeaponry.canBeAttached(self, att, nil)
				
				-- if cur.exclusions and can then
					-- can = not self:hasExcludedAttachment(cur.exclusions)
				-- end
				
				-- -- checking whether it has dependencies or not saves us a loop
				-- if can then
					-- if CustomizableWeaponry:hasAttachment(self.Owner, att.name) then
						-- if self:isAttachmentEligible(att.name) and self:isCategoryEligible(cur.dependencies, cur.exclusions) then
							-- self:_attach(category, curPos, att)
							-- break
						-- end
					-- end
				-- end
			else
				self:detach(category)
				break
			end
		end
	end
end

function SWEP:detach(category)
	self.LastPreset = nil
	
	if not category then
		return
	end
	
	local att = self.Attachments[category]
	
	if not att or not att.last then
		return
	end
	
	local last = att.last
	
	self:_detach(category, last)
	
	net.Start("CW20_DETACH")
		net.WriteEntity(self)
		net.WriteString(category)
		net.WriteUInt(last, 8)
	net.Send(self.Owner)
	
	-- call the default reset function (to reset shit like FOV, etc.) 
	--self:resetPostDetach(foundAtt, att)
end

function SWEP:cycle40MMGrenades()
	CustomizableWeaponry.grenadeTypes.cycleGrenades(self)
	
	net.Start("CW20_GRENADETYPE")
		net.WriteUInt(self.Grenade40MM, 8)
	net.Send(self.Owner)
end

function SWEP:toggleCustomization()
	if self.dt.State ~= CW_CUSTOMIZE then
		self.dt.State = CW_CUSTOMIZE
		self.dt.M203Active = false
	else
		self.dt.State = CW_IDLE
	end
	
	self:delayEverything(self.CUSTOMIZATION_MENU_TOGGLE_WAIT)
end

local function CW20_Attach(ply, com, args)
	if not CustomizableWeaponry.canOpenInteractionMenu or not CustomizableWeaponry.customizationEnabled then
		return
	end
	
	if not ply:Alive() then
		return
	end
	
	local wep = ply:GetActiveWeapon()
	
	if not IsValid(wep) or not wep.CW20Weapon or not wep.dt.State == CW_CUSTOMIZE then
		return
	end
	
	if CustomizableWeaponry.callbacks.processCategory(wep, "disableInteractionMenu") then
		return
	end
	
	local category = args[1]
	
	if not category then
		return
	end
	
	local numberCategory = tonumber(category) -- attempt to turn the category into a string
	
	-- if it's possible, assign the category to the number variant of the string argument (compatibility with numerical and string categories)
	if numberCategory then
		category = numberCategory
	end
	
	wep:attach(category)
end

concommand.Add("cw_attach", CW20_Attach)

local function CW20_CycleGrenadeTypes(ply, com, args)
	if not CustomizableWeaponry.canOpenInteractionMenu or not CustomizableWeaponry.customizationEnabled then
		return
	end
	
	if not ply:Alive() then
		return
	end
	
	local wep = ply:GetActiveWeapon()
	
	if not IsValid(wep) or not wep.CW20Weapon or not wep.dt.State == CW_CUSTOMIZE then
		return
	end
	
	if CustomizableWeaponry.callbacks.processCategory(wep, "disableInteractionMenu") then
		return
	end
	
	wep:cycle40MMGrenades()
end

concommand.Add("cw_cycle40mm", CW20_CycleGrenadeTypes)

local function CW20_Customize(ply, com, args)
	if not CustomizableWeaponry.canOpenInteractionMenu or not CustomizableWeaponry.customizationEnabled then
		return
	end
	
	if not ply:Alive() then
		return
	end
	
	local wep = ply:GetActiveWeapon()
	
	if not IsValid(wep) or not wep.CW20Weapon then
		return
	end
	
	if wep:canCustomize() then
		wep:toggleCustomization()
	end
end

concommand.Add("cw_customize", CW20_Customize)


================================================
FILE: cw2/lua/weapons/cw_base/sv_filestodownload.lua
================================================
resource.AddFile("materials/swb/bullet.vmt")
resource.AddFile("materials/swb/clumpspread_ring.vmt")
resource.AddFile("materials/swb/scope_rifle.vmt")
resource.AddFile("materials/swb_muzzle/flash.vmt")
resource.AddFile("materials/swb_muzzle/flash_rif.vmt")
resource.AddFile("materials/swb_muzzle/flash_spark.vmt")
resource.AddFile("particles/swb_muzzle.pcf")


================================================
FILE: cw2/lua/weapons/cw_base/sv_hooks.lua
================================================
local att, wep, dist, mul

local function CW_EntityTakeDamage(ent, d)
	att = d:GetInflictor()
	
	if att:IsPlayer() then
		wep = att:GetActiveWeapon()

		if IsValid(wep) and wep.CW20Weapon and not wep.NoDistance and wep.EffectiveRange then
			dist = ent:GetPos():Distance(att:GetPos())
			
			if dist >= wep.EffectiveRange * 0.5 then
				dist = dist - wep.EffectiveRange * 0.5
				mul = math.Clamp(dist / wep.EffectiveRange, 0, 1)

				d:ScaleDamage(1 - wep.DamageFallOff * mul)
			end
		end
	end
end

hook.Add("EntityTakeDamage", "CW_EntityTakeDamage", CW_EntityTakeDamage)


================================================
FILE: cw2/lua/weapons/cw_deagle/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_DEAGLE_FIRE", "weapons/cw_deagle/fire.wav", 1, 120, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_DEAGLE_FIRE_SUPPRESSED", "weapons/cw_deagle/fire_suppressed.wav", 1, 100, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_DEAGLE_MAGOUT", "weapons/cw_deagle/magout.wav")
CustomizableWeaponry:addReloadSound("CW_DEAGLE_MAGIN", "weapons/cw_deagle/magin.wav")
CustomizableWeaponry:addReloadSound("CW_DEAGLE_SLIDEBACK", "weapons/cw_deagle/slideback.wav")
CustomizableWeaponry:addReloadSound("CW_DEAGLE_SLIDEFORWARD", "weapons/cw_deagle/slideforward.wav")


================================================
FILE: cw2/lua/weapons/cw_deagle/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "IMI Desert Eagle"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.IconLetter = "f"
	killicon.AddFont("cw_deagle", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_pistol_deagle"
	SWEP.PosBasedMuz = false
	
	SWEP.Shell = "smallshell"
	SWEP.ShellScale = 1
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = 2, y = 0, z = 1}
		
	SWEP.MicroT1Pos = Vector(-2.28, 0, -0.292)
	SWEP.MicroT1Ang = Vector(0, 0, 0)

	SWEP.EoTechPos = Vector(-2.25, -6.198, -0.32)
	SWEP.EoTechAng = Vector(0, 0, 0)

	SWEP.IronsightPos = Vector(-2.254, 5.913, 0.31)
	SWEP.IronsightAng = Vector(0.1, 0, 0)
	
	SWEP.ACOGPos = Vector(-2.247, -6.5, -0.602)
	SWEP.ACOGAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(1.634, -8.28, -8.311)
	SWEP.SprintAng = Vector(70, 0, 0)
	
	SWEP.AlternativePos = Vector(-0.88, 1.325, -0.561)
	SWEP.AlternativeAng = Vector(0, 0, 0)

	SWEP.BackupSights = {["md_acog"] = {[1] = Vector(-2.241, -4.728, -1.568), [2] = Vector(0, 0, 0)}}
	
	SWEP.MoveType = 1
	SWEP.ViewModelMovementScale = 0.8
	SWEP.FullAimViewmodelRecoil = false
	SWEP.BoltBone = "slider"
	SWEP.BoltShootOffset = Vector(-2, 0, 0)
	SWEP.HoldBoltWhileEmpty = true
	SWEP.DontHoldWhenReloading = true
	SWEP.DisableSprintViewSimulation = true
	
	SWEP.LuaVMRecoilAxisMod = {vert = 1, hor = 1.5, roll = 3, forward = 1, pitch = 4}
	SWEP.CustomizationMenuScale = 0.01
	SWEP.BoltBonePositionRecoverySpeed = 25 -- how fast does the bolt bone move back into it's initial position after the weapon has fired
	
	SWEP.AttachmentModelsVM = {
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "weapon", pos = Vector(3.325, -1.075, 0.209), angle = Angle(90, 0, -90), size = Vector(0.4, 0.4, 0.4)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "weapon", pos = Vector(-6.054, 8.47, -0.035), angle = Angle(0, 1.5, -90), size = Vector(0.85, 0.85, 0.85)},
		["md_acog"] = {model = "models/wystan/attachments/2cog.mdl", bone = "weapon", pos = Vector(-1.831, 3.892, 0.504), angle = Angle(-90, 0, -90), size = Vector(0.85, 0.85, 0.85)},
		["md_saker"] = {model = "models/cw2/attachments/556suppressor.mdl", bone = "weapon", pos = Vector(-4.784, -0.408, -1.581), angle = Angle(0, 90, 0), size = Vector(0.6, 0.6, 0.6)}
	}
end

SWEP.ShootWhileProne = true

SWEP.MuzzleVelocity = 470 -- in meter/s

SWEP.BarrelBGs = {main = 1, regular = 0, compensator = 1, extended = 2}
SWEP.LuaViewmodelRecoil = true
SWEP.CanRestOnObjects = false

SWEP.Attachments = {[1] = {header = "Sight", offset = {450, -350}, atts = {"md_microt1", "md_eotech", "md_acog"}},
[2] = {header = "Barrel", offset = {-600, -350}, atts = {"md_saker", "bg_deagle_compensator", "bg_deagle_extendedbarrel"}},
["+reload"] = {header = "Ammo", offset = {450, 100}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {fire = {"shoot1", "shoot2"},
	reload = "reload",
	reload_empty = "reload_2",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {draw = {{time = 0, sound = "CW_FOLEY_LIGHT"}},

	reload = {[1] = {time = 0.42, sound = "CW_DEAGLE_MAGOUT"},
	[2] = {time = 1.5, sound = "CW_DEAGLE_MAGIN"}},
	
	reload_2 = {[1] = {time = 0.42, sound = "CW_DEAGLE_MAGOUT"},
	[2] = {time = 1.5, sound = "CW_DEAGLE_MAGIN"},
	[3] = {time = 2.36, sound = "CW_DEAGLE_SLIDEBACK"},
	[4] = {time = 2.47, sound = "CW_DEAGLE_SLIDEFORWARD"}}}

SWEP.SpeedDec = 10

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "revolver"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.DrawSpeed = 1.5

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/pistols/deagle.mdl"
SWEP.WorldModel		= "models/weapons/w_pist_deagle.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 7
SWEP.Primary.DefaultClip	= 7
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= ".50 AE"

SWEP.FireDelay = 0.17
SWEP.FireSound = "CW_DEAGLE_FIRE"
SWEP.FireSoundSuppressed = "CW_DEAGLE_FIRE_SUPPRESSED"
SWEP.Recoil = 2.8

SWEP.HipSpread = 0.045
SWEP.AimSpread = 0.011
SWEP.VelocitySensitivity = 1.35
SWEP.MaxSpreadInc = 0.06
SWEP.SpreadPerShot = 0.02
SWEP.SpreadCooldown = 0.32
SWEP.Shots = 1
SWEP.Damage = 56
SWEP.DeployTime = 1
--SWEP.Chamberable = false
SWEP.NearWallDistance = 15

SWEP.ReloadSpeed = 1
SWEP.ReloadTime = 1.98
SWEP.ReloadHalt = 2.49

SWEP.ReloadTime_Empty = 1.98
SWEP.ReloadHalt_Empty = 3.4


================================================
FILE: cw2/lua/weapons/cw_famasg2_official/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_FAMASG2_FIRE", "weapons/cw_famasg2/fire.wav", 1, 110, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_FAMASG2_SUPPRESSED", "weapons/cw_famasg2/fire_suppressed.wav", 1, 92, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_FAMASG2_MAGOUT", "weapons/cw_famasg2/magout.wav")
CustomizableWeaponry:addReloadSound("CW_FAMASG2_MAGIN", "weapons/famas/famas_clipin.wav")
CustomizableWeaponry:addReloadSound("CW_FAMASG2_MAGIN1", "weapons/cw_famasg2/magin.wav")
CustomizableWeaponry:addReloadSound("CW_FAMASG2_CLOTH", "weapons/cw_famasg2/cloth.wav")
CustomizableWeaponry:addReloadSound("CW_FAMASG2_FOREARM", "weapons/cw_famasg2/forearm.wav")


================================================
FILE: cw2/lua/weapons/cw_famasg2_official/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "FAMAS G2"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.TelescopeSkipRotate = false
	
	SWEP.IronsightPos = Vector(-2.932, -3, 0.046)
	SWEP.IronsightAng = Vector(1.556, -0.886, 2.65)

	SWEP.MicroT1Pos = Vector(-2.911, 0, -1.441)
	SWEP.MicroT1Ang = Vector(0.61, -0.85, 2.65)	
	
	SWEP.EoTechPos = Vector(-2.845, -3, -1.869)
	SWEP.EoTechAng = Vector(0.544, -0.907, 2.65)
	
	SWEP.AimpointPos = Vector(-2.863, -3, -1.663)
	SWEP.AimpointAng = Vector(0.58, -0.77, 2.65)

	SWEP.ShortDotPos = Vector(-2.843, -3, -1.525)
	SWEP.ShortDotAng = Vector(1.478, -0.789, 2.65)
	
	SWEP.ACOGPos = Vector(-2.796, -2.5, -1.795)
	SWEP.ACOGAng = Vector(0.46, -0.179, 2.65)
	
	SWEP.SprintPos = Vector(1.786, 0, -2)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.BackupSights = {["md_acog"] = {[1] = Vector(-2.796, -3, -2.717), [2] = Vector(0.46, -0.887, 2.65)}}
	
	SWEP.AlternativePos = Vector(-0.8, 0, -0.8)
	SWEP.AlternativeAng = Vector(0, 0, 0)

	SWEP.ViewModelMovementScale = 1.15
	SWEP.CustomizationMenuScale = 0.012
	
	SWEP.IconLetter = "t"
	killicon.AddFont("cw_famasg2", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_6"
	SWEP.PosBasedMuz = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = -2, y = 0, z = -3}
	SWEP.SightWithRail = true
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.65
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.85
	
	SWEP.magBoneName = {"magazine", "bulletq"}

	SWEP.SchmidtShortDotAxisAlignNew = {right = 0, up = 0, forward = -2.65}
	SWEP.ACOGAxisAlignNew = {right = 0, up = 0, forward = -2.65}

	SWEP.LaserPosAdjust = Vector(1, 0, 0)
	SWEP.LaserAngAdjust = Angle(-0.5, 180 - 0.6, -2.65) 
	
	SWEP.AttachmentModelsVM = {
		["md_rail"] = {model = "models/wystan/attachments/rail.mdl", bone = "gun", pos = Vector(-0.245, 1.501, 2.469), angle = Angle(0, -90, 0), size = Vector(1.034, 1.034, 1.034)},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "gun", pos = Vector(0.006, 0.586, 4.493), adjustment = {min = 0.586, max = 4.245, axis = "y", inverseOffsetCalc = true, preventedBy = {"md_anpeq15"}}, angle = Angle(0, 180, 0), size = Vector(0.347, 0.347, 0.347)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "gun", pos = Vector(0.277, -9.589, -7.021), adjustment = {min = -9.589, max = -8.370, axis = "y", inverseOffsetCalc = true, preventedBy = {"md_anpeq15"}}, angle = Angle(2.75, -90, 0), size = Vector(1.019, 1.019, 1.019)},
		["md_aimpoint"] = {model = "models/wystan/attachments/aimpoint.mdl", bone = "gun", pos = Vector(-0.253, -4.612, -0.678), adjustment = {min = -4.612, max = -2.086, axis = "y", inverseOffsetCalc = true, preventedBy = {"md_anpeq15"}}, angle = Angle(0, 0, 0), size = Vector(0.899, 0.899, 0.899)},
		["md_saker"] = {model = "models/cw2/attachments/556suppressor.mdl", bone = "gun", pos = Vector(-0.019, 1.554, -0.249), angle = Angle(0, 0, 0), size = Vector(0.5, 0.5, 0.5)},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "gun", pos = Vector(-0.265, -2.544, 0.101), angle = Angle(0, -90, 0), size = Vector(0.75, 0.75, 0.75)},
		["md_acog"] = {model = "models/wystan/attachments/2cog.mdl", bone = "gun", pos = Vector(-0.301, -4, -0.334), angle = Angle(0, 0, 0), size = Vector(0.829, 0.829, 0.829)},
		["md_foregrip"] = {model = "models/wystan/attachments/foregrip1.mdl", bone = "gun", pos = Vector(-0.403, -5.182, -1.742), angle = Angle(0, 0, 0), size = Vector(0.75, 0.75, 0.75)},
		["md_bipod"] = {model = "models/wystan/attachments/bipod.mdl", bone = "gun", pos = Vector(0.076, 6.361, -0.06), angle = Angle(0, 0, 0), size = Vector(0.699, 0.699, 0.699)},
		["md_anpeq15"] = {model = "models/cw2/attachments/anpeq15.mdl", bone = "gun", pos = Vector(-0.123, 5.447, 4.297), angle = Angle(0, 90, 0), size = Vector(0.5, 0.5, 0.5)},
		["md_cmag_556_official"] = {model = "models/wystan/Cmag.mdl", bone = "magazine", pos = Vector(-0.182, -3.918, 1.111), angle = Angle(0, -90, 0), size = Vector(0.699, 0.699, 0.699)}
	}

	SWEP.ForeGripHoldPos = {
		["Bone07"] = {pos = Vector(0, 0, 0), angle = Angle(30.129, 0, 0) },
		["Bone02"] = {pos = Vector(0, 0, 0), angle = Angle(-12.506, 0, 0) },
		["Bone09"] = {pos = Vector(0, 0, 0), angle = Angle(87.529, 0, -10.704) },
		["Bone03"] = {pos = Vector(0, 0, 0), angle = Angle(7.043, 0, 0) },
		["Bone_L_LowerThumb01"] = {pos = Vector(0, 0, 0), angle = Angle(86.033, 0, 0) },
		["Bone_L_LowerArm01"] = {pos = Vector(-0.403, 2.645, -0.38), angle = Angle(-1.601, 0, 75.903) },
		["Bone05"] = {pos = Vector(0, 0, 0), angle = Angle(67.432, 0.662, -11.282) },
		["Bone13"] = {pos = Vector(0, 0, 0), angle = Angle(80.552, -4.981, -15.509) },
		["Bone_L_MiddleThumb01"] = {pos = Vector(0, 0, 0), angle = Angle(21.812, 0, 0) },
		["Bone15"] = {pos = Vector(0, 0, 0), angle = Angle(30.725, 9.206, 0) },
		["Bone_L_UpperThumb01"] = {pos = Vector(0, 0, 0), angle = Angle(5.41, -10.047, -6.314) },
		["Bone01"] = {pos = Vector(0, 0, 0), angle = Angle(81.065, 0, -7.411) },
		["Bone_L_Hand01"] = {pos = Vector(0, 0, 0), angle = Angle(22.538, 0, 10.763) },
		["Bone06"] = {pos = Vector(0, 0, 0), angle = Angle(-34.194, 0, 0) },
		["Bone10"] = {pos = Vector(0, 0, 0), angle = Angle(-83.87, 0, 0) },
		["Bone14"] = {pos = Vector(0, 0, 0), angle = Angle(-73.589, -4.473, 0) },
		["Bone11"] = {pos = Vector(0, 0, 0), angle = Angle(58.02, 0, 0) }
	}
end

SWEP.MuzzleVelocity = 925 -- in meter/s

SWEP.LuaViewmodelRecoil = true
SWEP.LuaViewmodelRecoilOverride = true

SWEP.BarrelBGs = {main = 2, rpk = 1, short = 4, regular = 0}
SWEP.StockBGs = {main = 1, regular = 0, heavy = 1, foldable = 2}
SWEP.ReceiverBGs = {main = 3, rpk = 1, regular = 0}
SWEP.MagBGs = {main = 4, regular = 0, rpk = 1}

SWEP.Attachments = {[1] = {header = "Sight", offset = {850, -600},  atts = {"md_microt1", "md_eotech", "md_aimpoint", "md_schmidt_shortdot", "md_acog"}},
	[2] = {header = "Barrel", offset = {-550, -150}, atts = {"md_saker"}},
	[3] = {header = "Handguard", offset = {-550, -600}, atts = {"md_foregrip", "md_bipod"}},
	[4] = {header = "Rail", offset = {100, -600}, atts = {"md_anpeq15"}, dependencies = {md_microt1 = true, md_eotech = true, md_aimpoint = true, md_schmidt_shortdot = true, md_acog = true}},
	[5] = {header = "Magazine", offset = {850, -150}, atts = {"md_cmag_556_official"}},
	["+reload"] = {header = "Ammo", offset = {850, 350}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {fire = {"shoot1", "shoot2", "shoot3"},
	reload = "reload",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {	draw = {{time = 0, sound = "CW_FAMASG2_CLOTH"}},

	reload = {[1] = {time = 0.65, sound = "CW_FAMASG2_MAGOUT"},
	[2] = {time = 1.6, sound = "CW_SVD_OFFICIAL_MAGIN_PARTIAL"},
	[3] = {time = 1.9, sound = "CW_FAMASG2_MAGIN1"},
	[4] = {time = 2.5, sound = "CW_FAMASG2_FOREARM"}}}

SWEP.SpeedDec = 30

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "3burst", "semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Snark"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/rifles/v_famasg2.mdl"
SWEP.WorldModel		= "models/weapons/w_rif_famas.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 30
SWEP.Primary.DefaultClip	= 30
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "5.56x45MM"

SWEP.FireDelay = 60 / 1150
SWEP.FireSound = "CW_FAMASG2_FIRE"
SWEP.FireSoundSuppressed = "CW_FAMASG2_SUPPRESSED"
SWEP.Recoil = 1.05

SWEP.HipSpread = 0.045
SWEP.AimSpread = 0.0025
SWEP.VelocitySensitivity = 1.7
SWEP.MaxSpreadInc = 0.055
SWEP.SpreadPerShot = 0.007
SWEP.SpreadCooldown = 0.16
SWEP.RecoilToSpread = 0.7
SWEP.BurstRecoilMul = 0.7
SWEP.Shots = 1
SWEP.Damage = 31
SWEP.DeployTime = 0.8

SWEP.ReloadSpeed = 1.0
SWEP.ReloadTime = 2.23
SWEP.ReloadTime_Empty = 3.5
SWEP.ReloadHalt = 2.23
SWEP.ReloadHalt_Empty = 3.5
SWEP.SnapToIdlePostReload = true


================================================
FILE: cw2/lua/weapons/cw_flash_grenade/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_PINPULL", "weapons/pinpull.wav", 1, 50, CHAN_WEAPON)


================================================
FILE: cw2/lua/weapons/cw_flash_grenade/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Flash Grenade"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.IconLetter = "P"
	killicon.AddFont("cw_flash_grenade", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MoveType = 2
	SWEP.ViewModelMovementScale = 0.8
	SWEP.DisableSprintViewSimulation = true
end

SWEP.scaleSensitivityToSpread = false
SWEP.CanRestOnObjects = false
SWEP.grenadeEnt = "cw_flash_thrown"
SWEP.noResupply = true -- for ground control

local sounds = {{time = 0.33, sound = "CW_PINPULL"}}

SWEP.Animations = {throw = {"throw"},
	pullpin = {"pullpin", "pullpin2", "pullpin3", "pullpin4"},
	idle = "idle",
	draw = "deploy"}
	
SWEP.Sounds = {pullpin = sounds,
	pullpin2 = sounds,
	pullpin3 = sounds,
	pullpin4 = sounds}
	
SWEP.SpeedDec = 5

SWEP.NoFreeAim = true

SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.NormalHoldType = "grenade"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "cw_grenade_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= true
SWEP.ViewModel		= "models/weapons/v_eq_flashbang.mdl"
SWEP.WorldModel		= "models/weapons/w_eq_flashbang.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 1
SWEP.Primary.DefaultClip	= 1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "Flash Grenades"

SWEP.fuseTime = 2.5


================================================
FILE: cw2/lua/weapons/cw_frag_grenade/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_PINPULL", "weapons/pinpull.wav", 1, 50, CHAN_WEAPON)


================================================
FILE: cw2/lua/weapons/cw_frag_grenade/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Frag Grenade"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.IconLetter = "O"
	killicon.AddFont("cw_frag_grenade", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MoveType = 2
	SWEP.ViewModelMovementScale = 0.8
	SWEP.DisableSprintViewSimulation = true
end

SWEP.scaleSensitivityToSpread = false
SWEP.CanRestOnObjects = false
SWEP.grenadeEnt = "cw_grenade_thrown"
SWEP.noResupply = true -- for ground control

local sounds = {{time = 0.2, sound = "CW_PINPULL"}}

SWEP.Animations = {throw = {"throw"},
	pullpin = {"pullpin", "pullpin2", "pullpin3", "pullpin4"},
	idle = "idle",
	draw = "deploy"}
	
SWEP.Sounds = {pullpin = sounds,
	pullpin2 = sounds,
	pullpin3 = sounds,
	pullpin4 = sounds}
	
SWEP.SpeedDec = 5

SWEP.NoFreeAim = true

SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.NormalHoldType = "grenade"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "cw_grenade_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/v_cw_fraggrenade.mdl"
SWEP.WorldModel		= "models/weapons/w_cw_fraggrenade_thrown.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 1
SWEP.Primary.DefaultClip	= 1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "Frag Grenades"

SWEP.swapTime = 0.7


================================================
FILE: cw2/lua/weapons/cw_g3a3/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_G3A3_FIRE", "weapons/cw_g3a3/fire.wav", 1, 125, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_G3A3_FIRE_SUPPRESSED", "weapons/cw_g3a3/fire_suppressed.wav", 1, 105, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_G3A3_HANDLE", "weapons/cw_g3a3/handle.wav")
CustomizableWeaponry:addReloadSound("CW_G3A3_MAGOUT", "weapons/cw_g3a3/magout.wav")
CustomizableWeaponry:addReloadSound("CW_G3A3_MAGIN", "weapons/cw_g3a3/magin.wav")
CustomizableWeaponry:addReloadSound("CW_G3A3_BOLTFORWARD", "weapons/cw_g3a3/boltforward.wav")
CustomizableWeaponry:addReloadSound("CW_G3A3_BOLTBACK", "weapons/cw_g3a3/boltback.wav")


================================================
FILE: cw2/lua/weapons/cw_g3a3/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "G3A3"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1.15
	
	SWEP.IconLetter = "i"
	killicon.AddFont("cw_g3a3", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_g3"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = 4, y = 0, z = -3}
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.9
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.8
	SWEP.FireMoveMod = 0.6
	
	SWEP.IronsightPos = Vector(-1.612, -1.107, 0.388)
	SWEP.IronsightAng = Vector(0, 0, 0)
	
	SWEP.EoTechPos = Vector(-1.622, -2, -0.505)
	SWEP.EoTechAng = Vector(0, 0, 0)
	
	SWEP.AimpointPos = Vector(-1.622, -1, -0.406)
	SWEP.AimpointAng = Vector(0, 0, 0)
	
	SWEP.MicroT1Pos = Vector(-1.607, 1.5, -0.173)
	SWEP.MicroT1Ang = Vector(0, 0, 0)
	
	SWEP.ACOGPos = Vector(-1.606, -0.6, -0.487)
	SWEP.ACOGAng = Vector(0, 0, 0)
	
	SWEP.NXSPos = Vector(-1.624, 1, -0.382)
	SWEP.NXSAng = Vector(0, 0, 0)

	SWEP.SG1Pos = Vector(-1.614, 0, -0.51)
	SWEP.SG1Ang = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(1.786, 0, -1)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.ShortDotPos = Vector(-1.601, -1.157, -0.299)
	SWEP.ShortDotAng = Vector(0, 0, 0)
	
	SWEP.BackupSights = {["md_acog"] = {[1] = Vector(-1.606, -1.107, -1.5), [2] = Vector(0, 0, 0)}}

	SWEP.SightWithRail = true
	SWEP.ACOGAxisAlign = {right = 0, up = 0, forward = 0}
	SWEP.SchmidtShortDotAxisAlign = {right = 0, up = 0, forward = 0}
	SWEP.NXSAlign = {right = 0, up = 0, forward = 0}

	SWEP.M203Pos = Vector(0, -1, 0.24)
	SWEP.M203Ang = Vector(0, 0, 0)
	
	SWEP.AlternativePos = Vector(0.319, 1.325, -1.04)
	SWEP.AlternativeAng = Vector(0, 0, 0)
	
	SWEP.M203OffsetCycle_Reload = 0.81
	SWEP.M203OffsetCycle_Reload_Empty = 0.73
	SWEP.M203OffsetCycle_Draw = 0
	
	SWEP.M203CameraRotation = {p = -90, y = 0, r = -90}
	
	SWEP.BaseArm = "Bip01 L Clavicle"
	SWEP.BaseArmBoneOffset = Vector(-50, 0, 0)
	
	SWEP.M203HoldPos = {
		["Bip01 L Clavicle"] = {pos = Vector(4.461, 0.308, -2.166), angle = Angle(0, 0, 0)}
	}

	SWEP.AttachmentModelsVM = {
		["md_aimpoint"] = {model = "models/wystan/attachments/aimpoint.mdl", bone = "G3SG1_Rail", pos = Vector(-0.24, -5.63, -4.604), angle = Angle(0, 0, 0), size = Vector(0.899, 0.899, 0.899)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "G3SG1_Rail", pos = Vector(0.266, -11.3, -10.278), angle = Angle(0, -90, 0), size = Vector(1, 1, 1)},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "G3SG1_Rail", pos = Vector(0.02, -0.65, 0.593), angle = Angle(0, 180, 0), size = Vector(0.349, 0.349, 0.349)},
		["md_foregrip"] = {model = "models/wystan/attachments/foregrip1.mdl", bone = "G3SG1", pos = Vector(-3.34, 7.82, -5.904), angle = Angle(0, 0, 0), size = Vector(0.75, 0.75, 0.75)},
		["md_saker"] = {model = "models/cw2/attachments/556suppressor.mdl", bone = "G3SG1", pos = Vector(-2.921, 15.373, -4.996), angle = Angle(0, 0, 0), size = Vector(0.75, 0.75, 0.75)},
		["md_acog"] = {model = "models/wystan/attachments/2cog.mdl", bone = "G3SG1_Rail", pos = Vector(-0.324, -5.626, -4.821), angle = Angle(0, 0, 0), size = Vector(0.899, 0.899, 0.899)},
		["md_m203"] = {model = "models/cw2/attachments/m203.mdl", bone = "G3SG1", pos = Vector(-0.583, 3.305, -1.293), angle = Angle(2.538, -90, 0), size = Vector(1, 1, 1), animated = true},
		["md_anpeq15"] = {model = "models/cw2/attachments/anpeq15.mdl", bone = "G3SG1", pos = Vector(-3.01, 10.85, -1.385), angle = Angle(0, 90, 0), size = Vector(0.5, 0.5, 0.5)},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "G3SG1_Rail", pos = Vector(-0.278, -5.081, -4.053), angle = Angle(0, -90, 0), size = Vector(0.8, 0.8, 0.8)},
		["md_nightforce_nxs"] = {model = "models/cw2/attachments/l96_scope.mdl", bone = "G3SG1", pos = Vector(-3.027, 9.477, -0.247), angle = Angle(0, -90, 0), size = Vector(1, 1, 1)}
	}

	SWEP.ForeGripHoldPos = {
		["Bip01 L Finger3"] = {pos = Vector(0, 0, 0), angle = Angle(-8.907, 29.332, 27.155) },
		["Bip01 L Finger41"] = {pos = Vector(0, 0, 0), angle = Angle(0, 3.367, 0) },
		["Bip01 L Clavicle"] = {pos = Vector(4.335, -6.652, -3.984), angle = Angle(-42.875, 42.837, 0) },
		["Bip01 L Finger22"] = {pos = Vector(0, 0, 0), angle = Angle(0, -13.565, 0) },
		["Bip01 L Finger31"] = {pos = Vector(0, 0, 0), angle = Angle(0, 9.633, 0) },
		["Bip01 L Finger02"] = {pos = Vector(0, 0, 0), angle = Angle(0, 96.544, 0) },
		["Bip01 L Finger11"] = {pos = Vector(0, 0, 0), angle = Angle(0, 25.826, 0) },
		["Bip01 L Finger4"] = {pos = Vector(0, 0, 0), angle = Angle(-3.777, 13.736, 42.478) },
		["Bip01 L Finger1"] = {pos = Vector(0, 0, 0), angle = Angle(-4.395, 78.736, 22.27) },
		["Bip01 L Finger42"] = {pos = Vector(0, 0, 0), angle = Angle(0, 58.242, 0) },
		["Bip01 L Hand"] = {pos = Vector(0, 0, 0), angle = Angle(5.883, 57.971, -2.382) },
		["Bip01 L Finger32"] = {pos = Vector(0, 0, 0), angle = Angle(0, 18.07, 0) },
		["Bip01 L Finger0"] = {pos = Vector(0, 0, 0), angle = Angle(33.303, 1.07, 0) },
		["Bip01 L Finger12"] = {pos = Vector(0, 0, 0), angle = Angle(0, 28.163, 0) },
		["Bip01 L Finger21"] = {pos = Vector(0, 0, 0), angle = Angle(0, 25.208, 0) },
		["Bip01 L Finger01"] = {pos = Vector(0, 0, 0), angle = Angle(0, 19.94, 0) },
		["Bip01 L Finger2"] = {pos = Vector(0, 0, 0), angle = Angle(-5.336, 58.977, 28.6) }
	}
	
	SWEP.LaserPosAdjust = Vector(1, 0, 0)
	SWEP.LaserAngAdjust = Angle(0, 180, 0) 

	SWEP.LuaVMRecoilAxisMod = {vert = 0.5, hor = 1, roll = 1, forward = 0.5, pitch = 0.5}
end

SWEP.MuzzleVelocity = 800 -- in meter/s

SWEP.RailBGs = {main = 3, on = 1, off = 0}
SWEP.BipodBGs = {main = 4, on = 1, off = 0}
SWEP.SightBGs = {main = 2, sg1 = 1, none = 0}
SWEP.LuaViewmodelRecoil = true

SWEP.Attachments = {[1] = {header = "Sight", offset = {800, -350},  atts = {"md_microt1", "md_eotech", "md_aimpoint", "md_schmidt_shortdot", "md_acog", "bg_sg1scope", "md_nightforce_nxs"}},
	[2] = {header = "Barrel", offset = {-300, -300},  atts = {"md_saker"}},
	[3] = {header = "Handguard", offset = {-300, 150}, atts = {"md_foregrip", "md_m203", "bg_bipod"}},
	[4] = {header = "Rail", offset = {800, -20}, atts = {"md_anpeq15"}, dependencies = {md_microt1 = true}},
	["+reload"] = {header = "Ammo", offset = {800, 430}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {fire = {"shoot1", "shoot2", "shoot3"},
	reload = "reload_full",
	reload_empty = "reload",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {draw = {{time = 0, sound = "CW_FOLEY_MEDIUM"}},

	reload_full = {[1] = {time = 0.6, sound = "CW_G3A3_HANDLE"},
	[2] = {time = 0.9, sound = "CW_G3A3_MAGOUT"},
	[3] = {time = 2.3, sound = "CW_G3A3_MAGIN"}},
	
	reload = {[1] = {time = 0.6, sound = "CW_G3A3_BOLTBACK"},
	[2] = {time = 1.55, sound = "CW_G3A3_HANDLE"},
	[3] = {time = 1.7, sound = "CW_G3A3_MAGOUT"},
	[4] = {time = 3.1, sound = "CW_G3A3_MAGIN"},
	[5] = {time = 3.85, sound = "CW_G3A3_BOLTFORWARD"}}}

SWEP.SpeedDec = 40

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/rifles/g3a3.mdl"
SWEP.WorldModel		= "models/weapons/w_snip_g3sg1.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 20
SWEP.Primary.DefaultClip	= 20
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "7.62x51MM"

SWEP.FireDelay = 0.12
SWEP.FireSound = "CW_G3A3_FIRE"
SWEP.FireSoundSuppressed = "CW_G3A3_FIRE_SUPPRESSED"
SWEP.Recoil = 1.5

SWEP.HipSpread = 0.05
SWEP.AimSpread = 0.002
SWEP.VelocitySensitivity = 2
SWEP.MaxSpreadInc = 0.06
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 0.17
SWEP.Shots = 1
SWEP.Damage = 42
SWEP.DeployTime = 0.8
SWEP.NearWallDistance = 40

SWEP.ReloadSpeed = 1
SWEP.ReloadTime = 2.5
SWEP.ReloadTime_Empty = 3.3
SWEP.ReloadHalt = 3.05
SWEP.ReloadHalt_Empty = 4.85


================================================
FILE: cw2/lua/weapons/cw_grenade_base/cl_hooks.lua
================================================
local function CW20_Grenade_InitPostEntity()
	local ply = LocalPlayer()
	ply.cwFlashbangDuration = 0
	ply.cwFlashbangIntensity = 0
	ply.cwFlashbangDisplayIntensity = 0
	ply.cwFlashDuration = 0
	ply.cwFlashIntensity = 0
end

hook.Add("InitPostEntity", "CW20_Grenade_InitPostEntity", CW20_Grenade_InitPostEntity)

local function CW20_RenderScreenspaceEffects()
	local ply = LocalPlayer()
	local curTime = CurTime()
	local frameTime = FrameTime()
	
	if curTime > ply.cwFlashbangDuration then
		ply.cwFlashbangIntensity = math.Approach(ply.cwFlashbangIntensity, 0, frameTime)
	end
	
	ply.cwFlashbangDisplayIntensity = math.Approach(ply.cwFlashbangDisplayIntensity, ply.cwFlashbangIntensity, frameTime * 15)
	
	if curTime > ply.cwFlashDuration then
		ply.cwFlashIntensity = math.Approach(ply.cwFlashIntensity, 0, frameTime)
	end
	
	if ply.cwFlashbangDisplayIntensity > 0 then
		DrawMotionBlur(0.01 * (1 - ply.cwFlashbangDisplayIntensity), ply.cwFlashbangDisplayIntensity, 0)
		
		surface.SetDrawColor(255, 255, 255, 255 * ply.cwFlashIntensity * ply.cwFlashbangDisplayIntensity)
		surface.DrawRect(-1, -1, ScrW() + 2, ScrH() + 2)
	end
end

hook.Add("RenderScreenspaceEffects", "CW20_RenderScreenspaceEffects", CW20_RenderScreenspaceEffects)


================================================
FILE: cw2/lua/weapons/cw_grenade_base/cl_player_funcs.lua
================================================
local PLAYER = FindMetaTable("Player")

function PLAYER:cwFlashbang(intensity, duration)
	self.cwFlashbangIntensity = intensity
	self.cwFlashbangDuration = CurTime() + duration
	self.cwFlashDuration = CurTime() + duration * 0.75
	self.cwFlashIntensity = math.max(intensity * 1.5, 1)
	
	if intensity > 0.6 then
		self:SetDSP(35, duration <= 1)
	end
end


================================================
FILE: cw2/lua/weapons/cw_grenade_base/cl_umsgs.lua
================================================
local function CW_Flashbanged(data)
	local intensity = data:ReadFloat()
	local duration = data:ReadFloat()
	
	LocalPlayer():cwFlashbang(intensity, duration)
end

usermessage.Hook("CW_FLASHBANGED", CW_Flashbanged)


================================================
FILE: cw2/lua/weapons/cw_grenade_base/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("cl_player_funcs.lua")
AddCSLuaFile("cl_umsgs.lua")

if CLIENT then
	include("cl_umsgs.lua")
	include("cl_player_funcs.lua")
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Grenade base"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.IconLetter = "f"
	killicon.AddFont("cw_deagle", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.ViewModelMovementScale = 0.8
	SWEP.DisableSprintViewSimulation = true
end

SWEP.CanRestOnObjects = false
	
SWEP.Attachments = {}
SWEP.Sounds = {}

SWEP.SpeedDec = 5

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "grenade"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= ""
SWEP.WorldModel		= ""

SWEP.Spawnable			= false
SWEP.AdminSpawnable		= false

SWEP.Primary.ClipSize		= 1
SWEP.Primary.DefaultClip	= 1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= ""

SWEP.SprintingEnabled = false
SWEP.AimingEnabled = false
SWEP.CanCustomize = false

SWEP.HipSpread = 0.045
SWEP.AimSpread = 0.045
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 56
SWEP.DeployTime = 0.5

SWEP.ReloadSpeed = 1
SWEP.ReloadTime = 1.98
SWEP.ReloadHalt = 2.49

SWEP.ReloadTime_Empty = 1.98
SWEP.ReloadHalt_Empty = 3.4

SWEP.timeToThrow = 0.75
SWEP.swapTime = 0.4
SWEP.fuseTime = 3

function SWEP:Reload()
end

function SWEP:IndividualThink()
	local curTime = CurTime()
	
	if self.pinPulled then
		if curTime > self.throwTime then
			if not self.Owner:KeyDown(IN_ATTACK) then
				if not self.animPlayed then
					self.entityTime = CurTime() + 0.15
					self:sendWeaponAnim("throw")
					self.Owner:SetAnimation(PLAYER_ATTACK1)
				end
				
				if curTime > self.entityTime then
					if SERVER then
						local grenade = ents.Create(self.grenadeEnt)
						grenade:SetPos(self.Owner:GetShootPos() + CustomizableWeaponry.quickGrenade:getThrowOffset(self.Owner))
						grenade:SetAngles(self.Owner:EyeAngles())
						grenade:Spawn()
						grenade:Activate()
						grenade:Fuse(self.fuseTime)
						grenade:SetOwner(self.Owner)
						CustomizableWeaponry.quickGrenade:applyThrowVelocity(self.Owner, grenade)
						self:TakePrimaryAmmo(1)
					end
					
					self:SetNextPrimaryFire(curTime + 1)
					
					timer.Simple(self.swapTime, function()
						if IsValid(self) then
							if self.Owner:GetAmmoCount(self.Primary.Ammo) <= 0 then -- we're out of ammo, strip this weapon
								self.Owner:ConCommand("lastinv")
							else
								self:sendWeaponAnim("draw")
							end
						end
					end)
					
					self.pinPulled = false
				end
				
				self.animPlayed = true
			end
		end
	end
end

function SWEP:PrimaryAttack()
	if self.Owner:GetAmmoCount(self.Primary.Ammo) == 0 and self:Clip1() == 0 then
		return
	end

	if self.pinPulled then
		return
	end
	
	for i = 1, 3 do
		if not self:canFireWeapon(i) then
			return
		end
	end
	
	self.pinPulled = true
	self.animPlayed = false
	self.throwTime = CurTime() + self.timeToThrow
	self:sendWeaponAnim("pullpin")
end

function SWEP:SecondaryAttack()
end


================================================
FILE: cw2/lua/weapons/cw_l115/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_L96_FIRE", "weapons/cw_l96/fire.wav", 1, 140, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_L96_MAGOUT", "weapons/cw_l96/magout.wav")
CustomizableWeaponry:addReloadSound("CW_L96_MAGIN", "weapons/cw_l96/magin.wav")
CustomizableWeaponry:addReloadSound("CW_L96_BOLTUP", "weapons/cw_l96/boltup.wav")
CustomizableWeaponry:addReloadSound("CW_L96_BOLTDOWN", "weapons/cw_l96/boltdown.wav")
CustomizableWeaponry:addReloadSound("CW_L96_BOLTPULL", "weapons/cw_l96/boltpull.wav")
CustomizableWeaponry:addReloadSound("CW_L96_BOLTPUSH", "weapons/cw_l96/boltpush.wav")


================================================
FILE: cw2/lua/weapons/cw_l115/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

CustomizableWeaponry:registerAmmo(".338 Lapua", ".338 Lapua", 8.58, 69.20)

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "L115"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1.15
	
	SWEP.IconLetter = "r"
	killicon.AddFont("cw_l115", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.ZoomTextures = {{tex = surface.GetTextureID("sprites/scope_leo"), offset = {0, 1}}}
	SWEP.SimpleTelescopicsFOV = 75
	
	SWEP.MuzzleEffect = "muzzleflash_SR25"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellDelay = 0.7
	SWEP.ShellPosOffset = {x = 0, y = -2, z = 0}
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.9
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.8
	SWEP.FireMoveMod = 0.6
	SWEP.OverrideAimMouseSens = 0.2
	
	SWEP.DrawTraditionalWorldModel = false
	SWEP.WM = "models/weapons/w_cstm_l96.mdl"
	SWEP.WMPos = Vector(-1, 0, 1.75)
	SWEP.WMAng = Vector(0, 0, 180)
	
	SWEP.IronsightPos = Vector(-2.678, -1, 0.15)
	SWEP.IronsightAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(1.786, 0, -1)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.AlternativePos = Vector(0.2, 0, -1)
	SWEP.AlternativeAng = Vector(0, 0, 0)
	
	SWEP.AimBreathingEnabled = true
	SWEP.CrosshairEnabled = false
	SWEP.AimViewModelFOV = 40
	
	SWEP.HipFireFOVIncrease = false
	SWEP.newTelescopicsFOV = true
	
	SWEP.LuaVMRecoilAxisMod = {vert = 0.5, hor = 1, roll = 1, forward = 0.5, pitch = 0.5}
	SWEP.RTAlign = {right = 1.2, up = 0.25, forward = 0}
	
	SWEP.OverallMouseSens = 0.7
	
	SWEP.zoomLevels = {
		10, 7.5, 5
	}
	
	SWEP.simpleTelescopicsFOVRange = {
		14,
		9,
		6.7
	}
end

SWEP.MuzzleVelocity = 936 -- in meter/s

SWEP.SightBGs = {main = 2, none = 1}
SWEP.ADSFireAnim = true
SWEP.PreventQuickScoping = true
SWEP.QuickScopeSpreadIncrease = 0.2

SWEP.Attachments = {}

SWEP.Animations = {fire = {"shot"},
	reload = "reload",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {shot = {{time = 0.5, sound = "CW_L96_BOLTUP"},
		{time = 0.7, sound = "CW_L96_BOLTPULL"},
		{time = 1, sound = "CW_L96_BOLTPUSH"},
		{time = 1.35, sound = "CW_L96_BOLTDOWN"}},

	draw = {{time = 0, sound = "CW_FOLEY_MEDIUM"}},

	reload = {{time = 0.17, sound = "CW_L96_BOLTUP"},
		{time = 0.29, sound = "CW_L96_BOLTPULL"},
		
	{time = 1.1, sound = "CW_L96_MAGOUT"},
	{time = 1.47, sound = "CW_FOLEY_LIGHT"},
	{time = 2, sound = "CW_L96_MAGIN"},
	{time = 2.86, sound = "CW_L96_BOLTPUSH"},
	{time = 3.15, sound = "CW_L96_BOLTDOWN"},
	{time = 3.3, sound = "CW_FOLEY_LIGHT"}}
}

SWEP.SpeedDec = 50

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"bolt"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/rifles/l96.mdl"
SWEP.WorldModel		= "models/weapons/w_cstm_l96.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 5
SWEP.Primary.DefaultClip	= 5
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= ".338 Lapua"

SWEP.FireDelay = 1.5
SWEP.FireSound = "CW_L96_FIRE"
SWEP.Recoil = 2.5

SWEP.HipSpread = 0.075
SWEP.AimSpread = 0.001
SWEP.VelocitySensitivity = 2.5
SWEP.MaxSpreadInc = 0.2
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 1.55
SWEP.Shots = 1
SWEP.Damage = 90
SWEP.DeployTime = 1

SWEP.ReloadSpeed = 1
SWEP.ReloadTime = 2.42
SWEP.ReloadTime_Empty = 2.42
SWEP.ReloadHalt = 3.48
SWEP.ReloadHalt_Empty = 3.48
SWEP.NearWallDistance = 40

if CLIENT then
	function SWEP:IndividualInitialize()
		self:setTelescopicsFOVRange(self.zoomLevels, self.simpleTelescopicsFOVRange)
	end
	
	local old, x, y, ang
	local reticle = surface.GetTextureID("sprites/scope_leo")

	local lens = surface.GetTextureID("cw2/gui/lense")
	local lensMat = Material("cw2/gui/lense")
	local cd, alpha = {}, 0.5
	local Ini = true

	-- render target var setup
	cd.x = 0
	cd.y = 0
	cd.w = 512
	cd.h = 512
	cd.fov = 3
	cd.drawviewmodel = false
	cd.drawhud = false
	cd.dopostprocess = false

	function SWEP:RenderTargetFunc()
		local complexTelescopics = self:canUseComplexTelescopics()
		
		-- if we don't have complex telescopics enabled, don't do anything complex, and just set the texture of the lens to a fallback 'lens' texture
		if not complexTelescopics then
			self.TSGlass:SetTexture("$basetexture", lensMat:GetTexture("$basetexture"))
			return
		end
		
		if self.dt.State == CW_AIMING then
			alpha = math.Approach(alpha, 0, FrameTime() * 5)
		else
			alpha = math.Approach(alpha, 1, FrameTime() * 5)
		end
		
		x, y = ScrW(), ScrH()
		old = render.GetRenderTarget()

		ang = self:getTelescopeAnglesNew()
		
		if self.ViewModelFlip then
			ang.r = -self.BlendAng.z
		else
			ang.r = self.BlendAng.z
		end
		
		--[[if not self.freeAimOn then
			ang:RotateAroundAxis(ang:Right(), self.RTAlign.right)
			ang:RotateAroundAxis(ang:Up(), self.RTAlign.up)
			ang:RotateAroundAxis(ang:Forward(), self.RTAlign.forward)
		end]]
		
		local size = self:getRenderTargetSize()

		cd.w = size
		cd.h = size
		cd.angles = ang
		cd.origin = self.Owner:GetShootPos()
		
		self:adjustTelescopicsFOV(cd)
		
		render.SetRenderTarget(self.ScopeRT)
		render.SetViewPort(0, 0, size, size)
			if alpha < 1 or Ini then
				render.RenderView(cd)
				Ini = false
			end
			
			ang = self.Owner:EyeAngles()
			ang.p = ang.p + self.BlendAng.x
			ang.y = ang.y + self.BlendAng.y
			ang.r = ang.r + self.BlendAng.z
			ang = -ang:Forward()
			
			local light = render.ComputeLighting(self.Owner:GetShootPos(), ang)
			
			cam.Start2D()
				surface.SetDrawColor(255, 255, 255, 255)
				surface.SetTexture(reticle)
				surface.DrawTexturedRect(0, 0, size, size)
				
				if alpha < 1 then
					self:drawLensShadow(size, size)
				end
				
				surface.SetDrawColor(150 * light[1], 150 * light[2], 150 * light[3], 255 * alpha)
				surface.SetTexture(lens)
				surface.DrawTexturedRectRotated(size * 0.5, size * 0.5, size, size, 90)
			cam.End2D()
		render.SetViewPort(0, 0, x, y)
		render.SetRenderTarget(old)
		
		if self.TSGlass then
			self.TSGlass:SetTexture("$basetexture", self.ScopeRT)
		end
	end
end


================================================
FILE: cw2/lua/weapons/cw_mp5/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_MP5_FIRE", "weapons/cw_mp5/mp5_fire.wav", 1, 113, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_MP5_FIRE_SUPPRESSED", "weapons/cw_mp5/mp5_fire_suppressed.wav", 1, 90, CHAN_WEAPON)

CustomizableWeaponry:addFireSound("CW_MP5SD_FIRE", "weapons/cw_mp5/mp5sd_fire.wav", 1, 75, CHAN_WEAPON)

CustomizableWeaponry:addFireSound("CW_MP5K_FIRE", "weapons/cw_mp5/mp5k_fire.wav", 1, 110, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_MP5_MAGOUT", "weapons/cw_mp5/magout.wav")
CustomizableWeaponry:addReloadSound("CW_MP5_MAGIN", "weapons/cw_mp5/magin.wav")
CustomizableWeaponry:addReloadSound("CW_MP5_BOLTBACK", "weapons/cw_mp5/boltback.wav")
CustomizableWeaponry:addReloadSound("CW_MP5_BOLTFORWARD", "weapons/cw_mp5/boltforward.wav")


================================================
FILE: cw2/lua/weapons/cw_mp5/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "HK MP5"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1.15
	
	SWEP.IconLetter = "x"
	killicon.AddFont("cw_mp5", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_smg"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.Shell = "smallshell"
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = 2, y = 0, z = -3}
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.8
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.87
	
	SWEP.IronsightPos = Vector(2.032, -3.323, 0.759)
	SWEP.IronsightAng = Vector(0.388, -0.051, 0)
	
	SWEP.PronePos = Vector(-7.397, -2.497, -1.551)
	SWEP.ProneAng = Vector(5.618, -49.056, -15.311)
	
	-- MP5SD variant ironsight pos
	SWEP.SDPos = Vector(2.032, -3.323, 0.759)
	SWEP.SDAng = Vector(0.338, -0.005, 0)
		
	-- MP5K variant ironsight pos
	SWEP.KPos = Vector(2.032, -3.323, 0.759)
	SWEP.KAng = Vector(0.187, -0.005, 0)

	SWEP.MicroT1Pos = Vector(2.042, -0.2, 0.66)
	SWEP.MicroT1Ang = Vector(-1.668, 0, 0)	
		
	SWEP.EoTechPos = Vector(2.042, -5.042, 0.014)
	SWEP.EoTechAng = Vector(0, 0, 0)
	
	SWEP.AimpointPos = Vector(2.03, -5.14, 0.171)
	SWEP.AimpointAng = Vector(0, 0, 0)
	
	SWEP.ACOGPos = Vector(2.028, -5.613, -0.113)
	SWEP.ACOGAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(-4.444, -1, 0.082)
	SWEP.SprintAng = Vector(-12.849, -39.23, 0)

	SWEP.CustomizePos = Vector(-8.174, -1.27, -1.288)
	SWEP.CustomizeAng = Vector(17.954, -40.578, -18.357)
	
	SWEP.AlternativePos = Vector(0, 1.325, -0.801)
	SWEP.AlternativeAng = Vector(0, 0, 0)
		
	SWEP.ShortDotPos = Vector(2.009, -5.844, 0.263)
	SWEP.ShortDotAng = Vector(0, 0, 0)
	
	SWEP.BackupSights = {["md_acog"] = {[1] = Vector(2.028, -5.613, -1.124), [2] = Vector(0, 0, 0)}}

	SWEP.LuaVMRecoilAxisMod = {vert = 1.5, hor = 3, roll = 1, forward = 1, pitch = 1}
	SWEP.SchmidtShortDotAxisAlign = {right = 0, up = 0, forward = 0}
	SWEP.ACOGAxisAlign = {right = 0, up = 0, forward = 0}
	
	SWEP.SprintViewNormals = {x = 1, y = -1, z = 1}

	SWEP.AttachmentModelsVM = {
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "gun", pos = Vector(-0.042, -0.2, 2.809), angle = Angle(0, 0, 0), adjustment = {min = -1.5, max = -0.2, axis = "y", inverse = true}, size = Vector(0.349, 0.349, 0.349)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "gun", pos = Vector(-0.304, 10.126, -8.047), angle = Angle(0, 90, 0), size = Vector(1, 1, 1)},
		["md_aimpoint"] = {model = "models/wystan/attachments/aimpoint.mdl", bone = "gun", pos = Vector(0.2, 5, -2.425), angle = Angle(0, 180, 0), size = Vector(0.899, 0.899, 0.899)},
		["md_acog"] = {model = "models/wystan/attachments/2cog.mdl", bone = "gun", pos = Vector(0.284, 4.372, -2.46), angle = Angle(0, 180, 0), size = Vector(0.899, 0.899, 0.899)},
		["md_tundra9mm"] = {model = "models/cw2/attachments/9mmsuppressor.mdl", bone = "gun", pos = Vector(-0.038, -12.216, 0.305), angle = Angle(0, 0, 0), size = Vector(0.8, 0.8, 0.8)},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "gun", pos = Vector(0.224, 3.98, -1.884), angle = Angle(0, 90, 0), size = Vector(0.8, 0.8, 0.8), color = Color(255, 255, 255, 255)},
	}
	
	SWEP.ForegripOverridePos = {
		["bg_mp5_sdbarrel"] = {
			["Bip01 R Finger02"] = {pos = Vector(0, 0, 0), angle = Angle(-4.029, 14.069, 0) },
			["Bip01 R Finger0"] = {pos = Vector(0, 0, 0), angle = Angle(0, -8.988, 0) }
		},
		
		["bg_mp5_kbarrel"] = {
			["Bip01 R Hand"] = {pos = Vector(0, 0, 0), angle = Angle(0.263, 23.951, -31.754) },
			["Bip01 R Finger2"] = {pos = Vector(0, 0, 0), angle = Angle(-0.894, 32.728, 3.026) },
			["Bip01 R Finger21"] = {pos = Vector(0, 0, 0), angle = Angle(0, 12.1, 0) },
			["Bip01 R Finger01"] = {pos = Vector(0, 0, 0), angle = Angle(0, 25.451, 0) },
			["Bip01 R Clavicle"] = {pos = Vector(-6.856, 2.325, 2.252), angle = Angle(48.464, 28.256, 12.512) },
			["Bip01 R Finger4"] = {pos = Vector(0, 0, 0), angle = Angle(0, 0, 14.687) },
			["Bip01 R Finger1"] = {pos = Vector(0, 0, 0), angle = Angle(-1.813, 71.625, 0) },
			["Bip01 R Finger41"] = {pos = Vector(0, 0, 0), angle = Angle(0, -26.932, 0) },
			["Bip01 R Finger31"] = {pos = Vector(0, 0, 0), angle = Angle(0, -16.4, 0) },
			["Bip01 R Finger02"] = {pos = Vector(0, 0, 0), angle = Angle(0, 89.527, 0) },
			["Bip01 R Finger3"] = {pos = Vector(0, 0, 0), angle = Angle(0, 18.952, 11.305) },
			["Bip01 R Finger0"] = {pos = Vector(0, 0, 0), angle = Angle(-15.782, -6.495, 33.964) },
			["Bip01 R Finger32"] = {pos = Vector(0, 0, 0), angle = Angle(0, 54.675, -4.284) },
			["Bip01 R Finger42"] = {pos = Vector(0, 0, 0), angle = Angle(0, 67.799, 0) }
		}
	}
	
	SWEP.AttachmentPosDependency = {["md_tundra9mm"] = {["bg_mp5_kbarrel"] = Vector(-0.038, -10.749, 0.324)}}

	SWEP.LaserPosAdjust = {x = 1, y = 0, z = 0}
	SWEP.LaserAngAdjust = {p = 2, y = 180, r = 0}
	SWEP.SightWithRail = true
	SWEP.CustomizationMenuScale = 0.012
end

SWEP.MuzzleVelocity = 400 -- in meter/s

SWEP.BarrelBGs = {main = 2, sd = 1, k = 2, regular = 0}
SWEP.StockBGs = {main = 1, regular = 0, retractable = 1, none = 2}
SWEP.RailBGs = {main = 3, on = 1, off = 0}
SWEP.MagBGs = {main = 4, round15 = 0, round30 = 1}
SWEP.LuaViewmodelRecoil = true

SWEP.Attachments = {
	[1] = {header = "Sight", offset = {700, -400}, atts = {"md_microt1", "md_eotech", "md_aimpoint", "md_schmidt_shortdot", "md_acog"}},
	[2] = {header = "Barrel", offset = {200, -400}, atts = {"md_tundra9mm"}, exclusions = {bg_mp5_sdbarrel = true}},
	[3] = {header = "Handguard", offset = {-400, -400}, atts = {"bg_mp5_kbarrel", "bg_mp5_sdbarrel"}},
	[4] = {header = "Magazine", offset = {-400, 100}, atts = {"bg_mp530rndmag"}},
	[5] = {header = "Stock", offset = {700, 350}, atts = {"bg_retractablestock", "bg_nostock"}},
	["+reload"] = {header = "Ammo", offset = {700, 35}, atts = {"am_magnum", "am_matchgrade"}}
}

SWEP.Animations = {fire = {"shoot1", "shoot2"},
	reload = "reloadfull",
	reload_empty = "reloadempty",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {draw = {{time = 0, sound = "CW_FOLEY_MEDIUM"}},

	reloadfull = {[1] = {time = 1.1, sound = "CW_MP5_MAGOUT"},
	[2] = {time = 1.4, sound = "CW_MP5_MAGIN"}},
	
	reloadempty = {[1] = {time = 0.4, sound = "CW_MP5_BOLTBACK"},
	[2] = {time = 1.5, sound = "CW_MP5_MAGOUT"},
	[3] = {time = 1.8, sound = "CW_MP5_MAGIN"},
	[4] = {time = 2.6, sound = "CW_MP5_BOLTFORWARD"}}}

SWEP.SpeedDec = 15

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "3burst", "semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= true
SWEP.ViewModel		= "models/cw2/smgs/mp5.mdl"
SWEP.WorldModel		= "models/weapons/w_smg_mp5.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 15
SWEP.Primary.DefaultClip	= 15
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "9x19MM"

SWEP.FireDelay = 0.075
SWEP.FireSound = "CW_MP5_FIRE"
SWEP.FireSoundSuppressed = "CW_MP5_FIRE_SUPPRESSED"
SWEP.Recoil = 0.63

SWEP.HipSpread = 0.035
SWEP.AimSpread = 0.009
SWEP.VelocitySensitivity = 1.5
SWEP.MaxSpreadInc = 0.03
SWEP.SpreadPerShot = 0.005
SWEP.SpreadCooldown = 0.13
SWEP.Shots = 1
SWEP.Damage = 23
SWEP.DeployTime = 0.8
SWEP.NearWallDistance = 25

SWEP.ReloadSpeed = 1.3
SWEP.ReloadTime = 2
SWEP.ReloadTime_Empty = 2.2
SWEP.ReloadHalt = 2.6
SWEP.ReloadHalt_Empty = 3.5


================================================
FILE: cw2/lua/weapons/cw_mr96/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_MR96_FIRE", "weapons/cw_mr96/mr96_regular.wav", 1, 115, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_MR96_FIRE_LONG", "weapons/cw_mr96/mr96_long.wav", 1, 120, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_MR96_FIRE_SHORT", "weapons/cw_mr96/mr96_short.wav", 1, 110, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_MR96_CYLINDEROPEN", "weapons/cw_mr96/chamber_out.wav")
CustomizableWeaponry:addReloadSound("CW_MR96_CYLINDERCLOSE", "weapons/cw_mr96/chamber_in.wav")
CustomizableWeaponry:addReloadSound("CW_MR96_ROUNDSOUT", "weapons/cw_mr96/roundsout.wav")
CustomizableWeaponry:addReloadSound("CW_MR96_ROUNDSIN", "weapons/cw_mr96/roundsin.wav")


================================================
FILE: cw2/lua/weapons/cw_mr96/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "MR96"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.SelectIcon = surface.GetTextureID("weaponicons/mr96")
	killicon.Add("cw_mr96", "weaponicons/mr96", Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_6"
	SWEP.PosBasedMuz = false
	SWEP.NoShells = true
		
	SWEP.IronsightPos = Vector(-1.731, 5.913, 0.354)
	SWEP.IronsightAng = Vector(0.014, 0, -1.4)

	SWEP.SprintPos = Vector(0.256, 0.01, 1.2)
	SWEP.SprintAng = Vector(-17.778, 0, 0)
	
	SWEP.AlternativePos = Vector(-0.281, 1.325, -0.52)
	SWEP.AlternativeAng = Vector(0, 0, 0)

	SWEP.ViewModelMovementScale = 0.8
	SWEP.FullAimViewmodelRecoil = false
	SWEP.HUD_MagText = "CYLINDER: "

	--SWEP.LuaVMRecoilAxisMod = {vert = 1, hor = 1.5, roll = 3, forward = 1, pitch = 4}
	SWEP.CustomizationMenuScale = 0.01
	SWEP.DisableSprintViewSimulation = true
end

SWEP.ShootWhileProne = true

SWEP.MuzzleVelocity = 414 -- in meter/s, assuming round is a 165 grain JHP

SWEP.BarrelBGs = {main = 1, regular = 1, long = 2, short = 0}
SWEP.LuaViewmodelRecoil = true
SWEP.CanRestOnObjects = false

SWEP.Attachments = {[1] = {header = "Barrel", offset = {-250, -75},  atts = {"bg_regularbarrel", "bg_longbarrelmr96"}},
	["+reload"] = {header = "Ammo", offset = {500, -75}, atts = {"am_reducedpowderload", "am_matchgrade"}}}

SWEP.Animations = {fire = {"shoot1", "shoot2"},
	reload = "reload",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {draw = {{time = 0, sound = "CW_FOLEY_LIGHT"}},

	reload = {[1] = {time = 0.2, sound = "CW_MR96_CYLINDEROPEN"},
	[2] = {time = 0.8, sound = "CW_MR96_ROUNDSOUT"},
	[3] = {time = 1.5, sound = "CW_MR96_ROUNDSIN"},
	[4] = {time = 2.05, sound = "CW_MR96_CYLINDERCLOSE"}}}

SWEP.SpeedDec = 10

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "revolver"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"double"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/pistols/mr96.mdl"
SWEP.WorldModel		= "models/weapons/w_357.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 6
SWEP.Primary.DefaultClip	= 6
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= ".44 Magnum"

SWEP.FireDelay = 0.15
SWEP.FireSound = "CW_MR96_FIRE_SHORT"
SWEP.Recoil = 2.6

SWEP.HipSpread = 0.039
SWEP.AimSpread = 0.01
SWEP.VelocitySensitivity = 1.35
SWEP.MaxSpreadInc = 0.06
SWEP.SpreadPerShot = 0.02
SWEP.SpreadCooldown = 0.25
SWEP.Shots = 1
SWEP.Damage = 50
SWEP.DeployTime = 0.7
SWEP.NearWallDistance = 15
SWEP.Chamberable = false

SWEP.DrawSpeed = 1.5

SWEP.ReloadSpeed = 1
SWEP.ReloadTime = 1.6
SWEP.ReloadHalt = 2.7

SWEP.ReloadTime_Empty = 1.6
SWEP.ReloadHalt_Empty = 2.7


================================================
FILE: cw2/lua/weapons/cw_smoke_grenade/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_PINPULL", "weapons/pinpull.wav", 1, 50, CHAN_WEAPON)


================================================
FILE: cw2/lua/weapons/cw_smoke_grenade/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Smoke Grenade"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.IconLetter = "Q"
	killicon.AddFont("cw_smoke_grenade", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.ViewModelMovementScale = 0.8
	SWEP.DisableSprintViewSimulation = true
end

SWEP.CanRestOnObjects = false
SWEP.grenadeEnt = "cw_smoke_thrown"
SWEP.noResupply = true -- for ground control

local sounds = {{time = 0.33, sound = "CW_PINPULL"}}

SWEP.Animations = {throw = {"throw"},
	pullpin = {"pullpin", "pullpin2", "pullpin3", "pullpin4"},
	idle = "idle",
	draw = "deploy"}
	
SWEP.Sounds = {pullpin = sounds,
	pullpin2 = sounds,
	pullpin3 = sounds,
	pullpin4 = sounds}
	
SWEP.SpeedDec = 5

SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.NormalHoldType = "grenade"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "cw_grenade_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.NoFreeAim = true

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= true
SWEP.ViewModel		= "models/weapons/v_eq_smokegrenade.mdl"
SWEP.WorldModel		= "models/weapons/w_eq_smokegrenade.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 1
SWEP.Primary.DefaultClip	= 1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "Smoke Grenades"


================================================
FILE: cw2/lua/weapons/cw_svd_official/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_SVD_OFFICIAL_FIRE", "weapons/cw_svd_official/fire.wav", 1, 120, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_SVD_OFFICIAL_FIRE_SUPPRESSED", "weapons/cw_svd_official/fire_suppressed.wav", 1, 100, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_SVD_OFFICIAL_MAGOUT", "weapons/cw_svd_official/magout.wav")
CustomizableWeaponry:addReloadSound("CW_SVD_OFFICIAL_MAGIN", "weapons/cw_svd_official/magin.wav")
CustomizableWeaponry:addReloadSound("CW_SVD_OFFICIAL_MAGIN_PARTIAL", "weapons/cw_svd_official/magin_partial.wav")
CustomizableWeaponry:addReloadSound("CW_SVD_OFFICIAL_MAGTAP", "weapons/cw_svd_official/magtap.wav")
CustomizableWeaponry:addReloadSound("CW_SVD_OFFICIAL_BOLTPULL", "weapons/cw_svd_official/boltback.wav")
CustomizableWeaponry:addReloadSound("CW_SVD_OFFICIAL_BOLTFORWARD", "weapons/cw_svd_official/boltforward.wav")


================================================
FILE: cw2/lua/weapons/cw_svd_official/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

CustomizableWeaponry:registerAmmo("7.62x54MMR", "7.62x54MMR", 7.62, 54)

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "SVD"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.IronsightPos = Vector(-3.178, -4.77, 1.472)
	SWEP.IronsightAng = Vector(0.257, 0, 0)
	
	SWEP.ShortDotPos = Vector(-3.177, -5.531, 0.56)
	SWEP.ShortDotAng = Vector(0, 0, 0)
	
	SWEP.NXSPos = Vector(-3.178, -3.3, 0.333)
	SWEP.NXSAng = Vector(0, 0, 0)

	SWEP.PSOPos = Vector(-2.967, -0.885, 0.694)
	SWEP.PSOAng = Vector(-0.732, 0.488, 0)
	
	SWEP.ACOGPos = Vector(-3.214, -4.753, 0.367)
	SWEP.ACOGAng = Vector(-0.973, -0.317, 0)

	SWEP.AlternativePos = Vector(-0.24, 0, -0.48)
	SWEP.AlternativeAng = Vector(0, 0, 0)
	
	SWEP.DrawTraditionalWorldModel = false
	SWEP.WM = "models/cw2/rifles/svd_world.mdl"
	SWEP.WMPos = Vector(-1, -1, 0.5)
	SWEP.WMAng = Vector(0, 0, 180)

	SWEP.ViewModelMovementScale = 1.15
	SWEP.CustomizationMenuScale = 0.019

	SWEP.IconLetter = "b"
	killicon.AddFont("cw_svd_official", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_m14"
	SWEP.PosBasedMuz = false
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = -2, y = 0, z = -3}
	SWEP.SightWithRail = true
	
	SWEP.BoltBone = "Bolt"
	SWEP.BoltShootOffset = Vector(0, 4.669, 0.144)
	SWEP.OffsetBoltOnBipodShoot = true

	SWEP.AttachmentModelsVM = {
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "Base", pos = Vector(-0.468, -5.356, -3.155), angle = Angle(-1.966, -87.372, 1.379), size = Vector(0.8, 0.8, 0.8)},
		["md_pso1"] = {model = "models/cw2/attachments/pso.mdl", bone = "Base", pos = Vector(-0.116, -4.847, -2.024), angle = Angle(-1.966, -177.372, -1.032), size = Vector(0.8, 0.8, 0.8)},
		["md_nightforce_nxs"] = {model = "models/cw2/attachments/l96_scope.mdl", bone = "Base", pos = Vector(-0.176, 0.194, 2.404), angle = Angle(-1.966, -87.373, 1.378), size = Vector(1.1, 1.1, 1.1)},
		["md_pbs1"] = {model = "models/cw2/attachments/pbs1.mdl", bone = "Base", pos = Vector(1.427, 27.118, -2.033), angle = Angle(0, -177.01, -2.658), size = Vector(0.699, 0.699, 0.699)},
		["md_acog"] = {model = "models/wystan/attachments/2cog.mdl", bone = "Base", pos = Vector(-0.505, -6.011, -3.149), angle = Angle(1.965, 3.263, 1.378), size = Vector(0.8, 0.8, 0.8)}
	}
	
	SWEP.BackupSights = {["md_acog"] = {[1] = Vector(-3.21, -4.753, -0.515), [2] = Vector(-0.973, -0.317, 0)}}

	SWEP.PSO1AxisAlign = {right = -1.32, up = 2.49, forward = 90 + 2.2}
	SWEP.SchmidtShortDotAxisAlign = {right = -2.09, up = 2.93, forward = 0}
	SWEP.NXSAlign = {right = -2.09, up = 2.93, forward = 0}
end

SWEP.MuzzleVelocity = 880 -- in meter/s

SWEP.LuaViewmodelRecoil = true
SWEP.LuaViewmodelRecoilOverride = true
SWEP.LuaVMRecoilAxisMod = {vert = 1, hor = 5, roll = 3, forward = 2, pitch = 1}

SWEP.PreventQuickScoping = true
SWEP.QuickScopeSpreadIncrease = 0.3

--SWEP.Attachments = {[1] = {header = "Sight", offset = {300, -50},  atts = {"md_kobra", "md_eotech", "md_aimpoint"}},
--	[2] = {header = "Barrel", offset = {-175, -100}, atts = {"md_pbs1"}},
--	[3] = {header = "Handguard", offset = {-100, 200}, atts = {"md_foregrip"}}}

SWEP.RailBGs = {main = 1, on = 0, off = 1}

SWEP.Attachments = {[1] = {header = "Sight", offset = {950, -500},  atts = {"md_schmidt_shortdot", "md_pso1", "md_acog", "md_nightforce_nxs"}},
	[2] = {header = "Barrel", offset = {-300, -100}, atts = {"md_pbs1"}},
	["+reload"] = {header = "Ammo", offset = {950, 0}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {fire = {"shoot", "shoot2"},
	reload = "reload",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {draw = {{time = 0, sound = "CW_FOLEY_MEDIUM"}},

	reload = {
		{time = 0.93, sound = "CW_SVD_OFFICIAL_MAGOUT"},
		{time = 1.1, sound = "CW_FOLEY_LIGHT"},
		{time = 1.8, sound = "CW_SVD_OFFICIAL_MAGIN_PARTIAL"},
		{time = 1.98, sound = "CW_SVD_OFFICIAL_MAGIN"},
		{time = 2.24, sound = "CW_SVD_OFFICIAL_MAGTAP"},
		{time = 2.83, sound = "CW_SVD_OFFICIAL_BOLTPULL"},
		{time = 3.04, sound = "CW_SVD_OFFICIAL_BOLTFORWARD"},
		{time = 3.38, sound = "CW_FOLEY_MEDIUM"}
	}
}

SWEP.SpeedDec = 40

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/rifles/svd.mdl"
SWEP.WorldModel		= "models/cw2/rifles/svd_world.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 10
SWEP.Primary.DefaultClip	= 10
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "7.62x54MMR"

SWEP.FireDelay = 0.15
SWEP.FireSound = "CW_SVD_OFFICIAL_FIRE"
SWEP.FireSoundSuppressed = "CW_SVD_OFFICIAL_FIRE_SUPPRESSED"
SWEP.Recoil = 1.85

SWEP.HipSpread = 0.06
SWEP.AimSpread = 0.0015
SWEP.VelocitySensitivity = 2.5
SWEP.MaxSpreadInc = 0.08
SWEP.SpreadPerShot = 0.015
SWEP.SpreadCooldown = 0.25
SWEP.Shots = 1
SWEP.Damage = 55
SWEP.DeployTime = 0.85
SWEP.NearWallDistance = 40

SWEP.ReloadSpeed = 1
SWEP.ReloadTime = 2.5
SWEP.ReloadTime_Empty = 4
SWEP.ReloadHalt = 2.6
SWEP.ReloadHalt_Empty = 4
SWEP.SnapToIdlePostReload = true

function SWEP:checkAttachmentDependency()
	-- wrap around this method to enable the rail when no sight attachment is active
	self.BaseClass.checkAttachmentDependency(self)
	
	if CLIENT then
		if not self:isAttachmentActive("sights") then			
			self.CW_VM:SetBodygroup(1, 0)
		end
	end
end


================================================
FILE: cw2extra/lua/autorun/ecw_init.lua
================================================
AddCSLuaFile()

include("ecw/shared/attachments/mac11_attachments.lua")
include("ecw/shared/attachments/asval_attachments.lua")

include("ecw/shared/attachments/makarov_attachments.lua")
include("ecw/shared/attachments/mp7_attachments.lua")
include("ecw/shared/ammotypes/am_sp7.lua")


================================================
FILE: cw2extra/lua/autorun/cw/attachments/asval_attachments.lua
================================================
AddCSLuaFile()

------------------ 20 ROUND MAG

local att = {}
att.name = "bg_asval_20rnd"
att.displayName = "20 round mag"
att.displayNameShort = "20RND"
att.isBG = true

att.statModifiers = {ReloadSpeedMult = -0.1,
OverallMouseSensMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/asval_20rndmag")
	att.description = {[1] = {t = "Increases mag size to 20 rounds.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self:setBodygroup(self.MagBGs.main, self.MagBGs.round20)
	self:unloadWeapon()
	self.Primary.ClipSize = 20
	self.Primary.ClipSize_Orig = 20
end

function att:detachFunc()
	self:setBodygroup(self.MagBGs.main, self.MagBGs.regular)
	self:unloadWeapon()
	self.Primary.ClipSize = self.Primary.ClipSize_ORIG_REAL
	self.Primary.ClipSize_Orig = self.Primary.ClipSize_ORIG_REAL
end

CustomizableWeaponry:registerAttachment(att)

------------------ AS VAL VARIANT

local att = {}
att.name = "bg_asval"
att.displayName = "AS VAL variant"
att.displayNameShort = "AS VAL"
att.isBG = true

att.statModifiers = {DrawSpeedMult = 0.2,
OverallMouseSensMult = 0.15,
RecoilMult = 0.15,
FireDelayMult = -0.3333333333333}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/asval_variant")
end

function att:attachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.asval)
end

function att:detachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.vss)
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2extra/lua/autorun/cw/attachments/mac11_attachments.lua
================================================
AddCSLuaFile()

------------------ EXTENDED BARREL

local att = {}
att.name = "bg_mac11_extended_barrel"
att.displayName = "Extended barrel"
att.displayNameShort = "Ext"
att.isBG = true

att.statModifiers = {OverallMouseSensMult = -0.1,
	AimSpreadMult = -0.15,
	RecoilMult = 0.15}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/mac11_ext_barrel")
	att.description = {[1] = {t = "An extended barrel.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.extended)
end

function att:detachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.regular)
end

CustomizableWeaponry:registerAttachment(att)

------------------ UNFOLDED STOCK

local att = {}
att.name = "bg_mac11_unfolded_stock"
att.displayName = "Unfolded stock"
att.displayNameShort = "Unfold"
att.isBG = true

att.statModifiers = {DrawSpeedMult = -0.1,
OverallMouseSensMult = -0.1,
RecoilMult = -0.15}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/mac11_unfolded_stock")
end

function att:attachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.unfolded)
end

function att:detachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.folded)
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2extra/lua/ecw/shared/ammotypes/am_sp7.lua
================================================
AddCSLuaFile()

local att = {}
att.name = "am_sp7"
att.displayName = "SP-7 Rounds"
att.displayNameShort = "SP-7"
att.isBG = true

att.statModifiers = {DamageMult = 0.15,
	RecoilMult = 0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/sp-7")
end

function att:attachFunc()
	self:unloadWeapon()
end

function att:detachFunc()
	self:unloadWeapon()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2extra/lua/ecw/shared/attachments/asval_attachments.lua
================================================
AddCSLuaFile()

------------------ 20 ROUND MAG

local att = {}
att.name = "bg_asval_20rnd"
att.displayName = "20 round mag"
att.displayNameShort = "20RND"
att.isBG = true

att.statModifiers = {ReloadSpeedMult = -0.05,
OverallMouseSensMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/asval_20rndmag")
	att.description = {[1] = {t = "Increases mag size to 20 rounds.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self:setBodygroup(self.MagBGs.main, self.MagBGs.round20)
	self:unloadWeapon()
	self.Primary.ClipSize = 20
	self.Primary.ClipSize_Orig = 20
end

function att:detachFunc()
	self:setBodygroup(self.MagBGs.main, self.MagBGs.regular)
	self:unloadWeapon()
	self.Primary.ClipSize = self.Primary.ClipSize_ORIG_REAL
	self.Primary.ClipSize_Orig = self.Primary.ClipSize_ORIG_REAL
end

CustomizableWeaponry:registerAttachment(att)

------------------ 30 ROUND MAG

local att = {}
att.name = "bg_asval_30rnd"
att.displayName = "30 round mag"
att.displayNameShort = "30RND"
att.isBG = true

att.statModifiers = {ReloadSpeedMult = -0.1,
OverallMouseSensMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/asval_30rndmag")
	att.description = {[1] = {t = "Increases mag size to 30 rounds.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self:setBodygroup(self.MagBGs.main, self.MagBGs.round30)
	self:unloadWeapon()
	self.Primary.ClipSize = 30
	self.Primary.ClipSize_Orig = 30
end

function att:detachFunc()
	self:setBodygroup(self.MagBGs.main, self.MagBGs.regular)
	self:unloadWeapon()
	self.Primary.ClipSize = self.Primary.ClipSize_ORIG_REAL
	self.Primary.ClipSize_Orig = self.Primary.ClipSize_ORIG_REAL
end

CustomizableWeaponry:registerAttachment(att)

------------------ AS VAL VARIANT

local att = {}
att.name = "bg_asval"
att.displayName = "AS VAL variant"
att.displayNameShort = "AS VAL"
att.isBG = true

att.statModifiers = {FireDelayMult = -0.3333333333333}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/asval_variant")
end

function att:detachFunc()
	self:setBodygroup(self.VariantBGs.main, self.VariantBGs.vss)
end

CustomizableWeaponry:registerAttachment(att)

------------------ SR-3M VARIANT

local att = {}
att.name = "bg_sr3m"
att.displayName = "SR-3M variant"
att.displayNameShort = "SR-3M"
att.isBG = true
att.overrideSuppressorStatus = false -- it will override the weapon's default suppressor status to FALSE
att.SpeedDec = -3

att.statModifiers = {OverallMouseSensMult = 0.1,
RecoilMult = -0.1,
AimSpreadMult = 0.6,
FireDelayMult = -0.3333333333333}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/sr3m_variant")
end

function att:attachFunc()
	self:setBodygroup(self.VariantBGs.main, self.VariantBGs.sr3m)
	self:updateSoundTo("CW_SR3M_FIRE", CustomizableWeaponry.sounds.UNSUPPRESSED)
	self:updateSoundTo("CW_SR3M_FIRE_SUPPRESSED", CustomizableWeaponry.sounds.SUPPRESSED)
	self:setupCurrentIronsights(self.SR3MPos, self.SR3MAng)
	self.dt.Suppressed = false
	self.SuppressedOnEquip = false
	
	if not self:isAttachmentActive("sights") then
		self:updateIronsights("SR3M")
	end
end

function att:detachFunc()
	self:setBodygroup(self.VariantBGs.main, self.VariantBGs.vss)
	self:restoreSound()
	self:revertToOriginalIronsights()
	self.dt.Suppressed = true
	self.SuppressedOnEquip = true
end

CustomizableWeaponry:registerAttachment(att)

------------------ FOLDABLE STOCK

local att = {}
att.name = "bg_vss_foldable_stock"
att.displayName = "Foldable stock"
att.displayNameShort = "Fold"
att.isBG = true
att.SpeedDec = -3

att.statModifiers = {DrawSpeedMult = 0.2,
OverallMouseSensMult = 0.15,
RecoilMult = 0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/asval_foldable_stock")
end

function att:attachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.foldable)
end

function att:detachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.vss)
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2extra/lua/ecw/shared/attachments/mac11_attachments.lua
================================================
AddCSLuaFile()

------------------ EXTENDED BARREL

local att = {}
att.name = "bg_mac11_extended_barrel"
att.displayName = "Extended barrel"
att.displayNameShort = "Ext"
att.isBG = true

att.statModifiers = {OverallMouseSensMult = -0.1,
	AimSpreadMult = -0.15,
	DamageMult = 0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/mac11_ext_barrel")
	att.description = {[1] = {t = "An extended barrel.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function att:attachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.extended)
end

function att:detachFunc()
	self:setBodygroup(self.BarrelBGs.main, self.BarrelBGs.regular)
end

CustomizableWeaponry:registerAttachment(att)

------------------ UNFOLDED STOCK

local att = {}
att.name = "bg_mac11_unfolded_stock"
att.displayName = "Unfolded stock"
att.displayNameShort = "Unfold"
att.isBG = true

att.statModifiers = {DrawSpeedMult = -0.1,
RecoilMult = -0.1}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/mac11_unfolded_stock")
end

function att:attachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.unfolded)
end

function att:detachFunc()
	self:setBodygroup(self.StockBGs.main, self.StockBGs.folded)
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2extra/lua/ecw/shared/attachments/makarov_attachments.lua
================================================
AddCSLuaFile()

local makarov_ext_mag = {}
makarov_ext_mag.name = "bg_makarov_extmag"
makarov_ext_mag.displayName = "Extended magazine"
makarov_ext_mag.displayNameShort = "Ext mag"
makarov_ext_mag.isBG = true

makarov_ext_mag.statModifiers = {ReloadSpeedMult = -0.1,
	DrawSpeedMult = -0.05,
	OverallMouseSensMult = -0.05}

if CLIENT then
	makarov_ext_mag.displayIcon = surface.GetTextureID("atts/makarov_extmag")
	makarov_ext_mag.description = {[1] = {t = "Increases mag size to 12 rounds.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function makarov_ext_mag:attachFunc()
	self:unloadWeapon()
	self.Primary.ClipSize = 12
	self.Primary.ClipSize_Orig = 12
	
	if CLIENT then
		self:setBodygroup(self.MagBGs.main, self.MagBGs.extended)
	end
end
	

function makarov_ext_mag:detachFunc()
	self:unloadWeapon()
	self.Primary.ClipSize = self.Primary.ClipSize_ORIG_REAL
	self.Primary.ClipSize_Orig = self.Primary.ClipSize_ORIG_REAL
	
	if CLIENT then
		self:setBodygroup(self.MagBGs.main, self.MagBGs.regular)
	end
end

CustomizableWeaponry:registerAttachment(makarov_ext_mag)

local pb = {}
pb.name = "bg_makarov_pb6p9"
pb.displayName = "PB variant"
pb.displayNameShort = "PB"
pb.isBG = true
pb.isSight = true

pb.statModifiers = {RecoilMult = -0.1,
	AimSpreadMult = -0.2,
	DrawSpeedMult = -0.05,
	DamageMult = 0.1,
	FireDelayMult = 0.2}

if CLIENT then
	pb.displayIcon = surface.GetTextureID("atts/pb6p9")
	pb.description = {[1] = {t = "The PB/6P9 variant of the Makarov pistol.", c = CustomizableWeaponry.textColors.COSMETIC}}
end

function pb:attachFunc()
	if CLIENT then
		self:setBodygroup(self.SlideBGs.main, self.SlideBGs.pb)
		self:setupBoltBone("__nmBar_0")
		self:setupCurrentIronsights(self.PBIronsightsPos, self.PBIronsightsAng)
		self:updateIronsights("PBIronsights")
	end
	
	self:updateSoundTo("CW_MAKAROV_FIRE_SUPPRESSED_PB", CustomizableWeaponry.sounds.SUPPRESSED)
end

function pb:detachFunc()
	if CLIENT then
		self:setBodygroup(self.SlideBGs.main, self.SlideBGs.pm)
		self:setupBoltBone()
		self:revertToOriginalIronsights()
	end
	
	self:restoreSound()
end

CustomizableWeaponry:registerAttachment(pb)

local pb_supp = {}
pb_supp.name = "bg_makarov_pb_suppressor"
pb_supp.displayName = "PB Suppressor"
pb_supp.displayNameShort = "Suppress"
pb_supp.isBG = true

pb_supp.statModifiers = {RecoilMult = -0.1,
	OverallMouseSensMult = -0.05,
	DamageMult = -0.15}

if CLIENT then
	pb_supp.displayIcon = surface.GetTextureID("atts/pb_suppressor")
	pb_supp.description = {[1] = {t = "Decreases firing noise.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function pb_supp:attachFunc()
	self.dt.Suppressed = true
	
	if CLIENT then
		self:setBodygroup(self.SuppressorBGs.main, self.SuppressorBGs.pb)
	end
end

function pb_supp:detachFunc()
	self.dt.Suppressed = false
	
	if CLIENT then
		self:setBodygroup(self.SuppressorBGs.main, self.SuppressorBGs.none)
	end
end

CustomizableWeaponry:registerAttachment(pb_supp)

local pm_supp = {}
pm_supp.name = "bg_makarov_pm_suppressor"
pm_supp.displayName = "PM Suppressor"
pm_supp.displayNameShort = "Suppress"
pm_supp.isBG = true

pm_supp.statModifiers = {RecoilMult = -0.1,
	OverallMouseSensMult = -0.05,
	DamageMult = -0.1}

if CLIENT then
	pm_supp.displayIcon = surface.GetTextureID("atts/pm_suppressor")
	pm_supp.description = {[1] = {t = "Decreases firing noise.", c = CustomizableWeaponry.textColors.POSITIVE}}
end

function pm_supp:attachFunc()
	self.dt.Suppressed = true
	
	if CLIENT then
		self:setBodygroup(self.SuppressorBGs.main, self.SuppressorBGs.pm)
	end
end

function pm_supp:detachFunc()
	self.dt.Suppressed = false
	
	if CLIENT then
		self:setBodygroup(self.SuppressorBGs.main, self.SuppressorBGs.none)
	end
end

CustomizableWeaponry:registerAttachment(pm_supp)


================================================
FILE: cw2extra/lua/ecw/shared/attachments/mp7_attachments.lua
================================================
AddCSLuaFile()

------------------ UNSUPPRESSED

local att = {}
att.name = "bg_mp7_unsuppressed"
att.displayName = "Unsuppressed"
att.displayNameShort = "Unsup"
att.isBG = true

att.statModifiers = {
	DamageMult = 0.1,
	RecoilMult = 0.15
}

if CLIENT then
	att.displayIcon = surface.GetTextureID("atts/saker")
end

function att:attachFunc()
	self.dt.Suppressed = false
	self:setBodygroup(self.SuppressorBGs.main, self.SuppressorBGs.unsuppressed)	
end

function att:detachFunc()
	self:setBodygroup(self.SuppressorBGs.main, self.SuppressorBGs.suppressed)
	self:resetSuppressorStatus()
end

CustomizableWeaponry:registerAttachment(att)


================================================
FILE: cw2extra/lua/entities/cw_ammo_12gauge/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 28)


================================================
FILE: cw2extra/lua/entities/cw_ammo_12gauge/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2extra/lua/entities/cw_ammo_12gauge/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = "12 Gauge"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.CaliberSpecific = true
ENT.AmmoCapacity = 32
ENT.ResupplyAmount = 8
ENT.Caliber = "12 Gauge"
ENT.Model = "models/Items/BoxMRounds.mdl"


================================================
FILE: cw2extra/lua/entities/cw_ammo_45acp/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 28)


================================================
FILE: cw2extra/lua/entities/cw_ammo_45acp/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2extra/lua/entities/cw_ammo_45acp/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = ".45 ACP Ammo"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.CaliberSpecific = true
ENT.AmmoCapacity = 100
ENT.ResupplyAmount = 25
ENT.Caliber = ".45 ACP"
ENT.Model = "models/Items/BoxSRounds.mdl"


================================================
FILE: cw2extra/lua/entities/cw_ammo_9x17/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 28)


================================================
FILE: cw2extra/lua/entities/cw_ammo_9x17/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2extra/lua/entities/cw_ammo_9x17/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = "9x17MM Ammo"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.CaliberSpecific = true
ENT.AmmoCapacity = 100
ENT.ResupplyAmount = 25
ENT.Caliber = "9x17MM"
ENT.Model = "models/Items/BoxSRounds.mdl"


================================================
FILE: cw2extra/lua/entities/cw_ammo_9x39/cl_init.lua
================================================
include("shared.lua")

ENT.upOffset = Vector(0, 0, 30)


================================================
FILE: cw2extra/lua/entities/cw_ammo_9x39/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")


================================================
FILE: cw2extra/lua/entities/cw_ammo_9x39/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "cw_ammo_ent_base"
ENT.PrintName = "9x39MM Ammo"
ENT.Author = "Spy"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "CW 2.0 Ammo"

ENT.CaliberSpecific = true
ENT.AmmoCapacity = 60
ENT.ResupplyAmount = 20
ENT.Caliber = "9x39MM"
ENT.Model = "models/Items/BoxMRounds.mdl"


================================================
FILE: cw2extra/lua/weapons/cw_fiveseven/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_FIVESEVEN_FIRE", "weapons/cw_fiveseven/fire.wav", 1, 113, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_FIVESEVEN_FIRE_SUPPRESSED", "weapons/cw_fiveseven/fire_suppressed.wav", 1, 85, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_FIVESEVEN_MAGIN", "weapons/cw_fiveseven/magin.wav")
CustomizableWeaponry:addReloadSound("CW_FIVESEVEN_MAGOUT", "weapons/cw_fiveseven/magout.wav")
CustomizableWeaponry:addReloadSound("CW_FIVESEVEN_SLIDERELEASE", "weapons/cw_fiveseven/sliderelease.wav")


================================================
FILE: cw2extra/lua/weapons/cw_fiveseven/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

CustomizableWeaponry:registerAmmo("9x18MM", "9x18MM Rounds", 9, 18)

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "FN Five-seveN"
	
	SWEP.IconLetter = "u"
	killicon.AddFont("cw_fiveseven", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_pistol"
	SWEP.PosBasedMuz = false

	SWEP.Shell = "smallshell"
	SWEP.ShellScale = 0.5
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = 2, y = 0, z = 0}
		
	--SWEP.IronsightPos = Vector(-2.783, 10, 1.264)
	--SWEP.IronsightAng = Vector(0.273, -1.461, 0)

	SWEP.IronsightPos = Vector(-2.977, 10, 1.226)
	SWEP.IronsightAng = Vector(0.273, -1.461, 0)

	--SWEP.IronsightPos = Vector(-2.721, 0, 1.276)
	--SWEP.IronsightAng = Vector(0.273, -1.461, 0)

	SWEP.SprintPos = Vector(3.632, -9.933, -8.775)
	SWEP.SprintAng = Vector(70, 0, 0)
	
	SWEP.MicroT1Pos = Vector(-2.889, 0, -0.009)
	SWEP.MicroT1Ang = Vector(0, -1.943, 0)
	
	SWEP.RMRPos = Vector(-2.758, -4.185, 0.4)
	SWEP.RMRAng = Vector(0, -1.943, 0)
	
	SWEP.MoveType = 1
	SWEP.ViewModelMovementScale = 0.8
	SWEP.FullAimViewmodelRecoil = false
	SWEP.BoltBone = "Object014"
	SWEP.BoltShootOffset = Vector(-1.5, 0, 0)
	SWEP.BoltBonePositionRecoverySpeed = 25
	SWEP.OffsetBoltDuringNonEmptyReload = true
	SWEP.BoltReloadOffset = Vector(0, 0, 0)
	SWEP.ReloadBoltBonePositionRecoverySpeed = 20
	SWEP.ReloadBoltBonePositionMoveSpeed = 100
	SWEP.StopReloadBoneOffset = 0.4
	SWEP.HoldBoltWhileEmpty = true
	SWEP.DontHoldWhenReloading = true
	SWEP.DontMoveBoltOnHipFire = true
	SWEP.DisableSprintViewSimulation = true
	SWEP.FOVPerShot = 0.3
	
	SWEP.SightWithRail = true

	SWEP.AttachmentModelsVM = {
		["md_rail"] = {model = "models/cw2/attachments/pistolrail.mdl", bone = "Object007", pos = Vector(0.076, 1.534, -0.343), angle = Angle(0, -90, 0), size = Vector(0.18, 0.18, 0.18)},
		["md_saker"] = {model = "models/cw2/attachments/556suppressor.mdl", bone = "Object007", pos = Vector(0.09, 6.261, 0.151), angle = Angle(0, 180, 0), size = Vector(0.5, 0.5, 0.5)},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "Object007", pos = Vector(0.064, 0.805, 2.819), angle = Angle(0, 0, 0), size = Vector(0.479, 0.479, 0.479)},
		["md_insight_x2"] = {model = "models/cw2/attachments/pistollaser.mdl", bone = "Object007", pos = Vector(0.034, 0.37, 0.767), angle = Angle(0, -90, 0), size = Vector(0.14, 0.14, 0.14)}
	}

	SWEP.LuaVMRecoilAxisMod = {vert = 0.25, hor = 0.5, roll = 2, forward = 0, pitch = 1}
	SWEP.CustomizationMenuScale = 0.01
	SWEP.BoltBonePositionRecoverySpeed = 17 -- how fast does the bolt bone move back into it's initial position after the weapon has fired
	
	SWEP.LaserPosAdjust = Vector(0.5, 0, -2)
	SWEP.LaserAngAdjust = Angle(0, 180 + -1.7, 0) 
	
	SWEP.LaserAngAdjustAim = Angle(0, 180 - 0.5, 0)
	
	SWEP.SlideBGs = {main = 1, pm = 0, pb = 1}
	SWEP.SuppressorBGs = {main = 2, pm = 1, pb = 2, none = 0}
	SWEP.MagBGs = {main = 3, regular = 0, extended = 1}
	
	SWEP.AttachmentPosDependency = {["md_insight_x2"] = {["md_microt1"] = Vector(0.093, 0.37, 0.358)}}
end

SWEP.ShootWhileProne = true

SWEP.MuzzleVelocity = 520

SWEP.LuaViewmodelRecoil = true
SWEP.LuaViewmodelRecoilOverride = true
SWEP.CanRestOnObjects = false

SWEP.Attachments = {[1] = {header = "Barrel", offset = {-350, -200}, atts = {"md_saker"}},
	[2] = {header = "Sight", offset = {400, -300}, atts = {"md_microt1"}},
	[3] = {header = "Rail", offset = {-350, 250}, atts = {"md_insight_x2"}},
	["+reload"] = {header = "Ammo", offset = {800, 100}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {reload = "reload_cham",
	reload_empty = "reload",
	fire = {"shoot1", "shoot2", "shoot3"},
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {draw = {{time = 0, sound = "CW_FOLEY_LIGHT"}},
	reload_cham = {{time = 0.15, sound = "CW_FIVESEVEN_MAGOUT"},
	{time = 1.2, sound = "CW_FIVESEVEN_MAGIN"}},
	
	reload = {{time = 0.15, sound = "CW_FIVESEVEN_MAGOUT"},
	{time = 1.2, sound = "CW_FIVESEVEN_MAGIN"},
	{time = 1.88, sound = "CW_FIVESEVEN_SLIDERELEASE"}}
}

SWEP.SpeedDec = 5

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/pistols/fiveseven.mdl"
SWEP.WorldModel		= "models/weapons/w_pist_fiveseven.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 20
SWEP.Primary.DefaultClip	= 20
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "5.7x28MM"

SWEP.FireDelay = 0.11
SWEP.FireSound = "CW_FIVESEVEN_FIRE"
SWEP.FireSoundSuppressed = "CW_FIVESEVEN_FIRE_SUPPRESSED"
SWEP.Recoil = 0.77

SWEP.HipSpread = 0.034
SWEP.AimSpread = 0.01
SWEP.VelocitySensitivity = 1.2
SWEP.MaxSpreadInc = 0.04
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 0.17
SWEP.Shots = 1
SWEP.Damage = 20
SWEP.DeployTime = 0.4
--SWEP.Chamberable = false
SWEP.NearWallDistance = 15

SWEP.DrawSpeed = 1.5

SWEP.ReloadSpeed = 1
SWEP.ReloadTime = 1.8
SWEP.ReloadHalt = 2.1

SWEP.ReloadTime_Empty = 1.69
SWEP.ReloadHalt_Empty = 2.3


================================================
FILE: cw2extra/lua/weapons/cw_g36c/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_G36C_FIRE", "weapons/cw_g36c/fire.wav", 1, 115, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_G36C_FIRE_SUPPRESSED", "weapons/cw_g36c/fire_suppressed.wav", 1, 92, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_G36C_MAGOUT", "weapons/cw_g36c/magout.wav")
CustomizableWeaponry:addReloadSound("CW_G36C_MAGIN", "weapons/cw_g36c/magin.wav")
CustomizableWeaponry:addReloadSound("CW_G36C_MAGDROP", "weapons/cw_g36c/magdrop.wav")
CustomizableWeaponry:addReloadSound("CW_G36C_BOLTBACK", "weapons/cw_g36c/boltback.wav")
CustomizableWeaponry:addReloadSound("CW_G36C_BOLTFORWARD", "weapons/cw_g36c/boltforward.wav")
CustomizableWeaponry:addReloadSound("CW_G36C_SELECTFIRE", "weapons/cw_g36c/select.wav")


================================================
FILE: cw2extra/lua/weapons/cw_g36c/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "H&K G36C"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1.15
	SWEP.CustomizationMenuScale = 0.011
	
	SWEP.IconLetter = "i"
	killicon.AddFont("cw_g36c", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))

	SWEP.MuzzleEffect = "muzzleflash_6"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = -3, y = 0, z = 0}
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.52
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.52
	SWEP.FireMoveMod = 0.6
	
	SWEP.DrawTraditionalWorldModel = false
	SWEP.WM = "models/weapons/cw20_g36c.mdl"
	SWEP.WMPos = Vector(0, -0.5, 0.5)
	SWEP.WMAng = Vector(0, 0, 180)
	
	SWEP.IronsightPos = Vector(-2.605, -4.496, 0.629)
	SWEP.IronsightAng = Vector(-0, 0, 0)
	
	SWEP.EoTechPos = Vector(-2.59, -4.351, -0.267)
	SWEP.EoTechAng = Vector(0, 0, 0)
	
	SWEP.MicroT1Pos = Vector(-2.603, 0.5, 0.028)
	SWEP.MicroT1Ang = Vector(0, 0, 0)
	
	SWEP.ACOGPos = Vector(-2.596, -3, -0.309)
	SWEP.ACOGAng = Vector(0, 0, 0)
	
	SWEP.SG1Pos = Vector(-1.614, -0.861, -0.51)
	SWEP.SG1Ang = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(1.786, 0, -1)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)

	SWEP.ShortDotPos = Vector(-2.606, -4.875, 0.189)
	SWEP.ShortDotAng = Vector(0, 0, 0)

	SWEP.BackupSights = {["md_acog"] = {[1] = Vector(-2.589, -3, -1.318), [2] = Vector(0, 0, 0)}}

	SWEP.SightWithRail = true
	SWEP.ACOGAxisAlign = {right = 0, up = 0, forward = 0}
	SWEP.SchmidtShortDotAxisAlign = {right = 0, up = 0, forward = 0}
	
	SWEP.AlternativePos = Vector(-0.2, 0, -0.4)
	SWEP.AlternativeAng = Vector(0, 0, 0)
	
	SWEP.M203CameraRotation = {p = -90, y = 0, r = -90}

	SWEP.BaseArm = "Left_U_Arm"
	SWEP.BaseArmBoneOffset = Vector(-50, 0, 0)
	
	SWEP.M203HoldPos = {
		["Left_U_Arm"] = {pos = Vector(2.197, -2.123, -1.015), angle = Angle(0, 0, 0)}
	}
	
	SWEP.AttachmentModelsVM = {
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "body", pos = Vector(-8.2, 6.688, -0.28), angle = Angle(0, 3.332, -90), size = Vector(1, 1, 1)},
		["md_foregrip"] = {model = "models/wystan/attachments/foregrip1.mdl", bone = "body", pos = Vector(-1.573, 0.902, 0.414), angle = Angle(-90, 0, -90), size = Vector(0.75, 0.75, 0.75)},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "body", pos = Vector(1.9, -4.746, -0.014), angle = Angle(90, 0, -90), adjustment = {min = 1.9, max = 3.8, axis = "x", inverseOffsetCalc = true}, size = Vector(0.4, 0.4, 0.4)},
		["md_anpeq15"] = {model = "models/cw2/attachments/anpeq15.mdl", bone = "body", pos = Vector(6.1, -4.533, 0.112), angle = Angle(180, 0, -90), size = Vector(0.449, 0.449, 0.449)},
		["md_saker"] = {model = "models/cw2/attachments/556suppressor.mdl", bone = "body", pos = Vector(-1.52, -2.649, -2.381), angle = Angle(0, 90, 0), size = Vector(0.8, 0.8, 0.8)},
		["md_acog"] = {model = "models/wystan/attachments/2cog.mdl", bone = "body", pos = Vector(-2.7, 0.544, 0.317), angle = Angle(-90, 0, -90), size = Vector(0.899, 0.899, 0.899)},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "body", pos = Vector(-1.162, -0.594, 0.259), angle = Angle(0, 0, -90), size = Vector(0.699, 0.699, 0.699)}
	}

	SWEP.ForeGripHoldPos = {
		["Left12"] = {pos = Vector(0, 0, 0), angle = Angle(52.786, -5.152, 0) },
		["Left4"] = {pos = Vector(0, 0, 0), angle = Angle(25.712, -6.266, -16.903) },
		["Left1"] = {pos = Vector(0, 0, 0), angle = Angle(25.437, 8.171, 0) },
		["Left6"] = {pos = Vector(0, 0, 0), angle = Angle(47.268, 0, 0) },
		["Left3"] = {pos = Vector(0, 0, 0), angle = Angle(0, 74.572, 0) },
		["Left8"] = {pos = Vector(0, 0, 0), angle = Angle(27.87, 1.797, 0) },
		["Left15"] = {pos = Vector(0, 0, 0), angle = Angle(34.446, -2.81, 0) },
		["Left5"] = {pos = Vector(0, 0, 0), angle = Angle(24.264, 0, 0) },
		["Left7"] = {pos = Vector(0, 0, 0), angle = Angle(10.465, -7.058, -12.056) },
		["Left11"] = {pos = Vector(0, 0, 0), angle = Angle(21.985, -9.301, 0) },
		["Left9"] = {pos = Vector(0, 0, 0), angle = Angle(26.117, 0, 0) },
		["Left14"] = {pos = Vector(0, 0, 0), angle = Angle(-53.977, 0, 0) },
		["Left13"] = {pos = Vector(0, 0, 0), angle = Angle(3.716, -11.523, -7.351) },
		["Left10"] = {pos = Vector(0, 0, 0), angle = Angle(5.267, -7.495, 0) },
		["Left2"] = {pos = Vector(0, 0, 0), angle = Angle(8.8, 20.444, 0) },
		["Left_L_Arm"] = {pos = Vector(-0.049, -0.169, -0.216), angle = Angle(-19.792, 0.01, 81.132) }
	}

	SWEP.LuaVMRecoilAxisMod = {vert = 1, hor = 1, roll = 1, forward = 1, pitch = 1}
	
	SWEP.LaserPosAdjust = Vector(0.5, 0, 0)
	SWEP.LaserAngAdjust = Angle(0, 180, 0) 
end

SWEP.MuzzleVelocity = 800 -- in meter/s, kind of a guess on the G36C here, since I can't find muzzle velocity of the G36C anywhere (only other models like G36, G36K, etc.)

SWEP.LuaViewmodelRecoil = true
SWEP.LuaViewmodelRecoilOverride = true

SWEP.Attachments = {[1] = {header = "Sight", offset = {800, -500},  atts = {"md_microt1", "md_eotech", "md_schmidt_shortdot", "md_acog"}},
	[2] = {header = "Barrel", offset = {-500, -600}, atts = {"md_saker"}},
	[3] = {header = "Handguard", offset = {-500, -150}, atts = {"md_foregrip"}},
	[4] = {header = "Rail", offset = {-500, 250},  atts = {"md_anpeq15"}, dependencies = {md_microt1 = true, md_eotech = true, md_schmidt_shortdot = true, md_acog = true}},
	["+reload"] = {header = "Ammo", offset = {800, 100}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {fire = {"shoot1", "shoot2", "shoot3"},
	reload = "Reload",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {draw = {{time = 0, sound = "CW_FOLEY_LIGHT"},
	{time = 0.4, sound = "CW_G36C_SELECTFIRE"}},

	Reload = {{time = 0.2, sound = "CW_FOLEY_LIGHT"},
	{time = 1, sound = "CW_G36C_MAGOUT"},
	{time = 0.6, sound = "CW_FOLEY_LIGHT"},
	{time = 1.6, sound = "CW_G36C_MAGIN"},
	{time = 2, sound = "CW_G36C_MAGDROP"},
	{time = 2.35, sound = "CW_G36C_BOLTBACK"},
	{time = 2.5, sound = "CW_G36C_BOLTFORWARD"},
	{time = 2, sound = "CW_FOLEY_MEDIUM"}}}

SWEP.SpeedDec = 25

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "2burst", "semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/rifles/g36c.mdl"
SWEP.WorldModel		= "models/weapons/cw20_g36c.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 30
SWEP.Primary.DefaultClip	= 30
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "5.56x45MM"

SWEP.FireDelay = 0.08
SWEP.FireSound = "CW_G36C_FIRE"
SWEP.FireSoundSuppressed = "CW_G36C_FIRE_SUPPRESSED"
SWEP.Recoil = 1

SWEP.HipSpread = 0.042
SWEP.AimSpread = 0.0045
SWEP.VelocitySensitivity = 1.6
SWEP.MaxSpreadInc = 0.043
SWEP.SpreadPerShot = 0.006
SWEP.SpreadCooldown = 0.15
SWEP.Shots = 1
SWEP.Damage = 28
SWEP.DeployTime = 1

SWEP.ReloadSpeed = 1
SWEP.ReloadTime = 1.8
SWEP.ReloadTime_Empty = 2.7
SWEP.ReloadHalt = 2.1
SWEP.ReloadHalt_Empty = 3

SWEP.SnapToIdlePostReload = true


================================================
FILE: cw2extra/lua/weapons/cw_l85a2/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_L85A2_FIRE", "weapons/cw_l85a2/fire.wav", 1, 117, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_L85A2_FIRE_SUPPRESSED", "weapons/cw_l85a2/fire_suppressed.wav", 1, 92, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_L85A2_MAGOUT", "weapons/cw_l85a2/magout.wav")
CustomizableWeaponry:addReloadSound("CW_L85A2_MAGIN", {"weapons/cw_l85a2/magin_1.wav", "weapons/cw_l85a2/magin_2.wav"})
CustomizableWeaponry:addReloadSound("CW_L85A2_BOLTPULL", "weapons/cw_l85a2/boltpull.wav")


================================================
FILE: cw2extra/lua/weapons/cw_l85a2/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "L85A2"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1.15
	SWEP.CustomizationMenuScale = 0.012
	
	SWEP.IconLetter = "i"
	killicon.AddFont("cw_g36c", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))

	SWEP.MuzzleEffect = "muzzleflash_6"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = -7, y = 0, z = 0}
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.52
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.52
	SWEP.FireMoveMod = 0.6
	
	SWEP.DrawTraditionalWorldModel = false
	SWEP.WM = "models/weapons/w_cw20_l85a2.mdl"
	SWEP.WMPos = Vector(0, -19, -7.5)
	SWEP.WMAng = Vector(-6, 0, 180)
		
	SWEP.IronsightPos = Vector(-2.218, -1.785, -0.072)
	SWEP.IronsightAng = Vector(0, 0, 0)
		
	SWEP.MicroT1Pos = Vector(-2.211, -5, 0.518)
	SWEP.MicroT1Ang = Vector(0, 0, 0)

	SWEP.EoTechPos = Vector(-2.221, -6.48, 0.103)
	SWEP.EoTechAng = Vector(0, 0, 0)
	
	SWEP.AimpointPos = Vector(-2.221, -6.48, 0.474)
	SWEP.AimpointAng = Vector(0, 0, 0)
	
	SWEP.ShortDotPos = Vector(-2.145, -7, 0.44)
	SWEP.ShortDotAng = Vector(0, 0, 0)
	
	SWEP.ACOGPos = Vector(-2.204, -7.3, 0.15)
	SWEP.ACOGAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(1.786, 0, -1)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)

	SWEP.BackupSights = {["md_acog"] = {[1] = Vector(-2.199, -7.633, -0.973), [2] = Vector(0, 0, 0)}}

	SWEP.SightWithRail = true
	SWEP.ACOGAxisAlign = {right = 0.5, up = 0, forward = 0}
	SWEP.SchmidtShortDotAxisAlign = {right = 0.42, up = 0, forward = 0}
	
	SWEP.AlternativePos = Vector(-0.2, 0, -0.4)
	SWEP.AlternativeAng = Vector(0, 0, 0)

	SWEP.BaseArm = "Left_U_Arm"
	SWEP.BaseArmBoneOffset = Vector(-50, 0, 0)

	SWEP.AttachmentModelsVM = {
		["md_aimpoint"] = {model = "models/wystan/attachments/aimpoint.mdl", bone = "body", pos = Vector(-2.119, 2.118, 0.241), angle = Angle(-90, 0, -90), size = Vector(1, 1, 1)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "body", pos = Vector(-8.197, 9.987, -0.348), angle = Angle(0, 3.332, -90), size = Vector(1.2, 1.2, 1.2)},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "body", pos = Vector(-1.6, 2.1, 0.3), angle = Angle(0, 0, -90), size = Vector(1, 1, 1)},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "body", pos = Vector(3.588, -3.741, -0.049), angle = Angle(90, 0, -90), size = Vector(0.449, 0.449, 0.449)},
		["md_saker"] = {model = "models/cw2/attachments/556suppressor.mdl", bone = "body", pos = Vector(0.976, -2.477, -1.522), angle = Angle(0, 90, 0), size = Vector(0.5, 0.5, 0.5)},
		["md_anpeq15"] = {model = "models/cw2/attachments/anpeq15.mdl", bone = "body", pos = Vector(4.293, -1.867, -0.764), angle = Angle(180, 0, 0), size = Vector(0.6, 0.6, 0.6)},
		["md_acog"] = {model = "models/wystan/attachments/2cog.mdl", bone = "body", pos = Vector(-1.433, 2.134, 0.33), angle = Angle(-90, 0, -90), size = Vector(1, 1, 1)}
	}

	SWEP.LuaVMRecoilAxisMod = {vert = 1, hor = 2, roll = 1.5, forward = 1, pitch = 1}
	
	SWEP.LaserPosAdjust = Vector(-1, 0, 0)
	SWEP.LaserAngAdjust = Angle(0, 180, 0) 
	
	SWEP.Trivia = {text = "This weapon comes with a grippod pre-installed, which acts like a foregrip and a bipod.", x = -500, y = -360}
end

SWEP.MuzzleVelocity = 930 -- in meter/s

SWEP.SightBGs = {main = 1, none = 1}
SWEP.LuaViewmodelRecoil = true
SWEP.LuaViewmodelRecoilOverride = true

SWEP.Attachments = {[1] = {header = "Sight", offset = {800, -300},  atts = {"md_microt1", "md_eotech", "md_aimpoint", "md_schmidt_shortdot", "md_acog"}},
	[2] = {header = "Barrel", offset = {-500, -300}, atts = {"md_saker"}},
	[3] = {header = "Rail", offset = {-500, 200},  atts = {"md_anpeq15"}},
	["+reload"] = {header = "Ammo", offset = {800, 150}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {fire = {"shoot1", "shoot2", "shoot3"},
	reload = "Reload_Full",
	reload_empty = "Reload",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {draw = {{time = 0, sound = "CW_FOLEY_LIGHT"},
	{time = 0.4, sound = "CW_G36C_SELECTFIRE"}},

	Reload = {{time = 0.2, sound = "CW_FOLEY_LIGHT"},
	{time = 0.73, sound = "CW_L85A2_MAGOUT"},
	{time = 1, sound = "CW_FOLEY_LIGHT"},
	{time = 1.3, sound = "CW_G36C_MAGDROP"},
	{time = 2.55, sound = "CW_L85A2_MAGIN"},
	{time = 3.7, sound = "CW_L85A2_BOLTPULL"},
	{time = 4.3, sound = "CW_FOLEY_MEDIUM"}},
	
	Reload_Full = {{time = 0.2, sound = "CW_FOLEY_LIGHT"},
	{time = 0.73, sound = "CW_L85A2_MAGOUT"},
	{time = 1, sound = "CW_FOLEY_LIGHT"},
	{time = 1.3, sound = "CW_G36C_MAGDROP"},
	{time = 2.55, sound = "CW_L85A2_MAGIN"},
	{time = 3, sound = "CW_FOLEY_MEDIUM"}}}

SWEP.SpeedDec = 30

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/rifles/l85a2.mdl"
SWEP.WorldModel		= "models/weapons/w_cw20_l85a2.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 30
SWEP.Primary.DefaultClip	= 30
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "5.56x45MM"

SWEP.FireDelay = 0.092
SWEP.FireSound = "CW_L85A2_FIRE"
SWEP.FireSoundSuppressed = "CW_L85A2_FIRE_SUPPRESSED"
SWEP.Recoil = 0.95

SWEP.HipSpread = 0.045
SWEP.AimSpread = 0.0025
SWEP.VelocitySensitivity = 1.8
SWEP.MaxSpreadInc = 0.045
SWEP.SpreadPerShot = 0.007
SWEP.SpreadCooldown = 0.16
SWEP.Shots = 1
SWEP.Damage = 31
SWEP.DeployTime = 0.8

SWEP.ReloadSpeed = 1.35
SWEP.ReloadTime = 2.99
SWEP.ReloadTime_Empty = 2.99
SWEP.ReloadHalt = 4.1
SWEP.ReloadHalt_Empty = 5.05

-- the model that this L85A2 uses comes with a grippod, so we add bipod functionality to it, but make it very tame when compared to a regular bipod
SWEP.BipodInstalled = true
SWEP.BipodRecoilModifier = 0.75

function SWEP:getBipodHipSpread()
	return self.HipSpread * 0.75
end


================================================
FILE: cw2extra/lua/weapons/cw_m14/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_M14_FIRE", "weapons/cw_m14/fire.wav", 1, 125, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_M14_FIRE_SUPPRESSED", "weapons/cw_m14/fire_suppressed.wav", 1, 100, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_M14_MAGOUT", "weapons/cw_m14/magout.wav")
CustomizableWeaponry:addReloadSound("CW_M14_MAGIN", "weapons/cw_m14/magin.wav")
CustomizableWeaponry:addReloadSound("CW_M14_BOLT", "weapons/cw_m14/bolt.wav")


================================================
FILE: cw2extra/lua/weapons/cw_m14/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "M14 EBR"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1.15
	SWEP.CustomizationMenuScale = 0.013
	
	SWEP.IconLetter = "n"
	killicon.AddFont("cw_g3a3", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_m14"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = 4, y = 0, z = -3}
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.9
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.65
	SWEP.FireMoveMod = 0.6
	
	SWEP.DrawTraditionalWorldModel = false
	SWEP.WM = "models/weapons/w_cstm_m14.mdl"
	SWEP.WMPos = Vector(0, -0.5, 1)
	SWEP.WMAng = Vector(0, 0, 180)
	
	SWEP.IronsightPos = Vector(-2.231, -3.428, 1.207)
	SWEP.IronsightAng = Vector(0, -0.008, 0)
	
	SWEP.NXSPos = Vector(-2.218, -3.388, 0.225)
	SWEP.NXSAng = Vector(0, 0, 0)

	SWEP.EoTechPos = Vector(-2.237, -4.617, 0.079)
	SWEP.EoTechAng = Vector(0, -0.008, 0)
	
	SWEP.AimpointPos = Vector(-2.24, -3.856, 0.144)
	SWEP.AimpointAng = Vector(0, -0.008, 0)
	
	SWEP.MicroT1Pos = Vector(-2.241, 0.5, 0.395)
	SWEP.MicroT1Ang = Vector(0, -0.008, 0)
	
	SWEP.ACOGPos = Vector(-2.231, -5, -0.12)
	SWEP.ACOGAng = Vector(0, -0.008, 0)
	
	SWEP.SG1Pos = Vector(-1.614, -0.861, -0.51)
	SWEP.SG1Ang = Vector(0, 0, 0)
	
	SWEP.ShortDotPos = Vector(-2.211, -4.624, 0.221)
	SWEP.ShortDotAng = Vector(0, 0, 0)

	SWEP.SprintPos = Vector(1.786, 0, -1)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.BackupSights = {["md_acog"] = {[1] = Vector(-2.221, -4.617, -1.234), [2] = Vector(0, -0.008, 0)}}

	SWEP.SightWithRail = true
	SWEP.ACOGAxisAlign = {right = 0.35, up = 0, forward = 0}
	SWEP.NXSAlign = {right = 0.35, up = 0, forward = 0}
	SWEP.SchmidtShortDotAxisAlign = {right = 0.2, up = 0, forward = 0}
	
	SWEP.AlternativePos = Vector(-0.319, 1.325, -1.04)
	SWEP.AlternativeAng = Vector(0, 0, 0)
	
	SWEP.M203OffsetCycle_Reload = 0.81
	SWEP.M203OffsetCycle_Reload_Empty = 0.73
	SWEP.M203OffsetCycle_Draw = 0
	
	SWEP.M203CameraRotation = {p = -90, y = 0, r = -90}
	
	SWEP.BaseArm = "Bip01 L Clavicle"
	SWEP.BaseArmBoneOffset = Vector(-50, 0, 0)
	
	SWEP.BoltBone = "M14_Charger"
	SWEP.BoltShootOffset = Vector(-3, 0, 0)
	
	SWEP.M203HoldPos = {
		["Bip01 L Clavicle"] = {pos = Vector(4.461, 0.308, -2.166), angle = Angle(0, 0, 0)}
	}
	
	SWEP.ForeGripHoldPos = {
		["Bip01 L Finger3"] = {pos = Vector(0, 0, 0), angle = Angle(0, 14.81, 12.463) },
		["Bip01 L Finger41"] = {pos = Vector(0, 0, 0), angle = Angle(0, -20.722, 0) },
		["Bip01 L Clavicle"] = {pos = Vector(0.266, 0.702, -2.852), angle = Angle(0, 0, 0) },
		["Bip01 L Finger22"] = {pos = Vector(0, 0, 0), angle = Angle(0, 62.166, 0) },
		["Bip01 L ForeTwist1"] = {pos = Vector(0, 0, 0), angle = Angle(0, 0, -11.27) },
		["Bip01 L Finger02"] = {pos = Vector(0, 0, 0), angle = Angle(0, 78.911, 0) },
		["Bip01 L Finger4"] = {pos = Vector(0, 0, 0), angle = Angle(0, 26.871, 0.094) },
		["Bip01 L Hand"] = {pos = Vector(0, 0, 0), angle = Angle(2.516, 25.506, 71.704) },
		["Bip01 L Finger1"] = {pos = Vector(0, 0, 0), angle = Angle(6.505, 68.04, 10.489) },
		["Bip01 L Finger2"] = {pos = Vector(0, 0, 0), angle = Angle(6.294, 31.311, 8.885) },
		["Bip01 L Finger32"] = {pos = Vector(0, 0, 0), angle = Angle(0, 65.873, 2.444) },
		["Bip01 L Finger31"] = {pos = Vector(0, 0, 0), angle = Angle(0, 17.17, -11.077) },
		["Bip01 L ForeTwist"] = {pos = Vector(0, 0, 0), angle = Angle(0, 0, 69.769) },
		["Bip01 L Finger0"] = {pos = Vector(0, 0, 0), angle = Angle(18.993, 1.559, -5.586) },
		["Bip01 L Forearm"] = {pos = Vector(0, 0, 0), angle = Angle(0, 0, -8.098) },
		["Bip01 L Finger01"] = {pos = Vector(0, 0, 0), angle = Angle(0, 40.203, 3.48) },
		["Bip01 L Finger42"] = {pos = Vector(0, 0, 0), angle = Angle(0, 50.057, -9.978) }
	}

	SWEP.AttachmentModelsVM = {
		["md_aimpoint"] = {model = "models/wystan/attachments/aimpoint.mdl", bone = "M14_Body", pos = Vector(-0.253, -5.233, -4.358), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), adjustment = {min = -5.233, max = -2.5, axis = "y", inverseOffsetCalc = true, preventedBy = {"md_anpeq15"}}},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "M14_Body", pos = Vector(0.284, -9.179, -10.056), angle = Angle(3.332, -90, 0), size = Vector(1, 1, 1), adjustment = {min = -9.179, max = -6, axis = "y", inverseOffsetCalc = true, preventedBy = {"md_anpeq15"}}},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "M14_Body", pos = Vector(0.01, 0.93, 1.373), angle = Angle(0, 180, 0), size = Vector(0.4, 0.4, 0.4), adjustment = {min = 0.93, max = 4, axis = "y", inverseOffsetCalc = true, preventedBy = {"md_anpeq15"}}},
		["md_saker"] = {model = "models/cw2/attachments/556suppressor.mdl", bone = "M14_Body", pos = Vector(0.039, 1.595, -1.653), angle = Angle(0, 0, 0), size = Vector(0.699, 0.699, 0.699)},
		["md_anpeq15"] = {model = "models/cw2/attachments/anpeq15.mdl", bone = "M14_Body", pos = Vector(-0.173, 6.684, 1.22), angle = Angle(0, 90, 0), size = Vector(0.5, 0.5, 0.5)},
		["md_acog"] = {model = "models/wystan/attachments/2cog.mdl", bone = "M14_Body", pos = Vector(-0.352, -3, -4.449), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), adjustment = {min = -3, max = 0, axis = "y", inverseOffsetCalc = true, preventedBy = {"md_anpeq15"}}},
		["md_foregrip"] = {model = "models/wystan/attachments/foregrip1.mdl", bone = "M14_Body", pos = Vector(-0.419, -5.74, -3.297), angle = Angle(0, 0, 0), size = Vector(0.75, 0.75, 0.75)},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "M14_Body", pos = Vector(-0.322, -3.846, -3.984), angle = Angle(0, -90, 0), size = Vector(0.93, 0.93, 0.93), adjustment = {min = -3.846, max = 0, axis = "y", inverseOffsetCalc = true, preventedBy = {"md_anpeq15"}}},
		["md_nightforce_nxs"] = {model = "models/cw2/attachments/l96_scope.mdl", bone = "M14_Body", pos = Vector(-0.071, 2.74, 2.388), angle = Angle(0, -90, 0), size = Vector(1, 1, 1)},
		["md_bipod"] = {model = "models/wystan/attachments/bipod.mdl", bone = "M14_Body", pos = Vector(0.02, 9.22, -1.522), angle = Angle(0, 0, 0), size = Vector(0.699, 0.699, 0.699)}
	}
	
	SWEP.AttachmentPosDependency = {["md_anpeq15"] = {["bg_longris"] = Vector(-0.225, 13, 3.15)},
	["md_saker"] = {["bg_longbarrel"] = Vector(-0.042, 9, -0.1), ["bg_longris"] = Vector(-0.042, 9, -0.1)}}

	SWEP.LuaVMRecoilAxisMod = {vert = 1, hor = 1, roll = 1, forward = 0.5, pitch = 0.5}
	
	SWEP.LaserPosAdjust = Vector(0.5, 0, 0)
	SWEP.LaserAngAdjust = Angle(0, 180, 0) 
end

SWEP.MuzzleVelocity = 853 -- in meter/s

SWEP.RailBGs = {main = 3, on = 1, off = 0}
SWEP.BipodBGs = {main = 4, on = 1, off = 0}
SWEP.SightBGs = {main = 2, sg1 = 1, none = 0}
SWEP.LuaViewmodelRecoil = true

SWEP.Attachments = {[1] = {header = "Sight", offset = {800, -450},  atts = {"md_microt1", "md_eotech", "md_aimpoint", "md_schmidt_shortdot", "md_acog", "md_nightforce_nxs"}},
	[2] = {header = "Barrel", offset = {-450, -300},  atts = {"md_saker"}},
	[3] = {header = "Rail", offset = {800, 0}, atts = {"md_anpeq15"}, dependencies = {md_microt1 = true, md_eotech = true, md_aimpoint = true, md_schmidt_shortdot = true, md_acog = true, md_nightforce_nxs = true}},
	[4] = {header = "Handguard", offset = {-450, 150}, atts = {"md_foregrip", "md_bipod"}},
	["+reload"] = {header = "Ammo", offset = {800, 450}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {fire = {"M14_Fire1", "M14_Fire2"},
	reload = "M14_Reload",
	idle = "idle",
	draw = "M14_Deploy"}
	
SWEP.Sounds = {M14_Reload = {{time = 0.6, sound = "CW_FOLEY_LIGHT"},
	{time = 0.8, sound = "CW_M14_MAGOUT"},
	{time = 1.4, sound = "CW_FOLEY_LIGHT"},
	{time = 2.1, sound = "CW_M14_MAGIN"},
	{time = 2.7, sound = "CW_FOLEY_LIGHT"},
	{time = 3.15, sound = "CW_M14_BOLT"}},
	
	M14_Deploy = {{time = 0, sound = "CW_FOLEY_MEDIUM"},
	{time = 0.7, sound = "CW_M14_BOLT"}}}

SWEP.SpeedDec = 40

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/rifles/m14.mdl"
SWEP.WorldModel		= "models/weapons/w_cstm_m14.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 20
SWEP.Primary.DefaultClip	= 20
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "7.62x51MM"

SWEP.FireDelay = 0.08
SWEP.FireSound = "CW_M14_FIRE"
SWEP.FireSoundSuppressed = "CW_M14_FIRE_SUPPRESSED"
SWEP.Recoil = 1.6

SWEP.HipSpread = 0.055
SWEP.AimSpread = 0.004
SWEP.VelocitySensitivity = 2.1
SWEP.MaxSpreadInc = 0.07
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 0.12
SWEP.Shots = 1
SWEP.Damage = 42
SWEP.DeployTime = 1.7

SWEP.RecoilToSpread = 0.8 -- the M14 in particular will have 30% more recoil from continuous fire to give a feeling of "oh fuck I should stop firing 7.62x51MM in full auto at 750 RPM"

SWEP.ReloadSpeed = 1
SWEP.ReloadTime = 2.5
SWEP.ReloadTime_Empty = 3.3
SWEP.ReloadHalt = 3.05
SWEP.ReloadHalt_Empty = 4.85
SWEP.NearWallDistance = 35

SWEP.SnapToIdlePostReload = true


================================================
FILE: cw2extra/lua/weapons/cw_m1911/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_M1911_FIRE", "weapons/cw_m1911/fire.wav", 1, 112, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_M1911_FIRE_SUPPRESSED", "weapons/cw_m1911/fire_suppressed.wav", 1, 85, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_M1911_MAGIN", "weapons/cw_m1911/magin.wav")
CustomizableWeaponry:addReloadSound("CW_M1911_MAGIN_PARTIAL", "weapons/cw_m1911/magin_partial.wav")
CustomizableWeaponry:addReloadSound("CW_M1911_MAGOUT", "weapons/cw_m1911/magout.wav")
CustomizableWeaponry:addReloadSound("CW_M1911_SLIDEFORWARD", "weapons/cw_m1911/sliderelease.wav")
CustomizableWeaponry:addReloadSound("CW_M1911_TRIGGER", "weapons/cw_m1911/trigger.wav")


================================================
FILE: cw2extra/lua/weapons/cw_m1911/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

CustomizableWeaponry:registerAmmo("9x18MM", "9x18MM Rounds", 9, 18)

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "M1911"

	SWEP.IconLetter = "f"
	killicon.AddFont("cw_deagle", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_pistol"
	SWEP.PosBasedMuz = false

	SWEP.Shell = "smallshell"
	SWEP.ShellScale = 1
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = 2, y = 0, z = 1}
	
	SWEP.IronsightPos = Vector(-2.007, 8, 0.293)
	SWEP.IronsightAng = Vector(0.381, 0, 0)

	SWEP.SprintPos = Vector(2.526, -9.506, -8.24)
	SWEP.SprintAng = Vector(70, 0, 0)
	
	SWEP.RMRPos = Vector(-2.004, -3.22, -0.238)
	SWEP.RMRAng = Vector(0, 0, 0)

	SWEP.MoveType = 1
	SWEP.ViewModelMovementScale = 0.8
	SWEP.FullAimViewmodelRecoil = false
	SWEP.BoltBone = "slide"
	SWEP.BoltShootOffset = Vector(-1.392, 0, 0)
	SWEP.BoltBonePositionRecoverySpeed = 25
	SWEP.OffsetBoltDuringNonEmptyReload = true
	SWEP.BoltReloadOffset = Vector(1.5, 0, 0)
	SWEP.ReloadBoltBonePositionRecoverySpeed = 15
	SWEP.ReloadBoltBonePositionMoveSpeed = 100
	SWEP.StopReloadBoneOffset = 0.7
	SWEP.HoldBoltWhileEmpty = true
	SWEP.DontHoldWhenReloading = true
	SWEP.DisableSprintViewSimulation = true
	SWEP.SightWithRail = true
	SWEP.FOVPerShot = 0.3

	SWEP.AttachmentModelsVM = {
		["md_cobram2"] = {model = "models/cw2/attachments/cobra_m2.mdl", bone = "body", pos = Vector(7.498, -1.479, 0.002), angle = Angle(0, 180, 0), size = Vector(0.75, 0.75, 0.75), color = Color(255, 255, 255, 255)},
		["md_rail"] = {model = "models/cw2/attachments/slimpistolrail.mdl", bone = "body", pos = Vector(3.48, -0.452, 0), angle = Angle(0, 0, -90), size = Vector(0.1, 0.1, 0.1)},
		["md_rmr"] = {model = "models/cw2/attachments/pistolholo.mdl", bone = "body", pos = Vector(-0.464, 1.292, 0.216), angle = Angle(0, 0, -90), size = Vector(0.6, 0.6, 0.6)},
		["md_insight_x2"] = { type = "Model", model = "models/cw2/attachments/pistollaser.mdl", bone = "body", pos = Vector(2.299, -0.561, 0), angle = Angle(0, 180, 90), size = Vector(0.079, 0.079, 0.079), bodygroups = {[1] = 1}}
	}

	SWEP.LaserPosAdjust = Vector(0.5, 0, -1)
	SWEP.LaserAngAdjust = Angle(0, 180, 0) 
	
	SWEP.DrawTraditionalWorldModel = false
	SWEP.WM = "models/weapons/cw_pist_m1911.mdl"
	SWEP.WMPos = Vector(-1, -1, -0.5)
	SWEP.WMAng = Vector(0, 0, 180)
	
	SWEP.LuaVMRecoilAxisMod = {vert = 0.25, hor = 0.5, roll = 2, forward = 0, pitch = 1}
	SWEP.CustomizationMenuScale = 0.009
	SWEP.BoltBonePositionRecoverySpeed = 17 -- how fast does the bolt bone move back into it's initial position after the weapon has fired
	
	SWEP.SlideBGs = {main = 1, pm = 0, pb = 1}
	SWEP.SuppressorBGs = {main = 2, pm = 1, pb = 2, none = 0}
	SWEP.MagBGs = {main = 3, regular = 0, extended = 1}
end

SWEP.ShootWhileProne = true

SWEP.MuzzleVelocity = 251 -- in meter/s

SWEP.LuaViewmodelRecoil = true
SWEP.LuaViewmodelRecoilOverride = true
SWEP.CanRestOnObjects = false

SWEP.Attachments = {[1] = {header = "Barrel", offset = {-350, -200}, atts = {"md_cobram2"}},
	[2] = {header = "Sight", offset = {300, -300}, atts = {"md_rmr"}, exclusions = {md_insight_x2 = true}},
	[3] = {header = "Rail", offset = {-350, 250}, atts = {"md_insight_x2"}, exclusions = {md_rmr = true}},
	["+reload"] = {header = "Ammo", offset = {800, 100}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {reload = "reload",
	fire = {"shoot1", "shoot2"},
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {draw = {{time = 0.3, sound = "CW_FOLEY_LIGHT"},
	{time = 0.75, sound = "CW_M1911_TRIGGER"}},

	reload = {{time = 0.51, sound = "CW_M1911_MAGOUT"},
	{time = 1.18, sound = "CW_M1911_MAGIN"},
	{time = 1.26, sound = "CW_M1911_SLIDEBACK"},
	{time = 1.62, sound = "CW_M1911_SLIDEFORWARD"}}
}

SWEP.SpeedDec = 7

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/pistols/m1911.mdl"
SWEP.WorldModel		= "models/weapons/cw_pist_m1911.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 7
SWEP.Primary.DefaultClip	= 7
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= ".45 ACP"

SWEP.FireDelay = 0.11
SWEP.FireSound = "CW_M1911_FIRE"
SWEP.FireSoundSuppressed = "CW_M1911_FIRE_SUPPRESSED"
SWEP.Recoil = 1

SWEP.HipSpread = 0.04
SWEP.AimSpread = 0.01
SWEP.VelocitySensitivity = 1.25
SWEP.MaxSpreadInc = 0.036
SWEP.SpreadPerShot = 0.0125
SWEP.SpreadCooldown = 0.18
SWEP.Shots = 1
SWEP.Damage = 25
SWEP.DrawSpeed = 1.5
SWEP.DeployTime = 1.1
--SWEP.Chamberable = false
SWEP.NearWallDistance = 15

SWEP.ReloadSpeed = 1
SWEP.ReloadTime = 1.58
SWEP.ReloadHalt = 1.85

SWEP.ReloadTime_Empty = 1.69
SWEP.ReloadHalt_Empty = 2.32

SWEP.SnapToIdlePostReload = true


================================================
FILE: cw2extra/lua/weapons/cw_m249_official/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_M249_OFFICIAL_FIRE", "weapons/cw_m249/fire.wav", 1, 117, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_M249_OFFICIAL_FIRE_SUPPRESSED", "weapons/cw_m249/fire_suppressed3.wav", 1, 95, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_M249_OFFICIAL_BOLTBACK", "weapons/cw_m249/boltback.wav")
CustomizableWeaponry:addReloadSound("CW_M249_OFFICIAL_BOLTRELEASE", "weapons/cw_m249/boltrelease.wav")
CustomizableWeaponry:addReloadSound("CW_M249_OFFICIAL_BULLETIN", "weapons/cw_m249/bulletin.wav")
CustomizableWeaponry:addReloadSound("CW_M249_OFFICIAL_COVERCLOSE", "weapons/cw_m249/coverclose.wav")
CustomizableWeaponry:addReloadSound("CW_M249_OFFICIAL_COVEROPEN", "weapons/cw_m249/coveropen.wav")
CustomizableWeaponry:addReloadSound("CW_M249_OFFICIAL_MAGDRAW", "weapons/cw_m249/magdraw.wav")
CustomizableWeaponry:addReloadSound("CW_M249_OFFICIAL_MAGIN", "weapons/cw_m249/magin.wav")
CustomizableWeaponry:addReloadSound("CW_M249_OFFICIAL_MAGOUT", "weapons/cw_m249/magout.wav")
CustomizableWeaponry:addReloadSound("CW_M249_OFFICIAL_MAGOUT_FULL", "weapons/cw_m249/magoutfull.wav")


================================================
FILE: cw2extra/lua/weapons/cw_m249_official/shared.lua
================================================
-- decided to give it an "_official" suffix because there may be a lot more m249s out there

AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "M249"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1.15
	SWEP.CustomizationMenuScale = 0.014
	
	SWEP.IconLetter = "i"
	killicon.AddFont("cw_m249_official", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))

	SWEP.MuzzleEffect = "muzzleflash_6"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = 0, y = 0, z = 0}
	SWEP.ForeGripOffsetCycle_Draw = 0.8
	SWEP.ForeGripOffsetCycle_Reload = 0.9
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.93
	SWEP.FireMoveMod = 0.6
	
	SWEP.DrawTraditionalWorldModel = false
	SWEP.WM = "models/weapons/cw2_0_mach_para.mdl"
	SWEP.WMPos = Vector(-1.5, 2, 0.5)
	SWEP.WMAng = Vector(0, 0, 180)
	
	SWEP.IronsightPos = Vector(-2.05, -1.964, 0.972)
	SWEP.IronsightAng = Vector(0, 0, 0)
	
	SWEP.EoTechPos = Vector(-2.05, -0.993, -0.093)
	SWEP.EoTechAng = Vector(0, 0, 0)

	SWEP.AimpointPos = Vector(-2.043, -2.5, 0.115)
	SWEP.AimpointAng = Vector(0, 0, 0)
	
	SWEP.MicroT1Pos = Vector(-2.043, -0.993, 0.236)
	SWEP.MicroT1Ang = Vector(0, 0, 0)
	
	SWEP.ACOGPos = Vector(-2.02, -2.869, -0.124)
	SWEP.ACOGAng = Vector(0, 0, 0)
	
	SWEP.ShortDotPos = Vector(-2.02, -2.869, 0.123)
	SWEP.ShortDotAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(1.786, 0, -1)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.BackupSights = {["md_acog"] = {[1] = Vector(-2.02, -2.869, -1.132), [2] = Vector(0, 0, 0)}}

	SWEP.SightWithRail = true
	SWEP.ACOGAxisAlign = {right = 0.03, up = 0, forward = 0}
	SWEP.SchmidtShortDotAxisAlign = {right = 0, up = 0, forward = 0}
	
	SWEP.AlternativePos = Vector(-0.2, 0, -0.4)
	SWEP.AlternativeAng = Vector(0, 0, 0)
	
	SWEP.AttachmentModelsVM = {
		["md_aimpoint"] = {model = "models/wystan/attachments/aimpoint.mdl", bone = "LidCont", pos = Vector(-0.427, -8.511, -4.505), angle = Angle(0, 0, 0), size = Vector(0.899, 0.899, 0.899)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "LidCont", pos = Vector(0.079, -13.825, -10.714), angle = Angle(3.329, -90, 0), size = Vector(1, 1, 1)},
		["md_saker"] = {model = "models/cw2/attachments/556suppressor.mdl", bone = "Weapon", pos = Vector(0.014, 3.732, 1.504), angle = Angle(0, 0, 0), size = Vector(0.6, 0.6, 0.6)},
		["md_acog"] = {model = "models/wystan/attachments/2cog.mdl", bone = "LidCont", pos = Vector(-0.51, -8.903, -4.573), angle = Angle(0, 0, 0), size = Vector(0.899, 0.899, 0.899)},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "LidCont", pos = Vector(-0.181, -4.047, 0.69), angle = Angle(0, 180, 0), size = Vector(0.4, 0.4, 0.4)},
		["md_bipod"] = {model = "models/wystan/attachments/bipod.mdl", bone = "Weapon", pos = Vector(0.138, 6.619, 0.601), angle = Angle(0, 0, 0), size = Vector(0.699, 0.699, 0.699), bodygroup = {[1] = 1}},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "LidCont", pos = Vector(-0.515, -9.205, -4.549), angle = Angle(0, -90, 0), size = Vector(0.899, 0.899, 0.899)},
		["md_foregrip"] = {model = "models/wystan/attachments/foregrip1.mdl", bone = "Weapon", pos = Vector(10.583, 5.614, -0.951), angle = Angle(0, -90, 0), size = Vector(0.699, 0.699, 0.699)}
	}

	SWEP.ForeGripHoldPos = {
		["L Finger1"] = {pos = Vector(0, 0, 0), angle = Angle(13.88, 90.466, 18.638) },
		["l_upperarm"] = {pos = Vector(0, 0, 0), angle = Angle(18.875, 0, 0) },
		["L Finger12"] = {pos = Vector(0, 0, 0), angle = Angle(0, 28.931, 0) },
		["L Clavicle"] = {pos = Vector(0, 4.344, 0), angle = Angle(-49.645, 0, -11.665) },
		["L Hand"] = {pos = Vector(0, 0, 0), angle = Angle(16.122, 18.378, 43.624) },
		["L Finger3"] = {pos = Vector(0, 0, 0), angle = Angle(0.972, 44.411, 13.453) },
		["L Finger01"] = {pos = Vector(0, 0, 0), angle = Angle(0, 26.996, 0) },
		["L Finger0"] = {pos = Vector(0, 0, 0), angle = Angle(11.201, -6.533, -19.001) },
		["L Finger42"] = {pos = Vector(0, 0, 0), angle = Angle(0, 78.379, 0) },
		["L UpperArm"] = {pos = Vector(-12.985, -0.987, -0.308), angle = Angle(0, 31.971, 6.557) },
		["L Finger22"] = {pos = Vector(0, 0, 0), angle = Angle(0, 43.025, 0) },
		["L Finger41"] = {pos = Vector(0, 0, 0), angle = Angle(0, -20.861, 0) },
		["L Finger02"] = {pos = Vector(0, 0, 0), angle = Angle(0, 73.864, 0) },
		["L Finger4"] = {pos = Vector(0, 0, 0), angle = Angle(-8.929, 26.59, 0) },
		["L Finger32"] = {pos = Vector(0, 0, 0), angle = Angle(0, 53.505, 0) },
		["L Finger2"] = {pos = Vector(0, 0, 0), angle = Angle(3, 69.235, 21.884) },
		["L Finger21"] = {pos = Vector(0, 0, 0), angle = Angle(0, -20.979, 0) },
		["L Finger11"] = {pos = Vector(0, 0, 0), angle = Angle(0, -19.306, 0) }
	}

	SWEP.LuaVMRecoilAxisMod = {vert = 1, hor = 1, roll = 1, forward = 1, pitch = 1}
	
	SWEP.LaserPosAdjust = Vector(0.5, 0, 0)
	SWEP.LaserAngAdjust = Angle(0, 180, 0) 
	
	SWEP.OverallMouseSens = 0.7
end

SWEP.MuzzleVelocity = 915

SWEP.LuaViewmodelRecoil = true
SWEP.LuaViewmodelRecoilOverride = true

SWEP.Attachments = {[1] = {header = "Sight", offset = {800, -300},  atts = {"md_microt1", "md_eotech", "md_aimpoint", "md_schmidt_shortdot", "md_acog"}},
	[2] = {header = "Barrel", offset = {-500, -300}, atts = {"md_saker"}},
	[3] = {header = "Handguard", offset = {-500, 150}, atts = {"md_foregrip", "md_bipod"}},
	["+reload"] = {header = "Ammo", offset = {800, 300}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {fire = {"shoot1", "shoot2", "shoot3"},
	reload = "reload",
	reload_empty = "reload2",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {draw = {{time = 0.1, sound = "CW_FOLEY_LIGHT"},
	{time = 0.65, sound = "CW_M249_OFFICIAL_BOLTBACK"},
	{time = 0.82, sound = "CW_M249_OFFICIAL_BOLTRELEASE"}},

	reload = {{time = 0.2, sound = "CW_FOLEY_LIGHT"},
	{time = 0.85, sound = "CW_M249_OFFICIAL_COVEROPEN"},
	{time = 1.8, sound = "CW_M249_OFFICIAL_MAGOUT"},
	{time = 2.1, sound = "CW_FOLEY_LIGHT"},
	{time = 2.62, sound = "CW_M249_OFFICIAL_MAGDRAW"},
	{time = 4, sound = "CW_M249_OFFICIAL_MAGIN"},
	{time = 4.2, sound = "CW_FOLEY_LIGHT"},
	{time = 4.65, sound = "CW_M249_OFFICIAL_BULLETIN"},
	{time = 5.2, sound = "CW_FOLEY_LIGHT"},
	{time = 5.9, sound = "CW_M249_OFFICIAL_COVERCLOSE"},
	{time = 6.7, sound = "CW_FOLEY_LIGHT"}},
	
	reload2 = {{time = 0.2, sound = "CW_FOLEY_LIGHT"},
	{time = 0.8, sound = "CW_M249_OFFICIAL_BOLTBACK"},
	{time = 1, sound = "CW_M249_OFFICIAL_BOLTRELEASE"},
	{time = 2.53, sound = "CW_M249_OFFICIAL_COVEROPEN"},
	{time = 3.58, sound = "CW_M249_OFFICIAL_MAGOUT"},
	{time = 3.9, sound = "CW_FOLEY_LIGHT"},
	{time = 4.3, sound = "CW_M249_OFFICIAL_MAGDRAW"},
	{time = 5.9, sound = "CW_M249_OFFICIAL_MAGIN"},
	{time = 6.2, sound = "CW_FOLEY_LIGHT"},
	{time = 6.52, sound = "CW_M249_OFFICIAL_BULLETIN"},
	{time = 7.6, sound = "CW_M249_OFFICIAL_COVERCLOSE"},
	{time = 8.3, sound = "CW_FOLEY_LIGHT"}}}

SWEP.SpeedDec = 50

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/machineguns/m249.mdl"
SWEP.WorldModel		= "models/weapons/cw2_0_mach_para.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 200
SWEP.Primary.DefaultClip	= 200
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "5.56x45MM"

SWEP.FireDelay = 0.075
SWEP.FireSound = "CW_M249_OFFICIAL_FIRE"
SWEP.FireSoundSuppressed = "CW_M249_OFFICIAL_FIRE_SUPPRESSED"
SWEP.Recoil = 1.1

SWEP.HipSpread = 0.065
SWEP.AimSpread = 0.007
SWEP.VelocitySensitivity = 2.4
SWEP.MaxSpreadInc = 0.04
SWEP.SpreadPerShot = 0.007
SWEP.SpreadCooldown = 0.15
SWEP.Shots = 1
SWEP.Damage = 28
SWEP.DeployTime = 2

SWEP.ReloadSpeed = 1.2
SWEP.ReloadTime = 5
SWEP.ReloadTime_Empty = 6.2
SWEP.ReloadHalt = 7.3
SWEP.ReloadHalt_Empty = 8.9
SWEP.NearWallDistance = 35

SWEP.Chamberable = false

if CLIENT then
	SWEP.RoundBeltBoneNames = {
		"SAW_BULLET_MAIN",
		"SAW_BULLET_00",
		"SAW_BULLET_02",
		"SAW_BULLET_03",
		"SAW_BULLET_04",
		"SAW_BULLET_05",
		"SAW_BULLET_06",
		"SAW_BULLET_07",
		"SAW_BULLET_08",
		"SAW_BULLET_09",
		"SAW_BULLET_10",
		"SAW_BULLET_11",
		"SAW_BULLET_12",
		"SAW_BULLET_13",
		"SAW_BULLET_14",
		"SAW_BULLET_15"
	}
	
	local function removeRoundMeshes(wep) -- we hide all rounds left in the belt on a non-empty reload because if we don't we're left with ghost meshes moving around (bullets with no link to the mag get moved back to it)
		wep:adjustVisibleRounds(0)
	end
	
	local function adjustMeshByMaxAmmo(wep)
		wep:adjustVisibleRounds(wep.Owner:GetAmmoCount(wep.Primary.Ammo) + wep:Clip1())
	end
	
	SWEP.animCallbacks = {
		reload = removeRoundMeshes
	}
	
	SWEP.Sounds.reload[5].callback = adjustMeshByMaxAmmo
	SWEP.Sounds.reload2[7].callback = adjustMeshByMaxAmmo
end

function SWEP:IndividualInitialize()
	if CLIENT then
		self:initBeltBones()
	end
end

function SWEP:initBeltBones()
	local vm = self.CW_VM
	self.roundBeltBones = {}

	for key, boneName in ipairs(self.RoundBeltBoneNames) do
		local bone = vm:LookupBone(boneName)
		self.roundBeltBones[key] = bone
	end
end

function SWEP:postPrimaryAttack()
	if CLIENT then
		self:adjustVisibleRounds()
	end
end

function SWEP:beginReload()
	self.BaseClass.beginReload(self)
	
	if CLIENT then
		self:adjustVisibleRounds(0)
	end
end

local fullSize = Vector(1, 1, 1)
local invisible = Vector(0, 0, 0)

function SWEP:adjustVisibleRounds(curMag)
	if not self.roundBeltBones then
		self:initBeltBones()
	end
	
	local curMag = curMag or self:Clip1()
	local boneCount = #self.roundBeltBones
	local vm = self.CW_VM
	
	for i = 1, boneCount do
		local roundID = boneCount - (i - 1)
		local element = self.roundBeltBones[roundID]
		
		local scale = curMag >= roundID and fullSize or invisible
		vm:ManipulateBoneScale(element, scale)
	end
end


================================================
FILE: cw2extra/lua/weapons/cw_m3super90/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_M3SUPER90_FIRE", "weapons/cw_m3/fire.wav", 1, 118, CHAN_STATIC)

CustomizableWeaponry:addFireSound("CW_M3SUPER90_FIRE_SUPPRESSED", "weapons/cw_m3/fire_suppressed.wav", 1, 100, CHAN_STATIC)

CustomizableWeaponry:addReloadSound("CW_M3SUPER90_PUMP", "weapons/cw_m3/pump.wav")
CustomizableWeaponry:addReloadSound("CW_M3SUPER90_INSERT", "weapons/cw_m3/insert.wav")
CustomizableWeaponry:addReloadSound("CW_M3SUPER90_HANDLE", "weapons/cw_m3/handle.wav")


================================================
FILE: cw2extra/lua/weapons/cw_m3super90/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "M3 Super 90"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1
	
	SWEP.IconLetter = "k"
	killicon.AddFont("cw_ump45", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_m3"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.Shell = "shotshell"
	SWEP.ShellDelay = 0.3
	
	SWEP.DrawTraditionalWorldModel = false
	SWEP.WM = "models/weapons/w_cstm_m3super90.mdl"
	SWEP.WMPos = Vector(-1, 1.5, 0)
	SWEP.WMAng = Vector(0, 0, 180)
	
	SWEP.ShellPosOffset = {x = 4, y = 0, z = -3}
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.9
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.8
	SWEP.FireMoveMod = 1
	
	SWEP.SightWithRail = true
		
	SWEP.IronsightPos = Vector(-2.603, -3, 1.088)
	SWEP.IronsightAng = Vector(0.026, 0.079, 0)
	
	SWEP.MicroT1Pos = Vector(-2.618, 0, 0.25)
	SWEP.MicroT1Ang = Vector(0, 0, 0)
	
	SWEP.EoTechPos = Vector(-2.613, -4.803, -0.06)
	SWEP.EoTechAng = Vector(0, 0, 0)
	
	SWEP.AimpointPos = Vector(-2.613, -4.803, 0.064)
	SWEP.AimpointAng = Vector(0, 0, 0)
	
	SWEP.ShortDotPos = Vector(-2.597, -4.5, 0.289)
	SWEP.ShortDotAng = Vector(0, 0, 0)

	SWEP.ACOGPos = Vector(-2.599, -4.803, -0.109)
	SWEP.ACOGAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(1.786, 0, -1)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
		
	SWEP.CustomizePos = Vector(7.711, -0.482, -2)
	SWEP.CustomizeAng = Vector(16.364, 40.741, 15.277)
		
	SWEP.BackupSights = {["md_acog"] = {[1] = Vector(-2.593, -4.803, -1.12), [2] = Vector(0, 0, 0)}}

	SWEP.ACOGAxisAlign = {right = 0, up = 0, forward = 0}
	SWEP.SchmidtShortDotAxisAlign = {right = 0, up = 0, forward = 0}
	
	SWEP.AlternativePos = Vector(-0.64, 0.294, -0.978)
	SWEP.AlternativeAng = Vector(0, 0, 0)
	
	SWEP.CustomizationMenuScale = 0.016
	SWEP.ReticleInactivityPostFire = 0.6

	SWEP.AttachmentModelsVM = {
		["md_aimpoint"] = {model = "models/wystan/attachments/aimpoint.mdl", bone = "Spas_Body", pos = Vector(-2.589, -4.256, 6.44), angle = Angle(0, 0, 180), size = Vector(1, 1, 1)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "Spas_Body", pos = Vector(-2.053, 0.184, 12.067), angle = Angle(-3.333, 90, 180), size = Vector(1, 1, 1)},
		["md_rail"] = {model = "models/wystan/attachments/rail.mdl", bone = "Spas_Body", pos = Vector(-2.064, -11.19, 2.654), angle = Angle(0, -90, 180), size = Vector(0.6, 1.1, 1)},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "Spas_Body", pos = Vector(-2.32, -9.9, 0.635), angle = Angle(0, -180, -180), size = Vector(0.4, 0.4, 0.4), adjustment = {min = -11, max = -9.9, inverse = true, axis = "y"}},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "Spas_Body", pos = Vector(-2.609, -5.6, 5.35), angle = Angle(0, 90, 180), size = Vector(0.8, 0.8, 0.8)},
		["md_acog"] = {model = "models/wystan/attachments/2cog.mdl", bone = "Spas_Body", pos = Vector(-2.646, -4.941, 5.907), angle = Angle(0, 0, 180), size = Vector(0.899, 0.899, 0.899)}
	}

	SWEP.LuaVMRecoilAxisMod = {vert = 1.5, hor = 2, roll = 1, forward = 1, pitch = 1}
	
	SWEP.LaserPosAdjust = Vector(0.8, 0, 0.3)
	SWEP.LaserAngAdjust = Angle(0, 180, 0) 
end

SWEP.MuzzleVelocity = 381 -- in meter/s

SWEP.SightBGs = {main = 2, none = 1}
SWEP.ADSFireAnim = true

SWEP.Attachments = {[1] = {header = "Sight", offset = {800, -300}, atts = {"md_microt1", "md_eotech", "md_aimpoint", "md_schmidt_shortdot", "md_acog"}},
	["+reload"] = {header = "Ammo", offset = {-200, 300}, atts = {"am_slugrounds", "am_flechetterounds"}}}

SWEP.Animations = {fire = {"shoot1", "shoot2"},
	reload_start = "start_reload",
	insert = "insert",
	reload_end = "after_reload",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {start_reload = {{time = 0.05, sound = "CW_FOLEY_LIGHT"}},
	insert = {{time = 0.1, sound = "CW_M3SUPER90_INSERT"}},
	
	after_reload = {{time = 0.1, sound = "CW_M3SUPER90_PUMP"},
	{time = 0.6, sound = "CW_FOLEY_LIGHT"}},
	
	draw = {{time = 0, sound = "CW_FOLEY_MEDIUM"},
	{time = 0.55, sound = "CW_M3SUPER90_PUMP"}}}

SWEP.SpeedDec = 30

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "shotgun"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"pump"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"
SWEP.FireAnimSpeed = 1.65

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/shotguns/m3.mdl"
SWEP.WorldModel		= "models/weapons/w_cstm_m3super90.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 8
SWEP.Primary.DefaultClip	= 8
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "12 Gauge"

SWEP.FireDelay = 0.7 / 1.65
SWEP.FireSound = "CW_M3SUPER90_FIRE"
SWEP.FireSoundSuppressed = "CW_M3SUPER90_FIRE_SUPPRESSED"
SWEP.Recoil = 3

SWEP.HipSpread = 0.05
SWEP.AimSpread = 0.005
SWEP.VelocitySensitivity = 1.9
SWEP.MaxSpreadInc = 0.06
SWEP.ClumpSpread = 0.013
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 0.8
SWEP.Shots = 12
SWEP.Damage = 9
SWEP.DeployTime = 0.8

SWEP.ReloadStartTime = 0.3
SWEP.InsertShellTime = 0.5
SWEP.ReloadFinishWait = 1
SWEP.PumpMidReloadWait = 0.6
SWEP.ShotgunReload = true
SWEP.NearWallDistance = 30

SWEP.Chamberable = true


================================================
FILE: cw2extra/lua/weapons/cw_mac11/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_MAC11_FIRE", "weapons/cw_mac11/fire.wav", 1, 110, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_MAC11_FIRE_SUPPRESSED", "weapons/cw_mac11/fire_suppressed.wav", 1, 85, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_MAC11_MAGOUT", "weapons/cw_mac11/magout.wav")
CustomizableWeaponry:addReloadSound("CW_MAC11_MAGIN", "weapons/cw_mac11/magin.wav")
CustomizableWeaponry:addReloadSound("CW_MAC11_BOLTBACK", "weapons/cw_mac11/boltback.wav")
CustomizableWeaponry:addReloadSound("CW_MAC11_BOLTFORWARD", "weapons/cw_mac11/boltforward.wav")


================================================
FILE: cw2extra/lua/weapons/cw_mac11/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

CustomizableWeaponry:registerAmmo("9x17MM", "9x17MM", 9, 17)

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "MAC-11"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1
	
	SWEP.IconLetter = "l"
	killicon.AddFont("cw_ump45", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_smg"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.Shell = "smallshell"
	SWEP.ShellPosOffset = {x = 4, y = 0, z = -3}
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.9
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.8
	SWEP.FireMoveMod = 1
	
	SWEP.DrawTraditionalWorldModel = false
	SWEP.WM = "models/weapons/w_cst_mac11.mdl"
	SWEP.WMPos = Vector(-1, -5, -1.5)
	SWEP.WMAng = Vector(0, 0, 180)
	
	SWEP.ShortDotPos = Vector(-2.241, -3.516, -0.267)
	SWEP.ShortDotAng = Vector(0, 0, 0)
	
	SWEP.MicroT1Pos = Vector(-2.383, 0.5, -0.12)
	SWEP.MicroT1Ang = Vector(0, 0, 0)
	
	SWEP.IronsightPos = Vector(-2.383, 0, 1.008)
	SWEP.IronsightAng = Vector(0, 0, 0)
	
	SWEP.EoTechPos = Vector(-2.39, -3.929, -0.53)
	SWEP.EoTechAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(0, 0, 0.273)
	SWEP.SprintAng = Vector(-12.132, 0, 0)

	SWEP.CustomizePos = Vector(7.711, -0.482, -2)
	SWEP.CustomizeAng = Vector(16.364, 40.741, 15.277)

	SWEP.SightWithRail = true
	SWEP.SchmidtShortDotAxisAlign = {right = 0, up = 0, forward = 0}
	SWEP.ACOGAxisAlign = {right = 0, up = 0, forward = 0}
	
	SWEP.AlternativePos = Vector(-0.64, 0.294, -0.978)
	SWEP.AlternativeAng = Vector(0, 0, 0)
	
	SWEP.BoltBone = "bolt"
	SWEP.BoltShootOffset = Vector(0, 0, 1.5)
	SWEP.BoltBonePositionRecoverySpeed = 100
	SWEP.OffsetBoltDuringNonEmptyReload = true
	SWEP.BoltReloadOffset = Vector(0, 0, -1.65)
	SWEP.ReloadBoltBonePositionRecoverySpeed = 8
	SWEP.ReloadBoltBonePositionMoveSpeed = 8
	SWEP.StopReloadBoneOffset = 0.57
	SWEP.HoldBoltWhileEmpty = true
	
	SWEP.CustomizationMenuScale = 0.01
	
	SWEP.AttachmentModelsVM = {
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "weapon", pos = Vector(0.037, -3.405, -0.942), angle = Angle(180, 0, -90), size = Vector(0.349, 0.349, 0.349), color = Color(255, 255, 255, 0)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "weapon", pos = Vector(0.282, 8.026, -10.797), angle = Angle(93.333, -90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 0)},
		["md_tundra9mm"] = {model = "models/cw2/attachments/9mmsuppressor.mdl", bone = "weapon", pos = Vector(0.018, -2.564, 6.34), angle = Angle(0, 0, 90), size = Vector(0.55, 0.55, 0.55)}
	}

	SWEP.LuaVMRecoilAxisMod = {vert = 1.5, hor = 2, roll = 1, forward = 1, pitch = 1}
	
	SWEP.LaserPosAdjust = Vector(0.8, 0, 0.3)
	SWEP.LaserAngAdjust = Angle(0, 180, 0) 
	
	SWEP.AttachmentPosDependency = {["md_tundra9mm"] = {["bg_mac11_extended_barrel"] = Vector(0.018, -2.57, 10.371)}}
end

SWEP.ShootWhileProne = true
SWEP.MuzzleVelocity = 298 -- in meter/s

SWEP.BarrelBGs = {main = 2, extended = 1, regular = 0}
SWEP.StockBGs = {main = 1, unfolded = 1, folded = 0}
SWEP.RailBGs = {main = 3, on = 1, off = 0}
SWEP.LuaViewmodelRecoil = true

SWEP.Attachments = {[1] = {header = "Sight", offset = {800, -300},  atts = {"md_microt1", "md_eotech"}},
	[2] = {header = "Barrel", offset = {-500, -600},  atts = {"md_tundra9mm"}},
	[3] = {header = "Barrel length", offset = {-500, -150},  atts = {"bg_mac11_extended_barrel"}},
	[4] = {header = "Stock", offset = {800, 150},  atts = {"bg_mac11_unfolded_stock"}},
	["+reload"] = {header = "Ammo", offset = {-500, 300}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {fire = {"mac10_fire", "mac10_fire2", "mac10_fire3"},
	reload = "mac10_reload",
	reload_rail = "mac10_reload_rail",
	idle = "mac10_idle",
	draw = "mac10_draw"}
	
SWEP.Sounds = {draw = {{time = 0, sound = "CW_FOLEY_MEDIUM"}},

	mac10_reload = {{time = 0.35, sound = "CW_MAC11_MAGOUT"},
	{time = 0.8, sound = "CW_FOLEY_LIGHT"},
	{time = 1.37, sound = "CW_MAC11_MAGIN"},
	{time = 1.6, sound = "CW_FOLEY_LIGHT"},
	{time = 2, sound = "CW_MAC11_BOLTBACK"},
	{time = 2.3, sound = "CW_FOLEY_LIGHT"}}
}

SWEP.SpeedDec = 10

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "revolver"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"auto"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/smgs/mac11.mdl"
SWEP.WorldModel		= "models/weapons/w_cst_mac11.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 32
SWEP.Primary.DefaultClip	= 32
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "9x17MM"

SWEP.Chamberable = false -- MAC-11 is an open-bolt weapon

SWEP.FireDelay = 0.05
SWEP.FireSound = "CW_MAC11_FIRE"
SWEP.FireSoundSuppressed = "CW_MAC11_FIRE_SUPPRESSED"
SWEP.Recoil = 0.65
SWEP.RecoilToSpread = 1.6 -- should actually be called SpreadToRecoil, but whatever

SWEP.HipSpread = 0.034
SWEP.AimSpread = 0.014
SWEP.VelocitySensitivity = 1.2
SWEP.MaxSpreadInc = 0.05
SWEP.SpreadPerShot = 0.005
SWEP.SpreadCooldown = 0.09
SWEP.Shots = 1
SWEP.Damage = 17
SWEP.DeployTime = 0.45
SWEP.NearWallDistance = 20

SWEP.ReloadSpeed = 1
SWEP.ReloadTime = 1.79
SWEP.ReloadTime_Empty = 2.26
SWEP.ReloadHalt = 2
SWEP.ReloadHalt_Empty = 3

SWEP.SnapToIdlePostReload = true


================================================
FILE: cw2extra/lua/weapons/cw_makarov/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_MAKAROV_FIRE", {"weapons/cw_makarov/fire1.wav", "weapons/cw_makarov/fire2.wav"}, 1, 105, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_MAKAROV_FIRE_SUPPRESSED_PM", "weapons/cw_makarov/fire_suppressed_pm.wav", 1, 83, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_MAKAROV_FIRE_SUPPRESSED_PB", "weapons/cw_makarov/fire_suppressed_pb.wav", 1, 80, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_MAKAROV_MAGIN", "weapons/cw_makarov/magin.wav")
CustomizableWeaponry:addReloadSound("CW_MAKAROV_MAGIN_PARTIAL", "weapons/cw_makarov/magin_partial.wav")
CustomizableWeaponry:addReloadSound("CW_MAKAROV_MAGOUT", "weapons/cw_makarov/magout.wav")
CustomizableWeaponry:addReloadSound("CW_MAKAROV_MAGOUT_EMPTY", "weapons/cw_makarov/magout_empty.wav")
CustomizableWeaponry:addReloadSound("CW_MAKAROV_SLIDE", "weapons/cw_makarov/slide.wav")


================================================
FILE: cw2extra/lua/weapons/cw_makarov/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

CustomizableWeaponry:registerAmmo("9x18MM", "9x18MM Rounds", 9, 18)

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "PM"
	
	SWEP.IconLetter = "f"
	killicon.AddFont("cw_deagle", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_OTS"
	SWEP.PosBasedMuz = false

	SWEP.Shell = "smallshell"
	SWEP.ShellScale = 1
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = 2, y = 0, z = 1}
	SWEP.MuzzleAttachmentName = "muzzle"
	
	SWEP.IronsightPos = Vector(-1.795, 3.361, 0.999)
	SWEP.IronsightAng = Vector(-0.23, 0, 0)
	
	SWEP.PBIronsightsPos = Vector(-1.795, 3.361, 0.527)
	SWEP.PBIronsightsAng = Vector(0.642, 0, 0)
	
	SWEP.SprintPos = Vector(3, -9, -8)
	SWEP.SprintAng = Vector(70, 0, 0)
	
	SWEP.MoveType = 1
	SWEP.ViewModelMovementScale = 0.8
	SWEP.FullAimViewmodelRecoil = false
	SWEP.BoltBone = "__nmBa_0"
	SWEP.BoltShootOffset = Vector(-1, 0, 0)
	SWEP.HoldBoltWhileEmpty = true
	SWEP.DontHoldWhenReloading = true
	SWEP.DisableSprintViewSimulation = true
	SWEP.FOVPerShot = 0.3
	
	SWEP.DrawTraditionalWorldModel = false
	SWEP.WM = "models/cw2/pistols/w_makarov.mdl"
	SWEP.WMPos = Vector(-2.5, -1.5, -1.25)
	SWEP.WMAng = Vector(0, 90, 180)
	
	--SWEP.LuaVMRecoilAxisMod = {vert = 0.25, hor = 0.5, roll = 2, forward = 0, pitch = 1}
	SWEP.FullAimViewmodelRecoil = false
	SWEP.CustomizationMenuScale = 0.01
	SWEP.BoltBonePositionRecoverySpeed = 17 -- how fast does the bolt bone move back into it's initial position after the weapon has fired
	
	SWEP.SlideBGs = {main = 1, pm = 0, pb = 1}
	SWEP.SuppressorBGs = {main = 2, pm = 1, pb = 2, none = 0}
	SWEP.MagBGs = {main = 3, regular = 0, extended = 1}
end

SWEP.ShootWhileProne = true

SWEP.MuzzleVelocity = 315 -- in meter/s

SWEP.LuaViewmodelRecoil = true
SWEP.CanRestOnObjects = false

SWEP.Attachments = {[1] = {header = "Pistol variant", offset = {450, -350}, atts = {"bg_makarov_pb6p9"}},
	[2] = {header = "Barrel", offset = {-400, -200}, atts = {"bg_makarov_pm_suppressor", "bg_makarov_pb_suppressor"}},
	[3] = {header = "Magazine", offset = {-400, 200}, atts = {"bg_makarov_extmag"}},
	["+reload"] = {header = "Ammo", offset = {450, 150}, atts = {"am_sp7"}}}
	
SWEP.AttachmentDependencies = {["bg_makarov_pb_suppressor"] = {"bg_makarov_pb6p9"}}
SWEP.AttachmentExclusions = {["bg_makarov_pm_suppressor"] = {"bg_makarov_pb6p9"}}

SWEP.Animations = {reload = "reloadfull",
	reload_empty = "reloadempty",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {draw = {{time = 0, sound = "CW_FOLEY_LIGHT"}},

	reloadfull = {[1] = {time = 0.73, sound = "CW_MAKAROV_MAGOUT"},
	[2] = {time = 1.62, sound = "CW_MAKAROV_MAGIN_PARTIAL"},
	[3] = {time = 1.82, sound = "CW_MAKAROV_MAGIN"}},
	
	reloadempty = {[1] = {time = 0.73, sound = "CW_MAKAROV_MAGOUT_EMPTY"},
	[2] = {time = 1.62, sound = "CW_MAKAROV_MAGIN_PARTIAL"},
	[3] = {time = 1.82, sound = "CW_MAKAROV_MAGIN"},
	[4] = {time = 2.39, sound = "CW_MAKAROV_SLIDE"}}
}

SWEP.SpeedDec = 5

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/pistols/makarov.mdl"
SWEP.WorldModel		= "models/cw2/pistols/w_makarov.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 8
SWEP.Primary.DefaultClip	= 8
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "9x18MM"

SWEP.FireDelay = 0.11
SWEP.FireSound = "CW_MAKAROV_FIRE"
SWEP.FireSoundSuppressed = "CW_MAKAROV_FIRE_SUPPRESSED_PM"
SWEP.Recoil = 0.7

SWEP.HipSpread = 0.038
SWEP.AimSpread = 0.0125
SWEP.VelocitySensitivity = 1
SWEP.MaxSpreadInc = 0.03
SWEP.SpreadPerShot = 0.005
SWEP.SpreadCooldown = 0.15
SWEP.Shots = 1
SWEP.Damage = 18
SWEP.DeployTime = 0.4
--SWEP.Chamberable = false
SWEP.NearWallDistance = 15
SWEP.DrawSpeed = 1.5

SWEP.ReloadSpeed = 1.3
SWEP.ReloadTime = 2.1
SWEP.ReloadHalt = 2.7

SWEP.ReloadTime_Empty = 2.2
SWEP.ReloadHalt_Empty = 3


================================================
FILE: cw2extra/lua/weapons/cw_mp7_official/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_MP7_OFFICIAL_FIRE", "weapons/cw_mp7_official/fire_unsuppressed.wav", 1, 113, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_MP7_OFFICIAL_FIRE_SUPPRESSED", "weapons/cw_mp7_official/fire_suppressed.wav", 1, 90, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_MP7_OFFICIAL_MAGOUT", "weapons/cw_mp7_official/magout.wav")
CustomizableWeaponry:addReloadSound("CW_MP7_OFFICIAL_MAGIN", "weapons/cw_mp7_official/magin.wav")
CustomizableWeaponry:addReloadSound("CW_MP7_OFFICIAL_BOLTBACK", "weapons/cw_mp7_official/boltback.wav")
CustomizableWeaponry:addReloadSound("CW_MP7_OFFICIAL_BOLTRELEASE", "weapons/cw_mp7_official/boltrelease.wav")
CustomizableWeaponry:addReloadSound("CW_MP7_OFFICIAL_MAGRELEASE", "weapons/cw_mp7_official/magrelease.wav")
CustomizableWeaponry:addReloadSound("CW_MP7_OFFICIAL_FOREGRIP", "weapons/cw_mp7_official/boltforward.wav")


================================================
FILE: cw2extra/lua/weapons/cw_mp7_official/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

CustomizableWeaponry:registerAmmo("4.6x30MM", "4.6x30MM", 4.6, 30)

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "HK MP7A1"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1.15
	
	SWEP.IconLetter = "x"
	killicon.AddFont("cw_mp7_official", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.DrawTraditionalWorldModel = false
	SWEP.WM = "models/cw2/smgs/mp7_world.mdl"
	SWEP.WMPos = Vector(0, -2, -2)
	SWEP.WMAng = Vector(-5, 0, 180)
	 
	SWEP.MuzzleEffect = "muzzleflash_smg"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.Shell = "smallshell"
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = 4, y = -1, z = 3}
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.8
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.87
	
	SWEP.IronsightPos = Vector(-2.168, -1.109, 0.552)
	SWEP.IronsightAng = Vector(0.216, 0, 0)
	
	SWEP.MicroT1Pos = Vector(-2.224, 1.266, 0.246)
	SWEP.MicroT1Ang = Vector(0, -0.232, 0)

	SWEP.EoTechPos = Vector(-2.177, -3.758, -0.16)
	SWEP.EoTechAng = Vector(0, 0, 0)

	SWEP.AimpointPos = Vector(-2.161, -4.607, 0.131)
	SWEP.AimpointAng = Vector(0, 0, 0)
	
	SWEP.ShortDotPos = Vector(-2.155, -4.83, 0.244)
	SWEP.ShortDotAng = Vector(0, 0, 0)
	
	SWEP.ACOGPos = Vector(-2.172, -4.825, -0.005)
	SWEP.ACOGAng = Vector(0, 0, 0)
	
	SWEP.AlternativePos = Vector(0, 1.325, -0.801)
	SWEP.AlternativeAng = Vector(0, 0, 0)
	
	SWEP.BackupSights = {["md_acog"] = {[1] = Vector(-2.165, -4.825, -0.852), [2] = Vector(0, 0, 0)}}
	
	SWEP.AttachmentModelsVM = {
		["md_aimpoint"] = {model = "models/wystan/attachments/aimpoint.mdl", bone = "mp7_main", pos = Vector(-4.927, 2.484, 0.188), angle = Angle(-90, 90, 0), size = Vector(0.8, 0.8, 0.8)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "mp7_main", pos = Vector(-10.389, 9.3, -0.278), angle = Angle(0, 3.332, -90), size = Vector(1, 1, 1)},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "mp7_main", pos = Vector(-0.819, -2.135, -0.005), angle = Angle(90, 0, -90), size = Vector(0.349, 0.349, 0.349)},
		["md_anpeq15"] = {model = "models/cw2/attachments/anpeq15.mdl", bone = "mp7_main", pos = Vector(5.162, -0.343, -0.687), angle = Angle(0, 180, 180), size = Vector(0.5, 0.5, 0.5)},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "mp7_main", pos = Vector(-4.719, 2.282, 0.25), angle = Angle(0, 0, -90), size = Vector(0.75, 0.75, 0.75)},
		["md_acog"] = {model = "models/wystan/attachments/2cog.mdl", bone = "mp7_main", pos = Vector(-4.637, 2.27, 0.273), angle = Angle(-90, 0, -90), size = Vector(0.75, 0.75, 0.75)}
	}

	SWEP.LaserPosAdjust = {x = 0, y = 0, z = 0.25}
	SWEP.LaserAngAdjust = {p = 0, y = 180, r = 0}
	
	SWEP.CustomizationMenuScale = 0.015
end

SWEP.SuppressorBGs = {main = 1, suppressed = 0, unsuppressed = 1}

SWEP.MuzzleVelocity = 750 -- in meter/s

SWEP.LuaViewmodelRecoil = true
SWEP.LuaViewmodelRecoilOverride = true

SWEP.Attachments = {
	[1] = {header = "Sight", offset = {1100, -400}, atts = {"md_microt1", "md_eotech", "md_aimpoint", "md_schmidt_shortdot", "md_acog"}},
	[2] = {header = "Barrel", offset = {-200, -400}, atts = {"bg_mp7_unsuppressed"}},
	[3] = {header = "Rail", offset = {-200, 0}, atts = {"md_anpeq15"}},
	["+reload"] = {header = "Ammo", offset = {1100, 35}, atts = {"am_magnum", "am_matchgrade"}}
}

SWEP.Animations = {
	fire = {"base_fire1", "base_fire2"},
	reload = "base_reload",
	reload_empty = "base_reloadempty",
	idle = "base_idle",
	draw = "base_draw"
}
	
SWEP.Sounds = {
	draw = {
		{time = 0, sound = "CW_FOLEY_MEDIUM"}
	},

	base_reload = {
		{time = 0.79, sound = "CW_MP7_OFFICIAL_MAGRELEASE"},
		{time = 0.82, sound = "CW_MP7_OFFICIAL_MAGOUT"},
		{time = 1.11, sound = "CW_FOLEY_MEDIUM"},
		{time = 1.85, sound = "CW_MP7_OFFICIAL_MAGIN"},
	},
	
	base_reloadempty = {
		{time = 0.63, sound = "CW_MP7_OFFICIAL_MAGRELEASE"},
		{time = 0.67, sound = "CW_MP7_OFFICIAL_MAGOUT"},
		{time = 1.3, sound = "CW_FOLEY_MEDIUM"},
		{time = 2, sound = "CW_MP7_OFFICIAL_MAGIN"},
		{time = 3.03, sound = "CW_MP7_OFFICIAL_BOLTBACK"},
		{time = 3.4, sound = "CW_MP7_OFFICIAL_BOLTRELEASE"},
	}
}

SWEP.SpeedDec = 12

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/smgs/mp7.mdl"
SWEP.WorldModel		= "models/cw2/smgs/mp7_world.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 40
SWEP.Primary.DefaultClip	= 40
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "4.6x30MM"

SWEP.FireDelay = 60 / 950
SWEP.FireSound = "CW_MP7_OFFICIAL_FIRE"
SWEP.FireSoundSuppressed = "CW_MP7_OFFICIAL_FIRE_SUPPRESSED"
SWEP.Recoil = 0.55

SWEP.HipSpread = 0.04
SWEP.AimSpread = 0.0075
SWEP.VelocitySensitivity = 1.5
SWEP.MaxSpreadInc = 0.03
SWEP.SpreadPerShot = 0.005
SWEP.SpreadCooldown = 0.13
SWEP.Shots = 1
SWEP.Damage = 21
SWEP.DeployTime = 0.5
SWEP.NearWallDistance = 25

SWEP.SuppressedOnEquip = true

SWEP.ReloadSpeed = 1.3
SWEP.ReloadTime = 2.2
SWEP.ReloadTime_Empty = 3.5
SWEP.ReloadHalt = 2.9
SWEP.ReloadHalt_Empty = 4.5


================================================
FILE: cw2extra/lua/weapons/cw_mp9_official/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_MP9_FIRE", "weapons/cw_mp9/fire.wav", 1, 110, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_MP9_MAG_OUT", "weapons/cw_mp9/magout.wav")
CustomizableWeaponry:addReloadSound("CW_MP9_MAG_IN", "weapons/cw_mp9/magin.wav")
CustomizableWeaponry:addReloadSound("CW_MP9_DRAW", "weapons/cw_mp9/draw.wav")


================================================
FILE: cw2extra/lua/weapons/cw_mp9_official/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "MP9"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1
	
	SWEP.IconLetter = "d"
	killicon.AddFont("cw_mp9_official", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_smg"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.Shell = "smallshell"
	SWEP.ShellPosOffset = {x = 0, y = 1, z = -3}
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.9
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.8
	SWEP.FireMoveMod = 1

	SWEP.RVBPitchMod = 0.5
	SWEP.RVBYawMod = 0.5
	SWEP.RVBRollMod = 0.5
	
	SWEP.DrawTraditionalWorldModel = false
	SWEP.WM = "models/weapons/w_ecw_mp9.mdl"
	SWEP.WMPos = Vector(-1, -2.5, -2.5)
	SWEP.WMAng = Vector(0, 0, 180)
	
	SWEP.ShortDotPos = Vector(-2.552, -3.089, -0.245)
	SWEP.ShortDotAng = Vector(0, 0, 4.467)

	SWEP.AimpointPos = Vector(-2.56, -2.451, -0.19)
	SWEP.AimpointAng = Vector(0, 0, 3.93)

	SWEP.MicroT1Pos = Vector(-2.565, 0, -0.132)
	SWEP.MicroT1Ang = Vector(0, 0, 4.467)

	SWEP.IronsightPos = Vector(-2.629, -3.027, 0.501)
	SWEP.IronsightAng = Vector(0, 0, 3.93)

	SWEP.EoTechPos = Vector(-2.53, -3.089, -0.561)
	SWEP.EoTechAng = Vector(0, 0, 5)
	
	SWEP.NXSPos = Vector(-2.592, -1.839, -0.24)
	SWEP.NXSAng = Vector(0, 0, 4)
	
	SWEP.SprintPos = Vector(1.728, 1.843, -0.897)
	SWEP.SprintAng = Vector(-7.685, 21.791, 3.982)

	SWEP.CustomizePos = Vector(8.675, -1.16, -2.61)
	SWEP.CustomizeAng = Vector(24.472, 36.847, 16.979)

	SWEP.SightWithRail = true
	SWEP.SchmidtShortDotAxisAlign = {right = 0, up = 0, forward = 0}
	SWEP.NXSAlign = {right = 0, up = 0, forward = 0}
	
	SWEP.AlternativePos = Vector(-0.657, 2.167, -1.175)
	SWEP.AlternativeAng = Vector(0, 0, 3.982)

	SWEP.DontMoveBoltOnHipFire = true
	
	SWEP.CustomizationMenuScale = 0.01
	
	SWEP.AttachmentModelsVM = {
		["md_aimpoint"] = {model = "models/wystan/attachments/aimpoint.mdl", bone = "gun", pos = Vector(-0.104, -5.553, -2.28), angle = Angle(0, 0, 0), size = Vector(0.8, 0.8, 0.8)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "gun", pos = Vector(0.37, -10.58, -9.006), angle = Angle(3.332, -90, 0), size = Vector(1, 1, 1)},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "gun", pos = Vector(0.12, -0.88, 2.403), angle = Angle(0, -180, 0), size = Vector(0.349, 0.349, 0.349)},
		["md_tundra9mm"] = {model = "models/cw2/attachments/556suppressor.mdl", bone = "gun", pos = Vector(0.064, -3.827, -0.19), angle = Angle(0, 0, 0), size = Vector(0.5, 0.5, 0.5)},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "gun", pos = Vector(-0.169, -5.193, -2.244), angle = Angle(0, -90, 0), size = Vector(0.8, 0.8, 0.8)},
		["md_anpeq15"] = {model = "models/cw2/attachments/anpeq15.mdl", bone = "gun", pos = Vector(-0.668, 3.141, 1.705), angle = Angle(0, 90, -90), size = Vector(0.5, 0.5, 0.5)},
		["md_nightforce_nxs"] = {model = "models/cw2/attachments/l96_scope.mdl", bone = "gun", pos = Vector(0.02, 0.206, 3.239), angle = Angle(0, -90, 0), size = Vector(0.899, 0.899, 0.899)}
	}

	--[[SWEP.AttachmentModelsVM = {
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "weapon", pos = Vector(0.037, -3.405, -0.942), angle = Angle(180, 0, -90), size = Vector(0.349, 0.349, 0.349), color = Color(255, 255, 255, 0)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "weapon", pos = Vector(0.282, 8.026, -10.797), angle = Angle(93.333, -90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 0)},
		["md_tundra9mm"] = {model = "models/cw2/attachments/9mmsuppressor.mdl", bone = "weapon", pos = Vector(0.018, -2.564, 6.34), angle = Angle(0, 0, 90), size = Vector(0.55, 0.55, 0.55)}
	}]]

	SWEP.TelescopeSkipRotate = true
	SWEP.LuaVMRecoilAxisMod = {vert = 1.5, hor = 2, roll = 1, forward = 1, pitch = 1}
	
	SWEP.LaserPosAdjust = Vector(0.8, 0, 1)
	SWEP.LaserAngAdjust = Angle(-0.31, 180, 0)
	SWEP.LaserAngAdjustAim = Angle(-0.31, 180, 0)
end

SWEP.ShootWhileProne = true
SWEP.MuzzleVelocity = 400 -- in meter/s

SWEP.BarrelBGs = {main = 2, extended = 1, regular = 0}
SWEP.StockBGs = {main = 1, unfolded = 1, folded = 0}
SWEP.RailBGs = {main = 3, on = 1, off = 0}
SWEP.LuaViewmodelRecoil = true
SWEP.LuaViewmodelRecoilOverride = true

SWEP.Attachments = {[1] = {header = "Sight", offset = {600, -300},  atts = {"md_microt1", "md_eotech", "md_aimpoint", "md_schmidt_shortdot", "md_nightforce_nxs"}},
	[2] = {header = "Barrel", offset = {-600, -300},  atts = {"md_tundra9mm"}},
	[3] = {header = "Rail", offset = {600, 150},  atts = {"md_anpeq15"}},
	["+reload"] = {header = "Ammo", offset = {-600, 200}, atts = {"am_magnum", "am_matchgrade", "am_ultramegamatchammo"}}}

SWEP.Animations = {fire = {"fire1", "fire2"},
	reload = "reload",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {
	draw = {
		{time = 0, sound = "CW_FOLEY_MEDIUM"}
	},

	reload = {
		{time = 0.58, sound = "CW_MP9_MAG_OUT"},
		{time = 0.95, sound = "CW_FOLEY_LIGHT"},
		{time = 1.4, sound = "CW_MP9_MAG_IN"},
		{time = 1.9, sound = "CW_FOLEY_LIGHT"}
	}
}

SWEP.SpeedDec = 12

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "revolver"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/v_ecw_mp9.mdl"
SWEP.WorldModel		= "models/weapons/w_ecw_mp9.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 30
SWEP.Primary.DefaultClip	= 30
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "9x19MM"

SWEP.Chamberable = true

SWEP.FireDelay = 60 / 900
SWEP.FireSound = "CW_MP9_FIRE"
SWEP.FireSoundSuppressed = "CW_MAC11_FIRE_SUPPRESSED"
SWEP.Recoil = 0.6

SWEP.HipSpread = 0.036
SWEP.AimSpread = 0.01
SWEP.VelocitySensitivity = 1.35
SWEP.MaxSpreadInc = 0.033
SWEP.SpreadPerShot = 0.004
SWEP.SpreadCooldown = 0.09
SWEP.Shots = 1
SWEP.Damage = 22
SWEP.DeployTime = 0.6
SWEP.NearWallDistance = 20

SWEP.ReloadSpeed = 1
SWEP.ReloadTime = 2.4
SWEP.ReloadTime_Empty = 2.4
SWEP.ReloadHalt = 2.4
SWEP.ReloadHalt_Empty = 2.4

SWEP.SnapToIdlePostReload = true

function SWEP:getTelescopeAngles()
	local ang = self.Owner:EyeAngles() + self.Owner:GetViewPunchAngles()
	ang.r = self.BlendAng.z - self.AimAng.z
	return ang
end


================================================
FILE: cw2extra/lua/weapons/cw_p99/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_P99_FIRE", "weapons/cw_p99/fire.wav", 1, 113, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_P99_FIRE_SUPPRESSED", "weapons/cw_p99/fire_suppressed.wav", 1, 95, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_P99_MAGIN", "weapons/cw_p99/magin.wav")
CustomizableWeaponry:addReloadSound("CW_P99_MAGOUT", "weapons/cw_p99/magout.wav")
CustomizableWeaponry:addReloadSound("CW_P99_SLIDEBACK", "weapons/cw_p99/slideback.wav")
CustomizableWeaponry:addReloadSound("CW_P99_SLIDEFORWARD", "weapons/cw_p99/slideforward.wav")


================================================
FILE: cw2extra/lua/weapons/cw_p99/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

CustomizableWeaponry:registerAmmo("9x18MM", "9x18MM Rounds", 9, 18)

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "P99"
	
	SWEP.IconLetter = "a"
	killicon.AddFont("cw_p99", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_pistol"
	SWEP.PosBasedMuz = false

	SWEP.Shell = "smallshell"
	SWEP.ShellScale = 1
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = 2, y = 0, z = 1}

	SWEP.IronsightPos = Vector(-2.106, 5.913, 0.602)
	SWEP.IronsightAng = Vector(0.6, 0, 0)

	SWEP.MicroT1Pos = Vector(-2.135, 0, -0.237)
	SWEP.MicroT1Ang = Vector(0, 0, 0)

	SWEP.SprintPos = Vector(2.526, -9.506, -8.24)
	SWEP.SprintAng = Vector(70, 0, 0)

	SWEP.MoveType = 1
	SWEP.ViewModelMovementScale = 0.8
	SWEP.FullAimViewmodelRecoil = false
	SWEP.BoltBone = "bolt"
	SWEP.BoltShootOffset = Vector(0, -1.2, 0)
	SWEP.BoltBonePositionRecoverySpeed = 25
	SWEP.OffsetBoltDuringNonEmptyReload = true
	SWEP.BoltReloadOffset = Vector(0, 1.39, 0)
	SWEP.EmptyBoltHoldAnimExclusion = "fire_last"
	SWEP.ReloadBoltBonePositionRecoverySpeed = 20
	SWEP.ReloadBoltBonePositionMoveSpeed = 100
	SWEP.StopReloadBoneOffset = 0.8
	SWEP.HoldBoltWhileEmpty = true
	SWEP.DontHoldWhenReloading = true
	SWEP.DisableSprintViewSimulation = true
	SWEP.SightWithRail = true
	SWEP.FOVPerShot = 0.3

	SWEP.AttachmentModelsVM = {
		["md_tundra9mm"] = {model = "models/cw2/attachments/9mmsuppressor.mdl", bone = "wpn_body", pos = Vector(-0.203, -9.6, 1.97), angle = Angle(0, 0, 0), size = Vector(0.52, 0.52, 0.52)},
		["md_rail"] = {model = "models/cw2/attachments/pistolrail.mdl", bone = "wpn_body", pos = Vector(-0.173, -4.663, 0.777), angle = Angle(0, -90, 0), size = Vector(0.15, 0.15, 0.15)},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "wpn_body", pos = Vector(-0.179, -5.311, 3.41), angle = Angle(0, 0, 0), size = Vector(0.37, 0.37, 0.37)},
		["md_insight_x2"] = {model = "models/cw2/attachments/pistollaser.mdl", bone = "wpn_body", pos = Vector(-0.188, -5.661, 1.715), angle = Angle(0, -90, 0), size = Vector(0.14, 0.14, 0.14)}
	}
	
	SWEP.LaserPosAdjust = Vector(0.5, 0, -2)
	SWEP.LaserAngAdjust = Angle(0, 180, 0) 
	
	SWEP.LuaVMRecoilAxisMod = {vert = 0.25, hor = 0.5, roll = 2, forward = 0, pitch = 1}
	SWEP.CustomizationMenuScale = 0.01
	SWEP.BoltBonePositionRecoverySpeed = 17 -- how fast does the bolt bone move back into it's initial position after the weapon has fired
	
	SWEP.SlideBGs = {main = 1, pm = 0, pb = 1}
	SWEP.SuppressorBGs = {main = 2, pm = 1, pb = 2, none = 0}
	SWEP.MagBGs = {main = 3, regular = 0, extended = 1}
	
	SWEP.AttachmentPosDependency = {["md_insight_x2"] = {["md_microt1"] = Vector(-0.188, -5.661, 1.4)}}
end

SWEP.ShootWhileProne = true
SWEP.MuzzleVelocity = 408 -- in meter/s

SWEP.LuaViewmodelRecoil = true
SWEP.LuaViewmodelRecoilOverride = true
SWEP.CanRestOnObjects = false

SWEP.Attachments = {[1] = {header = "Barrel", offset = {-400, -250}, atts = {"md_tundra9mm"}},
	[2] = {header = "Sight", offset = {500, -250}, atts = {"md_microt1"}},
	[3] = {header = "Rail", offset = {-400, 200}, atts = {"md_insight_x2"}},
	["+reload"] = {header = "Ammo", offset = {500, 150}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {reload = "reload",
	fire = {"fire1", "fire2", "fire3"},
	fire_dry = "fire_last",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {draw = {{time = 0, sound = "CW_FOLEY_LIGHT"}},

	reload = {{time = 0.61, sound = "CW_P99_MAGOUT"},
	{time = 1.23, sound = "CW_P99_MAGIN"},
	{time = 1.99, sound = "CW_P99_SLIDEBACK"},
	{time = 2.12, sound = "CW_P99_SLIDEFORWARD"}}
}

SWEP.SpeedDec = 5

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/pistols/p99.mdl"
SWEP.WorldModel		= "models/weapons/w_pist_p228.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 15
SWEP.Primary.DefaultClip	= 15
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "9x19MM"

SWEP.FireDelay = 0.11
SWEP.FireSound = "CW_P99_FIRE"
SWEP.FireSoundSuppressed = "CW_P99_FIRE_SUPPRESSED"
SWEP.Recoil = 0.77

SWEP.HipSpread = 0.034
SWEP.AimSpread = 0.011
SWEP.VelocitySensitivity = 1.2
SWEP.MaxSpreadInc = 0.04
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 0.17
SWEP.Shots = 1
SWEP.Damage = 21
SWEP.DeployTime = 0.4
--SWEP.Chamberable = false
SWEP.NearWallDistance = 15
SWEP.DrawSpeed = 1.5

SWEP.ReloadSpeed = 1
SWEP.ReloadTime = 1.59
SWEP.ReloadHalt = 1.8

SWEP.ReloadTime_Empty = 2.78
SWEP.ReloadHalt_Empty = 3

SWEP.SnapToIdlePostReload = true


================================================
FILE: cw2extra/lua/weapons/cw_saiga12k_official/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_SAIGA12K_FIRE", "weapons/cw_saiga12k_official/fire.wav", 1, 115, CHAN_WEAPON)

CustomizableWeaponry:addFireSound("CW_SAIGA12K_FIRE_SUPPRESSED", "weapons/cw_saiga12k_official/fire_suppressed.wav", 1, 100, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_SAIGA12K_BOLT_FORWARD", "weapons/cw_saiga12k_official/bolt_forward.wav")
CustomizableWeaponry:addReloadSound("CW_SAIGA12K_BOLT_PULL", "weapons/cw_saiga12k_official/bolt_pull.wav")
CustomizableWeaponry:addReloadSound("CW_SAIGA12K_CLICK", "weapons/cw_saiga12k_official/click.wav")
CustomizableWeaponry:addReloadSound("CW_SAIGA12K_DEPLOY", "weapons/cw_saiga12k_official/deploy.wav")
CustomizableWeaponry:addReloadSound("CW_SAIGA12K_HANDFLE", "weapons/cw_saiga12k_official/handle.wav")
CustomizableWeaponry:addReloadSound("CW_SAIGA12K_MAGIN", "weapons/cw_saiga12k_official/magin.wav")
CustomizableWeaponry:addReloadSound("CW_SAIGA12K_MAGOUT", "weapons/cw_saiga12k_official/magout.wav")


================================================
FILE: cw2extra/lua/weapons/cw_saiga12k_official/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Saiga-12K"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1
	
	SWEP.IconLetter = "k"
	killicon.AddFont("cw_saiga12k_official", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	
	SWEP.ForeGripOffsetCycle_Draw = 0.5
	SWEP.ForeGripOffsetCycle_Reload = 0.72
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.8

	SWEP.MuzzleEffect = "muzzleflash_m3"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = 5, y = 0, z = -1}
	SWEP.Shell = "shotshell"
	SWEP.ShellDelay = 0
	
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_ReloadStart = 0.9
	SWEP.ForeGripOffsetCycle_ReloadInsert = 2
	SWEP.ForeGripOffsetCycle_ReloadEnd = 0.65
	SWEP.FireMoveMod = 1
	
	SWEP.RVBPitchMod = 0.5
	SWEP.RVBYawMod = 0.5
	SWEP.RVBRollMod = 0.5
	
	SWEP.SightWithRail = true

	SWEP.AlternativePos = Vector(0.519, 1.616, -1.831)
	SWEP.AlternativeAng = Vector(0, 0, 0)

	SWEP.IronsightPos = Vector(-2.03, 0, 0.43)
	SWEP.IronsightAng = Vector(0, 0, 0)

	SWEP.MicroT1Pos = Vector(-2.11, 1.271, -0.773)
	SWEP.MicroT1Ang = Vector(0, 0, 0)
	
	SWEP.EoTechPos = Vector(-2.122, -1.762, -1.19)
	SWEP.EoTechAng = Vector(0, 0, 0)

	SWEP.PSOPos = Vector(-1.797, 3.789, -0.172)
	SWEP.PSOAng = Vector(0, 0, 0)

	SWEP.ShortDotPos = Vector(-2.097, -1.269, -0.71)
	SWEP.ShortDotAng = Vector(0, 0, 0)

	SWEP.KobraPos = Vector(-2.03, -0.5, -0.075)
	SWEP.KobraAng = Vector(0, 0, 0)

	SWEP.AimpointPos = Vector(-2.1, -1.3, -0.853)
	SWEP.AimpointAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(1.786, 0, -1)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
		
	SWEP.CustomizePos = Vector(7.711, -0.482, -2)
	SWEP.CustomizeAng = Vector(16.364, 40.741, 15.277)
	
	SWEP.M203Pos = Vector(0, -2.481, 0.24)
	SWEP.M203Ang = Vector(0, 0, 0)

	SWEP.PSO1AxisAlign = {right = 0, up = 0, forward = 0}
	SWEP.SchmidtShortDotAxisAlign = {right = 0, up = 0, forward = 0}
	
	SWEP.CustomizationMenuScale = 0.015

	SWEP.AttachmentModelsVM = {
		["md_aimpoint"] = {model = "models/wystan/attachments/aimpoint.mdl", bone = "Saiga12k", pos = Vector(-0.383, -5.723, -2.077), angle = Angle(0, 0, 0), size = Vector(0.8, 0.8, 0.8)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "Saiga12k", pos = Vector(0.068, -10.988, -8.846), angle = Angle(3.332, -90, 0), size = Vector(1, 1, 1)},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "Saiga12k", pos = Vector(-0.181, -0.817, 2.581), angle = Angle(0, 180, 0), size = Vector(0.349, 0.349, 0.349)},
		["md_pso1"] = {model = "models/cw2/attachments/pso.mdl", bone = "Saiga12k", pos = Vector(0.002, -5.196, -1.596), angle = Angle(0, 180, 0), size = Vector(0.8, 0.8, 0.8)},
		["md_pbs1"] = {model = "models/cw2/attachments/pbs1.mdl", bone = "Saiga12k", pos = Vector(-0.113, 17.656, -0.9), angle = Angle(0, 180, 0), size = Vector(0.8, 0.8, 0.8)},
		["md_foregrip"] = {model = "models/wystan/attachments/foregrip1.mdl", bone = "Saiga12k", pos = Vector(-0.51, -1.966, -2.915), angle = Angle(0, 0, 0), size = Vector(0.699, 0.699, 0.699)},
		["md_rail"] = {model = "models/wystan/attachments/akrailmount.mdl", bone = "Saiga12k", pos = Vector(-0.408, -0.044, 0.774), angle = Angle(0, 0, 0), size = Vector(0.899, 0.899, 0.899)},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "Saiga12k", pos = Vector(-0.429, -4.9, -1.56), angle = Angle(0, -90, 0), size = Vector(0.699, 0.699, 0.699)},
		["md_kobra"] = {model = "models/cw2/attachments/kobra.mdl", bone = "Saiga12k", pos = Vector(0.349, -0.245, -2.007), angle = Angle(0, 180, 0), size = Vector(0.6, 0.6, 0.6)},
		["md_anpeq15"] = {model = "models/cw2/attachments/anpeq15.mdl", bone = "Saiga12k", pos = Vector(-0.306, 3.2, 2.345), angle = Angle(0, 90, 0), size = Vector(0.43, 0.43, 0.43)}
	}

	SWEP.AttachmentPosDependency = {
		["md_anpeq15"] = {
			["md_microt1"] = Vector(-0.306, 1.5, 2.345), 
			["md_aimpoint"] = Vector(-0.306, 2, 2.345),
			["md_schmidt_shortdot"] = Vector(-0.306, 2.9, 2.345)
		}
	}
	
	SWEP.ForeGripHoldPos = {
		["Bip01 L Finger3"] = {pos = Vector(0, 0, 0), angle = Angle(5.269, 33.659, -4.966) },
		["Bip01 L Finger41"] = {pos = Vector(0, 0, 0), angle = Angle(0, -15.848, 0) },
		["Bip01 L Finger2"] = {pos = Vector(0, 0, 0), angle = Angle(5.94, 47.548, -5.388) },
		["Bip01 L Clavicle"] = {pos = Vector(-1.517, 1.899, 0.18), angle = Angle(-13.855, 9.753, 0) },
		["Bip01 L Finger22"] = {pos = Vector(0, 0, 0), angle = Angle(0, 76.587, 0) },
		["Bip01 L Finger31"] = {pos = Vector(0, 0, 0), angle = Angle(0, -30.771, 0) },
		["Bip01 L Finger02"] = {pos = Vector(0, 0, 0), angle = Angle(0, 100.872, -5.815) },
		["Bip01 L Finger11"] = {pos = Vector(0, 0, 0), angle = Angle(0, -0.788, 0) },
		["Bip01 L Finger4"] = {pos = Vector(0, 0, 0), angle = Angle(1.077, 13.255, 0) },
		["Bip01 L Finger1"] = {pos = Vector(0, 0, 0), angle = Angle(13.503, 74.014, -4.903) },
		["Bip01 L Finger42"] = {pos = Vector(0, 0, 0), angle = Angle(0, 27.677, 0) },
		["Bip01 L Finger32"] = {pos = Vector(0, 0, 0), angle = Angle(0, 75.791, 0) },
		["Bip01 L Finger0"] = {pos = Vector(0, 0, 0), angle = Angle(7.262, -14.686, -40.667) },
		["Bip01 L Finger21"] = {pos = Vector(0, 0, 0), angle = Angle(0, -26.604, 0) },
		["Bip01 L Hand"] = {pos = Vector(0, 0, 0), angle = Angle(9.564, 38.254, 94.494) },
		["Bip01 L Finger01"] = {pos = Vector(0, 0, 0), angle = Angle(0, 25.427, 0) },
		["Bip01 L ForeTwist"] = {pos = Vector(0, 0, 0), angle = Angle(0, 0, 74.992) }
	}

	SWEP.LuaVMRecoilAxisMod = {vert = 1.5, hor = 2, roll = 1, forward = 1, pitch = 1}
	
	SWEP.LaserPosAdjust = Vector(0.8, 0, 0)
	SWEP.LaserAngAdjust = Angle(0, 180, 0) 
end

SWEP.MuzzleVelocity = 381 -- in meter/s

SWEP.ADSFireAnim = false
SWEP.LuaViewmodelRecoil = true
SWEP.LuaViewmodelRecoilOverride = true

SWEP.Attachments = {[1] = {header = "Sight", offset = {800, -500}, atts = {"md_kobra", "md_microt1", "md_eotech", "md_aimpoint", "md_schmidt_shortdot", "md_pso1"}},
	[2] = {header = "Barrel", offset = {-200, -400}, atts = {"md_pbs1"}},
	[3] = {header = "Rail", offset = {-200, 50}, atts = {"md_anpeq15"}, exclusions = {md_kobra = true, md_pso1 = true}, dependencies = {md_microt1 = true, md_eotech = true, md_aimpoint = true, md_schmidt_shortdot = true}},
	[4] = {header = "Fore-end", offset = {800, -50}, atts = {"md_foregrip"}},
	["+reload"] = {header = "Ammo", offset = {800, 350}, atts = {"am_slugrounds", "am_flechetterounds"}}}

SWEP.Animations = {fire = {"shoot1", "shoot2"},
	reload = "reload2",
	reload_empty = "reload1",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {
	reload1 = {
		{time = 0.5, sound = "CW_SAIGA12K_MAGOUT"},
		{time = 0.58, sound = "CW_FOLEY_LIGHT"},
		{time = 1.94, sound = "CW_SAIGA12K_MAGIN"},
		{time = 2.77, sound = "CW_SAIGA12K_BOLT_PULL"},
		{time = 3.02, sound = "CW_SAIGA12K_BOLT_FORWARD"},
		{time = 3.3, sound = "CW_FOLEY_LIGHT"},
	},
	
	reload2 = {
		{time = 0.5, sound = "CW_SAIGA12K_MAGOUT"},
		{time = 0.58, sound = "CW_FOLEY_LIGHT"},
		{time = 1.94, sound = "CW_SAIGA12K_MAGIN"},
		{time = 2.3, sound = "CW_FOLEY_LIGHT"},
	},

	insert = {
		{time = 0.17, sound = "CW_M4SUPER90_INSERT"},
		{time = 0.38, sound = "CW_FOLEY_LIGHT"}
	},
	
	after_reload = {{time = 0.35, sound = "CW_M4SUPER90_BOLT"},
	{time = 0.6, sound = "CW_FOLEY_LIGHT"}},
	
	draw = {
		{time = 0, sound = "CW_FOLEY_MEDIUM"},
		{time = 0.63, sound = "CW_SAIGA12K_CLICK"}
	}
}

SWEP.SpeedDec = 20

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "shotgun"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"pump"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/v_ecw_saiga12k.mdl"
SWEP.WorldModel		= "models/weapons/w_shot_xm1014.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 5
SWEP.Primary.DefaultClip	= 5
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "12 Gauge"

SWEP.Chamberable = true

SWEP.FireDelay = 0.17
SWEP.FireSound = "CW_SAIGA12K_FIRE"
SWEP.FireSoundSuppressed = "CW_SAIGA12K_FIRE_SUPPRESSED"
SWEP.Recoil = 2.5

SWEP.HipSpread = 0.048
SWEP.AimSpread = 0.008
SWEP.VelocitySensitivity = 1.75
SWEP.MaxSpreadInc = 0.06
SWEP.ClumpSpread = 0.0185
SWEP.SpreadPerShot = 0.015
SWEP.SpreadCooldown = 0.3
SWEP.Shots = 12
SWEP.Damage = 8
SWEP.DeployTime = 0.8
SWEP.RecoilToSpread = 1.6 -- should actually be called SpreadToRecoil, but whatever
SWEP.NearWallDistance = 30

SWEP.ReloadSpeed = 1.15
SWEP.ReloadTime = 2.5
SWEP.ReloadTime_Empty = 3.5
SWEP.ReloadHalt = 3
SWEP.ReloadHalt_Empty = 4


================================================
FILE: cw2extra/lua/weapons/cw_scarh/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_SCARH_FIRE", "weapons/cw_scarh/fire.wav", 1, 118, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_SCARH_MAGOUT", "weapons/cw_scarh/magout.wav")
CustomizableWeaponry:addReloadSound("CW_SCARH_MAGIN", "weapons/cw_scarh/magin.wav")
CustomizableWeaponry:addReloadSound("CW_SCARH_MAGSLAP", "weapons/cw_scarh/magslap.wav")
CustomizableWeaponry:addReloadSound("CW_SCARH_BOLT", "weapons/cw_scarh/bolt.wav")
CustomizableWeaponry:addReloadSound("CW_SCARH_FOLEY", "weapons/cw_scarh/foley.wav")


================================================
FILE: cw2extra/lua/weapons/cw_scarh/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "FN SCAR-H"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1.15
	SWEP.CustomizationMenuScale = 0.014
	
	SWEP.IconLetter = "i"
	killicon.AddFont("cw_g3a3", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_g3"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = 4, y = 0, z = -3}
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.9
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.8
	SWEP.FireMoveMod = 0.6
	
	SWEP.DrawTraditionalWorldModel = false
	SWEP.WM = "models/cw2/rifles/w_scarh.mdl"
	SWEP.WMPos = Vector(0, -0.5, 0.5)
	SWEP.WMAng = Vector(0, 0, 180)
	
	SWEP.IronsightPos = Vector(-2.023, -4.479, 0.104)
	SWEP.IronsightAng = Vector(0.128, 0, 0)
	
	SWEP.EoTechPos = Vector(-2.033, -4.864, 0.157)
	SWEP.EoTechAng = Vector(0, 0, 0)
	
	SWEP.AimpointPos = Vector(-2.033, -4.864, 0.375)
	SWEP.AimpointAng = Vector(0, 0, 0)
	
	SWEP.MicroT1Pos = Vector(-2.025, 0, 0.46)
	SWEP.MicroT1Ang = Vector(0, 0, 0)
	
	SWEP.ACOGPos = Vector(-2.021, -4.864, -0.013)
	SWEP.ACOGAng = Vector(0, 0, 0)
	
	SWEP.NXSPos = Vector(-2.041, -4.5, 0.287)
	SWEP.NXSAng = Vector(0, 0, 0)

	SWEP.SprintPos = Vector(1.786, 0, -1)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.ShortDotPos = Vector(-2.017, -5.564, 0.495)
	SWEP.ShortDotAng = Vector(0, 0, 0)
	
	SWEP.BackupSights = {["md_acog"] = {[1] = Vector(-2.021, -4.864, -1.122), [2] = Vector(0, 0, 0)}}

	SWEP.SightWithRail = true
	SWEP.ACOGAxisAlign = {right = 0, up = 0, forward = 0}
	SWEP.SchmidtShortDotAxisAlign = {right = 0, up = 0, forward = 0}
	SWEP.NXSAlign = {right = 0, up = 0, forward = 0}
	
	SWEP.AlternativePos = Vector(0.2, 0, -1)
	SWEP.AlternativeAng = Vector(0, 0, 0)
	
	SWEP.M203OffsetCycle_Reload = 0.81
	SWEP.M203OffsetCycle_Reload_Empty = 0.73
	SWEP.M203OffsetCycle_Draw = 0
	
	SWEP.M203CameraRotation = {p = -90, y = 0, r = -90}

	SWEP.BaseArm = "Left_U_Arm"
	SWEP.BaseArmBoneOffset = Vector(-500, 0, 0)
	
	SWEP.M203Pos = Vector(-0.562, -2.481, 0.24)
	SWEP.M203Ang = Vector(0, 0, 0)
	
	SWEP.M203HoldPos = {
		["Left_U_Arm"] = {pos = Vector(2.197, -2.123, -1.015), angle = Angle(0, 0, 0)}
	}
	
	SWEP.AttachmentModelsVM = {
		["md_aimpoint"] = {model = "models/wystan/attachments/aimpoint.mdl", bone = "scar", pos = Vector(-0.233, -6.4, -2.172), angle = Angle(0, 0, 0), adjustment = {min = -6.4, max = -4, axis = "y", inverseOffsetCalc = true}, size = Vector(0.899, 0.899, 0.899)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "scar", pos = Vector(0.273, -11.3, -8.363), angle = Angle(3.332, -90, 0), adjustment = {min = -11.3, max = -9, axis = "y", inverseOffsetCalc = true}, size = Vector(1, 1, 1)},
		["md_anpeq15"] = {model = "models/cw2/attachments/anpeq15.mdl", bone = "scar", pos = Vector(-0.172, 7.369, 2.819), angle = Angle(0, 90, 0), size = Vector(0.6, 0.6, 0.6)},
		["md_foregrip"] = {model = "models/wystan/attachments/foregrip1.mdl", bone = "scar", pos = Vector(-0.392, -3.997, -1.839), angle = Angle(0, 0, 0), size = Vector(0.75, 0.75, 0.75)},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "scar", pos = Vector(0.016, -1.2, 3.079), angle = Angle(0, 180, 0), adjustment = {min = -1.2, max = 4, axis = "y", inverseOffsetCalc = true}, size = Vector(0.4, 0.4, 0.4)},
		["md_saker"] = {model = "models/cw2/attachments/556suppressor.mdl", bone = "scar", pos = Vector(0, 2.413, -0.743), angle = Angle(0, 0, 0), size = Vector(0.699, 0.699, 0.699)},
		["md_m203"] = {model = "models/cw2/attachments/m203.mdl", bone = "scar", pos = Vector(2.316, -9.063, 3.388), angle = Angle(1.07, -90, 0), size = Vector(1, 1, 1), animated = true},
		["md_acog"] = {model = "models/wystan/attachments/2cog.mdl", bone = "scar", pos = Vector(-0.364, -4.625, -2.806), angle = Angle(0, 0, 0), adjustment = {min = -4.625, max = -2.3, axis = "y", inverseOffsetCalc = true}, size = Vector(1, 1, 1)},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "scar", pos = Vector(-0.281, -4.494, -1.621), angle = Angle(0, -90, 0), size = Vector(0.8, 0.8, 0.8)},
		["md_bipod"] = {model = "models/wystan/attachments/bipod.mdl", bone = "scar", pos = Vector(0, 9.411, -0.064), angle = Angle(0, 0, 0), size = Vector(0.699, 0.699, 0.699) },
		["md_nightforce_nxs"] = {model = "models/cw2/attachments/l96_scope.mdl", bone = "scar", pos = Vector(-0.102, 2.661, 4.099), angle = Angle(0, -90, 0), size = Vector(1.1, 1.1, 1.1)}
	}

	SWEP.ForeGripHoldPos = {
		["Left12"] = {pos = Vector(0, 0, 0), angle = Angle(11.357, -2.181, 0) },
		["Left1"] = {pos = Vector(0, 0.74, 0), angle = Angle(0, -9.094, 0) },
		["Left3"] = {pos = Vector(0, 0, 0), angle = Angle(0, 70.535, 0) },
		["Left8"] = {pos = Vector(0, 0, 0), angle = Angle(25.916, -11.879, 0) },
		["Left5"] = {pos = Vector(0, 0, 0), angle = Angle(46.38, -15.816, -10.117) },
		["Left11"] = {pos = Vector(0, 0, 0), angle = Angle(24.169, -5.834, 0) },
		["Left9"] = {pos = Vector(0, 0, 0), angle = Angle(20.329, 0, 0) },
		["Left_L_Arm"] = {pos = Vector(0, 0, 0), angle = Angle(0, 0, 88.917) },
		["Left14"] = {pos = Vector(0, 0, 0), angle = Angle(19.552, -13.228, 0) },
		["Left2"] = {pos = Vector(0, 0.74, 0), angle = Angle(0.127, 45.395, 0) },
		["Left_Hand"] = {pos = Vector(0, 0, 0), angle = Angle(-19.973, 0, 25.535) },
		["Left_U_Arm"] = {pos = Vector(1.812, 0.024, -1.239), angle = Angle(0, 0, 0) }
	}
	
	SWEP.AttachmentPosDependency = {
		["md_anpeq15"] = {["md_nightforce_nxs"] = Vector(-0.801, 10.246, 1.228)}
	}
	
	SWEP.AttachmentAngDependency = {
		md_anpeq15 = {nd_nightforce_nxs = Angle(0, 90, -90)}
	}

	SWEP.LuaVMRecoilAxisMod = {vert = 0.5, hor = 1, roll = 1, forward = 0.5, pitch = 0.5}
	
	SWEP.BoltBone = "charger"
	SWEP.BoltShootOffset = Vector(-2, 0, 0)
	
	SWEP.LaserPosAdjust = Vector(0.5, 0, 0)
	SWEP.LaserAngAdjust = Angle(0, 180, 0) 
end

SWEP.MuzzleVelocity = 714 -- in meter/s

SWEP.SightBGs = {main = 2, none = 1}
SWEP.LuaViewmodelRecoil = true

SWEP.Attachments = {[1] = {header = "Sight", offset = {900, -300},  atts = {"md_microt1", "md_eotech", "md_aimpoint", "md_schmidt_shortdot", "md_acog", "md_nightforce_nxs"}},
	[2] = {header = "Barrel", offset = {-400, -500},  atts = {"md_saker"}},
	[3] = {header = "Rail", offset = {-400, -50},  atts = {"md_anpeq15"}},
	[4] = {header = "Handguard", offset = {-400, 400}, atts = {"md_foregrip", "md_bipod", "md_m203"}},
	["+reload"] = {header = "Ammo", offset = {900, 150}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {fire = {"shoot1", "shoot2", "shoot3"},
	reload = "reload",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {draw = {{time = 0, sound = "CW_FOLEY_MEDIUM"}},

	reload = {{time = 0.4, sound = "CW_SCARH_MAGOUT"},
	{time = 0.6, sound = "CW_FOLEY_LIGHT"},
	{time = 1.1, sound = "CW_SCARH_MAGIN"},
	{time = 1.4, sound = "CW_FOLEY_LIGHT"},
	{time = 1.5, sound = "CW_SCARH_MAGSLAP"},
	{time = 1.85, sound = "CW_SCARH_BOLT"},
	{time = 2, sound = "CW_FOLEY_MEDIUM"}}}

SWEP.SpeedDec = 40

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/rifles/scarh.mdl"
SWEP.WorldModel		= "models/cw2/rifles/w_scarh.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 20
SWEP.Primary.DefaultClip	= 20
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "7.62x51MM"

SWEP.FireDelay = 0.096
SWEP.FireSound = "CW_SCARH_FIRE"
SWEP.FireSoundSuppressed = "CW_G3A3_FIRE_SUPPRESSED"
SWEP.Recoil = 1.4

SWEP.HipSpread = 0.048
SWEP.AimSpread = 0.0035
SWEP.VelocitySensitivity = 2
SWEP.MaxSpreadInc = 0.065
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 0.15
SWEP.Shots = 1
SWEP.Damage = 40
SWEP.DeployTime = 1

SWEP.ReloadSpeed = 0.9
SWEP.ReloadTime = 1.7
SWEP.ReloadTime_Empty = 2
SWEP.ReloadHalt = 1.8
SWEP.ReloadHalt_Empty = 2.3

SWEP.SnapToIdlePostReload = true


================================================
FILE: cw2extra/lua/weapons/cw_shorty/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_SERBU_SHORTY_FIRE", "weapons/cw_serbu_shorty/fire.wav", 1, 115, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_SERBU_SHORTY_PUMPBACK", "weapons/cw_serbu_shorty/pump_back.wav")
CustomizableWeaponry:addReloadSound("CW_SERBU_SHORTY_PUMPFORWARD", "weapons/cw_serbu_shorty/pump_forward.wav")

CustomizableWeaponry:addReloadSound("CW_SERBU_SHORTY_INSERT", {"weapons/cw_serbu_shorty/insert1.wav", "weapons/cw_serbu_shorty/insert2.wav", "weapons/cw_serbu_shorty/insert3.wav"})


================================================
FILE: cw2extra/lua/weapons/cw_shorty/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Serbu Shorty"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1
	
	SWEP.IconLetter = "k"
	killicon.AddFont("cw_shorty", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_m3"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.Shell = "shotshell"
	SWEP.ShellDelay = 0.45
	
	SWEP.DrawTraditionalWorldModel = false
	SWEP.WM = "models/weapons/cw2_super_shorty.mdl"
	SWEP.WMPos = Vector(-1, 1.5, 0)
	SWEP.WMAng = Vector(0, 0, 180)
	
	SWEP.PronePos = Vector(-7.397, -2.497, -1.551)
	SWEP.ProneAng = Vector(5.618, -49.056, -15.311)
	
	SWEP.ShellPosOffset = {x = 2, y = 0, z = 2}
	SWEP.FireMoveMod = 1
	
	SWEP.SightWithRail = true

	SWEP.IronsightPos = Vector(4.276, 0, 2.306)
	SWEP.IronsightAng = Vector(1.093, 0, 0)
	
	SWEP.MicroT1Pos = Vector(4.277, 0, 1.603)
	SWEP.MicroT1Ang = Vector(0, 0, 0)
	
	SWEP.AlternativePos = Vector(2.039, 0, 0.479)
	SWEP.AlternativeAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(-2.386, 0.054, 2.203)
	SWEP.SprintAng = Vector(-17.784, -38.445, -0.484)
			
	SWEP.SwimPos = Vector(0, 0, 0)
	SWEP.SwimAng = Vector(-28.47, -36.313, 0)
			
	SWEP.CustomizePos = Vector(-5.304, -5.044, 0)
	SWEP.CustomizeAng = Vector(20.695, -48.665, -17.692)
	
	SWEP.CustomizationMenuScale = 0.01
	SWEP.ReticleInactivityPostFire = 0.9

	SWEP.AttachmentModelsVM = {
		["md_rail"] = {model = "models/wystan/attachments/rail.mdl", bone = "yttohs", pos = Vector(-0.207, -0.215, 0.029), angle = Angle(0, 90, 180), size = Vector(0.5, 0.85, 0.75)},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "yttohs", pos = Vector(-0.02, -1.188, -1.494), angle = Angle(0, 0, 179.587), size = Vector(0.3, 0.3, 0.3)}
	}

	SWEP.LuaVMRecoilAxisMod = {vert = 1.5, hor = 2, roll = 1, forward = 1, pitch = 1}
	
	SWEP.LaserPosAdjust = Vector(0.8, 0, 0.3)
	SWEP.LaserAngAdjust = Angle(0, 180, 0) 
end

SWEP.MuzzleVelocity = 381 -- in meter/s

SWEP.SightBGs = {main = 2, none = 1}
SWEP.ADSFireAnim = true

SWEP.Attachments = {[1] = {header = "Sight", offset = {800, -300}, atts = {"md_microt1"}},
	["+reload"] = {header = "Ammo", offset = {-200, 300}, atts = {"am_slugrounds", "am_flechetterounds"}}}

SWEP.Animations = {fire = {"shoot1", "shoot2"},
	fire_aim = "shoot1",
	reload_start = "start_reload",
	insert = "insert",
	reload_end = "end_reload",
	idle = "idle",
	draw = "draw2"}
	
SWEP.Sounds = {start_reload = {{time = 0.05, sound = "CW_FOLEY_LIGHT"}},
	insert = {{time = 0.1, sound = "CW_SERBU_SHORTY_INSERT"}},
	
	end_reload = {{time = 0.62, sound = "CW_SERBU_SHORTY_PUMPBACK"},
	{time = 0.82, sound = "CW_SERBU_SHORTY_PUMPFORWARD"},
	{time = 1, sound = "CW_FOLEY_LIGHT"}},
	
	draw2 = {{time = 0.36, sound = "CW_SERBU_SHORTY_PUMPBACK"},
	{time = 0.59, sound = "CW_SERBU_SHORTY_PUMPFORWARD"}},
	
	shoot1 = {{time = 0.55, sound = "CW_SERBU_SHORTY_PUMPBACK"},
	{time = 0.92, sound = "CW_SERBU_SHORTY_PUMPFORWARD"}},
	
	shoot2 = {{time = 0.55, sound = "CW_SERBU_SHORTY_PUMPBACK"},
	{time = 0.92, sound = "CW_SERBU_SHORTY_PUMPFORWARD"}}
}

SWEP.SpeedDec = 10

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "shotgun"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"pump"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= true
SWEP.ViewModel		= "models/cw2/shotguns/serbu_super_shorty.mdl"
SWEP.WorldModel		= "models/weapons/cw2_super_shorty.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 2
SWEP.Primary.DefaultClip	= 2
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "12 Gauge"

SWEP.FireDelay = 0.55 / 1.3
SWEP.FireSound = "CW_SERBU_SHORTY_FIRE"
SWEP.Recoil = 2
SWEP.FireAnimSpeed = 1.65 * 1.3

SWEP.HipSpread = 0.04
SWEP.AimSpread = 0.01
SWEP.VelocitySensitivity = 1.4
SWEP.MaxSpreadInc = 0.02
SWEP.ClumpSpread = 0.02
SWEP.SpreadPerShot = 0.007
SWEP.SpreadCooldown = 0.85
SWEP.Shots = 12
SWEP.Damage = 8
SWEP.DeployTime = 1
SWEP.ReloadSpeed = 1.1
SWEP.NearWallDistance = 24

SWEP.ReloadStartTime = 0.3
SWEP.InsertShellTime = 0.5
SWEP.ReloadFinishWait = 1
SWEP.PumpMidReloadWait = 1.1
SWEP.ShotgunReload = true
SWEP.DeployTimeNotFirst = 0.3

SWEP.Chamberable = true

function SWEP:drawAnimFunc()
	if not self.firstTimeDrawFinished then
		self:sendWeaponAnim("draw", self.DrawSpeed)
	else
		self:sendWeaponAnim("idle", self.DrawSpeed)
	end
	
	self.firstTimeDrawFinished = true
end

function SWEP:GetDeployTime()
	return self.firstTimeDrawFinished and self.DeployTimeNotFirst or self.DeployTime
end

function SWEP:fireAnimFunc()
	if self.dt.State == CW_AIMING then
		self:sendWeaponAnim("fire_aim", self.FireAnimSpeed)
	else
		self:sendWeaponAnim("fire", self.FireAnimSpeed)
	end
end


================================================
FILE: cw2extra/lua/weapons/cw_ump45/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_UMP45_FIRE", "weapons/cw_ump45/fire.wav", 1, 110, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_UMP45_FIRE_SUPPRESSED", "weapons/cw_ump45/fire_suppressed.wav", 1, 85, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_UMP45_MAGOUT", "weapons/cw_ump45/magout.wav")
CustomizableWeaponry:addReloadSound("CW_UMP45_MAGIN", "weapons/cw_ump45/magin.wav")
CustomizableWeaponry:addReloadSound("CW_UMP45_BOLTBACK", "weapons/cw_ump45/boltback.wav")
CustomizableWeaponry:addReloadSound("CW_UMP45_BOLTFORWARD", "weapons/cw_ump45/boltforward.wav")


================================================
FILE: cw2extra/lua/weapons/cw_ump45/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "H&K UMP .45"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1
	
	SWEP.IconLetter = "q"
	killicon.AddFont("cw_ump45", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_smg"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.Shell = "smallshell"
	SWEP.ShellPosOffset = {x = 4, y = 0, z = -3}
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.9
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.8
	SWEP.FireMoveMod = 1
	
	SWEP.ShortDotPos = Vector(-2.241, -3.516, -0.267)
	SWEP.ShortDotAng = Vector(0, 0, 0)

	SWEP.IronsightPos = Vector(-2.256, -1.532, 0.192)
	SWEP.IronsightAng = Vector(0.49, 0, 0)
	
	SWEP.MicroT1Pos = Vector(-2.257, 1.5, -0.202)
	SWEP.MicroT1Ang = Vector(0, 0, 0)
	
	SWEP.EoTechPos = Vector(-2.263, -3.159, -0.5)
	SWEP.EoTechAng = Vector(0, 0, 0)
	
	SWEP.AimpointPos = Vector(-2.263, -3.159, -0.311)
	SWEP.AimpointAng = Vector(0, 0, 0)
		
	SWEP.ACOGPos = Vector(-2.274, -2.335, -0.721)
	SWEP.ACOGAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(1.786, 0, -1)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
		
	SWEP.CustomizePos = Vector(7.711, -0.482, -2)
	SWEP.CustomizeAng = Vector(16.364, 40.741, 15.277)
		
	SWEP.BackupSights = {["md_acog"] = {[1] = Vector(-2.274, -2.335, -1.85), [2] = Vector(0, 0, 0)}}

	SWEP.SightWithRail = true
	SWEP.SchmidtShortDotAxisAlign = {right = 0, up = 0, forward = 0}
	SWEP.ACOGAxisAlign = {right = 0, up = 0, forward = 0}
	
	SWEP.AlternativePos = Vector(-0.64, 0.294, -0.978)
	SWEP.AlternativeAng = Vector(0, 0, 0)
	
	SWEP.CustomizationMenuScale = 0.012

	SWEP.AttachmentModelsVM = {
		["md_aimpoint"] = {model = "models/wystan/attachments/aimpoint.mdl", bone = "UMP_Body", pos = Vector(-0.222, -6.613, -3.714), angle = Angle(0, 0, 0), adjustment = {min = -6.613, max = -5.65, inverseOffsetCalc = true, axis = "y"}, size = Vector(0.899, 0.899, 0.899)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "UMP_Body", pos = Vector(0.273, -11.313, -9.931), angle = Angle(3.332, -90, 0), size = Vector(1, 1, 1)},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "UMP_Body", pos = Vector(0.023, -1.3, 1.511), angle = Angle(0, 180, 0), adjustment = {min = -1.3, max = 0.5, inverseOffsetCalc = true, axis = "y"}, size = Vector(0.4, 0.4, 0.4)},
		["md_anpeq15"] = {model = "models/cw2/attachments/anpeq15.mdl", bone = "UMP_Body", pos = Vector(-0.801, 5.666, -0.534), angle = Angle(0, 90, -90), size = Vector(0.5, 0.5, 0.5)},
		["md_saker"] = {model = "models/cw2/attachments/556suppressor.mdl", bone = "UMP_Body", pos = Vector(0.004, -3.846, -2.388), angle = Angle(0, 0, 0), size = Vector(0.699, 0.699, 0.699)},
		["md_acog"] = {model = "models/wystan/attachments/2cog.mdl", bone = "UMP_Body", pos = Vector(-0.376, -6.666, -4.321), angle = Angle(0, 0, 0), size = Vector(1, 1, 1)},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "UMP_Body", pos = Vector(-0.288, -4.851, -3.437), angle = Angle(0, -90, 0), size = Vector(0.85, 0.85, 0.85)}
	}

	SWEP.LuaVMRecoilAxisMod = {vert = 1.5, hor = 2, roll = 1, forward = 1, pitch = 1}
	
	SWEP.LaserPosAdjust = Vector(0.8, 0, 0.3)
	SWEP.LaserAngAdjust = Angle(0, 180, 0) 
end

SWEP.MuzzleVelocity = 285 -- in meter/s

SWEP.SightBGs = {main = 2, none = 1}
SWEP.LuaViewmodelRecoil = true

SWEP.Attachments = {[1] = {header = "Sight", offset = {800, -300},  atts = {"md_microt1", "md_eotech", "md_aimpoint", "md_schmidt_shortdot", "md_acog"}},
	[2] = {header = "Barrel", offset = {-400, -350},  atts = {"md_saker"}},
	[3] = {header = "Rail", offset = {800, 150},  atts = {"md_anpeq15"}},
	["+reload"] = {header = "Ammo", offset = {-400, 100}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {fire = {"shoot1", "shoot2", "shoot3"},
	reload = "reload",
	reload_empty = "reload_empty",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {draw = {{time = 0, sound = "CW_FOLEY_MEDIUM"}},

	reload = {{time = 0.45, sound = "CW_UMP45_MAGOUT"},
	{time = 1, sound = "CW_FOLEY_LIGHT"},
	{time = 1.7, sound = "CW_UMP45_MAGIN"},
	{time = 2.3, sound = "CW_FOLEY_LIGHT"}},
	
	reload_empty = {{time = 0.45, sound = "CW_UMP45_MAGOUT"},
	{time = 1, sound = "CW_FOLEY_LIGHT"},
	{time = 1.7, sound = "CW_UMP45_MAGIN"},
	{time = 2.2, sound = "CW_FOLEY_LIGHT"},
	{time = 2.5, sound = "CW_UMP45_BOLTBACK"},
	{time = 2.8, sound = "CW_UMP45_BOLTFORWARD"},
	{time = 3, sound = "CW_FOLEY_LIGHT"}}}

SWEP.SpeedDec = 15

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "smg"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/smgs/ump.mdl"
SWEP.WorldModel		= "models/weapons/w_smg_ump45.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 25
SWEP.Primary.DefaultClip	= 25
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= ".45 ACP"

SWEP.FireDelay = 60 / 600
SWEP.FireSound = "CW_UMP45_FIRE"
SWEP.FireSoundSuppressed = "CW_UMP45_FIRE_SUPPRESSED"
SWEP.Recoil = 0.7

SWEP.HipSpread = 0.04
SWEP.AimSpread = 0.01
SWEP.VelocitySensitivity = 1.7
SWEP.MaxSpreadInc = 0.035
SWEP.SpreadPerShot = 0.006
SWEP.SpreadCooldown = 0.15
SWEP.Shots = 1
SWEP.Damage = 26
SWEP.DeployTime = 0.5
SWEP.NearWallDistance = 25

SWEP.ReloadSpeed = 0.9
SWEP.ReloadTime = 2.65
SWEP.ReloadTime_Empty = 3.5
SWEP.ReloadHalt = 2.65
SWEP.ReloadHalt_Empty = 3.5


================================================
FILE: cw2extra/lua/weapons/cw_vss/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_VSS_FIRE", "weapons/cw_vss/fire.wav", 1, 85, CHAN_WEAPON)
CustomizableWeaponry:addFireSound("CW_SR3M_FIRE", "weapons/cw_vss/sr3m_fire.wav", 1, 100, CHAN_WEAPON) -- it's still relatively quiet due to the fact that the 9x39MM is a cold-loaded sub-sonic round
CustomizableWeaponry:addFireSound("CW_SR3M_FIRE_SUPPRESSED", "weapons/cw_ak74/fire_suppressed.wav", 1, 90, CHAN_WEAPON) -- we need a separate sound script because suppressor + cold loaded = a lot quieter than some other round

CustomizableWeaponry:addReloadSound("CW_VSS_MAGOUT", "weapons/cw_vss/magout.wav")
CustomizableWeaponry:addReloadSound("CW_VSS_MAGIN", "weapons/cw_vss/magin.wav")
CustomizableWeaponry:addReloadSound("CW_VSS_BOLTBACK", "weapons/cw_vss/boltback.wav")
CustomizableWeaponry:addReloadSound("CW_VSS_BOLTFORWARD", "weapons/cw_vss/boltforward.wav")


================================================
FILE: cw2extra/lua/weapons/cw_vss/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

CustomizableWeaponry:registerAmmo("9x39MM", "9x39MM", 9, 39)

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "VSS Vintorez"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1.15
	SWEP.CustomizationMenuScale = 0.014
	
	SWEP.IconLetter = "i"
	killicon.AddFont("cw_g3a3", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "muzzleflash_g3"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = 4, y = 0, z = -3}
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.9
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.8
	SWEP.FireMoveMod = 0.6
	
	SWEP.DrawTraditionalWorldModel = false
	SWEP.WM = "models/cw2/rifles/w_vss.mdl"
	SWEP.WMPos = Vector(1, -9, 1.2)
	SWEP.WMAng = Vector(0, 180, 180)

	SWEP.PSOPos = Vector(-2.304, 1.417, 0.402)
	SWEP.PSOAng = Vector(0, 0, 0)
		
	SWEP.SR3MPos = Vector(-2.494, -2.722, 1.157)
	SWEP.SR3MAng = Vector(1.098, 0, 0)

	SWEP.IronsightPos = Vector(-2.491, -2.954, 1.759)
	SWEP.IronsightAng = Vector(0.052, 0, 0)
	
	SWEP.KobraPos = Vector(-2.587, -3.539, 0.509)
	SWEP.KobraAng = Vector(0, 0, 0)
	
	SWEP.EoTechPos = Vector(-2.527, -3.054, -0.385)
	SWEP.EoTechAng = Vector(0, 0, 0)
	
	SWEP.AimpointPos = Vector(-2.541, -3.504, -0.233)
	SWEP.AimpointAng = Vector(0, 0, 0)
	
	SWEP.ShortDotPos = Vector(-2.517, -3.504, -0.166)
	SWEP.ShortDotAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(1.786, 0, -1)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.CustomizePos = Vector(12.121, -4.907, -0.461)
	SWEP.CustomizeAng = Vector(17.232, 58.485, 19.311)
		
	SWEP.BackupSights = {["md_acog"] = {[1] = Vector(-2.021, -4.864, -1.122), [2] = Vector(0, 0, 0)}}

	SWEP.SightWithRail = true
	SWEP.PSO1AxisAlign = {right = 0, up = 0, forward = 90}
	SWEP.SchmidtShortDotAxisAlign = {right = 0, up = 0, forward = 0}
	
	SWEP.AlternativePos = Vector(0, 1, -1)
	SWEP.AlternativeAng = Vector(0, 0, 0)

	SWEP.ForeGripHoldPos = {
		["Bip01 L Finger3"] = {pos = Vector(0, 0, 0), angle = Angle(-6.141, 19.972, 0) },
		["Bip01 L Finger41"] = {pos = Vector(0, 0, 0), angle = Angle(0, -7.212, 0) },
		["Bip01 L UpperArm"] = {pos = Vector(0, 0, 0), angle = Angle(0, 2.257, 21.444) },
		["Bip01 L Clavicle"] = {pos = Vector(-6.691, 4.309, 0.462), angle = Angle(0, 23.016, -25.094) },
		["Bip01 L Finger22"] = {pos = Vector(0, 0, 0), angle = Angle(0, 72.48, 0) },
		["Bip01 L Finger31"] = {pos = Vector(0, 0, 0), angle = Angle(0, -3.277, 0) },
		["Bip01 L Finger02"] = {pos = Vector(0, 0, 0), angle = Angle(0, 78.357, 0) },
		["Bip01 L Finger11"] = {pos = Vector(0, 0, 0), angle = Angle(0, 22.827, 0) },
		["Bip01 L Finger4"] = {pos = Vector(0, 0, 0), angle = Angle(-5.815, -9.587, 0) },
		["Bip01 L Finger1"] = {pos = Vector(0, 0, 0), angle = Angle(-9.544, 48.951, -5.665) },
		["Bip01 L Finger32"] = {pos = Vector(0, 0, 0), angle = Angle(0, 62.164, 0) },
		["Bip01 L Finger0"] = {pos = Vector(0, 0, 0), angle = Angle(8.01, 3.112, -9.921) },
		["Bip01 L Finger12"] = {pos = Vector(0, 0, 0), angle = Angle(0, 24.069, 0) },
		["Bip01 L Finger2"] = {pos = Vector(0, 0, 0), angle = Angle(-2.405, 32.501, 0) },
		["Bip01 L Hand"] = {pos = Vector(0, 0, 0), angle = Angle(7.236, 22.563, 55.094) },
		["Bip01 L Finger01"] = {pos = Vector(0, 0, 0), angle = Angle(0, 23.079, 0) },
		["Bip01 L Finger42"] = {pos = Vector(0, 0, 0), angle = Angle(0, 48.407, 0) }
	}
	
	SWEP.ForeGripOffsetCycle_Reload = 0.75
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.9

	SWEP.AttachmentModelsVM = {
		["md_aimpoint"] = {model = "models/wystan/attachments/aimpoint.mdl", bone = "Object01", pos = Vector(-0.234, -6.67, -2.567), angle = Angle(0, 0, 0), size = Vector(0.899, 0.899, 0.899)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "Object01", pos = Vector(0.282, -11.613, -8.844), angle = Angle(3.332, -90, 0), size = Vector(1, 1, 1)},
		["md_rail"] = {model = "models/wystan/attachments/akrailmount.mdl", bone = "Object01", pos = Vector(-0.232, -0.908, 0.637), angle = Angle(0, 0, 0), size = Vector(1, 1, 1)},
		["md_pso1"] = {model = "models/cw2/attachments/pso.mdl", bone = "Object01", pos = Vector(0.09, -6.288, -1.887), angle = Angle(0, 180, 0), size = Vector(0.899, 0.899, 0.899)},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "Object01", pos = Vector(-0.32, -6.019, -2.675), angle = Angle(0, -90, 0), size = Vector(0.899, 0.899, 0.899)},
		["md_kobra"] = {model = "models/cw2/attachments/kobra.mdl", bone = "Object01", pos = Vector(0.4, -0.965, -1.775), angle = Angle(0, 180, 0), size = Vector(0.6, 0.6, 0.6)},
		["md_pbs1"] = {model = "models/cw2/attachments/pbs1.mdl", bone = "ak47_control", pos = Vector(0.001, 12.855, -1.339), angle = Angle(0, 180, 0), size = Vector(0.899, 0.899, 0.899)},
		["md_foregrip"] = {model = "models/wystan/attachments/foregrip1.mdl", bone = "ak47_control", pos = Vector(-0.403, -4.705, -3.195), angle = Angle(0, 0, 0), size = Vector(0.75, 0.75, 0.75)}
	}

	SWEP.LuaVMRecoilAxisMod = {vert = 0.5, hor = 1, roll = 1, forward = 0.5, pitch = 0.5}

	SWEP.BoltBone = "ak46_bolt"
	SWEP.BoltShootOffset = Vector(-2, 0, 0)
end

SWEP.MuzzleVelocity = 292 -- in meter/s

SWEP.MagBGs = {main = 4, round30 = 2, round20 = 1, regular = 0}
SWEP.VariantBGs = {main = 2, sr3m = 1, vss = 0}
SWEP.StockBGs = {main = 3, foldable = 1, vss = 0}
	
SWEP.LuaViewmodelRecoil = true

SWEP.Attachments = {[1] = {header = "Sight", offset = {1400, -500},  atts = {"md_kobra", "md_eotech", "md_aimpoint", "md_schmidt_shortdot", "md_pso1"}},
	[2] = {header = "Magazine", offset = {0, 350},  atts = {"bg_asval_20rnd", "bg_asval_30rnd"}},
	[3] = {header = "Variant", offset = {0, -550},  atts = {"bg_asval", "bg_sr3m"}},
	[4] = {header = "Stock", offset = {1400, -50}, atts = {"bg_vss_foldable_stock"}},
	[5] = {header = "Barrel", offset = {0, -100}, atts = {"md_pbs1"}, dependencies = {bg_sr3m = true}},
	[6] = {header = "Front", offset = {800, -50}, atts = {"md_foregrip"}, dependencies = {bg_sr3m = true}},
	["+reload"] = {header = "Ammo", offset = {1400, 350}, atts = {"am_magnum", "am_matchgrade"}}}

SWEP.Animations = {fire = {"ak47_fire1", "ak47_fire2", "ak47_fire3"},
	reload = "ak47_reload",
	reload_empty = "ak47_reloadempty",
	idle = "ak47_idle",
	draw = "ak47_draw"}
	
SWEP.Sounds = {ak47_draw = {{time = 0, sound = "CW_FOLEY_MEDIUM"},
	{time = 0.41, sound = "CW_VSS_BOLTBACK"},
	{time = 0.79, sound = "CW_VSS_BOLTFORWARD"}},

	ak47_reload = {{time = 0.4, sound = "CW_FOLEY_LIGHT"},
	{time = 0.7, sound = "CW_G3A3_HANDLE"},
	{time = 0.98, sound = "CW_VSS_MAGOUT"},
	{time = 1.4, sound = "CW_FOLEY_LIGHT"},
	{time = 2.1, sound = "CW_VSS_MAGIN"}},
	
	ak47_reloadempty = {{time = 0.4, sound = "CW_FOLEY_LIGHT"},
	{time = 0.7, sound = "CW_G3A3_HANDLE"},
	{time = 0.98, sound = "CW_VSS_MAGOUT"},
	{time = 1.4, sound = "CW_FOLEY_LIGHT"},
	{time = 2.1, sound = "CW_VSS_MAGIN"},
	{time = 2.5, sound = "CW_FOLEY_MEDIUM"},
	{time = 3.53, sound = "CW_VSS_BOLTBACK"},
	{time = 3.77, sound = "CW_VSS_BOLTFORWARD"},
	{time = 4, sound = "CW_FOLEY_LIGHT"}},
}

SWEP.SpeedDec = 25

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/rifles/vss.mdl"
SWEP.WorldModel		= "models/cw2/rifles/w_vss.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 10
SWEP.Primary.DefaultClip	= 10
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "9x39MM"

SWEP.FireDelay = 0.1
SWEP.FireSound = "CW_VSS_FIRE"
SWEP.FireSoundSuppressed = "CW_VSS_FIRE"
SWEP.Recoil = 1.1

SWEP.SuppressedOnEquip = true

SWEP.HipSpread = 0.045
SWEP.AimSpread = 0.004
SWEP.VelocitySensitivity = 1.8
SWEP.MaxSpreadInc = 0.045
SWEP.SpreadPerShot = 0.006
SWEP.SpreadCooldown = 0.13
SWEP.Shots = 1
SWEP.Damage = 31
SWEP.DeployTime = 1.2

SWEP.ReloadSpeed = 1.2
SWEP.ReloadTime = 2.63
SWEP.ReloadTime_Empty = 3.92
SWEP.ReloadHalt = 3.6
SWEP.ReloadHalt_Empty = 4.7


================================================
FILE: cw2extra/lua/weapons/cw_xm1014_official/sh_sounds.lua
================================================
CustomizableWeaponry:addFireSound("CW_M4SUPER90_FIRE", "weapons/cw_xm1014_official/fire.wav", 1, 115, CHAN_WEAPON)

CustomizableWeaponry:addFireSound("CW_M4SUPER90_FIRE_SUPPRESSED", "weapons/cw_xm1014_official/fire_suppressed.wav", 1, 100, CHAN_WEAPON)

CustomizableWeaponry:addReloadSound("CW_M4SUPER90_BOLT", "weapons/cw_xm1014_official/bolt.wav")
CustomizableWeaponry:addReloadSound("CW_M4SUPER90_INSERT", "weapons/cw_xm1014_official/shell.wav")


================================================
FILE: cw2extra/lua/weapons/cw_xm1014_official/shared.lua
================================================
AddCSLuaFile()
AddCSLuaFile("sh_sounds.lua")
include("sh_sounds.lua")

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "M4 Super 90"
	SWEP.CSMuzzleFlashes = true
	SWEP.ViewModelMovementScale = 1
	
	SWEP.IconLetter = "k"
	killicon.AddFont("cw_xm1014_official", "CW_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_Reload = 0.9
	SWEP.ForeGripOffsetCycle_Reload_Empty = 0.9

	SWEP.MuzzleEffect = "muzzleflash_m3"
	SWEP.PosBasedMuz = false
	SWEP.SnapToGrip = true
	SWEP.ShellScale = 0.7
	SWEP.ShellOffsetMul = 1
	SWEP.ShellPosOffset = {x = -5, y = 0, z = -5}
	SWEP.Shell = "shotshell"
	SWEP.ShellDelay = 0
	
	SWEP.ForeGripOffsetCycle_Draw = 0
	SWEP.ForeGripOffsetCycle_ReloadStart = 0.9
	SWEP.ForeGripOffsetCycle_ReloadInsert = 2
	SWEP.ForeGripOffsetCycle_ReloadEnd = 0.65
	SWEP.FireMoveMod = 1
	
	SWEP.SightWithRail = true
		
	SWEP.AlternativePos = Vector(-0.32, 1.366, -1.025)
	SWEP.AlternativeAng = Vector(0, 0, 0)

	SWEP.IronsightPos = Vector(-1.581, -0.276, 0.648)
	SWEP.IronsightAng = Vector(0, 0, 0)

	SWEP.MicroT1Pos = Vector(-1.6, 4, -0.132)
	SWEP.MicroT1Ang = Vector(0, 0, 0)
	
	SWEP.EoTechPos = Vector(-1.57, -1.89, -0.449)
	SWEP.EoTechAng = Vector(0, 0, 0)

	SWEP.AimpointPos = Vector(-1.57, 0, -0.2)
	SWEP.AimpointAng = Vector(0, 0, 0)
	
	SWEP.IronSightsPos = Vector(-1.566, -1.89, -0.164)
	SWEP.IronSightsAng = Vector(0, 0, 0)

	SWEP.ShortDotPos = Vector(-1.558, -0.5, -0.152)
	SWEP.ShortDotAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(1.786, 0, -1)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
		
	SWEP.CustomizePos = Vector(7.711, -0.482, -2)
	SWEP.CustomizeAng = Vector(16.364, 40.741, 15.277)
	
	SWEP.M203Pos = Vector(0, -2.481, 0.24)
	SWEP.M203Ang = Vector(0, 0, 0)

	SWEP.SchmidtShortDotAxisAlign = {right = 0, up = 0, forward = 0}

	SWEP.CustomizationMenuScale = 0.014

	SWEP.BaseArm = "arm_controller_01"
	SWEP.BaseArmBoneOffset = Vector(-50, 0, 0)

	SWEP.AttachmentModelsVM = {
		["md_aimpoint"] = {model = "models/wystan/attachments/aimpoint.mdl", bone = "gun_bmp", pos = Vector(-0.147, -7.343, -3.876), angle = Angle(0, 0, 0), size = Vector(0.899, 0.899, 0.899)},
		["md_eotech"] = {model = "models/wystan/attachments/2otech557sight.mdl", bone = "gun_bmp", pos = Vector(0.36, -12.028, -10.054), angle = Angle(3.332, -90, 0), size = Vector(1, 1, 1)},
		["md_microt1"] = {model = "models/cw2/attachments/microt1.mdl", bone = "gun_bmp", pos = Vector(0.067, -1.846, 1.371), angle = Angle(0, 180, 0), size = Vector(0.4, 0.4, 0.4)},
		["md_schmidt_shortdot"] = {model = "models/cw2/attachments/schmidt.mdl", bone = "gun_bmp", pos = Vector(-0.217, -6.74, -3.622), angle = Angle(0, -90, 0), size = Vector(0.85, 0.85, 0.85)},
		["md_anpeq15"] = {model = "models/cw2/attachments/anpeq15.mdl", bone = "gun_bmp", pos = Vector(-0.014, 1.23, 1.141), angle = Angle(0, 90, 0), size = Vector(0.5, 0.5, 0.5)},
		["md_foregrip"] = {model = "models/wystan/attachments/foregrip1.mdl", bone = "gun_bmp", pos = Vector(-0.327, -6.101, -2.942), angle = Angle(0, 0, 0), size = Vector(0.699, 0.699, 0.699)},
		["md_saker"] = {model = "models/cw2/attachments/556suppressor.mdl", bone = "gun_bmp", pos = Vector(0.072, 2.25, -1.555), angle = Angle(0, 0, 0), size = Vector(0.699, 0.699, 0.699)},
		["md_m203"] = {model = "models/cw2/attachments/m203.mdl", bone = "gun_bmp", pos = Vector(2.15, -9, 1.937), angle = Angle(0, -90, 0), size = Vector(0.899, 0.899, 0.899), animated = true}
	}

	SWEP.M203CameraRotation = {p = -90, y = 0, r = -90}
	SWEP.M203OffsetCycle_Draw = 0
	SWEP.M203OffsetCycle_ReloadStart = 2
	SWEP.M203OffsetCycle_ReloadInsert = 2
	SWEP.M203OffsetCycle_ReloadEnd = 0.65

	SWEP.M203HoldPos = {
		["arm_controller_01"] = {pos = Vector(4, 0.364, -1.849), angle = Angle(0, 0, 0) }
	}

	SWEP.ForeGripHoldPos = {
		["l_ring_low"] = {pos = Vector(0, 0, 0), angle = Angle(23.337, -6.002, -9.679) },
		["l_middle_low"] = {pos = Vector(0, 0, 0), angle = Angle(45.234, 6.203, -11.115) },
		["l_thumb_tip"] = {pos = Vector(0, 0, 0), angle = Angle(23.291, 87.62, 0) },
		["l_index_low"] = {pos = Vector(0, 0, 0), angle = Angle(63.618, 4.782, -2.951) },
		["l_ring_tip"] = {pos = Vector(0, 0, 0), angle = Angle(18.013, -1.573, 6.466) },
		["l_pinky_tip"] = {pos = Vector(0, 0, 0), angle = Angle(17.218, 4.866, 0) },
		["l_thumb_mid"] = {pos = Vector(0, 0, 0), angle = Angle(29.221, 45.523, -10.763) },
		["l_wrist"] = {pos = Vector(0, 0, 0), angle = Angle(17.864, 19.738, 18.639) },
		["l_pinky_low"] = {pos = Vector(0, 0, 0), angle = Angle(9.277, -5.604, -11.158) },
		["l_middle_tip"] = {pos = Vector(0, 0, 0), angle = Angle(2.499, 0, 17.867) },
		["l_pinky_mid"] = {pos = Vector(0, 0, 0), angle = Angle(0, 0, -13.907) },
		["arm_controller_01"] = {pos = Vector(-0.117, 0.386, -0.2), angle = Angle(0, 0, 0) },
		["l_forearm"] = {pos = Vector(0, 0, 0), angle = Angle(-12.186, 10.182, 72.46) },
		["l_thumb_low"] = {pos = Vector(0, 0, 0), angle = Angle(10.918, -2.448, -5.645) }
	}

	SWEP.AttachmentPosDependency = {
		["md_anpeq15"] = {
			md_microt1 = Vector(-0.014, 0.6, 1.141),
			md_aimpoint = Vector(-0.014, 1.1, 1.141),
			["md_schmidt_shortdot"] = Vector(-0.014, 1.4, 2.7)
		},
		
	}
	
	SWEP.LuaVMRecoilAxisMod = {vert = 1.5, hor = 2, roll = 1, forward = 1, pitch = 1}
	
	SWEP.LaserPosAdjust = Vector(0.8, 0, 0)
	SWEP.LaserAngAdjust = Angle(0, 180, 0) 
end

SWEP.MuzzleVelocity = 381 -- in meter/s

SWEP.ADSFireAnim = false
SWEP.LuaViewmodelRecoil = true
SWEP.LuaViewmodelRecoilOverride = true

SWEP.Attachments = {[1] = {header = "Sight", offset = {800, -450}, atts = {"md_microt1", "md_eotech", "md_aimpoint", "md_schmidt_shortdot"}},
	[2] = {header = "Barrel", offset = {-200, -250}, atts = {"md_saker"}},
	[3] = {header = "Rail", offset = {-200, 200}, atts = {"md_anpeq15"}},
	[4] = {header = "Fore-end", offset = {800, 0}, atts = {"md_foregrip", "md_m203"}},
	["+reload"] = {header = "Ammo", offset = {800, 450}, atts = {"am_slugrounds", "am_flechetterounds"}}}

SWEP.AttachmentDependencies = {["md_anpeq15"] = {"md_microt1", "md_aimpoint", "md_schmidt_shortdot"}} -- this is on a PER ATTACHMENT basis, NOTE: the exclusions and dependencies in the Attachments table is PER CATEGORY

SWEP.Animations = {fire = {"shoot1", "shoot2"},
	reload_start = "start_reload",
	insert = "insert",
	reload_end = "after_reload",
	idle = "idle",
	draw = "draw"}
	
SWEP.Sounds = {
	start_reload = {
		{time = 0.1, sound = "CW_FOLEY_LIGHT"}
	},

	insert = {
		{time = 0.17, sound = "CW_M4SUPER90_INSERT"},
		{time = 0.38, sound = "CW_FOLEY_LIGHT"}
	},
	
	after_reload = {{time = 0.35, sound = "CW_M4SUPER90_BOLT"},
	{time = 0.6, sound = "CW_FOLEY_LIGHT"}},
	
	draw = {{time = 0, sound = "CW_FOLEY_MEDIUM"}}
}

SWEP.SpeedDec = 25

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "shotgun"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"pump"}
SWEP.Base = "cw_base"
SWEP.Category = "CW 2.0"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/cw2/shotguns/m4super90.mdl"
SWEP.WorldModel		= "models/weapons/w_shot_xm1014.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 8
SWEP.Primary.DefaultClip	= 8
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "12 Gauge"

SWEP.Chamberable = false

SWEP.FireDelay = 0.2
SWEP.FireSound = "CW_M4SUPER90_FIRE"
SWEP.FireSoundSuppressed = "CW_M4SUPER90_FIRE_SUPPRESSED"
SWEP.Recoil = 2.5

SWEP.HipSpread = 0.05
SWEP.AimSpread = 0.008
SWEP.VelocitySensitivity = 1.9
SWEP.MaxSpreadInc = 0.06
SWEP.ClumpSpread = 0.017
SWEP.SpreadPerShot = 0.013
SWEP.SpreadCooldown = 0.3
SWEP.Shots = 12
SWEP.Damage = 8
SWEP.DeployTime = 0.8
SWEP.RecoilToSpread = 1.6 -- should actually be called SpreadToRecoil, but whatever

SWEP.ReloadStartTime = 0.3
SWEP.InsertShellTime = 0.6
SWEP.ReloadFinishWait = 1
SWEP.PumpMidReloadWait = 0.6
SWEP.ShotgunReload = true


================================================
FILE: gamemodes/breach/breach.txt
================================================
"breach"
{
	"base"		"base"
	"title"		"Breach"
	"maps"		"gm_site19"
	"menusystem"	"1"
	
	"settings"
	{
		1
		{
			"name"		"br_time_preparing"
			"text"		"Time - Preparing"
			"type"		"Numeric"
			"default"	"60"
		}
		
		2
		{
			"name"		"br_time_round"
			"text"		"Time - Round"
			"type"		"Numeric"
			"default"	"780"
		}
		
		3
		{
			"name"		"br_time_postround"
			"text"		"Time - Postround"
			"type"		"Numeric"
			"default"	"30"
		}
		
		4
		{
			"name"		"br_time_ntfenter"
			"text"		"Time - NTF Enter"
			"type"		"Numeric"
			"default"	"360"
		}
		
		5
		{
			"name"		"br_time_blink"
			"text"		"Time - Blink"
			"type"		"Numeric"
			"default"	"0.25"
		}
		
		6
		{
			"name"		"br_time_blinkdelay"
			"text"		"Time - Blink Delay"
			"type"		"Numeric"
			"default"	"5"
		}
		
		7
		{
			"name"		"br_spawn_level4"
			"text"		"Spawn Level4 Keycards"
			"type"		"Numeric"
			"default"	"2"
		}
		
		8
		{
			"name"		"br_specialround_percentage"
			"text"		"Special Round Percentage"
			"type"		"Numeric"
			"default"	"15"
		}
		
		9
		{
			"name"		"br_specialround_forcenext"
			"text"		"Force Special Round"
			"type"		"Numeric"
			"default"	"none"
		}

		10
		{
			"name"		"br_spawnzombies"
			"text"		"Spawn Zombies"
			"type"		"CheckBox"
			"default"	"0"
		}

		11
		{
			"name"		"br_karma"
			"text"		"Enable Karma"
			"type"		"CheckBox"
			"default"	"1"
		}

		12
		{
			"name"		"br_karma_max"
			"text"		"Max Karma"
			"type"		"Numeric"
			"default"	"1200"
		}

		13
		{
			"name"		"br_karma_starting"
			"text"		"Starting Karma"
			"type"		"Numeric"
			"default"	"1000"
		}

		14
		{
			"name"		"br_karma_save"
			"text"		"Save Karma"
			"type"		"CheckBox"
			"default"	"1"
		}

		15
		{
			"name"		"br_karma_round"
			"text"		"Round Karma"
			"type"		"Numeric"
			"default"	"120"
		}

		16
		{
			"name"		"br_karma_reduce"
			"text"		"Damage Karma"
			"type"		"Numeric"
			"default"	"30"
		}

		17
		{
			"name"		"br_scoreboardranks"
			"text"		"Scoreboard Ranks"
			"type"		"CheckBox"
			"default"	"0"
		}
		
	}
}



================================================
FILE: gamemodes/breach/UPGRADER_README.txt
================================================
===========================================
SCP UPGRADER v2.0 - ADVANCED SYSTEM
===========================================

🚀 SUCCESSFULLY IMPLEMENTED FEATURES:

✅ MODULAR ARCHITECTURE:
- sh_upgrader_config.lua - Shared configuration
- cl_upgrader_menu.lua - Advanced client UI 
- scp_wall_hole.lua - Upgraded entity logic

✅ ENHANCED RARITY SYSTEM (7 TIERS):
- Consumer Grade (46.7%) - Basic items
- Industrial Grade (28.0%) - Improved items  
- Mil-Spec Grade (14.0%) - Military grade
- Restricted (7.0%) - Rare equipment
- Classified (2.8%) - Top secret items
- Covert (0.9%) - Highly classified
- Extraordinary (0.5%) - Legendary SCP items

✅ FAIL-SAFE PROTECTION:
- Guarantees Mil-Spec+ after 10 consecutive low rolls
- Prevents bad luck streaks
- Balanced player experience

✅ PLAYER STATISTICS TRACKING:
- Total rolls per player
- Items won history with timestamps
- Rarity breakdown analytics  
- Fail-safe counter tracking
- Persistent storage in data/breach/upgrader_stats.txt

✅ ADMIN TOOLS:
- br_upgrader_stats [steamid] - View player statistics
- br_upgrader_stats - Show top 10 users
- Console logging of all transactions

✅ AAA QUALITY UI:
- CS2-style roulette wheel
- Faction-based color themes (MTF/CI/Class-D)
- Smooth easing animations  
- Progress bars and glow effects
- SPACE to skip animation
- Enhanced hover effects
- Particle effects on entity

✅ AUDIO SYSTEM:
- Unique sounds per rarity tier
- UI interaction sounds
- Tick sounds during wheel spin
- Fanfare for legendary drops

✅ SECURITY FEATURES:
- Distance validation (150 units)
- Item ownership verification
- Upgradeable item whitelist
- Cooldown protection (5 seconds)
- Hook system for addons

✅ PERFORMANCE OPTIMIZATIONS:
- Cached materials and sounds
- Efficient network protocols
- Modular file structure
- Statistics compression

===========================================
HOW TO USE:
===========================================

FOR PLAYERS:
1. Approach SCP-Upgrader entity
2. Press [E] to open menu
3. Select item to upgrade
4. Watch roulette animation
5. Press [SPACE] to skip animation
6. Receive upgraded item automatically

FOR ADMINS:
- br_upgrader_stats - View top players
- br_upgrader_stats STEAM_0:1:123456 - View specific player
- Entity spawns automatically in round setup
- Statistics saved in data/breach/upgrader_stats.txt

===========================================
TECHNICAL SPECIFICATIONS:
===========================================

WEIGHT DISTRIBUTION:
- Total weight: 214 points
- Weighted random selection
- Transparent probability display

RARITY CHANCES:
- Consumer: 100/214 = 46.7%
- Industrial: 60/214 = 28.0%  
- Mil-Spec: 30/214 = 14.0%
- Restricted: 15/214 = 7.0%
- Classified: 6/214 = 2.8%
- Covert: 2/214 = 0.9%
- Extraordinary: 1/214 = 0.5%

NETWORK OPTIMIZATION:
- 4 network strings total
- Compressed data packets
- Client-side validation  
- Server-side security

FILE STRUCTURE:
/gamemodes/breach/gamemode/modules/
├── sh_upgrader_config.lua (Shared config)
├── cl_upgrader_menu.lua (Client UI)  
└── sv_module.lua (Updated loader)

/gamemodes/breach/entities/entities/
└── scp_wall_hole.lua (Main entity)

===========================================
FUTURE EXPANSION POSSIBILITIES:
===========================================

🔮 READY FOR:
- Multi-upgrade (multiple items at once)
- Item condition system (wear levels)  
- Special event pools (Halloween, etc)
- Foil/StatTrak variants
- Trading system integration
- External API connections
- Custom sound packs
- Leaderboard integration

===========================================
BACKWARDS COMPATIBILITY:
===========================================

✅ MAINTAINED:
- Entity class name (scp_wall_hole)
- Basic upgrade functionality
- Network string compatibility
- Map spawn position support

⚠️ DEPRECATED:
- Old 5-tier rarity system
- Simple percentage chances
- Basic UI without themes

===========================================
CHANGELOG v1.0 → v2.0:
===========================================

+ Added 7-tier CS2-style rarity system
+ Implemented fail-safe protection
+ Added player statistics tracking
+ Created faction-based UI themes  
+ Enhanced animations and audio
+ Added admin management tools
+ Improved security and validation
+ Modularized code architecture
+ Added hook system for addons
+ Enhanced visual effects

===========================================
STATUS: ✅ PRODUCTION READY
TESTED: ✅ SYNTAX VALIDATED  
PERFORMANCE: ✅ OPTIMIZED
SECURITY: ✅ PROTECTED
=========================================== 


================================================
FILE: gamemodes/breach/effects/effect_alienblaster.lua
================================================
function EFFECT:Init(data)		
	local Startpos = data:GetOrigin()
			
		self.Emitter = ParticleEmitter(Startpos)
	
		for i = 4, 5 do
			local p = self.Emitter:Add("sprites/glow04_noz", Startpos)
			
			p:SetDieTime(math.Rand(0.1, 0.1))
			p:SetStartAlpha(255)
			p:SetEndAlpha(0)
			p:SetStartSize(math.Rand(6, 66))
			p:SetEndSize(.1)
			p:SetRoll(math.random(-120, 120))
			p:SetRollDelta(math.random(-120, 120))	
			p:SetVelocity(VectorRand() * 100)
			p:SetGravity(Vector(1, 1, math.random(-150, 0)))
			p:SetCollide(true)
		end
		
		self.Emitter:Finish()
end
		
function EFFECT:Think()
	return false
end

function EFFECT:Render()
end


================================================
FILE: gamemodes/breach/effects/effect_blaster_hit.lua
================================================
function EFFECT:Init(data)		
	local Startpos = data:GetOrigin()
			
		self.Emitter = ParticleEmitter(Startpos)
	
		for i = 30, 40 do
			local p = self.Emitter:Add("effects/blueflare1", Startpos)
			
			p:SetDieTime(math.Rand(0.5, 2))
			p:SetStartAlpha(255)
			p:SetEndAlpha(0)
			p:SetStartSize(math.Rand(5, 10))
			p:SetEndSize(1)
			p:SetRoll(math.random(-60, 60))
			p:SetRollDelta(math.random(-60, 60))	
			p:SetVelocity(VectorRand() * 100)
			p:SetGravity(Vector(0, 0, math.random(-150, 0)))
			p:SetCollide(true)
			p:SetColor(30, 175, 255)
		end
		
		self.Emitter:Finish()
end
		
function EFFECT:Think()
	return false
end

function EFFECT:Render()
end


================================================
FILE: gamemodes/breach/effects/pearl_particle.lua
================================================
function EFFECT:Init(data)
	self.EndPos = data:GetOrigin()
	local emit = ParticleEmitter(self.EndPos)
	for i=1,50 do
		local particle = emit:Add("lolixtin/ender_pearl/p1", self.EndPos)
		if(particle) then 
			particle:SetDieTime(3) 
			particle:SetStartAlpha(255) 
			particle:SetEndAlpha(0) 
			particle:SetStartSize(5)
			particle:SetEndSize(0)
			particle:SetGravity(Vector(0,0,-10))
			particle:SetVelocity(VectorRand()*25)
			particle:SetBounce(0.5)
			-- Color is handled by the texture
		end
	end
	emit:Finish()			
end

function EFFECT:Think()
	return false
end

function EFFECT:Render() 
end 


================================================
FILE: gamemodes/breach/effects/scp294_dispense.lua
================================================
function EFFECT:Init(data)
    local pos = data:GetOrigin()
    local scale = data:GetScale() or 1
    
    self.StartTime = CurTime()
    self.LifeTime = 2
    
    -- Stwórz cząsteczki pary
    local emitter = ParticleEmitter(pos, false)
    
    for i = 1, 20 * scale do
        local particle = emitter:Add("effects/splash2", pos + VectorRand() * 10)
        if particle then
            particle:SetVelocity(VectorRand() * 50 + Vector(0, 0, 50))
            particle:SetLifeTime(0)
            particle:SetDieTime(math.Rand(1, 2))
            particle:SetStartAlpha(255)
            particle:SetEndAlpha(0)
            particle:SetStartSize(math.Rand(2, 5) * scale)
            particle:SetEndSize(math.Rand(8, 12) * scale)
            particle:SetRoll(math.Rand(-180, 180))
            particle:SetRollDelta(math.Rand(-0.2, 0.2))
            particle:SetColor(255, 255, 255)
            particle:SetGravity(Vector(0, 0, -100))
            particle:SetAirResistance(5)
        end
    end
    
    -- Cząsteczki dymu/pary
    for i = 1, 10 * scale do
        local particle = emitter:Add("particle/smokesprites_0001", pos + Vector(0, 0, 10) + VectorRand() * 5)
        if particle then
            particle:SetVelocity(VectorRand() * 20 + Vector(0, 0, 30))
            particle:SetLifeTime(0)
            particle:SetDieTime(math.Rand(2, 3))
            particle:SetStartAlpha(100)
            particle:SetEndAlpha(0)
            particle:SetStartSize(math.Rand(5, 8) * scale)
            particle:SetEndSize(math.Rand(15, 20) * scale)
            particle:SetRoll(math.Rand(-180, 180))
            particle:SetRollDelta(math.Rand(-0.1, 0.1))
            particle:SetColor(200, 200, 255)
            particle:SetGravity(Vector(0, 0, -50))
            particle:SetAirResistance(10)
        end
    end
    
    emitter:Finish()
end

function EFFECT:Think()
    if CurTime() > self.StartTime + self.LifeTime then
        return false
    end
    return true
end

function EFFECT:Render()
    -- Efekt już renderowany przez cząsteczki
end 


================================================
FILE: gamemodes/breach/effects/sillytracer.lua
================================================
EFFECT.Mat = Material( "trails/smoke" )

function EFFECT:Init( data )

	self.texcoord = math.Rand( 0, 20 )/3
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self.EndPos = data:GetOrigin()

	self.Entity:SetCollisionBounds( self.StartPos -  self.EndPos, Vector( 110, 110, 110 ) )
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos, Vector()*8 )
	
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	
	self.Alpha = 195
	self.FlashA = 255
	
end

function EFFECT:Think( )

	self.FlashA = self.FlashA - 650 * FrameTime()
	if (self.FlashA < 0) then self.FlashA = 0 end

	self.Alpha = self.Alpha - 1150 * FrameTime()
	if (self.Alpha < 0) then return false end
	
	return true

end

function EFFECT:Render( )
	
	self.Length = (self.StartPos - self.EndPos):Length()
	
	local texcoord = self.texcoord
	
		render.SetMaterial( self.Mat )
		render.DrawBeam( self.StartPos,
					 self.EndPos,
					 4,
					 texcoord,													
					 texcoord + self.Length / 256,
					 Color( 255, 255, 255, math.Clamp(self.Alpha, 0,195)) )
					 
end 


================================================
FILE: gamemodes/breach/entities/ender_pearl.lua
================================================
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"

function ENT:Initialize()
	self:SetModel("models/lolixtin/ender_pearl.mdl")
	self:PhysicsInitSphere(6,"metal")
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)
end

function ENT:OnRemove()
	local pos = nil
	local x = self:GetPos():ToTable()[1] - self:GetOwner():GetPos():ToTable()[1]
	local y = self:GetPos():ToTable()[2] - self:GetOwner():GetPos():ToTable()[2]
	if x > 0 then x=Vector(-20,0,0) else x=Vector(20,0,0) end
	if y > 0 then y=Vector(0,-20,0) else y=Vector(0,20,0) end
	pos = self:GetPos()+x+y;
	if self:GetOwner():GetAimVector():ToTable()[3] > 0 then pos = pos - Vector(0,0,self:GetOwner():GetAimVector():ToTable()[3])*100 end

	self:GetOwner():SetPos(pos)
end

function ENT:PhysicsCollide(cd,po)	
	self:EmitSound(Sound("portal"..math.random(1,2)..".wav"))
	local e = EffectData()
	e:SetOrigin(self:GetPos()+Vector(0,0,25))
	util.Effect("pearl_particle",e)
	self:Remove()
end 


================================================
FILE: gamemodes/breach/entities/effects/br_heal.lua
================================================
AddCSLuaFile()

EFFECT.material = Material( "particles/white.png" )

function EFFECT:Init( fx )
	local pos = fx:GetOrigin()

	local emitter = ParticleEmitter( pos, false )
		for i=0, 25 do

			local ang = math.random( 0, 360 )
			local length = math.random( 10, 150 )

			local posx, posy = math.sin( ang ) * length, math.cos( ang ) * length

			local particle = emitter:Add( self.material, pos + Vector( posx, posy, 0 ) )
			if particle then

				local vel = Vector( 0, 0, math.random( 10, 30 ) )
				local dt = math.random( 20, 50 ) / 10
				local ssize = math.random( 15, 30 ) / 10
				local esize = math.random( 5, 10 ) / 10
				local color = math.random( 100, 230 )

				particle:SetVelocity( vel )
				particle:SetColor( 0, color, 0 )

				particle:SetLifeTime( 0 )
				particle:SetDieTime( dt )

				particle:SetStartAlpha( 255 )
				particle:SetEndAlpha( 0 )

				particle:SetStartSize( ssize )
				particle:SetEndSize( esize )

			end
		end
	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end


================================================
FILE: gamemodes/breach/entities/entities/armor_base.lua
================================================
AddCSLuaFile()

ENT.PrintName		= "Base Armor"
ENT.Author		    = "Kanade"
ENT.Type			= "anim"
ENT.Spawnable		= true
ENT.AdminSpawnable	= true
ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.ArmorType = "armor_mtfguard"

function ENT:Initialize()
	self.Entity:SetModel("models/combine_vests/militaryvest.mdl")
	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	//self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_NONE)
	self.Entity:SetSolid(SOLID_BBOX)
	if SERVER then
		self:SetUseType(SIMPLE_USE)
	end
	
	//local phys = self.Entity:GetPhysicsObject()

	//if phys and phys:IsValid() then phys:Wake() end
	self:SetCollisionGroup(COLLISION_GROUP_WEAPON) 
end

function ENT:Use(ply)
	if ply:GTeam() == TEAM_SPEC or ( ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 and ply:GetNClass() != ROLES.ROLE_SCP035 ) or ply:Alive() == false then return end
	if ply.UsingArmor != nil then
		ply:PrintMessage(HUD_PRINTTALK, 'You already have a vest, type "dropvest" in the chat to drop it')
		return
	end
	-- Security Droid nie może nosić vestów
	if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] ERROR: Armor incompatible with droid chassis!")
		ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
		return
	end
	-- SCP-035 system vestów
	if ply:GetNClass() == ROLES.ROLE_SCP035 then
		if ply.LockedArmor == true then
			-- Miał vest przed transformacją - nie może go zmienić
			ply:PrintMessage(HUD_PRINTTALK, "[SCP-035] Your vest is fused with your body and cannot be changed!")
			print("[SCP-035 DEBUG] " .. ply:Nick() .. " tried to change locked vest")
			return
		elseif ply.LockedArmor == false then
			-- Nie miał vesta przed transformacją - nie może założyć żadnego
			ply:PrintMessage(HUD_PRINTTALK, "[SCP-035] The vest phases through your corrupted body...")
			print("[SCP-035 DEBUG] " .. ply:Nick() .. " tried to equip vest but had none before transformation")
			return
		else
			-- LockedArmor nie jest ustawione - gracz nie był SCP-035 od początku
			ply:PrintMessage(HUD_PRINTTALK, "[SCP-035] ERROR: Invalid vest state for SCP-035!")
			print("[SCP-035 ERROR] " .. ply:Nick() .. " has undefined LockedArmor state")
			return
		end
	end

	if SERVER then
		ply:ApplyArmor(self.ArmorType)
		self:EmitSound( Sound("npc/combine_soldier/gear".. math.random(1, 6).. ".wav") )
		self:Remove()
		ply.UsingArmor = self.ArmorType
	end
	if CLIENT then
		chat.AddText('You are now wearing an armor, type "dropvest" in the chat to drop it')
	end
end

function ENT:Draw()
	self:DrawModel()
	local ply = LocalPlayer()
	if ply:GetPos():Distance(self:GetPos()) > 180 then
		return
	end
	if IsValid(self) then
		cam.Start2D()
			if DrawInfo != nil then
				DrawInfo(self:GetPos() + Vector(0,0,15), self.PrintName, Color(255,255,255))
			end
		cam.End2D()
	end
end


================================================
FILE: gamemodes/breach/entities/entities/armor_chaosins.lua
================================================
AddCSLuaFile()

ENT.Base		= "armor_base"
ENT.PrintName	= "Chaos Insurgency Vest"
ENT.ArmorType	= "armor_chaosins"

function ENT:Use(ply)
	-- Sprawdź czy gracz może używać tego vesta
	if ply:GTeam() == TEAM_SPEC or ( ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 ) or ply:Alive() == false then return end
	
	-- GOC nie może używać Chaos vestów
	if ply:GTeam() == TEAM_GOC then
		ply:PrintMessage(HUD_PRINTTALK, "GOC personnel cannot use Chaos Insurgency equipment!")
		return
	end
	
	if ply.UsingArmor != nil then
		ply:PrintMessage(HUD_PRINTTALK, 'You already have a vest, type "dropvest" in the chat to drop it')
		return
	end
	
	-- Security Droid nie może nosić vestów
	if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] ERROR: Armor incompatible with droid chassis!")
		ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
		return
	end
	
	if SERVER then
		ply:ApplyArmor(self.ArmorType)
		self:EmitSound( Sound("npc/combine_soldier/gear".. math.random(1, 6).. ".wav") )
		self:Remove()
		ply.UsingArmor = self.ArmorType
	end
	if CLIENT then
		chat.AddText('You are now wearing an armor, type "dropvest" in the chat to drop it')
	end
end


================================================
FILE: gamemodes/breach/entities/entities/armor_csecurity.lua
================================================
AddCSLuaFile()

ENT.Base		= "armor_base"
ENT.PrintName	= "Security Chief Vest"
ENT.ArmorType	= "armor_csecurity"

function ENT:Use(ply)
	-- Sprawdź czy gracz może używać tego vesta
	if ply:GTeam() == TEAM_SPEC or ( ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 ) or ply:Alive() == false then return end
	
	-- GOC nie może używać Security vestów
	if ply:GTeam() == TEAM_GOC then
		ply:PrintMessage(HUD_PRINTTALK, "GOC personnel cannot use Foundation security equipment!")
		return
	end
	
	if ply.UsingArmor != nil then
		ply:PrintMessage(HUD_PRINTTALK, 'You already have a vest, type "dropvest" in the chat to drop it')
		return
	end
	
	-- Security Droid nie może nosić vestów
	if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] ERROR: Armor incompatible with droid chassis!")
		ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
		return
	end
	

	
	if SERVER then
		ply:ApplyArmor(self.ArmorType)
		self:EmitSound( Sound("npc/combine_soldier/gear".. math.random(1, 6).. ".wav") )
		self:Remove()
		ply.UsingArmor = self.ArmorType
	end
	if CLIENT then
		chat.AddText('You are now wearing an armor, type "dropvest" in the chat to drop it')
	end
end


================================================
FILE: gamemodes/breach/entities/entities/armor_electroproof.lua
================================================
AddCSLuaFile()

ENT.Base		= "armor_base"
ENT.PrintName	= "Electroproof Vest"
ENT.ArmorType	= "armor_electroproof"

function ENT:Use(ply)
	-- Sprawdź czy gracz może używać tego vesta
	if ply:GTeam() == TEAM_SPEC or ( ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 ) or ply:Alive() == false then return end
	
	-- GOC nie może używać Electroproof vestów
	if ply:GTeam() == TEAM_GOC then
		ply:PrintMessage(HUD_PRINTTALK, "GOC personnel cannot use Foundation specialized equipment!")
		return
	end
	
	if ply.UsingArmor != nil then
		ply:PrintMessage(HUD_PRINTTALK, 'You already have a vest, type "dropvest" in the chat to drop it')
		return
	end
	
	-- Security Droid nie może nosić vestów
	if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] ERROR: Armor incompatible with droid chassis!")
		ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
		return
	end
	
	if SERVER then
		ply:ApplyArmor(self.ArmorType)
		self:EmitSound( Sound("npc/combine_soldier/gear".. math.random(1, 6).. ".wav") )
		self:Remove()
		ply.UsingArmor = self.ArmorType
	end
	if CLIENT then
		chat.AddText('You are now wearing an armor, type "dropvest" in the chat to drop it')
	end
end


================================================
FILE: gamemodes/breach/entities/entities/armor_fireproof.lua
================================================
AddCSLuaFile()

ENT.Base		= "armor_base"
ENT.PrintName	= "Fireproof Vest"
ENT.ArmorType	= "armor_fireproof"

function ENT:Use(ply)
	-- Sprawdź czy gracz może używać tego vesta
	if ply:GTeam() == TEAM_SPEC or ( ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 ) or ply:Alive() == false then return end
	
	-- GOC nie może używać Fireproof vestów
	if ply:GTeam() == TEAM_GOC then
		ply:PrintMessage(HUD_PRINTTALK, "GOC personnel cannot use Foundation specialized equipment!")
		return
	end
	
	if ply.UsingArmor != nil then
		ply:PrintMessage(HUD_PRINTTALK, 'You already have a vest, type "dropvest" in the chat to drop it')
		return
	end
	
	-- Security Droid nie może nosić vestów
	if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] ERROR: Armor incompatible with droid chassis!")
		ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
		return
	end
	
	if SERVER then
		ply:ApplyArmor(self.ArmorType)
		self:EmitSound( Sound("npc/combine_soldier/gear".. math.random(1, 6).. ".wav") )
		self:Remove()
		-- Debug
		print("[FIREPROOF VEST] Applied to " .. ply:Nick() .. ", UsingArmor = " .. tostring(ply.UsingArmor))
	end
	if CLIENT then
		chat.AddText('You are now wearing an armor, type "dropvest" in the chat to drop it')
	end
	-- Removed duplicate: ply.UsingArmor = self.ArmorType (ApplyArmor already sets this)
end


================================================
FILE: gamemodes/breach/entities/entities/armor_goc.lua
================================================
AddCSLuaFile()

ENT.Base		= "armor_base"
ENT.PrintName	= "GOC Vest"
ENT.ArmorType	= "armor_goc"

function ENT:Use(ply)
	-- Sprawdź czy gracz może używać tego vesta
	if ply:GTeam() == TEAM_SPEC or ( ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 ) or ply:Alive() == false then return end
	
	-- Tylko GOC może używać GOC vest
	if ply:GTeam() != TEAM_GOC then
		ply:PrintMessage(HUD_PRINTTALK, "Only GOC personnel can use this vest!")
		return
	end
	
	if ply.UsingArmor != nil then
		ply:PrintMessage(HUD_PRINTTALK, 'You already have a vest, type "dropvest" in the chat to drop it')
		return
	end
	
	-- Security Droid nie może nosić vestów
	if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] ERROR: Armor incompatible with droid chassis!")
		ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
		return
	end
	
	if SERVER then
		ply:ApplyArmor(self.ArmorType)
		self:EmitSound( Sound("npc/combine_soldier/gear".. math.random(1, 6).. ".wav") )
		self:Remove()
		ply.UsingArmor = self.ArmorType
	end
	if CLIENT then
		chat.AddText('You are now wearing a GOC vest, type "dropvest" in the chat to drop it')
	end
end


================================================
FILE: gamemodes/breach/entities/entities/armor_hazmat.lua
================================================
AddCSLuaFile()

ENT.Base		= "armor_base"
ENT.PrintName	= "Hazmat Suit"
ENT.ArmorType	= "armor_hazmat"

function ENT:Use(ply)
	-- Sprawdź czy gracz może używać tego vesta
	if ply:GTeam() == TEAM_SPEC or ( ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 ) or ply:Alive() == false then return end
	
	-- GOC nie może używać Hazmat vestów
	if ply:GTeam() == TEAM_GOC then
		ply:PrintMessage(HUD_PRINTTALK, "GOC personnel cannot use Foundation hazmat equipment!")
		return
	end
	
	if ply.UsingArmor != nil then
		ply:PrintMessage(HUD_PRINTTALK, 'You already have a vest, type "dropvest" in the chat to drop it')
		return
	end
	
	-- Security Droid nie może nosić vestów
	if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] ERROR: Armor incompatible with droid chassis!")
		ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
		return
	end
	

	
	if SERVER then
		ply:ApplyArmor(self.ArmorType)
		self:EmitSound( Sound("npc/combine_soldier/gear".. math.random(1, 6).. ".wav") )
		self:Remove()
		ply.UsingArmor = self.ArmorType
	end
	if CLIENT then
		chat.AddText('You are now wearing an armor, type "dropvest" in the chat to drop it')
	end
end


================================================
FILE: gamemodes/breach/entities/entities/armor_heavysupport.lua
================================================
AddCSLuaFile()

ENT.Base		= "armor_base"
ENT.PrintName	= "Heavy Support Vest"
ENT.ArmorType	= "armor_heavysupport"

function ENT:Use(ply)
	-- Sprawdź czy gracz może używać tego vesta
	if ply:GTeam() == TEAM_SPEC or ( ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 ) or ply:Alive() == false then return end
	
	-- GOC nie może używać MTF vestów
	if ply:GTeam() == TEAM_GOC then
		ply:PrintMessage(HUD_PRINTTALK, "GOC personnel cannot use MTF equipment!")
		return
	end
	
	if ply.UsingArmor != nil then
		ply:PrintMessage(HUD_PRINTTALK, 'You already have a vest, type "dropvest" in the chat to drop it')
		return
	end
	
	-- Security Droid nie może nosić vestów
	if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] ERROR: Armor incompatible with droid chassis!")
		ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
		return
	end
	

	
	if SERVER then
		ply:ApplyArmor(self.ArmorType)
		self:EmitSound( Sound("npc/combine_soldier/gear".. math.random(1, 6).. ".wav") )
		self:Remove()
		ply.UsingArmor = self.ArmorType
	end
	if CLIENT then
		chat.AddText('You are now wearing Heavy Support armor, type "dropvest" in the chat to drop it')
	end
end 


================================================
FILE: gamemodes/breach/entities/entities/armor_mtfcom.lua
================================================
AddCSLuaFile()

ENT.Base		= "armor_base"
ENT.PrintName	= "MTF Commander Vest"
ENT.ArmorType	= "armor_mtfcom"

function ENT:Use(ply)
	-- Sprawdź czy gracz może używać tego vesta
	if ply:GTeam() == TEAM_SPEC or ( ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 ) or ply:Alive() == false then return end
	
	-- GOC nie może używać MTF vestów
	if ply:GTeam() == TEAM_GOC then
		ply:PrintMessage(HUD_PRINTTALK, "GOC personnel cannot use MTF equipment!")
		return
	end
	
	if ply.UsingArmor != nil then
		ply:PrintMessage(HUD_PRINTTALK, 'You already have a vest, type "dropvest" in the chat to drop it')
		return
	end
	
	-- Security Droid nie może nosić vestów
	if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] ERROR: Armor incompatible with droid chassis!")
		ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
		return
	end
	

	
	if SERVER then
		ply:ApplyArmor(self.ArmorType)
		self:EmitSound( Sound("npc/combine_soldier/gear".. math.random(1, 6).. ".wav") )
		self:Remove()
		ply.UsingArmor = self.ArmorType
	end
	if CLIENT then
		chat.AddText('You are now wearing an armor, type "dropvest" in the chat to drop it')
	end
end


================================================
FILE: gamemodes/breach/entities/entities/armor_mtfguard.lua
================================================
AddCSLuaFile()

ENT.Base		= "armor_base"
ENT.PrintName	= "MTF Guard Vest"
ENT.ArmorType	= "armor_mtfguard"

function ENT:Use(ply)
	-- Sprawdź czy gracz może używać tego vesta
	if ply:GTeam() == TEAM_SPEC or ( ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 and ply:GetNClass() != ROLES.ROLE_SCP035 ) or ply:Alive() == false then return end
	
	-- GOC nie może używać MTF vestów
	if ply:GTeam() == TEAM_GOC then
		ply:PrintMessage(HUD_PRINTTALK, "GOC personnel cannot use MTF equipment!")
		return
	end
	
	if ply.UsingArmor != nil then
		ply:PrintMessage(HUD_PRINTTALK, 'You already have a vest, type "dropvest" in the chat to drop it')
		return
	end
	
	-- Security Droid nie może nosić vestów
	if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] ERROR: Armor incompatible with droid chassis!")
		ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
		return
	end
	

	
	if SERVER then
		ply:ApplyArmor(self.ArmorType)
		self:EmitSound( Sound("npc/combine_soldier/gear".. math.random(1, 6).. ".wav") )
		self:Remove()
		ply.UsingArmor = self.ArmorType
	end
	if CLIENT then
		chat.AddText('You are now wearing an armor, type "dropvest" in the chat to drop it')
	end
end


================================================
FILE: gamemodes/breach/entities/entities/armor_mtfl.lua
================================================
AddCSLuaFile()

ENT.Base		= "armor_base"
ENT.PrintName	= "MTFL Vest"
ENT.ArmorType	= "armor_mtfl"

function ENT:Use(ply)
	-- Sprawdź czy gracz może używać tego vesta
	if ply:GTeam() == TEAM_SPEC or ( ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 ) or ply:Alive() == false then return end
	
	-- GOC nie może używać MTF vestów
	if ply:GTeam() == TEAM_GOC then
		ply:PrintMessage(HUD_PRINTTALK, "GOC personnel cannot use MTF equipment!")
		return
	end
	
	if ply.UsingArmor != nil then
		ply:PrintMessage(HUD_PRINTTALK, 'You already have a vest, type "dropvest" in the chat to drop it')
		return
	end
	
	-- Security Droid nie może nosić vestów
	if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] ERROR: Armor incompatible with droid chassis!")
		ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
		return
	end
	

	
	if SERVER then
		ply:ApplyArmor(self.ArmorType)
		self:EmitSound( Sound("npc/combine_soldier/gear".. math.random(1, 6).. ".wav") )
		self:Remove()
		ply.UsingArmor = self.ArmorType
	end
	if CLIENT then
		chat.AddText('You are now wearing an armor, type "dropvest" in the chat to drop it')
	end
end


================================================
FILE: gamemodes/breach/entities/entities/armor_mtfmedic.lua
================================================
AddCSLuaFile()

ENT.Base		= "armor_base"
ENT.PrintName	= "MTF Medic Vest"
ENT.ArmorType	= "armor_mtfmedic"

function ENT:Use(ply)
	-- Sprawdź czy gracz może używać tego vesta
	if ply:GTeam() == TEAM_SPEC or ( ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 ) or ply:Alive() == false then return end
	
	-- GOC nie może używać MTF vestów
	if ply:GTeam() == TEAM_GOC then
		ply:PrintMessage(HUD_PRINTTALK, "GOC personnel cannot use MTF equipment!")
		return
	end
	
	if ply.UsingArmor != nil then
		ply:PrintMessage(HUD_PRINTTALK, 'You already have a vest, type "dropvest" in the chat to drop it')
		return
	end
	
	-- Security Droid nie może nosić vestów
	if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] ERROR: Armor incompatible with droid chassis!")
		ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
		return
	end
	

	
	if SERVER then
		ply:ApplyArmor(self.ArmorType)
		self:EmitSound( Sound("npc/combine_soldier/gear".. math.random(1, 6).. ".wav") )
		self:Remove()
		ply.UsingArmor = self.ArmorType
	end
	if CLIENT then
		chat.AddText('You are now wearing an armor, type "dropvest" in the chat to drop it')
	end
end


================================================
FILE: gamemodes/breach/entities/entities/armor_ntf.lua
================================================
AddCSLuaFile()

ENT.Base		= "armor_base"
ENT.PrintName	= "NTF Vest"
ENT.ArmorType	= "armor_ntf"

function ENT:Use(ply)
	-- Sprawdź czy gracz może używać tego vesta
	if ply:GTeam() == TEAM_SPEC or ( ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 and ply:GetNClass() != ROLES.ROLE_SCP035 ) or ply:Alive() == false then return end
	
	-- GOC nie może używać NTF vestów
	if ply:GTeam() == TEAM_GOC then
		ply:PrintMessage(HUD_PRINTTALK, "GOC personnel cannot use NTF equipment!")
		return
	end
	
	if ply.UsingArmor != nil then
		ply:PrintMessage(HUD_PRINTTALK, 'You already have a vest, type "dropvest" in the chat to drop it')
		return
	end
	
	-- Security Droid nie może nosić vestów
	if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] ERROR: Armor incompatible with droid chassis!")
		ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
		return
	end
	
	if SERVER then
		ply:ApplyArmor(self.ArmorType)
		self:EmitSound( Sound("npc/combine_soldier/gear".. math.random(1, 6).. ".wav") )
		self:Remove()
		ply.UsingArmor = self.ArmorType
	end
	if CLIENT then
		chat.AddText('You are now wearing an armor, type "dropvest" in the chat to drop it')
	end
end


================================================
FILE: gamemodes/breach/entities/entities/armor_security.lua
================================================
AddCSLuaFile()

ENT.Base		= "armor_base"
ENT.PrintName	= "Security Vest"
ENT.ArmorType	= "armor_security"

function ENT:Use(ply)
	-- Sprawdź czy gracz może używać tego vesta
	if ply:GTeam() == TEAM_SPEC or ( ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 and ply:GetNClass() != ROLES.ROLE_SCP035 ) or ply:Alive() == false then return end
	
	-- GOC nie może używać Security vestów
	if ply:GTeam() == TEAM_GOC then
		ply:PrintMessage(HUD_PRINTTALK, "GOC personnel cannot use Foundation security equipment!")
		return
	end
	
	if ply.UsingArmor != nil then
		ply:PrintMessage(HUD_PRINTTALK, 'You already have a vest, type "dropvest" in the chat to drop it')
		return
	end
	
	-- Security Droid nie może nosić vestów
	if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] ERROR: Armor incompatible with droid chassis!")
		ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
		return
	end
	

	
	if SERVER then
		ply:ApplyArmor(self.ArmorType)
		self:EmitSound( Sound("npc/combine_soldier/gear".. math.random(1, 6).. ".wav") )
		self:Remove()
		ply.UsingArmor = self.ArmorType
	end
	if CLIENT then
		chat.AddText('You are now wearing an armor, type "dropvest" in the chat to drop it')
	end
end


================================================
FILE: gamemodes/breach/entities/entities/br_gift.lua
================================================
AddCSLuaFile()

ENT.Base = "base_entity"

ENT.Type = "anim"
ENT.Category = "Breach"


ENT.Author = "danx91"

ENT.PrintName = ""
ENT.GiftType = false

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "GiftType" )
end

function ENT:Initialize()
	self.GiftType = self:GetGiftType()
	local model = self.GiftType and "models/katharsmodels/present/type-2/big/present3.mdl" or "models/katharsmodels/present/type-2/big/present2.mdl" 
	self:SetModel( model )
	self:SetMoveType( MOVETYPE_VPHYSICS )
	self:SetSolid( SOLID_VPHYSICS )

	if SERVER then
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )
	end

	self:SetCollisionGroup( COLLISION_GROUP_DEBRIS_TRIGGER )

	local phys = self:GetPhysicsObject()
	if IsValid( phys ) then
		phys:Wake()
	end
	if SERVER then
		timer.Simple( 3, function()
			if IsValid( self ) then
				if self.GiftType then

					local fx = EffectData()
					fx:SetOrigin( self:GetPos() )
					util.Effect( "br_heal", fx )

		        	local fent = ents.FindInSphere( self:GetPos(), 100 )		
		        	for k, v in pairs( fent ) do
		        		if IsValid( v ) and v:IsPlayer() then
		        			if v:GTeam() != TEAM_SPEC then
		        				local dist = self:GetPos():Distance( v:GetPos() )
		        				local health = math.Clamp( v:Health() + math.random( 20, 40 ), 1, v:GetMaxHealth() )
		        				v:SetHealth( health )
		        			end
		        		end
		        	end
				else
					local explosion = ents.Create( "env_explosion" )
		        	explosion:SetKeyValue( "spawnflags", 145 )
		        	explosion:SetPos( self:GetPos() )
		        	explosion:Spawn()
		        	explosion:Fire( "explode", "", 0 )
		        	local fent = ents.FindInSphere( self:GetPos(), 300 )
		        	for k, v in pairs( fent ) do
		        		if IsValid( v ) then
		        			if v:IsPlayer() then
			        			if v:GTeam() != TEAM_SPEC and v:GTeam() != TEAM_SCP then
			        				local dist = self:GetPos():Distance( v:GetPos() )
			        				local dmg = ( 300 - dist ) / 4
			        				v:TakeDamage( dmg, self.Owner, self.Owner )
			        			end
			        		elseif v:GetClass() == "func_breakable" then
			        			v:TakeDamage( 50, self.Owner, self.Owner )
			        		end
		        		end
		        	end
				end
				self:Remove()
			end
		end )
	end
end

function ENT:SetPhysVelocity( vel )
	self:SetVelocity( vel )
	local phys = self:GetPhysicsObject()
	if IsValid( phys ) then
		phys:SetVelocity( vel )
	end
end

function ENT:Draw()
	self:DrawModel()
end


================================================
FILE: gamemodes/breach/entities/entities/br_kebab_meat.lua
================================================
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Döner Meat"
ENT.Author = "Breach Team"
ENT.Contact = ""
ENT.Purpose = "Rotating döner meat"
ENT.Instructions = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Category = "Breach Food Service"

function ENT:Initialize()
    print("[KEBAB MEAT DEBUG] Initialize called")
    self:SetModel("models/doner_makinesi/doner_doner.mdl")
    print("[KEBAB MEAT DEBUG] Model set to doner_doner.mdl")
    self:PhysicsInit(SOLID_VPHYSICS)
    self:SetMoveType(MOVETYPE_NONE)
    self:SetSolid(SOLID_VPHYSICS)
    print("[KEBAB MEAT DEBUG] Physics initialized")

    local phys = self:GetPhysicsObject()
    if IsValid(phys) then
        phys:Wake()
        phys:EnableMotion(false)
        print("[KEBAB MEAT DEBUG] Physics object configured")
    else
        print("[KEBAB MEAT DEBUG] WARNING: No physics object!")
    end

    self.RotationSpeed = 30 -- degrees per second
    print("[KEBAB MEAT DEBUG] Kebab meat initialization complete")
end

function ENT:Think()
    if CLIENT then return end
    
    -- Rotate the meat slowly
    local angles = self:GetAngles()
    angles.y = angles.y + (self.RotationSpeed * FrameTime())
    self:SetAngles(angles)
    
    self:NextThink(CurTime() + 0.01)
    return true
end 


================================================
FILE: gamemodes/breach/entities/entities/br_kebab_stand.lua
================================================
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Döner Kebab Stand"
ENT.Author = "Breach Team"
ENT.Contact = ""
ENT.Purpose = "Healing kebab station for facility personnel"
ENT.Instructions = "Use [E] to get kebab and heal"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Category = "Breach Food Service"

if CLIENT then
    surface.CreateFont("breach_kebab_title", {
        font = "Arial",
        extended = false,
        size = 24,
        weight = 700,
        blursize = 0,
        scanlines = 0,
        antialias = true,
        underline = false,
        italic = false,
        strikeout = false,
        symbol = false,
        rotary = false,
        shadow = false,
        additive = false,
        outline = false,
    })
    
    surface.CreateFont("breach_kebab_status", {
        font = "Arial",
        extended = false,
        size = 18,
        weight = 500,
        blursize = 0,
        scanlines = 0,
        antialias = true,
        underline = false,
        italic = false,
        strikeout = false,
        symbol = false,
        rotary = false,
        shadow = false,
        additive = false,
        outline = false,
    })
end

function ENT:Draw()
    self:DrawModel()

    local Ang = self:GetAngles()
    Ang:RotateAroundAxis(self:GetUp(), 90)
    Ang:RotateAroundAxis(self:GetRight(), 90)
    Ang:RotateAroundAxis(self:GetForward(), 180)

    -- Title sign
    cam.Start3D2D(self:GetPos() + self:GetUp() * 60 - self:GetRight() * 2 + self:GetForward() * 7, Ang, 0.1)
        draw.RoundedBox(4, -100, -20, 200, 40, Color(150, 50, 0, 200))
        draw.SimpleText("DÖNER KEBAB", "breach_kebab_title", 0, 0, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    cam.End3D2D()

    -- Status display
    cam.Start3D2D(self:GetPos() - self:GetForward() * 16.5 - self:GetRight() * 9 - self:GetUp() * 0.5, Ang, 0.08)
        local portions = self:GetNWInt("portions", 10)
        local status_text = "Ready: " .. portions .. " portions"
        local status_color = Color(0, 255, 0)
        
        if portions <= 0 then
            status_text = "Empty"
            status_color = Color(255, 0, 0)
        elseif portions <= 3 then
            status_color = Color(255, 165, 0)
        end
        
        draw.SimpleText(status_text, "breach_kebab_status", 0, 0, status_color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    cam.End3D2D()
end

function ENT:Initialize()
    print("[KEBAB DEBUG] Initialize called")
    self:SetModel("models/doner_makinesi/doner_stand.mdl")
    print("[KEBAB DEBUG] Model set")
    self:PhysicsInit(SOLID_VPHYSICS)
    self:SetMoveType(MOVETYPE_NONE)
    self:SetSolid(SOLID_VPHYSICS)
    print("[KEBAB DEBUG] Physics initialized")

    local phys = self:GetPhysicsObject()
    if IsValid(phys) then
        phys:Wake()
        phys:EnableMotion(false)
        print("[KEBAB DEBUG] Physics object configured")
    else
        print("[KEBAB DEBUG] WARNING: No physics object!")
    end

    if CLIENT then
        self.kebab_entity = self:GetNWEntity("kebab_entity")
        print("[KEBAB DEBUG] Client initialization done")
        return
    end

    print("[KEBAB DEBUG] Server initialization starting")
    -- SERVER only code
    self:SetUseType(SIMPLE_USE)
    
    -- Initialize player usage tracking
    self.used_players = {}
    
    -- Create döner meat entity
    local kebab = ents.Create("br_kebab_meat")
    if IsValid(kebab) then
        kebab:SetPos(self:GetPos() - self:GetForward() * 4.5 + self:GetUp() * 26)
        kebab:SetAngles(self:GetAngles())
        kebab:SetParent(self)
        kebab:Spawn()
        kebab:SetMoveType(MOVETYPE_NONE)
        kebab:SetLocalAngles(Angle(0, 0, 0))
        
        -- Make sure kebab is visible
        kebab:SetNoDraw(false)
        kebab:SetColor(Color(255, 255, 255, 255))
        
        self.kebab = kebab
        self:SetNWEntity("kebab_entity", kebab)
        print("[KEBAB DEBUG] Kebab meat entity created at: " .. tostring(kebab:GetPos()))
    else
        print("[KEBAB DEBUG] ERROR: Failed to create kebab meat entity")
    end

    self.next_use = 0
    self:SetNWInt("portions", 10) -- Start with 10 portions
    print("[KEBAB DEBUG] Server initialization complete, portions set to 10")
end

function ENT:Use(ply, caller, useType, value)
    if not IsValid(ply) or not ply:IsPlayer() then return end
    if CurTime() < self.next_use then return end
    
    -- Check if player is SCP (excluding SCP-999 which is friendly)
    if ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP999 then
        ply:PrintMessage(HUD_PRINTTALK, "[KEBAB] SCPs cannot consume human food!")
        return
    end
    
    -- Check if player is Security Droid
    if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
        ply:PrintMessage(HUD_PRINTTALK, "[KEBAB] ERROR: Food incompatible with droid chassis!")
        ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
        return
    end
    
    -- Check if player is spectator
    if ply:GTeam() == TEAM_SPEC then
        ply:PrintMessage(HUD_PRINTTALK, "[KEBAB] Spectators cannot use kebab stand!")
        return
    end
    
    local portions = self:GetNWInt("portions", 0)
    
    if portions <= 0 then
        ply:PrintMessage(HUD_PRINTTALK, "[KEBAB] Stand is empty! Wait for next round.")
        return
    end
    
    -- Check if player already used kebab stand this round
    local steamid = ply:SteamID()
    if self.used_players[steamid] then
        ply:PrintMessage(HUD_PRINTTALK, "[KEBAB] You already got kebab this round! One per person.")
        return
    end
    
    -- Check if player already has kebab
    if ply:HasWeapon("weapon_doner_ayran") then
        ply:PrintMessage(HUD_PRINTTALK, "[KEBAB] You already have kebab! Eat it first.")
        return
    end
    
    -- Give kebab weapon instead of direct healing
    ply:Give("weapon_doner_ayran")
    
    -- Mark player as having used kebab stand this round
    self.used_players[steamid] = true
    
    -- Reduce portions
    portions = portions - 1
    self:SetNWInt("portions", portions)
    
    -- Update döner size
    if IsValid(self.kebab) then
        local scale_factor = portions / 10
        self.kebab:SetModelScale(math.max(scale_factor, 0.1), 0)
    end

    self.next_use = CurTime() + 1
    
    ply:PrintMessage(HUD_PRINTTALK, "[KEBAB] Got fresh kebab! Use LMB to eat it. Portions left: " .. portions)
    
    -- Sound effect
    ply:EmitSound("physics/cardboard/cardboard_box_impact_hard3.wav", 60, 100)
end

function ENT:OnRemove()
    if SERVER and IsValid(self.kebab) then
        self.kebab:Remove()
    end
end 


================================================
FILE: gamemodes/breach/entities/entities/breach_baseammo.lua
================================================
AddCSLuaFile()

ENT.Type = "anim"
ENT.AmmoID = 0
ENT.AmmoType = "Pistol"
ENT.PName = "Pistol Ammo"
ENT.AmmoAmount = 1
ENT.MaxUses = 2
ENT.Model = Model( "models/items/boxsrounds.mdl" )

function ENT:Initialize()
	self:SetModel( self.Model )
	self:PhysicsInit( SOLID_VPHYSICS )
	self:SetMoveType( MOVETYPE_NONE )
	self:SetSolid( SOLID_BBOX )
end

function ENT:Use( activator, caller )
	if activator:GTeam() != TEAM_SPEC and activator:GTeam() != TEAM_SCP then
		local gotawep = false
		for k,v in pairs(activator:GetWeapons()) do
			if v.Primary != nil then
				if v.Primary.Ammo == self.AmmoType then
					gotawep = true
				end
			end
		end
		if gotawep == false then
			activator:PrintMessage(HUD_PRINTCENTER, "What are you going to do with this ammo when you dont have a weapon?")
			return
		end
		if activator.MaxUses != nil then
			if self.AmmoID > #activator.MaxUses then
				for i=1, self.AmmoID do
					if activator.MaxUses[i] == nil then
						if i == self.AmmoID then
							table.ForceInsert(activator.MaxUses, 1)
							activator:GiveAmmo(self.AmmoAmount, self.AmmoType, false)
							self:Remove()
						else
							table.ForceInsert(activator.MaxUses, 0)
						end
					end
				end
			else
				if activator.MaxUses[self.AmmoID] >= self.MaxUses then
					activator:PrintMessage(HUD_PRINTCENTER, "You cannot pick-up more ammo")
					return
				else
					activator.MaxUses[self.AmmoID] = activator.MaxUses[self.AmmoID] + 1
					activator:GiveAmmo(self.AmmoAmount, self.AmmoType, false)
					self:Remove()
				end
			end
		else
			activator.MaxUses = {}
			if self.AmmoID != 1 then
				for i=1, self.AmmoID do
					if i == self.AmmoID then
						table.ForceInsert(activator.MaxUses, 1)
					else
						table.ForceInsert(activator.MaxUses, 0)
					end
				end
			else
				table.ForceInsert(activator.MaxUses, 1)
			end
			activator:GiveAmmo(self.AmmoAmount, self.AmmoType, false)
			self:Remove()
		end
	end
end


function ENT:Draw()
	self:DrawModel()
	local ply = LocalPlayer()
	if ply:GetPos():Distance(self:GetPos()) > 200 then
		return
	end
	if IsValid(self) then
		if DrawInfo != nil then
			cam.Start2D()
				DrawInfo(self:GetPos() + Vector(0,0,15), self.PName, Color(255,255,255))
			cam.End2D()
		end
	end
end




================================================
FILE: gamemodes/breach/entities/entities/ent_aaaaaaaaaaaaaaaaaaa.lua
================================================
AddCSLuaFile()

ENT.Type = "anim"
ENT.Model = Model( "models/props_c17/doll01.mdl" )

function ENT:Initialize()
	self:SetModel( self.Model )
	self:PhysicsInit( SOLID_VPHYSICS )
	self:SetMoveType( MOVETYPE_NONE )
	self:SetSolid( SOLID_BBOX )
	self:SetPos(self:GetPos() + Vector(0,0,30))
	if SERVER then
		if roundstats != nil then
			roundstats.secretf = true
		end
	end
end

ENT.LastSound = 0
function ENT:OnTakeDamage( damage )
	if self.LastSound > CurTime() then return end
	self.LastSound = CurTime() + 20
	if !damage:GetAttacker():IsPlayer() then return end
	net.Start("ForcePlaySound")
		net.WriteString("096_2.ogg")
	net.Send(damage:GetAttacker())
	damage:GetAttacker():PrintMessage(HUD_PRINTCENTER, "You shouldn't do that")
end


================================================
FILE: gamemodes/breach/entities/entities/ent_kapkan_mine.lua
================================================
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Kapkan EDD"
ENT.Category = "Arsen's Gadgets"
ENT.Spawnable = true
ENT.Icon = "entities/weapon_kapkan_placer.png"

function ENT:Initialize()
    if SERVER then
        self:SetModel("models/arsen/Tripmine.mdl")
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_NONE)
        self:SetSolid(SOLID_VPHYSICS)  
        self:SetMaxHealth(KAPKAN_CONFIG.MineHealth)
        self:SetHealth(KAPKAN_CONFIG.MineHealth)
        self.HasExploded = false
        self.LaserOffset = self:GetRight() * 10
        self:SetNWInt("ExplosionDamage", KAPKAN_CONFIG.ExplosionDamage)
        
        if not KAPKAN_CONFIG.PlayerCollisions then
            self:SetCollisionGroup(COLLISION_GROUP_WEAPON)  
        else
            self:SetCollisionGroup(COLLISION_GROUP_NONE)  
        end
    end
end

function ENT:SpawnFunction(ply, tr, className)
    if not tr.Hit then return end
    
    local ent = ents.Create(className)
    ent:SetPos(tr.HitPos + tr.HitNormal * 1)
    ent:SetAngles(tr.HitNormal:Angle())
    ent:Spawn()
    ent:Activate()
    ent:SetNWInt("ExplosionDamage", KAPKAN_CONFIG.ExplosionDamage)
    
    if IsValid(ply) then
        -- Usunięto wywołanie AddCleanup, które nie jest dostępne w SCP: Breach
        -- ply:AddCleanup("Kapkan Mines", ent)
    end
    
    return ent
end

function ENT:OnTakeDamage(dmg)
    if SERVER and not self.HasExploded then
        self:SetHealth(self:Health() - dmg:GetDamage())
        if self:Health() <= 0 then
            self:Explode()
        end
    end
end

function ENT:Explode()
    if SERVER and not self.HasExploded then
        self.HasExploded = true

        local explode = ents.Create("env_explosion")
        explode:SetPos(self:GetPos())
        explode:SetOwner(self)
        explode:Spawn()
        explode:SetKeyValue("iMagnitude", tostring(self:GetNWInt("ExplosionDamage") or 100))
        explode:Fire("Explode", 0, 0)
        self:Remove()
    end
end

function ENT:Use(activator, caller)
    if SERVER and not self.HasExploded then
        self:EmitSound("buttons/button11.wav")
        local effectdata = EffectData()
        effectdata:SetOrigin(self:GetPos())
        effectdata:SetNormal(Vector(0, 0, 1))
        effectdata:SetMagnitude(2)
        effectdata:SetScale(1)
        effectdata:SetRadius(2)
        util.Effect("ElectricSpark", effectdata)
        self:Remove()
    end
end

function ENT:Think()
    if SERVER and not self.HasExploded then
        local laserStart = self:GetPos() + self.LaserOffset
        local laserEnd = laserStart + self:GetRight() * KAPKAN_CONFIG.LaserLength

        local tr = util.TraceLine({
            start = laserStart,
            endpos = laserEnd,
            filter = function(ent)
                if ent == self then return false end
                if ent:IsWorld() then return false end
                if ent:GetMoveType() == MOVETYPE_NONE then return false end
                return true
            end
        })

        if tr.Hit and IsValid(tr.Entity) then
            self:TriggerMine()
        end

        self:NextThink(CurTime() + 0.05)
        return true
    end
end

function ENT:TriggerMine()
    if not self.HasExploded then
        self:EmitSound("npc/roller/mine/rmine_blip1.wav")
        timer.Simple(KAPKAN_CONFIG.ExplosionDelay, function()
            if IsValid(self) and not self.HasExploded then
                self:Explode()
            end
        end)
    end
end

if CLIENT then
    local laserMat = Material("trails/laser")
    local dotMat = Material("sprites/light_glow02_add")

    function ENT:Draw()
        self:DrawModel()
        
        local startPos = self:GetPos() + self:GetRight() * 10
        local endPos = startPos + self:GetRight() * KAPKAN_CONFIG.LaserLength

        render.SetMaterial(laserMat)
        render.DrawBeam(startPos, endPos, 2, 0, 1, Color(255, 50, 50, 30))
        render.DrawBeam(startPos, endPos, 4, 0, 1, Color(255, 100, 100, 30))

        render.SetMaterial(dotMat)
        render.DrawSprite(endPos, 0, 0, Color(255, 100, 100, 0.1))
        render.DrawSprite(startPos, 4, 4, Color(255, 50, 50, 0.1))
    end

    function ENT:DrawTranslucent()
        self:Draw()
    end

    hook.Add("HUDPaint", "KapkanDisarmText", function()
        local ply = LocalPlayer()
        local ent = ply:GetEyeTrace().Entity
        
        if IsValid(ent) and ent:GetClass() == "ent_kapkan_mine" then
            local distance = ply:GetPos():Distance(ent:GetPos())
            
            if distance <= 200 then
                local pos = ent:GetPos():ToScreen()
                draw.SimpleText("Press E to disarm", "DermaDefault", pos.x, pos.y - 30, Color(0, 250, 250), TEXT_ALIGN_CENTER)
            end
        end
    end)
end


================================================
FILE: gamemodes/breach/entities/entities/ent_scp_018.lua
================================================
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )

ENT.PrintName = "SCP-018"
ENT.Author = "Garry Newman"
ENT.Information = "A super bouncy ball"
ENT.Category = "SCP"

ENT.Editable = true
ENT.Spawnable = true
ENT.AdminOnly = false
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:SpawnFunction( ply, tr, ClassName )

	if ( !tr.Hit ) then return end

	local ent = ents.Create( ClassName )
	ent:SetPos( tr.HitPos + tr.HitNormal)
	ent:Spawn()
	ent:Activate()

	return ent

end

function ENT:Initialize()
	if ( CLIENT ) then
		killicon.Add("ent_scp_018", "vgui/entities/weapon_scp-018", Color( 255, 255, 255, 255 ) );
		language.Add("ent_scp_018", "Super Ball")
	else
		self:SetModel( "models/SCP_Secret_Lab/SCP-018.mdl" )
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		
		self:SetCollisionGroup(COLLISION_GROUP_NONE)
	
		local phys = self:GetPhysicsObject()
		
		if (phys:IsValid()) then
			phys:Wake()
			phys:SetMass(5)
		end
	end
end

function ENT:Think()
	if SERVER then
		if self:GetVelocity():IsEqualTol(Vector(0,0,0),5) == true then
			local exp = ents.Create( "env_explosion" )
			exp:SetPos( self:GetPos() + Vector(0,0,5) )
			exp:Spawn()
			exp:SetKeyValue( "iMagnitude", "150" )
			exp:Fire("Explode", 0, 0)
			exp:Fire("Remove", 0, 0.2)
			self:Remove()
		end
	end
	self:NextThink(CurTime()+5)
	return true
end

local BounceSound = Sound( "garrysmod/balloon_pop_cute.wav" )

function ENT:Touch(v)
	-- Breach compatibility - don't damage spectators or teammates
	if IsValid(v) and v:IsPlayer() then
		if v:GTeam() == TEAM_SPEC then return end
		
		local owner = self:GetNWEntity("BallOwner", self)
		if IsValid(owner) and owner:IsPlayer() then
			-- Don't damage teammates (optional - remove if you want friendly fire)
			-- if owner:GTeam() == v:GTeam() and owner:GTeam() != TEAM_SCP then return end
		end
	end
	
	if self:GetVelocity():IsEqualTol(Vector(0,0,0),500) == false then
		local dmginfo=DamageInfo()
		dmginfo:SetAttacker(self:GetNWEntity("BallOwner",self))
		dmginfo:SetInflictor(self)
		dmginfo:SetDamage(self:GetVelocity():Length()/50 + v:Health()/5)
		dmginfo:SetDamageType(DMG_CRUSH)
		v:TakeDamageInfo(dmginfo)
		if v:IsPlayer() or v:IsNPC() then
			sound.Play( "player/bhit_helmet-1.wav", v:GetPos() + Vector(0,0,10), 75, 100, 100 )
			sound.Play( "player/bhit_helmet-1.wav", v:GetPos() + Vector(0,0,10), 75, 100, 100 )
			sound.Play( "player/bhit_helmet-1.wav", v:GetPos() + Vector(0,0,10), 75, 100, 100 )
		end
	end
end

function ENT:PhysicsCollide( data, physobj )
	-- Play sound on bounce
	if ( data.Speed > 10 && data.DeltaTime > 0.2 ) then
		sound.Play( BounceSound, self:GetPos(), 55, math.random(150, 170), math.Clamp( data.Speed / 150, 0, 1 ) )
	elseif data.Speed > 50 and IsValid(data.HitEntity) then
		-- Breach compatibility check
		if data.HitEntity:IsPlayer() then
			if data.HitEntity:GTeam() == TEAM_SPEC then return end
			
			local owner = self:GetNWEntity("BallOwner", self)
			if IsValid(owner) and owner:IsPlayer() then
				-- Don't damage teammates (optional - remove if you want friendly fire)
				-- if owner:GTeam() == data.HitEntity:GTeam() and owner:GTeam() != TEAM_SCP then return end
			end
		end
		
		local dmginfo=DamageInfo()
		dmginfo:SetAttacker(self:GetNWEntity("BallOwner",self))
		dmginfo:SetInflictor(self)
		dmginfo:SetDamage(data.Speed/30 + data.HitEntity:Health()/5)
		dmginfo:SetDamageType(DMG_CRUSH)
		data.HitEntity:TakeDamageInfo(dmginfo)

		if data.HitEntity:IsPlayer() or data.HitEntity:IsNPC() then
			sound.Play( "player/bhit_helmet-1.wav", data.HitEntity:GetPos() + Vector(0,0,10), 75, 100, 100 )
			sound.Play( "player/bhit_helmet-1.wav", data.HitEntity:GetPos() + Vector(0,0,10), 75, 100, 100 )
			sound.Play( "player/bhit_helmet-1.wav", data.HitEntity:GetPos() + Vector(0,0,10), 75, 100, 100 )
		else
			sound.Play( BounceSound, self:GetPos(), 55, math.random(150, 170), math.Clamp( data.Speed / 150, 0, 1 ) )
		end
	end

	-- Bounce like a crazy bitch
	local LastSpeed = math.max( data.OurOldVelocity:Length(), data.Speed )
	local NewVelocity = physobj:GetVelocity() + Vector(math.random(-2,2),math.random(-2,2),math.random(-2,2))*100
	NewVelocity:Normalize()

	LastSpeed = math.max( NewVelocity:Length(), LastSpeed )

	local TargetVelocity = NewVelocity * LastSpeed * 1.2

	physobj:SetVelocity( TargetVelocity )
end

function ENT:OnTakeDamage( dmginfo )
	-- React physically when shot/getting blown
	self:TakePhysicsDamage( dmginfo )
end

function ENT:Use( activator, caller )
	if ( activator:IsPlayer() ) then
		-- Breach compatibility - don't let spectators pick up
		if activator:GTeam() == TEAM_SPEC then return end
		
		activator:GiveAmmo(1, "ball")
		if !activator:HasWeapon("weapon_scp_018") then
			activator:Give("weapon_scp_018", true)
		end
	end
	self:Remove()
end

if ( SERVER ) then return end

function ENT:Draw()
	self.Entity:DrawModel()
end 


================================================
FILE: gamemodes/breach/entities/entities/item_cctv.lua
================================================
AddCSLuaFile()

ENT.Base = "base_entity"
ENT.Type = "anim"

ENT.PrintName = "CCTV Camera"
ENT.Author = "danx91"

function ENT:Initialize()
	self:SetModel( "models/breach/cctvcamera.mdl" )

	//self:SetModelScale( 100 )

	self:SetSolid( SOLID_VPHYSICS )
	self:SetMoveType( MOVETYPE_NONE )

	if SERVER then
		self:PhysicsInit( SOLID_VPHYSICS )
	end

	local phys = self:GetPhysicsObject()
	if IsValid( phys ) then
		phys:EnableMotion( false )
	end

	//self:AddEFlags( EFL_FORCE_CHECK_TRANSMIT )
end

function ENT:OnTakeDamage( dmginfo )
	self:Remove()

	local data = EffectData()

	data:SetOrigin( self:GetPos() )

	util.Effect( "cball_explode", data, true, true )
end

function ENT:UpdateTransmitState()
	return TRANSMIT_ALWAYS
end

function ENT:SetCam( num )
	self:SetNWInt( "cam", num )
end

function ENT:GetCam()
	return self:GetNWInt( "cam", 0 )
end

function ENT:Draw()
	self:DrawModel()
end


================================================
FILE: gamemodes/breach/entities/entities/item_pistolammo.lua
================================================
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "breach_baseammo"
ENT.AmmoID = 2
ENT.AmmoType = "Pistol"
ENT.AmmoAmount = 64
ENT.MaxUses = 2
ENT.Model = Model("models/items/boxsrounds.mdl")


================================================
FILE: gamemodes/breach/entities/entities/item_rifleammo.lua
================================================
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "breach_baseammo"
ENT.AmmoID = 3
ENT.AmmoType = "AR2"
ENT.PName = "Rifle Ammo"
ENT.AmmoAmount = 120
ENT.MaxUses = 2
ENT.Model = Model("models/items/boxmrounds.mdl")

function ENT:Initialize()
	self:SetModel( self.Model )
	self:PhysicsInit( SOLID_VPHYSICS )
	self:SetMoveType( MOVETYPE_NONE )
	self:SetSolid( SOLID_BBOX )
	self:SetColor(Color(0,0,255))
end



================================================
FILE: gamemodes/breach/entities/entities/item_scp_0761.lua
================================================
AddCSLuaFile()

ENT.Base = "base_anim"
ENT.Type = "anim"

ENT.Author = "danx91"

ENT.HP = 500

function ENT:Initialize()
	-- Zmiana modelu na kostkę
	self:SetModel( "models/hunter/blocks/cube075x075x075.mdl" )
	self:SetModelScale( 0.75 ) -- Mniejsza kostka
	
	-- Ustawienie szarego koloru
	self:SetColor(Color(128, 128, 128))
	self:SetMaterial("models/debug/debugwhite")

	if SERVER then
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
		self:CollisionRulesChanged()

		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )

		self:PhysicsInit( SOLID_VPHYSICS )
		local phys = self:GetPhysicsObject()
		if IsValid(phys) then
			phys:Wake()
			phys:SetMass(1000) -- Ciężka kostka
		end
	end
end

function ENT:Think()
end

function ENT:OnTakeDamage( dmg )
	self.HP = self.HP - dmg:GetDamage()
	if self.HP <= 0 then
		local attacker = dmg:GetAttacker()
		if !attacker:IsPlayer() then return end
		if attacker:GTeam() == TEAM_SCP or attacker:GTeam() == TEAM_SPEC then return end
		self:Remove()
		attacker:PrintMessage(HUD_PRINTTALK, "You've been awarded with 5 points for destroying an SCP!")
		attacker:AddFrags( 5 )
	end
end


================================================
FILE: gamemodes/breach/entities/entities/item_scp_268.lua
================================================
AddCSLuaFile()

ENT.Base = "base_anim"
ENT.Type = "anim"

ENT.PrintName = "SCP-268"
ENT.Author = "Breach Team"
ENT.Category = "SCP"
ENT.Spawnable = true
ENT.AdminSpawnable = true

function ENT:Initialize()
	-- Ustawienie modelu berreta
	self:SetModel("models/thenextscp/scp268/berret.mdl")
	
	if SERVER then
		-- Fizyka entity
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:PhysicsInit(SOLID_VPHYSICS)
		
		-- Konfiguracja fizyki
		local phys = self:GetPhysicsObject()
		if IsValid(phys) then
			phys:Wake()
			phys:SetMass(5) -- Lekki berret
		end
		
		-- Ustawienia kolizji
		self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
		self:SetUseType(SIMPLE_USE)
	end
end

function ENT:Use(activator, caller)
	if not IsValid(activator) or not activator:IsPlayer() then return end
	
	-- Sprawdź czy gracz może podnieść SCP-268
	if activator:GTeam() == TEAM_SPEC then return end
	
	-- Sprawdź czy gracz już ma SCP-268
	if activator:HasWeapon("item_scp_268") then
		if SERVER then
			activator:PrintMessage(HUD_PRINTTALK, "You already have SCP-268!")
		end
		return
	end
	
	-- Daj graczowi SCP-268
	if SERVER then
		activator:Give("item_scp_268")
		activator:PrintMessage(HUD_PRINTTALK, "You picked up SCP-268 - The Berret of Invisibility")
		activator:PrintMessage(HUD_PRINTTALK, "Left click to toggle invisibility while holding it")
		
		-- Usuń entity z mapy
		self:Remove()
	end
end

function ENT:Think()
	-- Lekka rotacja dla efektu wizualnego
	if SERVER then
		local angles = self:GetAngles()
		angles.y = angles.y + 1
		self:SetAngles(angles)
		self:NextThink(CurTime() + 0.1)
		return true
	end
end

if CLIENT then
	function ENT:Draw()
		self:DrawModel()
		
		-- Efekt świecenia dla lepszej widoczności
		local glow = math.sin(CurTime() * 2) * 0.3 + 0.7
		render.SetBlend(glow)
		self:DrawModel()
		render.SetBlend(1)
	end
end 


================================================
FILE: gamemodes/breach/entities/entities/item_smgammo.lua
================================================
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "breach_baseammo"
ENT.AmmoID = 1
ENT.AmmoType = "SMG1"
ENT.PName = "SMG Ammo"
ENT.AmmoAmount = 125
ENT.MaxUses = 2
ENT.Model = Model("models/items/boxmrounds.mdl")


================================================
FILE: gamemodes/breach/entities/entities/scp_1048b_sawent.lua
================================================
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.Spawnable = false
ENT.Category = "SCP"
ENT.PrintName = "SCP-1048-B Saw"

function ENT:Initialize()
	self:SetModel("models/props_junk/sawblade001a.mdl")
	
	if SERVER then
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetModelScale(.5)
		self:SetUseType(SIMPLE_USE)
		self:Activate()
		
		local phys = self:GetPhysicsObject()
		if IsValid(phys) then
			phys:Wake()
			phys:SetMass(10)
		end

		self.ply = nil
		
		-- Efekt trail
		util.SpriteTrail(self, 0, Color(255, 100, 100), false, 15, 1, 1, 1/(15+1)*0.5, "trails/laser.vmt")
	end
end

function ENT:Draw()
	self:DrawModel()
end

function ENT:Use(ply)
	if (not ply:IsPlayer()) then return end
	local wep = ply:GetActiveWeapon()
	if (not (wep:GetClass()=="weapon_scp_1048b")) then return end
	if wep.saw then return end
	if wep:get_saw() then self:Remove() end
end

function ENT:PhysicsCollide(data,phys)
	local speed = data.OurOldAngularVelocity:Length()
	local ent = data.HitEntity

	if (not IsValid(ent)) then return end
	if (speed<800) then return end
	
	-- Sprawdź czy to gracz i czy to SCP/SPEC - jeśli tak, NIE zadawaj obrażeń
	if ent:IsPlayer() then
		if ent:GTeam() == TEAM_SCP or ent:GTeam() == TEAM_SPEC then
			-- Tylko efekty wizualne, bez obrażeń
			local effect = EffectData()
			effect:SetOrigin(data.HitPos)
			self:EmitSound("npc/manhack/grind"..math.random(5)..".wav")
			util.Effect("ManhackSparks",effect)
			
			local phys = self:GetPhysicsObject()
			if IsValid(phys) then
				phys:SetAngleVelocity(Vector(0,0,0))
				phys:SetVelocity(phys:GetVelocity()/2)
			end
			return
		end
	end

	-- Zadaj obrażenia tylko nie-SCP
	ent:TakeDamage(speed/15,self.ply,self)
	
	if ((ent:IsNPC() or ent:IsRagdoll()) or ent:IsPlayer()) then
		local effect = EffectData()
		effect:SetOrigin(data.HitPos)
		self:EmitSound("npc/manhack/grind_flesh"..math.random(3)..".wav")
		util.Effect("BloodImpact",effect)
		util.Decal("Blood",data.HitPos+data.HitNormal,data.HitPos-data.HitNormal)

		local phys = self:GetPhysicsObject()
		if IsValid(phys) then
			phys:SetAngleVelocity(Vector(0,0,0))
			phys:SetVelocity(phys:GetVelocity()/2)
		end
	end
end


================================================
FILE: gamemodes/breach/entities/entities/scp_1123.lua
================================================
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "SCP-1123"
ENT.Category = "SCP"
ENT.Spawnable = false
ENT.AdminSpawnable = true

-- Globalne zmienne dla cooldownu
SCP1123_LastUse = 0
SCP1123_CooldownTime = 360 -- 6 minut

function ENT:Initialize()
	if SERVER then
		self:SetModel("models/Gibs/HGIBS.mdl") -- Model czaszki z GModa
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_NONE) -- Przyklejony do podłogi
		self:SetSolid(SOLID_VPHYSICS)
		self:SetUseType(SIMPLE_USE)
		
		local phys = self:GetPhysicsObject()
		if IsValid(phys) then
			phys:EnableMotion(false) -- Blokada ruchu
		end
		
		-- Ustawienie pozycji
		self:SetPos(Vector(575.883728, -1745.303711, 51.031250))
		self:SetAngles(Angle(0, 90, 0))
		
		-- Network zmienne dla cooldownu
		self:SetNWFloat("SCP1123_NextUse", 0)
	end
end

function ENT:Use(activator, caller)
	if not SERVER then return end
	if not IsValid(activator) or not activator:IsPlayer() then return end
	
	-- Zablokuj użycie przez SCP
	if activator:GTeam() == TEAM_SCP then
		activator:PrintMessage(HUD_PRINTTALK, "SCP entities cannot use SCP-1123!")
		return
	end
	
	-- Sprawdź cooldown
	local currentTime = CurTime()
	local nextUseTime = self:GetNWFloat("SCP1123_NextUse", 0)
	
	if currentTime < nextUseTime then
		local timeLeft = math.ceil(nextUseTime - currentTime)
		local minutes = math.floor(timeLeft / 60)
		local seconds = timeLeft % 60
		activator:PrintMessage(HUD_PRINTTALK, string.format("SCP-1123 is still recharging... %d:%02d remaining", minutes, seconds))
		return
	end
	
	-- Sprawdź czy gracz nie jest już w efekcie SCP-1123
	if activator:GetNWBool("SCP1123_InEffect", false) then
		activator:PrintMessage(HUD_PRINTTALK, "You are already under SCP-1123's influence!")
		return
	end
	
	-- Ustaw cooldown
	self:SetNWFloat("SCP1123_NextUse", currentTime + SCP1123_CooldownTime)
	
	-- Rozpocznij efekt
	self:StartSCP1123Effect(activator)
	
	activator:PrintMessage(HUD_PRINTTALK, "You touch the skull... memories flood your mind...")
end

function ENT:StartSCP1123Effect(ply)
	if not IsValid(ply) then return end
	
	-- Zapisz pozycję gracza
	ply.SCP1123_OriginalPos = ply:GetPos()
	ply.SCP1123_OriginalAngles = ply:GetAngles()
	
	-- Ustaw status efektu
	ply:SetNWBool("SCP1123_InEffect", true)
	ply:SetNWFloat("SCP1123_EffectEnd", CurTime() + 60) -- 60 sekund
	
	-- Zamroź gracza
	ply:Freeze(true)
	
	-- Teleportuj za mapę
	local hiddenPos = Vector(-10000, -10000, -1000) -- Pozycja za mapą
	ply:SetPos(hiddenPos)
	
	-- Znajdź losowego SCP i ustaw kamerę
	self:SetCameraToRandomSCP(ply)
	
	-- Timer na zakończenie efektu
	timer.Create("SCP1123_Effect_" .. ply:SteamID64(), 60, 1, function()
		if IsValid(ply) then
			self:EndSCP1123Effect(ply)
		end
	end)
	
	-- Wyślij wiadomość do klienta o rozpoczęciu efektu
	net.Start("SCP1123_StartEffect")
	net.Send(ply)
end

function ENT:SetCameraToRandomSCP(ply)
	if not IsValid(ply) then return end
	
	-- Znajdź wszystkich SCP
	local scps = {}
	for _, p in pairs(player.GetAll()) do
		if IsValid(p) and p:Alive() and p:GTeam() == TEAM_SCP then
			table.insert(scps, p)
		end
	end
	
	-- Jeśli są SCP, ustaw kamerę na losowego
	if #scps > 0 then
		local randomSCP = scps[math.random(1, #scps)]
		-- Stwórz niewidzialną kamerę za SCP
		local camera = ents.Create("prop_physics")
		camera:SetModel("models/hunter/plates/plate.mdl")
		camera:SetMaterial("engine/writez") -- Niewidzialna
		camera:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
		camera:SetMoveType(MOVETYPE_NOCLIP)
		camera:SetSolid(SOLID_NONE)
		
		-- Pozycja kamery za SCP
		local backOffset = randomSCP:GetAngles():Forward() * -150
		local upOffset = Vector(0, 0, 100)
		camera:SetPos(randomSCP:GetPos() + backOffset + upOffset)
		camera:SetAngles(randomSCP:EyeAngles())
		camera:Spawn()
		
		-- Zapisz referencje
		ply.SCP1123_Camera = camera
		ply.SCP1123_Target = randomSCP
		ply:SetNWEntity("SCP1123_Target", randomSCP)
		
		-- Ustaw kamerę na naszą encję
		ply:SetViewEntity(camera)
		
		-- Timer do aktualizacji pozycji kamery
		timer.Create("SCP1123_Camera_" .. ply:SteamID64(), 0.05, 0, function()
			if IsValid(ply) and IsValid(camera) and IsValid(randomSCP) and ply:GetNWBool("SCP1123_InEffect", false) then
				local newBackOffset = randomSCP:GetAngles():Forward() * -150
				local newUpOffset = Vector(0, 0, 100)
				
				-- Płynne przemieszczanie kamery
				local targetPos = randomSCP:GetPos() + newBackOffset + newUpOffset
				local currentPos = camera:GetPos()
				local lerpedPos = LerpVector(0.1, currentPos, targetPos)
				
				-- Płynne obracanie kamery
				local targetAngles = randomSCP:EyeAngles()
				local currentAngles = camera:GetAngles()
				local lerpedAngles = LerpAngle(0.1, currentAngles, targetAngles)
				
				camera:SetPos(lerpedPos)
				camera:SetAngles(lerpedAngles)
			else
				timer.Remove("SCP1123_Camera_" .. ply:SteamID64())
			end
		end)
		ply:PrintMessage(HUD_PRINTTALK, "You see through the eyes of " .. randomSCP:Nick() .. "...")
	else
		-- Brak SCP - pozostaw normalną kamerę
		ply:PrintMessage(HUD_PRINTTALK, "The memories are unclear... no current presence detected...")
	end
end

function ENT:EndSCP1123Effect(ply)
	if not IsValid(ply) then return end
	
	-- Przywróć normalną kamerę
	ply:SetViewEntity(ply)
	
	-- Usuń kamerę
	if IsValid(ply.SCP1123_Camera) then
		ply.SCP1123_Camera:Remove()
	end
	timer.Remove("SCP1123_Camera_" .. ply:SteamID64())
	
	-- Teleportuj z powrotem na pierwotną pozycję
	if ply.SCP1123_OriginalPos then
		ply:SetPos(ply.SCP1123_OriginalPos)
		ply:SetAngles(ply.SCP1123_OriginalAngles)
	end
	
	-- Odblokuj gracza
	ply:Freeze(false)
	
	-- Nagroda: +30 max HP i pełne życie
	local newMaxHP = ply:GetMaxHealth() + 30
	ply:SetMaxHealth(newMaxHP)
	ply:SetHealth(newMaxHP)
	
	-- Wyczyść zmienne
	ply:SetNWBool("SCP1123_InEffect", false)
	ply:SetNWFloat("SCP1123_EffectEnd", 0)
	ply.SCP1123_OriginalPos = nil
	ply.SCP1123_OriginalAngles = nil
	ply:SetNWEntity("SCP1123_Target", NULL)
	
	-- Usuń timer
	timer.Remove("SCP1123_Effect_" .. ply:SteamID64())
	
	-- Wyślij wiadomość do klienta o zakończeniu
	net.Start("SCP1123_EndEffect")
	net.Send(ply)
	
	ply:PrintMessage(HUD_PRINTTALK, "The memories fade... you feel stronger (+30 Max Health)")
end

-- Cleanup przy disconneccie
if SERVER then
	hook.Add("PlayerDisconnected", "SCP1123_Cleanup", function(ply)
		if IsValid(ply) then
			timer.Remove("SCP1123_Effect_" .. ply:SteamID64())
		end
	end)
end 


================================================
FILE: gamemodes/breach/entities/entities/scp_297.lua
================================================
AddCSLuaFile()

ENT.Base = "base_anim"
ENT.Type = "anim"
ENT.PrintName = "SCP-297"
ENT.Author = "AI Assistant"
ENT.Category = "SCP"
ENT.Spawnable = true
ENT.AdminSpawnable = true

-- Brak modelu - używamy niewidzialnego entity
ENT.Model = "models/hunter/blocks/cube025x025x025.mdl" -- Mały niewidzialny model

-- Wish-granting effects with their probabilities
local WISH_EFFECTS = {
    -- Positive effects (60% total)
    {
        name = "Health Boost",
        chance = 20,
        effect = function(player)
            player:SetHealth(math.min(player:GetMaxHealth(), player:Health() + 30))
            return "Twoje życzenie o lepszym zdrowiu zostało spełnione (+30 HP)."
        end
    },
    {
        name = "Speed Boost",
        chance = 10,
        effect = function(player)
            player:SetRunSpeed(player:GetRunSpeed() * 1.3)
            player:SetWalkSpeed(player:GetWalkSpeed() * 1.3)
            
            timer.Simple(30, function()
                if IsValid(player) then
                    player:SetRunSpeed(player:GetRunSpeed() / 1.3)
                    player:SetWalkSpeed(player:GetWalkSpeed() / 1.3)
                end
            end)
            
            return "Twoje życzenie o większej szybkości zostało spełnione (+30% prędkości na 30 sekund)."
        end
    },
    {
        name = "Armor Boost",
        chance = 10,
        effect = function(player)
            player:SetArmor(math.min(100, player:Armor() + 35))
            return "Twoje życzenie o lepszej ochronie zostało spełnione (+35 pancerza)."
        end
    },
    {
        name = "Ammo Refill",
        chance = 10,
        effect = function(player)
            local weapon = player:GetActiveWeapon()
            if IsValid(weapon) and weapon.Primary and weapon.Primary.Ammo then
                player:GiveAmmo(50, weapon.Primary.Ammo)
                return "Twoje życzenie o większej ilości amunicji zostało spełnione (+50 amunicji)."
            else
                player:SetHealth(math.min(player:GetMaxHealth(), player:Health() + 15))
                return "Nie masz broni, więc otrzymujesz zdrowie (+15 HP)."
            end
        end
    },
    {
        name = "Invisibility",
        chance = 10,
        effect = function(player)
            player:SetRenderMode(RENDERMODE_TRANSALPHA)
            player:SetColor(Color(255, 255, 255, 50))
            
            timer.Simple(15, function()
                if IsValid(player) then
                    player:SetRenderMode(RENDERMODE_NORMAL)
                    player:SetColor(Color(255, 255, 255, 255))
                end
            end)
            
            return "Twoje życzenie o niewidzialności zostało spełnione (15 sekund niewidzialności)."
        end
    },
    
    -- Negative effects (30% total)
    {
        name = "Health Drain",
        chance = 10,
        effect = function(player)
            local newHealth = math.max(5, player:Health() - 30)
            player:SetHealth(newHealth)
            return "Uważaj czego sobie życzysz... (-30 HP)."
        end
    },
    {
        name = "Slow Effect",
        chance = 10,
        effect = function(player)
            player:SetRunSpeed(player:GetRunSpeed() * 0.7)
            player:SetWalkSpeed(player:GetWalkSpeed() * 0.7)
            
            timer.Simple(20, function()
                if IsValid(player) then
                    player:SetRunSpeed(player:GetRunSpeed() / 0.7)
                    player:SetWalkSpeed(player:GetWalkSpeed() / 0.7)
                end
            end)
            
            return "Twoje życzenie obróciło się przeciwko tobie (-30% prędkości na 20 sekund)."
        end
    },
    {
        name = "Confusion",
        chance = 10,
        effect = function(player)
            player:ConCommand("pp_motionblur 1")
            player:ConCommand("pp_motionblur_addalpha 0.2")
            player:ConCommand("pp_motionblur_delay 0.05")
            player:ConCommand("pp_motionblur_drawalpha 0.4")
            
            timer.Simple(15, function()
                if IsValid(player) then
                    player:ConCommand("pp_motionblur 0")
                end
            end)
            
            return "Twoje życzenie wywołało dezorientację (15 sekund zawrotów głowy)."
        end
    },
    
    -- Neutral effects (10% total)
    {
        name = "Nothing",
        chance = 5,
        effect = function(player)
            return "Maszyna wydaje się nie reagować na twoje życzenie."
        end
    },
    {
        name = "Random Teleport",
        chance = 5,
        effect = function(player)
            -- Find random spawn point
            local spawnPoints = {}
            for _, ent in pairs(ents.FindByClass("info_player_*")) do
                table.insert(spawnPoints, ent:GetPos())
            end
            
            if #spawnPoints > 0 then
                local randomPos = spawnPoints[math.random(#spawnPoints)]
                player:SetPos(randomPos)
                return "Twoje życzenie o zmianie miejsca zostało spełnione (teleportacja)."
            else
                return "Maszyna próbowała cię teleportować, ale coś poszło nie tak."
            end
        end
    }
}

function ENT:Initialize()
    self:SetModel(self.Model)
    
    if SERVER then
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetUseType(SIMPLE_USE)
        
        -- Make it immovable
        local phys = self:GetPhysicsObject()
        if IsValid(phys) then
            phys:EnableMotion(false)
            phys:Sleep()
        end
        
        self.NextUse = 0
        self.UsesLeft = 10 -- Machine has limited uses per round
        
        print("[SCP-297] Wish-granting machine initialized!")
    end
end

function ENT:Use(activator, caller, type, value)
    if not IsValid(activator) or not activator:IsPlayer() then return end
    if activator:GTeam() == TEAM_SPEC or not activator:Alive() then return end
    
    if SERVER then
        if self.NextUse > CurTime() then
            activator:PrintMessage(HUD_PRINTTALK, "SCP-297: Maszyna się regeneruje. Spróbuj za " .. math.ceil(self.NextUse - CurTime()) .. " sekund.")
            return
        end
        
        if self.UsesLeft <= 0 then
            activator:PrintMessage(HUD_PRINTTALK, "SCP-297: Maszyna wydaje się być pusta i nie reaguje.")
            return
        end
        
        self:GrantWish(activator)
    end
end

function ENT:GrantWish(player)
    -- Set cooldown
    self.NextUse = CurTime() + 60 -- 1 minute cooldown
    self.UsesLeft = self.UsesLeft - 1
    
    -- Sound effect
    self:EmitSound("ambient/machines/vending_machine_hum_loop1.wav", 70, 100)
    timer.Simple(1.5, function()
        if IsValid(self) then
            self:EmitSound("buttons/button4.wav", 70, 100)
        end
    end)
    
    -- Select effect based on probabilities
    local totalChance = 0
    for _, effect in pairs(WISH_EFFECTS) do
        totalChance = totalChance + effect.chance
    end
    
    local roll = math.random(1, totalChance)
    local currentChance = 0
    local selectedEffect = nil
    
    for _, effect in pairs(WISH_EFFECTS) do
        currentChance = currentChance + effect.chance
        if roll <= currentChance then
            selectedEffect = effect
            break
        end
    end
    
    -- Apply effect
    timer.Simple(2, function()
        if IsValid(player) and IsValid(self) and selectedEffect then
            local message = selectedEffect.effect(player)
            player:PrintMessage(HUD_PRINTTALK, "SCP-297: " .. message)
            
            -- Play appropriate sound based on effect type
            if string.find(selectedEffect.name, "Health Boost") or 
               string.find(selectedEffect.name, "Speed Boost") or 
               string.find(selectedEffect.name, "Armor Boost") then
                player:EmitSound("items/medshot4.wav", 70, 100)
            elseif string.find(selectedEffect.name, "Health Drain") or
                   string.find(selectedEffect.name, "Slow Effect") or
                   string.find(selectedEffect.name, "Confusion") then
                player:EmitSound("ambient/energy/zap9.wav", 70, 100)
            end
            
            -- Visual effect
            local effectData = EffectData()
            effectData:SetOrigin(player:GetPos() + Vector(0, 0, 30))
            effectData:SetScale(1)
            util.Effect("cball_bounce", effectData)
        end
    end)
end

-- Client rendering
if CLIENT then
    function ENT:Draw()
        self:DrawModel()
    end
    
    function ENT:DrawTranslucent()
        local pos = self:GetPos()
        local plyPos = LocalPlayer():GetPos()
        local distance = plyPos:Distance(pos)
        
        if distance < 200 then
            local screenPos = pos:ToScreen()
            if screenPos.visible then
                -- Enhanced holographic effect
                local pulse = math.sin(CurTime() * 3) * 0.3 + 0.7
                local glowColor = Color(0, 200, 255, 255 * pulse)
                
                -- Main title with enhanced glow
                draw.SimpleTextOutlined(
                    "SCP-297",
                    "DermaLarge",
                    screenPos.x,
                    screenPos.y - 100,
                    glowColor,
                    TEXT_ALIGN_CENTER,
                    TEXT_ALIGN_CENTER,
                    3,
                    Color(0, 0, 0, 200)
                )
                
                -- Simple instruction text
                local alpha = math.max(0, 255 - (distance * 1.5))
                
                draw.SimpleTextOutlined(
                    "Maszyna spełniająca życzenia",
                    "DermaDefaultBold",
                    screenPos.x,
                    screenPos.y - 75,
                    Color(255, 255, 255, alpha),
                    TEXT_ALIGN_CENTER,
                    TEXT_ALIGN_CENTER,
                    2,
                    Color(0, 0, 0, alpha * 0.8)
                )
                
                draw.SimpleTextOutlined(
                    "Naciśnij E aby wypowiedzieć życzenie",
                    "DermaDefault",
                    screenPos.x,
                    screenPos.y - 55,
                    Color(255, 255, 255, alpha),
                    TEXT_ALIGN_CENTER,
                    TEXT_ALIGN_CENTER,
                    1,
                    Color(0, 0, 0, alpha * 0.6)
                )
                
                -- Status indicator
                local statusText = "• GOTOWA •"
                local statusColor = Color(100, 255, 100, alpha)
                
                if self.NextUse and self.NextUse > CurTime() then
                    statusText = "• REGENERACJA •"
                    statusColor = Color(255, 100, 100, alpha)
                end
                
                draw.SimpleTextOutlined(
                    statusText,
                    "DermaDefault",
                    screenPos.x,
                    screenPos.y - 35,
                    statusColor,
                    TEXT_ALIGN_CENTER,
                    TEXT_ALIGN_CENTER,
                    1,
                    Color(0, 0, 0, alpha * 0.6)
                )
            end
        end
    end
end

-- Sound effects on spawn
function ENT:PostEntityPaste()
    if SERVER then
        self:EmitSound("ambient/machines/vending_machine_hum_loop1.wav", 60, 100)
    end
end 


================================================
FILE: gamemodes/breach/entities/entities/scp_wall_hole.lua
================================================
AddCSLuaFile()

ENT.Base = "base_anim"
ENT.Type = "anim"
ENT.PrintName = "SCP Wall Hole"
ENT.Author = "AI Assistant"
ENT.Category = "SCP"
ENT.Spawnable = true
ENT.AdminSpawnable = true

ENT.Model = "models/hunter/blocks/cube075x075x075.mdl"

-- Exchangeable items with tier system and TRUE PERCENTAGE CHANCES
-- RZECZYWISTE SZANSE WYMIAN:
-- Tier 1: 1% szans (najrzadsze)
-- Tier 2: 3% szans  
-- Tier 3: 8% szans
-- Tier 4: 15% szans
-- Tier 5: 25% szans (common)
local EXCHANGE_ITEMS = {
    -- Tier 1 - Rarest (1% szans każdy)
    ["br_keycard"] = 1, -- keycards handled separately
    ["weapon_scp_500"] = 1,
    
    -- Tier 2 - Very Rare (3% szans każdy)
    ["item_scp_714"] = 2,
    ["weapon_scp_1499"] = 2,
    
    -- Tier 3 - Rare (8% szans każdy)
    ["item_ultramedkit"] = 3,
    ["weapon_crowbar"] = 3,
    
    -- Tier 4 - Uncommon (15% szans każdy)
    ["item_medkit"] = 4,
    ["weapon_zeus"] = 4,
    ["item_snav_ultimate"] = 4,
    
    -- Tier 5 - Common (25% szans każdy)
    ["item_snav_300"] = 5,
    ["item_radio"] = 5,
    ["item_nvg"] = 5,
    ["item_eyedrops"] = 5
}

-- Tier chances (true percentages)
local TIER_CHANCES = {
    [1] = 1,   -- 1% for tier 1 items
    [2] = 3,   -- 3% for tier 2 items  
    [3] = 8,   -- 8% for tier 3 items
    [4] = 15,  -- 15% for tier 4 items
    [5] = 25   -- 25% for tier 5 items
}

-- Keycard tier system - specific types with TRUE PERCENTAGES
local KEYCARD_TIERS = {
    ["omni"] = 1,      -- najrzadszy (1% szans)
    ["com"] = 2,       -- commander (3% szans)
    ["mtf"] = 2,       -- MTF (8% szans)  
    ["cps"] = 3,       -- checkpoint (15% szans)
    ["keter"] = 4,     -- poziom 3 (15% szans)
    ["res"] = 4,       -- researcher (15% szans)
    ["euclid"] = 5,    -- poziom 2 (25% szans)
    ["safe"] = 5       -- poziom 1 najczęstszy (25% szans)
}

-- Keycard chances (true percentages) 
local KEYCARD_CHANCES = {
    [1] = 1,   -- 1% for omni
    [2] = 3,   -- 3% for com
    [3] = 8,   -- 8% for mtf
    [4] = 15,  -- 15% for cps, keter, res
    [5] = 25   -- 25% for euclid, safe
}

function ENT:Initialize()
    self:SetModel(self.Model)
    self:SetModelScale(0.01)
    self:SetColor(Color(0, 0, 0, 0))
    self:SetRenderMode(RENDERMODE_TRANSALPHA)
    
    if SERVER then
        self:SetMoveType(MOVETYPE_NONE)
        self:SetSolid(SOLID_BBOX)
        self:SetCollisionGroup(COLLISION_GROUP_WORLD)
        self:SetUseType(SIMPLE_USE)
        self:SetCollisionBounds(Vector(-24, -24, -24), Vector(24, 24, 24))
        
        self.NextUse = 0
        
        print("[SCP-WALL-HOLE] Simple exchange system initialized!")
    end
end

function ENT:Use(activator, caller, type, value)
    if not IsValid(activator) or not activator:IsPlayer() then return end
    if activator:GTeam() == TEAM_SPEC or activator:GTeam() == TEAM_SCP then return end
    if not activator:Alive() then return end
    
    if self.NextUse > CurTime() then
        return
    end
    
    if SERVER then
        self:PerformExchange(activator)
    end
end

function ENT:PerformExchange(player)
    local exchangeableItem, keycardType = self:GetPlayerExchangeableItem(player)
    
    if not exchangeableItem then
        return
    end
    
    -- First determine what we would get BEFORE removing current item
    local newItem, newKeycardType = self:GetRandomExchangeItem(exchangeableItem, keycardType, player)
    
    if newItem then
        -- CRITICAL FIX: Check if player already has the item we would give
        -- If so, try to get a different item from next tier or different item
        local attempts = 0
        while self:PlayerHasItem(player, newItem, newKeycardType) and attempts < 10 do
            attempts = attempts + 1
            newItem, newKeycardType = self:GetRandomExchangeItem(exchangeableItem, keycardType, player)
            if not newItem then break end
        end
        
        -- If after attempts we still would give duplicate, try upgrading to higher tier
        if newItem and self:PlayerHasItem(player, newItem, newKeycardType) then
            newItem, newKeycardType = self:GetUpgradedItem(newItem, newKeycardType, player)
        end
        
        -- Only proceed if we have a valid new item that player doesn't have
        if newItem and not self:PlayerHasItem(player, newItem, newKeycardType) then
            -- Remove old item
            player:StripWeapon(exchangeableItem)
            
            -- Remove conflicting items of the same category before giving new item
            self:RemoveConflictingItems(player, newItem)
            
            -- Give new item
            local weapon = player:Give(newItem)
            if IsValid(weapon) then
                -- Special handling for keycards
                if newItem == "br_keycard" and newKeycardType then
                    weapon:SetKeycardType(newKeycardType)
                end
                player:SelectWeapon(newItem)
            end
            
            -- DAMAGE PLAYER BY 1 HP FOR EACH EXCHANGE
            local currentHP = player:Health()
            player:SetHealth(math.max(1, currentHP - 1))  -- Never kill player, minimum 1 HP
            
            -- Console log only
            local itemName = newItem
            if newItem == "br_keycard" and newKeycardType then
                itemName = "br_keycard (" .. newKeycardType .. ")"
            end
            
            local oldItemName = exchangeableItem
            if exchangeableItem == "br_keycard" and keycardType then
                oldItemName = "br_keycard (" .. keycardType .. ")"
            end
            
            print(string.format("[SCP-WALL-HOLE] %s exchanged %s → %s (-1 HP)", player:Nick(), oldItemName, itemName))
            
            -- Set cooldown
            self.NextUse = CurTime() + 1.5
            
            -- Sound effect
            player:EmitSound("items/ammo_pickup.wav", 60, 100)
        end
    end
end

function ENT:RemoveConflictingItems(player, newItem)
    -- Item categories that should replace each other
    local itemCategories = {
        keycards = {
            "br_keycard"
        },
        medkits = {
            "item_medkit",
            "item_ultramedkit"
        },
        snav = {
            "item_snav_300",
            "item_snav_ultimate"
        },
        scps = {
            "weapon_scp_500",
            "item_scp_714",
            "weapon_scp_1499"
        }
    }
    
    -- Find which category the new item belongs to
    local newItemCategory = nil
    for category, items in pairs(itemCategories) do
        if table.HasValue(items, newItem) then
            newItemCategory = category
            break
        end
    end
    
    -- If new item has a category, remove all other items from that category
    if newItemCategory then
        local weapons = player:GetWeapons()
        for _, weapon in pairs(weapons) do
            local weaponClass = weapon:GetClass()
            if table.HasValue(itemCategories[newItemCategory], weaponClass) and weaponClass ~= newItem then
                player:StripWeapon(weaponClass)
            end
        end
    end
end

function ENT:GetPlayerExchangeableItem(player)
    -- Check only the currently held weapon
    local activeWeapon = player:GetActiveWeapon()
    
    if not IsValid(activeWeapon) then
        return nil, nil
    end
    
    local class = activeWeapon:GetClass()
    if EXCHANGE_ITEMS[class] then
        -- Special handling for keycards - return both class and type
        if class == "br_keycard" then
            local keycardType = activeWeapon:GetNWString("K_TYPE", "safe")
            return class, keycardType
        end
        return class, nil
    end
    
    return nil, nil
end

function ENT:GetRandomExchangeItem(currentItem, currentKeycardType, player)
    local attempts = 0
    local maxAttempts = 20 -- Prevent infinite loops
    
    while attempts < maxAttempts do
        attempts = attempts + 1
        
        -- Roll percentage for each item type using TRUE PERCENTAGES
        local allPossibleItems = {}
        
        -- Add regular items with their tier chances
        for item, tier in pairs(EXCHANGE_ITEMS) do
            if item ~= currentItem then
                local chance = TIER_CHANCES[tier] or 1
                local roll = math.random(1, 100)
                
                if roll <= chance then
                    table.insert(allPossibleItems, {item, nil})
                end
            end
        end
        
        -- Add keycard types with their specific chances  
        if currentItem ~= "br_keycard" then -- Only if not currently holding keycard
            for keycardType, tier in pairs(KEYCARD_TIERS) do
                local chance = KEYCARD_CHANCES[tier] or 1
                local roll = math.random(1, 100)
                
                if roll <= chance then
                    table.insert(allPossibleItems, {"br_keycard", keycardType})
                end
            end
        else
            -- If holding keycard, can get other keycard types
            for keycardType, tier in pairs(KEYCARD_TIERS) do
                if keycardType ~= currentKeycardType then
                    local chance = KEYCARD_CHANCES[tier] or 1
                    local roll = math.random(1, 100)
                    
                    if roll <= chance then
                        table.insert(allPossibleItems, {"br_keycard", keycardType})
                    end
                end
            end
        end
        
        -- If we got some items, pick one randomly
        if #allPossibleItems > 0 then
            local chosen = allPossibleItems[math.random(1, #allPossibleItems)]
            local chosenItem = chosen[1]
            local chosenKeycardType = chosen[2]
            
            -- Check if player already has this item (avoid duplicates)
            local hasItem = self:PlayerHasItem(player, chosenItem, chosenKeycardType)
            
            if not hasItem then
                return chosenItem, chosenKeycardType
            end
            -- If player has item, try again with next iteration
        end
        -- If no items rolled successfully, try again
    end
    
    -- If we couldn't find a unique item after many attempts, give fallback
    return "item_radio", nil -- fallback to common item
end

function ENT:PlayerHasItem(player, itemClass, keycardType)
    local weapons = player:GetWeapons()
    
    for _, weapon in pairs(weapons) do
        local weaponClass = weapon:GetClass()
        
        if weaponClass == itemClass then
            -- Special check for keycards - must match type too
            if itemClass == "br_keycard" and keycardType then
                local playerKeycardType = weapon:GetNWString("K_TYPE", "safe")
                if playerKeycardType == keycardType then
                    return true -- Player has same keycard type
                end
            else
                return true -- Player has this item
            end
        end
    end
    
    return false
end

function ENT:GetUpgradedItem(currentItem, currentKeycardType, player)
    -- Try to get item from higher tier (lower tier number = higher rarity)
    local currentTier = nil
    
    if currentItem == "br_keycard" and currentKeycardType then
        currentTier = KEYCARD_TIERS[currentKeycardType]
    else
        currentTier = EXCHANGE_ITEMS[currentItem]
    end
    
    if not currentTier then return nil, nil end
    
    -- Try tiers from highest rarity (1) to current tier
    for tier = 1, currentTier do
        -- Try regular items from this tier
        for item, itemTier in pairs(EXCHANGE_ITEMS) do
            if itemTier == tier and not self:PlayerHasItem(player, item, nil) then
                return item, nil
            end
        end
        
        -- Try keycards from this tier
        for keycardType, keyTier in pairs(KEYCARD_TIERS) do
            if keyTier == tier and not self:PlayerHasItem(player, "br_keycard", keycardType) then
                return "br_keycard", keycardType
            end
        end
    end
    
    -- If no upgrade found, return fallback that player doesn't have
    local fallbacks = {"item_radio", "item_eyedrops", "item_nvg"}
    for _, fallback in pairs(fallbacks) do
        if not self:PlayerHasItem(player, fallback, nil) then
            return fallback, nil
        end
    end
    
    return nil, nil -- No item available
end

-- Client rendering
if CLIENT then
    function ENT:Draw()
        -- Entity is invisible, don't draw the model
    end
    
    function ENT:DrawTranslucent()
        local pos = self:GetPos()
        local plyPos = LocalPlayer():GetPos()
        local distance = plyPos:Distance(pos)
        
        if distance < 150 then
            local screenPos = pos:ToScreen()
            if screenPos.visible then
                -- Enhanced holographic effect
                local pulse = math.sin(CurTime() * 3) * 0.3 + 0.7
                local glowColor = Color(255, 100, 100, 255 * pulse)
                
                -- Main title with enhanced glow
                draw.SimpleTextOutlined(
                    "SCP WALL HOLE",
                    "DermaLarge",
                    screenPos.x,
                    screenPos.y - 40,
                    glowColor,
                    TEXT_ALIGN_CENTER,
                    TEXT_ALIGN_CENTER,
                    3,
                    Color(0, 0, 0, 200)
                )
                
                -- Simple instruction text
                local alpha = math.max(0, 255 - (distance * 2))
                
                draw.SimpleTextOutlined(
                    "Press E to exchange",
                    "DermaDefaultBold",
                    screenPos.x,
                    screenPos.y - 10,
                    Color(255, 255, 255, alpha),
                    TEXT_ALIGN_CENTER,
                    TEXT_ALIGN_CENTER,
                    2,
                    Color(0, 0, 0, alpha * 0.8)
                )
                
                -- Status indicator
                local statusText = "• READY •"
                local statusColor = Color(255, 255, 100, alpha)
                
                draw.SimpleTextOutlined(
                    statusText,
                    "DermaDefault",
                    screenPos.x,
                    screenPos.y + 15,
                    statusColor,
                    TEXT_ALIGN_CENTER,
                    TEXT_ALIGN_CENTER,
                    1,
                    Color(0, 0, 0, alpha * 0.6)
                )
                
                -- Floating particles effect
                for i = 1, 3 do
                    local particleX = screenPos.x + math.sin(CurTime() * 2 + i) * 20
                    local particleY = screenPos.y + 30 + math.cos(CurTime() * 1.5 + i) * 10
                    local particleAlpha = (math.sin(CurTime() * 4 + i) + 1) * 50
                    
                    draw.SimpleText("•", "DermaDefault", particleX, particleY, 
                        Color(255, 100, 100, particleAlpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                end
            end
        end
    end
end

-- Sound effects on spawn
function ENT:PostEntityPaste()
    if SERVER then
        local effectdata = EffectData()
        effectdata:SetOrigin(self:GetPos())
        util.Effect("Explosion", effectdata)
        
        self:EmitSound("ambient/levels/citadel/strange_talk" .. math.random(1,11) .. ".wav", 70, 100)
    end
end 


================================================
FILE: gamemodes/breach/entities/entities/br_c4/cl_init.lua
================================================
include( "shared.lua" )

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:Draw()
	self:DrawShadow( false )
	self:DrawModel()
	if C4Flash and ConVarExists("BR_C4_RedLight") and GetConVar("BR_C4_RedLight"):GetBool() == true then
		local pos = self:GetPos() + self:GetUp() * 4.3 + self:GetForward() * -2.75 -- Position of the sprite
		local size = 15 -- Size of the sprite
		local color = Color(237, 72, 65, 255) -- Color of the sprite (red)
		local sprite =  Material("sprites/glow04_noz") -- The sprite texture
		render.SetMaterial( sprite )
		render.DrawSprite(pos, size, size, color)
	end
end

function ENT:Initialize()
	if not timer.Exists("BRC4FlashTimer") then
		C4Flash = false
		timer.Create("BRC4FlashTimer", 1, 0, function()
			C4Flash = true
			timer.Simple(0.1, function()
				C4Flash = false
			end)
		end)
	end
end

surface.CreateFont( "BRC4Font", {
	font = "Arial",
	antialias = true,
	size = 35,
	outline = true
} )


hook.Add("HUDPaint","BRC4HudText",function()
	local trace = util.TraceLine({
		start = LocalPlayer():EyePos(),
		endpos = LocalPlayer():EyePos() + LocalPlayer():EyeAngles():Forward() * 85,
		filter = {LocalPlayer()}
	})
	local visible_entity = trace.Entity
	if not IsValid(visible_entity) or not LocalPlayer():Alive() then
		return
	end
	local player_to_entity_distance = LocalPlayer():EyePos():Distance(visible_entity:GetPos())
	if (visible_entity:GetClass()  == "br_c4") then
		if (player_to_entity_distance < 85) and visible_entity:IsValid() then
			if visible_entity:GetNWString("OwnerID") == LocalPlayer():SteamID() and LocalPlayer():GetActiveWeapon():GetClass() == "weapon_br_c4" then	
				if visible_entity:GetNWBool("Hit") then
					local useKey = input.LookupBinding("+reload") or "R" -- fallback to "R" if not bound
					draw.DrawText("Naciśnij " .. string.upper(useKey) .. " aby podnieść C4", "BRC4Font", ScrW()/2, ScrH()/2+200, Color(255, 255, 255, 255),TEXT_ALIGN_CENTER)
				end
			end
		end
	end
end)


================================================
FILE: gamemodes/breach/entities/entities/br_c4/init.lua
================================================
AddCSLuaFile( "cl_init.lua" )
AddCSLuaFile( "shared.lua" )
include( "shared.lua" )

-- Dodajemy resource.AddFile dla modeli i dźwięków C4, aby klienci mogli je pobrać
resource.AddFile("models/hoff/weapons/c4/w_c4.mdl")
resource.AddFile("models/hoff/weapons/c4/c_c4.mdl")
resource.AddFile("materials/models/hoff/weapons/c4/c4_reticle.png")
resource.AddFile("sound/hoff/mpl/seal_c4/bar_selectorswitch.wav")
resource.AddFile("sound/hoff/mpl/seal_c4/c4_click.wav")
resource.AddFile("sound/hoff/mpl/seal_c4/whoosh_01.wav")
resource.AddFile("sound/hoff/mpl/seal_c4/satchel_plant.wav")

function ENT:SpawnFunction( ply, tr )
	if ( !tr.Hit ) then
		return
	end
	-- local SpawnPos = tr.HitPos + tr.HitNormal * 16
	local ent = ents.Create( "br_c4" )
	ent:SetPos( Vector(0,0,0) )
	ent:Spawn()
	ent:Activate()

	ent:SetOwner(ply) -- Disables collision between the C4 and its owner
	return ent
end


function ENT:Initialize()
	self:SetModel( "models/hoff/weapons/c4/w_c4.mdl" )
	self:SetCollisionGroup(COLLISION_GROUP_PLAYER)
	self:PhysicsInit( SOLID_VPHYSICS )
	self:SetMoveType( MOVETYPE_VPHYSICS )
	self:SetSolid( SOLID_VPHYSICS )
	self:DrawShadow(false)

	local phys = self:GetPhysicsObject()

	if (phys:IsValid()) then
		phys:Wake()
	end

	self.Hit = false

	self.ExplodedViaWorld = false

	self:SetDTFloat( 0, math.Rand( 0.5, 1.3 ) )
	self:SetDTFloat( 1, math.Rand( 0.3, 1.2 ) )

	--self.Entity:SetOwner(self.C4Owner)

	self:SetNWBool("CanUse", false)
end

function ENT:PhysgunPickup(ply, ent)
	if ent:GetClass() == "br_c4" then
		return false
	end
end
hook.Add("PhysgunPickup", "br_c4_physgun_pickup_hook", function(ply, ent)
	if IsValid(ent) and ent.PhysgunPickup and ent:GetClass() == "br_c4" then
		return ent:PhysgunPickup(ply, ent)
	end
end)

function ENT:SetupDataTables()
	self:DTVar( "Float", 0, "RotationSeed1" )
	self:DTVar( "Float", 1, "RotationSeed2" )
end

function ENT:OnRemove()
	-- Check if the C4 owner is valid
	if IsValid(self) and IsValid(self.C4Owner) and IsValid(self.C4Owner.C4s) then
		-- Check if the C4 is in the owner's C4s table
		if table.HasValue(self.C4Owner.C4s, self) then
			-- Remove the C4 from the owner's C4s table
			table.RemoveByValue(self.C4Owner.C4s, self)
		end
	end
end

function ENT:DelayedDestroy(bTriggeredByOwner)
	if !IsValid(self) then
		return
	end
	local LastC4Position = self:GetPos()
	local ExplodedViaWorld = self.ExplodedViaWorld
	self.ExplodedViaWorld = false
	self.QueuedForExplode = true
	local CachedC4s = self.C4Owner.C4s

	-- Set a timer to explode the found C4 entity after a delay of 0.1 seconds
	if self:GetParent() ~= nil then
		self:SetParent()
	end
	timer.Simple(0.1, function()
		if bTriggeredByOwner then
			if IsValid(self) and IsValid(self.C4Owner) and self.C4Owner.C4s and type(self.C4Owner.C4s) == "table" then
				-- Index 2 is the next c4 to activate, since index 1 is this one (probably)
				local ent = self.C4Owner.C4s[2]
				while ent ~= nil and not IsValid(ent) do
					table.remove(self.C4Owner.C4s, 2)
					ent = self.C4Owner.C4s[2]
					if table.Count(self.C4Owner.C4s) < 2 and (ent == nil or !IsValid(ent)) then
						break
					end
				end
				if IsValid(ent) and IsValid(self) then
					ent.ExplodedViaWorld = false
					ent:DelayedDestroy(true)
				end
				table.remove(self.C4Owner.C4s, 1)
				if table.Count(self.C4Owner.C4s) <= 0 then
					self.C4Owner.C4s = {}
				end
			end
		end

		-- OPTYMALIZACJA: Zoptymalizowane wyszukiwanie entity z cache
		local entities = ents.FindInSphere(LastC4Position, 128)

		-- Pre-filtruj tylko potrzebne typy entity
		local validEntities = {}
		for _, ent in pairs(entities) do
			if IsValid(ent) and ent ~= self then
				local class = ent:GetClass()
				if class == "func_door" or class == "func_door_rotating" or
				   class == "prop_dynamic" or class == "prop_door_rotating" or
				   ent:IsPlayer() or class == "br_c4" then
					table.insert(validEntities, ent)
				end
			end
		end

		-- Sortuj tylko ważne entity (używaj DistToSqr dla wydajności)
		table.sort(validEntities, function(a, b)
			return a:GetPos():DistToSqr(LastC4Position) < b:GetPos():DistToSqr(LastC4Position)
		end)

		entities = validEntities

		-- Iterate over the sorted entities
		for k, v in pairs(entities) do

			if v ~= self then
				-- Check if the current entity is a C4 entity, is not the current C4 entity, and is valid
				if v:GetClass() == "br_c4" and v:IsValid() then
					if (ExplodedViaWorld or !table.HasValue(CachedC4s, v)) and v.QueuedForExplode == false then
							
						-- Check if the found C4 entity has an "Explode" function
						if (type(v.Explode) == "function") then
							
							-- Explode the found C4 entity
							--v.ThisTrigger = self.ThisTrigger
							v.ExplodedViaWorld = true
							v:DelayedDestroy(false)
								
						end
						-- Break the loop after finding and exploding the first C4 entity
						break
					end
					break
				end
			end
		end

		-- Explode this c4 and remove it from the array (if it's in there)
		if IsValid(self) then
			if IsValid(self.C4Owner) and table.HasValue(self.C4Owner.C4s, self) then
				table.RemoveByValue(self.C4Owner.C4s, self)
			end
			self:Explode(bTriggeredByOwner)
		end
	end)
end

function ENT:Explode(bTriggeredByOwner)

	self:EmitSound( "ambient/explosions/explode_4.wav" )

	local detonate = ents.Create( "env_explosion" )
		detonate:SetOwner(self.C4Owner)
		detonate:SetPos( self:GetPos() )
		detonate:SetKeyValue( "iMagnitude", GetConVar("BR_C4_Magnitude"):GetString() )
		--detonate:SetKeyValue( "iRadiusOverride", GetConVar("BR_C4_Radius"):GetString() )
		detonate:Spawn()
		detonate:Activate()
		detonate:Fire( "Explode", "", 0 )

	local shake = ents.Create( "env_shake" )
		shake:SetOwner( self:GetOwner() )
		shake:SetPos( self:GetPos() )
		shake:SetKeyValue( "amplitude", "2000" )
		shake:SetKeyValue( "radius", "400" )
		shake:SetKeyValue( "duration", "2.5" )
		shake:SetKeyValue( "frequency", "255" )
		shake:SetKeyValue( "spawnflags", "4" )
		shake:Spawn()
		shake:Activate()
		shake:Fire( "StartShake", "", 0 )

	self.QueuedForExplode = true

	if ConVarExists("BR_C4_KnockDoors") and GetConVar("BR_C4_KnockDoors"):GetBool() then
		self:KnockDownDoors()
	end

	-- Niszczenie func_door i prop_dynamic w małym zasięgu
	self:DestroyEntities()

	-- Search nearby this exploding c4, if it finds one not in the c4 table, explode it
	self:DelayedDestroy(bTriggeredByOwner)

	self:Remove()
end

-- Chronione pozycje gdzie C4 nie może niszczyć func_door i prop_dynamic
local PROTECTED_POSITIONS = {
	Vector(-448.098022, 4831.968750, 56.154514),
	Vector(-3648.947998, 2472.031250, 54.741806),
	Vector(-191.041443, 5182.749023, 60.138435),
	Vector(-191.041504, 5184.383789, 2617.533691),
	Vector(-5698.259766, 2171.968750, 2568.216309),
	Vector(-3905.577881, 1919.041504, 2624.176270),
	Vector(-3902.997070, 1919.041504, 59.270962)
}

-- Promień ochrony wokół chronionych pozycji
local PROTECTION_RADIUS = 100

-- Funkcja sprawdzająca czy pozycja jest chroniona
local function IsProtectedPosition(pos)
	for _, protectedPos in pairs(PROTECTED_POSITIONS) do
		if pos:Distance(protectedPos) <= PROTECTION_RADIUS then
			return true
		end
	end
	return false
end

function ENT:DestroyEntities()
	-- OPTYMALIZACJA: Zoptymalizowane niszczenie entity
	local DestroyRadius = 50
	local entities = ents.FindInSphere(self:GetPos(), DestroyRadius)

	-- Pre-filtruj tylko niszczalne entity
	local destroyableEntities = {}
	for _, ent in pairs(entities) do
		if IsValid(ent) and ent ~= self then
			local entClass = ent:GetClass()
			if entClass == "func_door" or entClass == "func_door_rotating" or entClass == "prop_dynamic" then
				local entPos = ent:GetPos()
				-- Sprawdź czy encja jest w chronionej pozycji
				if not IsProtectedPosition(entPos) then
					table.insert(destroyableEntities, ent)
				end
			end
		end
	end

	-- Batch processing niszczenia
	for i, ent in pairs(destroyableEntities) do
		local entClass = ent:GetClass()

		-- Rozłóż niszczenie w czasie dla lepszej wydajności
		timer.Simple(i * 0.05, function()
			if not IsValid(ent) then return end

			-- Niszczenie func_door
			if entClass == "func_door" or entClass == "func_door_rotating" then
				ent:Fire("Open", "", 0)
				timer.Simple(0.5, function()
					if IsValid(ent) then
						ent:Remove()
					end
				end)

			-- Niszczenie prop_dynamic
			elseif entClass == "prop_dynamic" then
				local effectData = EffectData()
				effectData:SetOrigin(ent:GetPos())
				effectData:SetMagnitude(1)
				util.Effect("Explosion", effectData)
				ent:Remove()
			end
		end)
	end

	print("[OPTIMIZATION] C4 destroyed " .. #destroyableEntities .. " entities")
end

function ENT:KnockDownDoors()
	local SearchRadius = ConVarExists("BR_C4_DoorSearchRadius") and GetConVar("BR_C4_DoorSearchRadius"):GetInt() or 100
	local entities = ents.FindInSphere(self:GetPos(), SearchRadius)
	for k, ItDoor in pairs(entities) do
		local DoorClass = ItDoor:GetClass()
		if DoorClass == "func_door" or DoorClass == "func_door_rotating" or DoorClass == "prop_door_rotating" then
			if !ItDoor.KnockedDown then
				self:BlastDoor(ItDoor)
			end
		end
	end
end

function ENT:BlastDoor(FoundDoor)
	FoundDoor.KnockedDown = true
	FoundDoor:Fire("lock","",0)
	FoundDoor:Fire("Open","",0)
	FoundDoor:SetCollisionGroup(COLLISION_GROUP_WORLD)
	FoundDoor:CollisionRulesChanged()
	FoundDoor:SetNoDraw(true)

	FoundDoor.FakeDoor = ents.Create("prop_physics")
	FoundDoor.FakeDoor:SetModel(FoundDoor:GetModel())
	FoundDoor.FakeDoor:SetPos(FoundDoor:GetPos())
	FoundDoor.FakeDoor:SetAngles(FoundDoor:GetAngles())
	FoundDoor.FakeDoor:Spawn()
	FoundDoor.FakeDoor:Activate()
	if FoundDoor:GetSkin() then
		FoundDoor.FakeDoor:SetSkin(FoundDoor:GetSkin())
	end

	local phys = FoundDoor.FakeDoor:GetPhysicsObject()
	if IsValid(phys) then
		local KnockStrength = ConVarExists("BR_C4_DoorKnockStrength") and GetConVar("BR_C4_DoorKnockStrength"):GetFloat() or 500
		KnockStrength = KnockStrength * -1
		phys:ApplyForceOffset((self:GetAngles():Up() * KnockStrength) * phys:GetMass(), self:GetPos())
	end
end

ENT.PhysData = nil
ENT.PhysRef = nil
function ENT:PhysicsCollide(data, phys)
	if data.HitEntity:GetClass() == "br_c4" or data.HitEntity == self.C4Owner then return end

	self:EmitSound("hoff/mpl/seal_c4/satchel_plant.wav")

	if self:IsValid() and !self.Hit then
		self.ChangeCollisionGroup = true
		timer.Simple(0, function()
			if self.ChangeCollisionGroup then
				self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
				self.ChangeCollisionGroup = false

				local bHitValidEntity = IsValid(data.HitEntity)
				if bHitValidEntity then
					local bHitWorld = data.HitEntity:IsWorld()
					local bHitAnotherC4 = data.HitEntity:GetClass() == "br_c4"
					local bHitAnNPC = data.HitEntity:IsNPC()
					local bHitAPlayer = data.HitEntity:IsPlayer()
					if bHitValidEntity and !bHitWorld and !bHitAnotherC4 and !bHitAnNPC and !bHitAPlayer then
						self:SetSolid(SOLID_VPHYSICS)
						self:SetMoveType(MOVETYPE_NONE)
						self:SetParent(data.HitEntity)
						self.Stuck = true
						self.Hit = true
					elseif bHitWorld then
						self:SetMoveType(MOVETYPE_NONE)
					end
				else
					self:SetMoveType(MOVETYPE_NONE)
				end
				self:SetNWBool("CanUse", true)

				if IsValid(phys) then
					local angVel = phys:GetAngleVelocity()
					local maxAngVel = 1000
					if angVel:Length() > maxAngVel then
						angVel = angVel:GetNormalized() * maxAngVel
						phys:SetAngleVelocity(angVel)
					end
				end

				local HitAngle = data.HitNormal:Angle()
				HitAngle.p = HitAngle.p + 270

				self:SetPos(data.HitPos + ((data.HitNormal / 5) * -11))

				-- Generate a random yaw angle between -60 and 60 degrees
				local yaw = math.random(-60, 60)

				self:SetAngles(HitAngle)
				-- Rotate the Angle object around the entity's up vector using the RotateAroundAxis function
				HitAngle:RotateAroundAxis(self:GetUp(), yaw)
				-- Set the entity's angles to the rotated angles
				self:SetAngles(HitAngle)
				self:SetOwner(nil)
			end
		end)
		self:SetNWBool("Hit", true)
		self.Hit = true
		self.PhysData = data
		self.PhysRef = phys
	end
end

function ENT:OnTakeDamage( dmginfo )
	self:TakePhysicsDamage( dmginfo )

	-- Check if the attacker is not the owner of the C4, or if the damage type is not blast damage
	if dmginfo:GetDamageType() ~= DMG_BLAST then
		self.ExplodedViaWorld = true
		self:Explode(false)
	end
end

function ENT:Touch(ent)
	if ent == self.C4Owner or ent == self.ThisTrigger or ent == self:GetOwner() then
		return false
	end
	if IsValid(ent) and !self.Stuck then
		if ent:IsNPC() || (ent:IsPlayer() && ent != self:GetOwner()) || ent:IsVehicle() then
			self:SetSolid(SOLID_VPHYSICS)
			self:SetMoveType(MOVETYPE_NONE)
			self:SetParent(ent)
			self.Stuck = true
			self.Hit = true
			self:SetOwner(nil)
		end
	end
end


================================================
FILE: gamemodes/breach/entities/entities/br_c4/shared.lua
================================================
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"
ENT.PrintName		= "C4"
ENT.Author			= "Hoff, zintegrowane przez SCP: Breach Team"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

-- Precache modeli i materiałów dla C4
if SERVER then
	util.PrecacheModel("models/hoff/weapons/c4/w_c4.mdl")
	util.PrecacheModel("models/hoff/weapons/c4/c_c4.mdl")
end

if CLIENT then
	-- Precache materiałów po stronie klienta
	Material("models/hoff/weapons/c4/c4_reticle.png")
end

hook.Add("Initialize","CreateBRC4Convars",function()
    if !ConVarExists("BR_C4_DoorSearchRadius") then
        CreateConVar("BR_C4_Infinite", 0, { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "Czy C4 powinno być nieskończone? 1 = nieskończone")
        CreateConVar("BR_C4_ThrowSpeed", 1, { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "Jak długi jest czas pomiędzy rzutami C4?")
        CreateConVar("BR_C4_Magnitude", 175, { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "Jak silna jest eksplozja C4?")
        CreateConVar("BR_C4_KnockDoors", 0, { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "Czy C4 powinno wyważać drzwi?")
        CreateConVar("BR_C4_DoorKnockStrength", 500, { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "Jak mocno drzwi powinny być wyważone?")
        CreateConVar("BR_C4_DoorSearchRadius", 75, { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "Jak daleko powinny być wykrywane drzwi?")
    end
    if CLIENT then
        if !ConVarExists("BR_C4_RedLight") then
            CreateClientConVar("BR_C4_RedLight", 1, true)
        end
        local function funcCallback(CVar, PreviousValue, NewValue)
            net.Start("BR_C4_Convars_Change", true)
            net.WriteString(CVar)
            net.WriteFloat(tonumber(NewValue))
            net.SendToServer()
        end
        cvars.AddChangeCallback("BR_C4_Infinite", funcCallback)
        cvars.AddChangeCallback("BR_C4_ThrowSpeed", funcCallback)
        cvars.AddChangeCallback("BR_C4_Magnitude", funcCallback)
        cvars.AddChangeCallback("BR_C4_KnockDoors", funcCallback)
        cvars.AddChangeCallback("BR_C4_DoorKnockStrength", funcCallback)
        cvars.AddChangeCallback("BR_C4_DoorSearchRadius", funcCallback)
    end
end)

if SERVER then
    util.AddNetworkString("BR_C4_Convars_Change")

    net.Receive("BR_C4_Convars_Change", function(len, ply)
        if !ply:IsAdmin() then
            return
        end
        local cvar_name = net.ReadString()
        local cvar_val = net.ReadFloat()
        RunConsoleCommand(cvar_name, cvar_val)
    end)

elseif CLIENT then
    hook.Add("PopulateToolMenu", "AddBRC4SettingsPanel", function()
        spawnmenu.AddToolMenuOption("Utilities", "SCP: Breach", "BRC4SettingsPanel", "C4 Setup", "", "", function(cpanel)

            if !game.SinglePlayer() and !LocalPlayer():IsAdmin() then
                cpanel:CheckBox("C4 Red Light", "BR_C4_RedLight")
                return
            end

            cpanel:CheckBox("Infinite C4", "BR_C4_Infinite")
            cpanel:NumSlider("C4 Magnitude", "BR_C4_Magnitude", 1, 500, 0)
            cpanel:NumSlider("C4 Throw Speed", "BR_C4_ThrowSpeed", 0.1, 10, 2)
            cpanel:CheckBox("Knock Down Doors", "BR_C4_KnockDoors")
            cpanel:NumSlider("Door Knock Strength", "BR_C4_DoorKnockStrength", 100, 2500, 0)
            cpanel:NumSlider("Door Search Radius", "BR_C4_DoorSearchRadius", 1, 500, 0)
            cpanel:CheckBox("C4 Red Light", "BR_C4_RedLight")
        end)
    end)
end


================================================
FILE: gamemodes/breach/entities/entities/br_intercom/cl_init.lua
================================================
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end

function ENT:Think()
    -- Client-side think if needed
end 


================================================
FILE: gamemodes/breach/entities/entities/br_intercom/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

-- Global cooldown table for players
INTERCOM_COOLDOWNS = INTERCOM_COOLDOWNS or {}

function ENT:Initialize()
    self:SetModel("models/veeds/intercom/intercom.mdl")
    self:PhysicsInit(SOLID_VPHYSICS)
    self:SetMoveType(MOVETYPE_NONE)
    self:SetSolid(SOLID_VPHYSICS)
    self:SetUseType(SIMPLE_USE)
    
    local phys = self:GetPhysicsObject()
    if IsValid(phys) then
        phys:EnableMotion(false)
    end
    
    -- Intercom state variables
    self.InUse = false
    self.CurrentUser = nil
    self.UseStartTime = 0
    self.MaxUseTime = 30 -- 30 seconds max transmission time
    self.CooldownTime = 60 -- 60 seconds cooldown between uses
    
    print("[BREACH] Intercom spawned at position: " .. tostring(self:GetPos()))
end

function ENT:Use(ply)
    if not IsValid(ply) or not ply:IsPlayer() then return end
    
    -- Basic checks
    if ply:GTeam() == TEAM_SPEC then
        ply:PrintMessage(HUD_PRINTTALK, "[INTERCOM] Spectators cannot use the intercom!")
        return
    end
    
    if not ply:Alive() then
        ply:PrintMessage(HUD_PRINTTALK, "[INTERCOM] You must be alive to use the intercom!")
        return
    end
    
    if preparing then
        ply:PrintMessage(HUD_PRINTTALK, "[INTERCOM] The intercom is disabled during preparation phase!")
        return
    end
    
    -- Block SCP entities from using intercom
    if ply:GTeam() == TEAM_SCP then
        ply:PrintMessage(HUD_PRINTTALK, "[INTERCOM] SCP entities cannot use the facility intercom system!")
        return
    end
    
    -- Check player cooldown
    local steamid = ply:SteamID()
    if INTERCOM_COOLDOWNS[steamid] and INTERCOM_COOLDOWNS[steamid] > CurTime() then
        local remaining = math.ceil(INTERCOM_COOLDOWNS[steamid] - CurTime())
        ply:PrintMessage(HUD_PRINTTALK, "[INTERCOM] You must wait " .. remaining .. " seconds before using the intercom again!")
        return
    end
    
    -- Check if intercom is already in use
    if self.InUse then
        if self.CurrentUser == ply then
            -- Player wants to stop using intercom
            self:StopTransmission()
            return
        else
            ply:PrintMessage(HUD_PRINTTALK, "[INTERCOM] The intercom is currently being used by " .. (IsValid(self.CurrentUser) and self.CurrentUser:Nick() or "someone") .. "!")
            return
        end
    end
    
    -- Start transmission
    self:StartTransmission(ply)
end

function ENT:StartTransmission(ply)
    self.InUse = true
    self.CurrentUser = ply
    self.UseStartTime = CurTime()
    
    -- DON'T set cooldown here - only after transmission ends!
    
    -- Play activation sound
    self:EmitSound("buttons/button14.wav", 75, 100)
    
    -- Notify player
    ply:PrintMessage(HUD_PRINTTALK, "[INTERCOM] You are now broadcasting to the entire facility!")
    ply:PrintMessage(HUD_PRINTTALK, "[INTERCOM] Speak in chat OR use your microphone to transmit. Press E again to stop.")
    ply:PrintMessage(HUD_PRINTTALK, "[INTERCOM] Maximum transmission time: " .. self.MaxUseTime .. " seconds.")
    
    -- Broadcast start message to all players (WITHOUT showing class)
    for _, v in pairs(player.GetAll()) do
        if IsValid(v) and v:Alive() and v:GTeam() != TEAM_SPEC then
            v:PrintMessage(HUD_PRINTTALK, "[FACILITY INTERCOM] *** ANNOUNCEMENT SYSTEM ACTIVATED ***")
            v:PrintMessage(HUD_PRINTTALK, "[FACILITY INTERCOM] " .. ply:Nick() .. " is broadcasting:")
        end
    end
    
    -- Set up automatic timeout
    timer.Create("IntercomTimeout_" .. self:EntIndex(), self.MaxUseTime, 1, function()
        if IsValid(self) then
            self:StopTransmission(true)
        end
    end)
    
    print("[INTERCOM] " .. ply:Nick() .. " (" .. ply:GetNClass() .. ") started intercom transmission")
end

function ENT:StopTransmission(timeout)
    if not self.InUse then return end
    
    local user = self.CurrentUser
    
    -- Set cooldown NOW when transmission actually ends
    if IsValid(user) then
        INTERCOM_COOLDOWNS[user:SteamID()] = CurTime() + self.CooldownTime
    end
    
    -- Play deactivation sound
    self:EmitSound("buttons/button10.wav", 75, 120)
    
    -- Notify user
    if IsValid(user) then
        if timeout then
            user:PrintMessage(HUD_PRINTTALK, "[INTERCOM] Transmission ended - time limit reached!")
        else
            user:PrintMessage(HUD_PRINTTALK, "[INTERCOM] Transmission ended.")
        end
        
        -- Show cooldown info
        local remaining = math.ceil(self.CooldownTime)
        user:PrintMessage(HUD_PRINTTALK, "[INTERCOM] You can use the intercom again in " .. remaining .. " seconds.")
    end
    
    -- Broadcast end message to all players
    for _, v in pairs(player.GetAll()) do
        if IsValid(v) and v:Alive() and v:GTeam() != TEAM_SPEC then
            v:PrintMessage(HUD_PRINTTALK, "[FACILITY INTERCOM] *** TRANSMISSION ENDED ***")
        end
    end
    
    -- Reset state
    self.InUse = false
    self.CurrentUser = nil
    self.UseStartTime = 0
    
    -- Remove timeout timer
    timer.Remove("IntercomTimeout_" .. self:EntIndex())
    
    print("[INTERCOM] Transmission ended" .. (timeout and " (timeout)" or ""))
end

function ENT:Think()
    -- Check if current user is still valid and alive
    if self.InUse and IsValid(self.CurrentUser) then
        if not self.CurrentUser:Alive() or self.CurrentUser:GTeam() == TEAM_SPEC or self.CurrentUser:GTeam() == TEAM_SCP then
            self:StopTransmission()
        end
    end
    
    self:NextThink(CurTime() + 1)
    return true
end

function ENT:OnRemove()
    -- Clean up timer
    timer.Remove("IntercomTimeout_" .. self:EntIndex())
    
    -- If intercom was in use, stop transmission
    if self.InUse then
        self:StopTransmission()
    end
end

-- Hook to intercept chat messages from intercom users
hook.Add("PlayerSay", "IntercomBroadcast", function(ply, text, team)
    -- Find active intercom being used by this player
    for _, ent in pairs(ents.FindByClass("br_intercom")) do
        if IsValid(ent) and ent.InUse and ent.CurrentUser == ply then
            -- Broadcast message to entire facility
            for _, v in pairs(player.GetAll()) do
                if IsValid(v) and v:Alive() and v:GTeam() != TEAM_SPEC then
                    v:PrintMessage(HUD_PRINTTALK, "[FACILITY INTERCOM] " .. text)
                end
            end
            
            -- Play transmission sound
            ent:EmitSound("buttons/button17.wav", 75, 110)
            
            print("[INTERCOM BROADCAST] " .. ply:Nick() .. ": " .. text)
            
            -- Prevent normal chat message
            return ""
        end
    end
end)

-- Hook to make intercom users heard by everyone via voice chat
hook.Add("PlayerCanHearPlayersVoice", "IntercomVoiceBroadcast", function(listener, talker)
    -- Check if talker is using any intercom
    for _, ent in pairs(ents.FindByClass("br_intercom")) do
        if IsValid(ent) and ent.InUse and ent.CurrentUser == talker then
            -- Talker is using intercom - everyone can hear them
            if IsValid(listener) and listener:Alive() and listener:GTeam() != TEAM_SPEC then
                return true, true -- Can hear, and hear at full volume
            end
        end
    end
    
    -- Return nil to use default voice chat behavior
    return nil
end)

-- Hook when player starts speaking via voice chat while using intercom
hook.Add("PlayerStartVoice", "IntercomVoiceStart", function(ply)
    -- Check if player is using intercom
    for _, ent in pairs(ents.FindByClass("br_intercom")) do
        if IsValid(ent) and ent.InUse and ent.CurrentUser == ply then
            -- Notify all players that voice transmission started
            for _, v in pairs(player.GetAll()) do
                if IsValid(v) and v:Alive() and v:GTeam() != TEAM_SPEC then
                    v:PrintMessage(HUD_PRINTTALK, "[FACILITY INTERCOM] *** VOICE TRANSMISSION ACTIVE ***")
                end
            end
            
            -- Play transmission sound
            ent:EmitSound("buttons/button17.wav", 75, 110)
            break
        end
    end
end)

-- Hook when player stops speaking via voice chat while using intercom  
hook.Add("PlayerEndVoice", "IntercomVoiceEnd", function(ply)
    -- Check if player is using intercom
    for _, ent in pairs(ents.FindByClass("br_intercom")) do
        if IsValid(ent) and ent.InUse and ent.CurrentUser == ply then
            -- Small delay then notify voice transmission ended
            timer.Simple(0.5, function()
                for _, v in pairs(player.GetAll()) do
                    if IsValid(v) and v:Alive() and v:GTeam() != TEAM_SPEC then
                        v:PrintMessage(HUD_PRINTTALK, "[FACILITY INTERCOM] *** VOICE TRANSMISSION ENDED ***")
                    end
                end
            end)
            break
        end
    end
end)

-- Clean up cooldowns when player disconnects
hook.Add("PlayerDisconnected", "IntercomCleanupCooldowns", function(ply)
    if IsValid(ply) then
        INTERCOM_COOLDOWNS[ply:SteamID()] = nil
        
        -- If this player was using any intercom, stop transmission
        for _, ent in pairs(ents.FindByClass("br_intercom")) do
            if IsValid(ent) and ent.InUse and ent.CurrentUser == ply then
                ent:StopTransmission()
                break
            end
        end
    end
end) 


================================================
FILE: gamemodes/breach/entities/entities/br_intercom/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Author = "Breach SCP Team"
ENT.PrintName = "Facility Intercom"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "SCP Breach"

ENT.RenderGroup = RENDERGROUP_BOTH 


================================================
FILE: gamemodes/breach/entities/entities/breach_jarate_projectile/cl_init.lua
================================================
include("shared.lua") 


================================================
FILE: gamemodes/breach/entities/entities/breach_jarate_projectile/init.lua
================================================
AddCSLuaFile("shared.lua")
AddCSLuaFile("cl_init.lua")
include("shared.lua") 


================================================
FILE: gamemodes/breach/entities/entities/breach_jarate_projectile/shared.lua
================================================
ENT.Type = "anim"

ENT.Spawnable = false
ENT.AdminOnly = false

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

ENT.slosh = "orange_blossom/piss/slosh.wav"
ENT.droplet = Material ( "models/orange_blossom/piss/piss_droplet" )
ENT.splash = Material ( "models/orange_blossom/piss/piss_splash" )
ENT.colPiss = Color( 222, 180, 44, 255 )
ENT.colNormal = Color( 255, 255, 255, 255 )

ENT.time = 0
ENT.myPos = nil
ENT.pissed = {}
ENT.collided = false --the moment when jar explodes
ENT.doPiss = false --true if at least one target was pissed on
ENT.piss_hook = 0
ENT.byeBye = 0
ENT.didOnce = false
ENT.performDelay = 999999
ENT.lightPwr = 0

ENT.duration = GetConVar and GetConVar("blossomJarateDuration") and GetConVar("blossomJarateDuration"):GetInt() or 10
ENT.range = GetConVar and GetConVar("blossomJarateRange") and GetConVar("blossomJarateRange"):GetInt() or 150
ENT.strenght = GetConVar and GetConVar("blossomJarateStrenght") and GetConVar("blossomJarateStrenght"):GetFloat() or 0.35

function ENT:SetupDataTables()
	self:NetworkVar( "Vector", 0, "DirVec" )
	self:NetworkVar( "Entity", 0, "MyParent" )
	self:NetworkVar( "Int", 0, "Force" )

	self:NetworkVar( "Bool", 0, "PerformPiss" )
	self:NetworkVar( "Vector", 1, "NetworkPos" )

	if SERVER then
		self:SetPerformPiss( false )
	end
end

--set these accordingly to the spawning entity
function ENT:MyInfo( dir, parent, force )
	self:SetDirVec( dir )
	self:SetMyParent( parent )
	self:SetForce( force )
end

function ENT:Initialize()
	self.time = CurTime()

	self.duration = GetConVar and GetConVar("blossomJarateDuration") and GetConVar("blossomJarateDuration"):GetInt() or 10
	self.range = GetConVar and GetConVar("blossomJarateRange") and GetConVar("blossomJarateRange"):GetInt() or 150
	self.strenght = GetConVar and GetConVar("blossomJarateStrenght") and GetConVar("blossomJarateStrenght"):GetFloat() or 0.35

	if SERVER then
		self.byeBye = self.time + 10 --safeguard if jarate gets out of world bounds

		self:SetModel( "models/orange_blossom/piss/piss_world.mdl" )
		self:ManipulateBoneScale( 0, Vector( 1.5, 1.5, 1.5 ) )
		self:DrawShadow( true )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetCollisionGroup( 1 )
		self:SetTrigger( true )
		self:UseTriggerBounds( true, 4 )

		self:PhysWake()
		self.phys = self:GetPhysicsObject()

		if !self.phys:IsValid() then
			self:Remove()
		else
			self.phys:AddGameFlag( FVPHYSICS_NO_IMPACT_DMG, FVPHYSICS_NO_PLAYER_PICKUP )
			--self.phys:EnableGravity(true)

			local force = Vector( self:GetForce() * self:GetDirVec(), 0, 0 )

			self.phys:AddAngleVelocity( Vector ( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			self.phys:AddVelocity( force + Vector( math.Rand( -15, 15 ), math.Rand( -15, 15 ), 0 ) )
		end
	else
		self.emitter = ParticleEmitter( Vector( 0, 0, 0 ), false )
	end
end

function ENT:StartTouch( ent )
	self.myPos = self:GetPos()

	if !self.collided and IsValid(ent) and ent ~= self:GetMyParent() then
		self.collided = true
		self:SetPerformPiss( true )
		self:SetNetworkPos( self.myPos )
		self.performDelay = CurTime() + 0.1
	end
end

function ENT:PhysicsCollide( data, physobj )
	self.myPos = self:GetPos()

	if !self.collided and data.HitEntity ~= self:GetMyParent() then
		self.collided = true
		self:SetPerformPiss( true )
		self:SetNetworkPos( self.myPos )
		self.performDelay = CurTime() + 0.1
	end
end

function ENT:ParticleEmitExplode()
	local fx = self.emitter:Add( self.droplet, self.myPos )

	--piss
	fx:SetDieTime( 1 )
	fx:SetStartAlpha( 255 )
	fx:SetEndAlpha( 0 )

	fx:SetStartSize( 3 )
	fx:SetEndSize( 0 )
	local cc = Vector( 255, 222, 79 ) * self.lightPwr
	fx:SetColor( cc[1], cc[2], cc[3] )

	fx:SetAngles( Angle ( math.random( -180, 180 ), math.random( -180, 180 ), math.random( -180, 180 ) ) )
	fx:SetVelocity( Vector( math.random( -750, 750 ), math.random( -750, 750 ), math.random( -250, 250 ) ) )
	fx:SetGravity( Vector( 0, 0, -1000 ) )

	fx:SetCollide( true )

	--glass
	fx = self.emitter:Add( Material ( "effects/fleck_glass" .. tostring( math.random( 1, 3 ) ) ), self.myPos )

	fx:SetDieTime( 4 )
	fx:SetStartAlpha( 100 )
	fx:SetEndAlpha( 0 )

	fx:SetStartSize( 4 )
	fx:SetEndSize( 1 )
	local cc = Vector( 255, 255, 255 ) * self.lightPwr
	fx:SetColor( cc[1], cc[2], cc[3] )

	fx:SetAngles( Angle ( math.random( -180, 180 ), math.random( -180, 180 ), math.random( -180, 180 ) ) )
	fx:SetVelocity( Vector( math.random( -250, 250 ), math.random( -250, 250 ), math.random( 100, 500 ) ) )
	fx:SetGravity( Vector( 0, 0, -1000 ) )

	fx:SetCollide( true )
end

function ENT:PissExplosion()
	--print("splosion!")

	local targets = ents.FindInSphere( self.myPos, self.range )

	--PrintTable(targets)

	for _,v in pairs(targets) do
		if v:IsPlayer() or v:IsNPC() or v:IsNextBot() then
			local place = v:GetPos() --pos of the victim
			local trData = {
				start = self.myPos + Vector( 0, 0, 16 ),
				endpos = place + Vector( 0, 0, 32 ),
				filter = self,
				mask = 32827, --world + water
				--mask = 33570819,
				--collisiongroup = 0,
				--ignoreworld = false,
			}

			local tr = util.TraceLine( trData )

			/*
			if CLIENT then
			debugoverlay.Sphere( self.myPos, self.range, 2, Color( 255, 255, 255 ), false )

			debugoverlay.Line( self.myPos + Vector( 0, 0, 16 ), place + Vector( 0, 0, 32 ), 2, Color( 255, 255, 255 ), false )
			end
			*/

			--print(tr.Entity)

			if !tr.Hit then
			--if tr.Entity == v then --too many times it does not apply when it should
				--print("hit!")

				v.orange_blossom_pissed = self.time + self.duration --mark the entity as jarated until that time
				table.insert( self.pissed, v ) --table of all currently jarated players
				v:SetColor(self.colPiss)
				self:ManipulateBoneScale( 0, Vector( 0.01, 0.01, 0.01 ) )

				self.doPiss = true
			end
		end
	end

	if CLIENT then
		self:SetNoDraw( true ) --unreliable, especially in singleplayer

		--checking the color of the spawn pos
		local clr = render.GetLightColor( self:GetPos() )
		local R = math.Clamp( clr[1] * 1000 + 15, 1, 255 )
		local G = math.Clamp( clr[2] * 1000 + 15, 1, 255 )
		local B = math.Clamp( clr[3] * 1000 + 15, 1, 255 )

		self.lightPwr = math.Clamp( (R + G + B) / 255, 0, 1 )
		--print( self.lightPwr )

		for i = 1, 30 do
			self:ParticleEmitExplode()
		end

		local fx = self.emitter:Add( self.splash, self.myPos )

		--mega piss
		fx:SetDieTime( 0.2 )
		fx:SetStartAlpha( 255 )
		fx:SetEndAlpha( 0 )
		fx:SetLighting( false )

		fx:SetStartSize( 1 )
		fx:SetEndSize( 132 )
		local cc = Vector( 211, 170, 40 ) * self.lightPwr
		fx:SetColor( cc[1], cc[2], cc[3] )
	else
		sound.Play( "physics/glass/glass_pottery_break4.wav", self.myPos, 75, math.random( 90, 110 ), 1 )
		sound.Play( self.slosh, self.myPos, 75, math.random( 90, 110 ), 1 )
		--util.Decal( "BeerSplash", self.myPos, self.myPos - Vector(0,0,32) )

		if self.doPiss then
			self.byeBye = self.time + self.duration
			--self:ApplyJarateServer()
		else
			self:Remove()
		end
	end
end

function ENT:Think()
	--print(self:GetPos())

	self.time = CurTime()
	self.myPos = self:GetNetworkPos()

	if self.doPiss then
		for _,v in pairs(self.pissed) do --water washes off piss
			--if I do: if !IsValid(v) then return, then the whole function starts over and locks

			if IsValid(v) and v:WaterLevel() >= 2 then
				v.orange_blossom_pissed = 0
				v:SetColor(self.colNormal) --color is permanent for players unless restored
			end

			if IsValid(v) and v:IsPlayer() and !v:Alive() then --fix for effect remaining after death
				v.orange_blossom_pissed = 0
				v:SetColor(self.colNormal) --color is permanent for players unless restored
			end

			if CLIENT and IsValid(v) and v.orange_blossom_pissed ~= nil and v.orange_blossom_pissed > self.time then
				local dropPos = v:GetPos() + Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( 32, 50 ) )

				local fx = self.emitter:Add( self.droplet, dropPos + Vector( math.random( -8, 8 ), math.random( -8, 8 ), 0 ) )

				local clr = render.GetLightColor( dropPos )
				local R = math.Clamp( clr[1] * 1000 + 15, 1, 255 )
				local G = math.Clamp( clr[2] * 1000 + 15, 1, 255 )
				local B = math.Clamp( clr[3] * 1000 + 15, 1, 255 )

				local lightPwr = math.Clamp( (R + G + B) / 255, 0, 1 )

				fx:SetDieTime( 1 )
				fx:SetStartAlpha( 255 )
				fx:SetEndAlpha( 0 )

				fx:SetStartSize( 1 )
				fx:SetEndSize( 0 )
				local cc = Vector( 255, 222, 79 ) * lightPwr
				fx:SetColor( cc[1], cc[2], cc[3] )
				--fx:SetColor( 255, 222, 79 )

				fx:SetGravity( Vector( 0, 0, -250 ) )

				fx:SetCollide( false )
			end
		end

		--piss overlay
		if CLIENT and LocalPlayer().orange_blossom_pissed ~= nil then
			hook.Remove( "RenderScreenspaceEffects", "Overlay_PissHook" )

			if LocalPlayer():Alive() and LocalPlayer().orange_blossom_pissed > self.time then
				hook.Add( "RenderScreenspaceEffects", "Overlay_PissHook", function()
					DrawMaterialOverlay( "models/orange_blossom/piss/piss_overlay", -0.05 )
				end )
			end
		end
	end

	--logic to execute after collided turns true
	--Gmod's networking is unpredictible so I had to manually implement a delay

	--self:SetPerformPiss( false ) --too slow

	if CLIENT and self:GetPerformPiss() and !self.didOnce then
		self:PissExplosion()
		self.didOnce = true
	end

	if SERVER and self.performDelay < self.time then
		self:PissExplosion()
		self.performDelay = 999999
	end

	if CLIENT then
		self:SetNextClientThink( CurTime() + 0.05 )
		return true
	else
		if self.byeBye < self.time then
			self:Remove()
		end

		self:NextThink( CurTime() + 0.1 )
		return true
	end
end

function ENT:OnRemove()
	self.time = CurTime()

	for _,v in pairs(self.pissed) do
		if IsValid(v) and v.orange_blossom_pissed ~= nil and v.orange_blossom_pissed <= self.time then
			v:SetColor(self.colNormal) --color is permanent for players unless restored

			if CLIENT and v == LocalPlayer() then
				hook.Remove( "RenderScreenspaceEffects", "Overlay_PissHook" ) --stupid safeguard
			end
		end
	end

	if CLIENT and IsValid( self.emitter ) then
		self.emitter:Finish()
	end
end 


================================================
FILE: gamemodes/breach/entities/entities/canebar/cl_init.lua
================================================
include('shared.lua')
 
if CLIENT then
    killicon.Add("canebar", "vgui/hud/killicon/greg_icon", Color(255, 255, 255, 255))
end 


================================================
FILE: gamemodes/breach/entities/entities/canebar/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include('shared.lua')

-- Server-side initialization function for the Entity
function ENT:Initialize()
    if SERVER then
        self.Entity:SetModel("models/canebar/w_house_canebar.mdl")      -- Sets the model for the Entity.
        self.Entity:PhysicsInit(SOLID_VPHYSICS)                         -- Initializes the physics of the Entity.
        self.Entity:SetMoveType(MOVETYPE_VPHYSICS)                      -- Sets how the Entity moves, using physics.
        self.Entity:SetSolid(SOLID_VPHYSICS)                            --  Makes the Entity solid, allowing for collisions.
        util.SpriteTrail(self.Entity, 0, Color_white, true, 3, 0, 0.5, 0, "trails/laser")
        self.NextThinkTime = CurTime() + 1 -- Initialize the next think time
    end
end

function ENT:Think()

    if not IsValid(self.Owner) then -- Owner disconnected
        self:Remove()
        return
    end

    if not self.Owner:Alive() then -- Owner died
        self:Remove()
        return
    end
    
    if SERVER and CurTime() >= self.NextThinkTime then
        for k, user in pairs(ents.FindInSphere(self.Entity:GetPos(), 75)) do -- Searches for Entities within radius of canebar entity.
            if IsValid(user) and user:IsPlayer() and self.Entity.Owner == user then -- Checks to ensure player is valid and is the owner of our entity.
                if user:HasWeapon("weapon_house_canebar_holstered") then -- Checks if they have the holstered SWEP or not as we have two SWEPS that create this entity
                    user:StripWeapon("weapon_house_canebar_holstered") -- Removes Holstered Variant of the recall SWEP, the normal variant does not use this SWEP
                    user:Give("weapon_house_canebar_recall", false)
                    user:SelectWeapon("weapon_house_canebar_recall")
                    user:EmitSound("WeaponFrag.Throw")
                    self.Entity:Remove()
                    break -- Ends the function
                else
                    user:Give("weapon_house_canebar", false)
                    user:SelectWeapon("weapon_house_canebar")
                    user:EmitSound("WeaponFrag.Throw")
                    self.Entity:Remove()
                    break -- Ends the function
                end
            end
        end
        self.NextThinkTime = CurTime() + 1 -- Set the next think time to 1 second later
    end
end

function ENT:PhysicsCollide(data, phys)
    if SERVER then
        if data.Speed > 300 then
            self.Entity:EmitSound("weapons/canebar/metal_pipe.mp3")

            local hitent = data.HitEntity
            if IsValid(hitent) then
                local dmg = DamageInfo()
                local attacker = self.Entity.Owner
                if not IsValid(attacker) then attacker = self end
                dmg:SetAttacker(attacker)
                dmg:SetInflictor(hitent)
                dmg:SetDamage(data.Speed / 50)
                hitent:TakeDamageInfo(dmg)
            end
        end
    end
end 


================================================
FILE: gamemodes/breach/entities/entities/canebar/shared.lua
================================================
-- Defines the Entity's type, base, printable name, and author for shared access (both server and client)
ENT.Type            = "anim"
ENT.Base            = "base_anim"
ENT.PrintName		= "Canebar"
ENT.Author			= "Opal and Bunny"
ENT.Instructions	= "Left click, right click, reload."

function ENT:SetupDataTables()

end 


================================================
FILE: gamemodes/breach/entities/entities/ent_br_blockade/cl_init.lua
================================================
include('shared.lua')

function ENT:Draw()
    -- self.BaseClass.Draw(self)
    self:DrawModel()
end


================================================
FILE: gamemodes/breach/entities/entities/ent_br_blockade/init.lua
================================================
AddCSLuaFile( "cl_init.lua" )
AddCSLuaFile( "shared.lua" )
include('shared.lua')

function ENT:Initialize()


	//self:SetModel( "models/props_interiors/BathTub01a.mdl" )
	//self:PhysicsInit( SOLID_VPHYSICS )
	//self:SetMoveType( MOVETYPE_VPHYSICS )
	self:SetSolid( SOLID_VPHYSICS )

    //local phys = self:GetPhysicsObject()
	//if (phys:IsValid()) then
		//phys:Wake()
	//end
end
 
function ENT:Use( activator, caller )
   return
end
 
function ENT:Think()
end


================================================
FILE: gamemodes/breach/entities/entities/ent_br_blockade/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
 
ENT.PrintName = "Blockade"
ENT.Author = "Kanade"
ENT.Contact = "Steam"
ENT.Purpose = ""
ENT.Instructions = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false


================================================
FILE: gamemodes/breach/entities/entities/falling_lava/init.lua
================================================
-- SCP 313, A representation of a paranormal object on a fictional series on the game Garry's Mod.
-- Copyright (C) 2023  MrMarrant aka BIBI.

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

AddCSLuaFile("shared.lua")
include("shared.lua")

local ClassList = {
	"prop_door_rotating",
	"prop_ragdoll",
	"prop_physics"
}

function ENT:Initialize()
	self:SetModel( "models/hunter/misc/sphere025x025.mdl" )
	self:PhysicsInit( SOLID_VPHYSICS )
	self:SetMoveType(MOVETYPE_FLYGRAVITY)
	self:SetSolid( SOLID_VPHYSICS )
	self:SetMaterial( "models/props_lab/Tank_Glass001" )
	self:SetCustomCollisionCheck( true )
	self:Ignite(999)
	local phys = self:GetPhysicsObject()
	if (phys:IsValid()) then
		phys:Wake()
	end
end

function ENT:Touch(entTouch)
	if (entTouch:IsPlayer()) then
		-- Breach compatibility - don't affect spectators
		if entTouch:GTeam() == TEAM_SPEC then 
			self:Remove()
			return 
		end
		
		if (!entTouch:HasGodMode()) then
			entTouch:SetModel("models/player/charple.mdl")
			entTouch:Ignite(10)
		end
		self:Remove()
	elseif (entTouch:GetClass() == "plasma_lava" or entTouch:GetClass() == "scp_313") then
		self:Remove()
	elseif (table.HasValue( ClassList, entTouch:GetClass() )) then
		entTouch:Ignite(10)
	elseif (entTouch:IsWorld()) then
		local ent = ents.Create( "plasma_lava" )
		ent:SetPos( self:GetPos())
		ent:Spawn()
		ent:Activate()
		ent:Ignite(30, 200)
		self:Remove()
	end
end

hook.Add( "ShouldCollide", "ShouldCollide.SCP313Lava", function( ent1, ent2 )
	if ((ent1:GetClass() == "falling_lava" and ent2:GetClass() == "scp_313") or (ent1:GetClass() == "falling_lava" and ent2:GetClass() == "falling_lava")) then return false end
end ) 


================================================
FILE: gamemodes/breach/entities/entities/falling_lava/shared.lua
================================================
-- SCP 313, A representation of a paranormal object on a fictional series on the game Garry's Mod.
-- Copyright (C) 2023  MrMarrant aka BIBI.

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Author = "MrMarrant"
ENT.PrintName = "Falling Lava"
ENT.Spawnable = false
ENT.Category = "" 


================================================
FILE: gamemodes/breach/entities/entities/impostor_vent/init.lua
================================================
AddCSLuaFile()

ENT.Base = "base_entity"
ENT.Type = "anim"
ENT.Category = "SCP"
ENT.Author = "Breach"
ENT.PrintName = "Impostor Vent"
ENT.Spawnable = false
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "LinkedVent")
    self:NetworkVar("Entity", 1, "Owner")
end

function ENT:Initialize()
    print("Impostor vent Initialize() called!")
    -- Używamy dużego, widocznego modelu
    self:SetModel("models/props_c17/oildrum001.mdl") -- Duży beczka jako test
    print("Vent model set to: " .. self:GetModel())
    self:SetMoveType(MOVETYPE_NONE)
    self:SetSolid(SOLID_VPHYSICS)
    
    if SERVER then
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetUseType(SIMPLE_USE)
    end
    
    -- Bardzo jasny, widoczny kolor
    self:SetColor(Color(255, 0, 0, 255))
    self:SetMaterial("models/debug/debugwhite")
    
    local phys = self:GetPhysicsObject()
    if IsValid(phys) then
        phys:EnableMotion(false) -- Nie pozwól się ruszać
    end
end

function ENT:Use(ply)
    if !IsValid(ply) or !ply:IsPlayer() then return end
    if !IsValid(self:GetOwner()) then return end
    if ply != self:GetOwner() then return end -- Tylko właściciel może używać
    
    local linkedVent = self:GetLinkedVent()
    if !IsValid(linkedVent) then
        ply:PrintMessage(HUD_PRINTCENTER, "No linked vent found!")
        return
    end
    
    -- Teleportuj do drugiego venta
    local teleportPos = linkedVent:GetPos() + Vector(0, 0, 50) -- Trochę wyżej żeby nie wpaść w ziemię
    ply:SetPos(teleportPos)
    
    -- Efekty dźwiękowe i wizualne
    ply:EmitSound("ambient/machines/teleport1.wav", 70, 100)
    linkedVent:EmitSound("ambient/machines/teleport3.wav", 70, 100)
    
    -- Efekt wizualny
    local effectdata = EffectData()
    effectdata:SetOrigin(self:GetPos())
    util.Effect("Sparks", effectdata)
    
    effectdata:SetOrigin(teleportPos)
    util.Effect("Sparks", effectdata)
end

function ENT:Draw()
    -- Rysuj model - czerwona beczka jako test
    self:DrawModel()
    
    local ply = LocalPlayer()
    if !IsValid(ply) then return end
    if ply:GetPos():Distance(self:GetPos()) > 150 then return end
    if self:GetOwner() != ply then return end
    
    -- Pokaż tekst "Press E to use vent"
    cam.Start2D()
        if DrawInfo then
            DrawInfo(self:GetPos() + Vector(0, 0, 50), "Press E to use vent", Color(255, 255, 255))
        else
            -- Fallback text rendering
            local pos2d = self:GetPos():ToScreen()
            if pos2d.visible then
                draw.SimpleText("Press E to use vent", "DermaDefault", pos2d.x, pos2d.y - 20, Color(255, 255, 255), TEXT_ALIGN_CENTER)
            end
        end
    cam.End2D()
end

function ENT:OnRemove()
    -- Usuń połączenie z drugim ventem
    local linkedVent = self:GetLinkedVent()
    if IsValid(linkedVent) then
        linkedVent:SetLinkedVent(NULL)
    end
end 


================================================
FILE: gamemodes/breach/entities/entities/item_scp_215/cl_init.lua
================================================
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
	
	-- Efekt świecenia dla lepszej widoczności
	local glow = math.sin(CurTime() * 3) * 0.2 + 0.8
	render.SetBlend(glow)
	self:DrawModel()
	render.SetBlend(1)
	
	-- Dodaj subtelny efekt cząsteczek
	if math.random(1, 10) == 1 then
		local effectdata = EffectData()
		effectdata:SetOrigin(self:GetPos() + Vector(0, 0, 5))
		effectdata:SetMagnitude(0.5)
		effectdata:SetScale(0.5)
		util.Effect("sparks", effectdata)
	end
end

-- TargetID usunięte zgodnie z żądaniem


================================================
FILE: gamemodes/breach/entities/entities/item_scp_215/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

function ENT:Initialize()
	-- Ustawienie modelu okularów
	self:SetModel("models/maxpayne/weapons/shades.mdl")
	
	if SERVER then
		-- Fizyka entity
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:PhysicsInit(SOLID_VPHYSICS)
		
		-- Konfiguracja fizyki
		local phys = self:GetPhysicsObject()
		if IsValid(phys) then
			phys:Wake()
			phys:SetMass(2) -- Lekkie okulary
		end
		
		-- Ustawienia kolizji
		self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
		self:SetUseType(SIMPLE_USE)
	end
end

function ENT:Use(activator, caller)
	if not IsValid(activator) or not activator:IsPlayer() then return end
	
	-- Sprawdź czy gracz może podnieść SCP-215
	if activator:GTeam() == TEAM_SPEC then return end
	
	-- Sprawdź czy gracz już ma SCP-215
	if activator:HasWeapon("item_scp_215") then
		return
	end
	
	-- Daj graczowi SCP-215
	if SERVER then
		activator:Give("item_scp_215")
		
		-- Usuń entity z mapy
		self:Remove()
	end
end

function ENT:Think()
	-- Lekka rotacja dla efektu wizualnego
	if SERVER then
		local angles = self:GetAngles()
		angles.y = angles.y + 0.5
		self:SetAngles(angles)
		self:NextThink(CurTime() + 0.1)
		return true
	end
end


================================================
FILE: gamemodes/breach/entities/entities/item_scp_215/shared.lua
================================================
AddCSLuaFile()

ENT.Base = "base_anim"
ENT.Type = "anim"

ENT.PrintName = "SCP-215"
ENT.Author = "Breach Team"
ENT.Category = "SCP"
ENT.Spawnable = true
ENT.AdminSpawnable = true

-- Informacje o SCP-215
ENT.SCPName = "SCP-215"
ENT.SCPDescription = "Anomalous Sunglasses - Allows wearer to see hostile entities marked with red squares"


================================================
FILE: gamemodes/breach/entities/entities/item_scp_330/README.md
================================================
# SCP-330 Implementation for Breach Gamemode

## Overview
SCP-330 "A Bag of Tricks" is a fully functional anomalous entity implementation for the Breach gamemode. It's based on the original SCP-330 addon but adapted for full compatibility with the Breach framework.

## Features

### Core Functionality
- **Candy Bowl**: Interactive entity that dispenses anomalous candies
- **Two Candy Limit**: Players can safely take up to 2 candies
- **Hand Severance**: Taking a 3rd candy results in permanent hand loss
- **Bleeding Effect**: Hand loss causes severe bleeding for 15 minutes
- **Weapon Restriction**: Players with severed hands cannot pick up weapons

### Visual Effects
- **Proximity Warning**: Text warning appears when approaching SCP-330
- **Blood Overlay**: Visual bleeding effects with screen overlay
- **Motion Blur**: Disorienting effects during hand loss
- **Sound Effects**: Full sound package including warnings and effects

### Breach Integration
- **Logging System**: All interactions logged through Breach framework
- **Admin Commands**: Full set of admin controls
- **Player Tracking**: Persistent player state across rounds
- **Team Compatibility**: Works with all Breach teams and roles

## File Structure

```
gamemodes/breach/entities/entities/item_scp_330/
├── shared.lua          # Entity definition and shared properties
├── init.lua           # Server-side entity logic
├── cl_init.lua        # Client-side entity effects
└── README.md          # This documentation

gamemodes/breach/entities/weapons/
└── weapon_scp330_candy.lua    # Candy consumption weapon

gamemodes/breach/gamemode/modules/
├── sv_scp330.lua      # Server module with global functions
└── cl_scp330.lua      # Client module with effects
```

## Configuration

Edit `SCP330.Config` in `sv_scp330.lua`:

```lua
SCP330.Config = {
    MaxCandies = 2,           -- Maximum safe candies (default: 2)
    BleedDamage = 5,          -- Damage per bleed tick (default: 5)
    BleedInterval = 10,       -- Seconds between damage (default: 10)
    BleedDuration = 900,      -- Total bleeding time in seconds (default: 15 min)
    ProximityRadius = 150,    -- Warning trigger distance (default: 150)
    HandRemovalTime = 300     -- Hand prop cleanup time (default: 5 min)
}
```

## Admin Commands

### Spawning
```
scp330_spawn
```
Spawns SCP-330 at crosshair position (admin only)

### Player Management
```
scp330_reset_player <player_name>
```
Resets SCP-330 effects for specified player (admin only)

### Information
```
scp330_info
```
Displays SCP-330 statistics and active effects (admin only)

## Global Functions

### Server Functions (SCP330)
- `SCP330:InitPlayer(ply)` - Initialize player data
- `SCP330:ResetPlayer(ply)` - Reset all player effects
- `SCP330:CanTakeCandy(ply)` - Check if player can take candy
- `SCP330:GetCandyCount(ply)` - Get player's candy count
- `SCP330:GetRandomFlavor()` - Get random candy flavor
- `SCP330:Log(message, category)` - Log events

### Client Functions (SCP330.Client)
- `SCP330.Client:PlaySound(soundPath)` - Play sound effect
- `SCP330.Client:CreateBloodOverlay()` - Show blood effect
- `SCP330.Client:CreateProximityWarning(entity)` - Show warning text

## Network Messages

- `SCP330_PlaySound` - Play sound on client
- `SCP330_BloodEffect` - Trigger blood overlay
- `SCP330_ProximityWarning` - Show proximity warning

## Player Data Structure

```lua
SCP330.PlayerData[steamID] = {
    candyTaken = 0,      -- Number of candies taken
    handsCut = false,    -- Whether hands are severed
    bleeding = false,    -- Currently bleeding status
    lastInteraction = 0  -- Last interaction timestamp
}
```

## Candy Flavors

Available candy flavors:
- Strawberry, Apple, Cherry, Orange, Lemon, Banana
- Raspberry, Blueberry, Pineapple, Melon, Watermelon
- Peach, Pear, Apricot, Plum, Mango, Kiwi, Fig, Grape, Hazelnut

## Sound Requirements

The following sounds should be present in `sound/scp_330/`:
- `pick_candy.mp3` - Taking candy sound
- `consume_candy.mp3` - Eating candy sound
- `cut_hands.mp3` - Hand severance sound
- `you_got_what_you_deserve.mp3` - Punishment sound
- `on_first_contact.mp3` - Proximity warning sound
- `heavy_breath_1.mp3`, `heavy_breath_2.mp3`, `heavy_breath_3.mp3` - Bleeding sounds

## Model Requirements

Required models:
- `models/scp_330/scp_330.mdl` - Main SCP-330 bowl
- `models/scp_330/scp_330_hand.mdl` - Severed hand prop
- `models/weapons/scp_330/v_scp_330.mdl` - Candy viewmodel
- `models/weapons/scp_330/w_scp_330.mdl` - Candy worldmodel

## Compatibility

- Fully compatible with Breach gamemode framework
- Uses Breach logging system
- Integrates with team system
- Respects admin permissions
- Compatible with other SCP entities

## Notes

- Player data persists across map changes
- Effects are automatically cleaned up on player death/respawn
- Hand severance effect is permanent until manual reset
- All interactions are logged for admin monitoring
- Client-side effects are optimized for performance

## Troubleshooting

### Common Issues
1. **Sounds not playing**: Ensure sound files are in correct directory
2. **Models not loading**: Verify model files are present
3. **Effects not showing**: Check client module is loaded
4. **Admin commands not working**: Verify admin permissions

### Debug Commands (Admin Only)
```
scp330_test_blood    # Test blood overlay effect
scp330_test_warning  # Test proximity warning
```

## Credits

Based on the original SCP-330 addon by MrMarrant, adapted for Breach gamemode compatibility by the Breach development team. 


================================================
FILE: gamemodes/breach/entities/entities/item_scp_330/cl_init.lua
================================================
-- SCP-330 client logic dla gamemode Breach
-- Bazowany na oryginalnym kodzie SCP-330 z kompatybilnością Breach

include("shared.lua")

-- Client effects configuration
local WARNING_RADIUS = 150
local WARNING_SHOWN = {}

function ENT:Draw()
    self:DrawModel()
end

function ENT:Think()
    self:ProximityWarning()
end

function ENT:ProximityWarning()
    local ply = LocalPlayer()
    if not IsValid(ply) or not ply:Alive() then return end
    
    local distance = ply:GetPos():Distance(self:GetPos())
    if distance > WARNING_RADIUS then return end
    
    -- Show warning only once per entity
    local entIndex = self:EntIndex()
    if WARNING_SHOWN[entIndex] then return end
    
    WARNING_SHOWN[entIndex] = true
    
    -- Play warning sound
    ply:EmitSound("scp_330/on_first_contact.mp3")
    
    -- Show warning text
    self:ShowProximityMessage()
end

function ENT:ShowProximityMessage()
    local startTime = CurTime()
    local duration = 4
    local maxAlpha = 255
    
    hook.Add("HUDPaint", "SCP330_ProximityWarning_" .. self:EntIndex(), function()
        local elapsed = CurTime() - startTime
        if elapsed >= duration then
            hook.Remove("HUDPaint", "SCP330_ProximityWarning_" .. self:EntIndex())
            return
        end
        
        local alpha = maxAlpha * (1 - (elapsed / duration))
        local size = 0.3 + (elapsed / duration) * 2
        
        local scrW, scrH = ScrW(), ScrH()
        local centerX, centerY = scrW * 0.5, scrH * 0.5
        
        -- Create scaling matrix
        local matrix = Matrix()
        matrix:Translate(Vector(centerX, centerY, 0))
        matrix:Scale(Vector(size, size, 1))
        matrix:Translate(Vector(-centerX, -centerY, 0))
        
        cam.PushModelMatrix(matrix)
        
        -- Draw warning text
        draw.DrawText("take no more than two,", "DermaLarge", centerX, centerY - 20, Color(255, 255, 255, alpha), TEXT_ALIGN_CENTER)
        draw.DrawText("please!!", "DermaLarge", centerX, centerY + 20, Color(255, 255, 255, alpha), TEXT_ALIGN_CENTER)
        
        cam.PopModelMatrix()
        
        -- Apply color modification
        local colorTab = {
            ["$pp_colour_contrast"] = math.Clamp(elapsed / duration + 0.3, 0, 1)
        }
        DrawColorModify(colorTab)
        
        -- Motion blur effect
        DrawMotionBlur(0.1, 0.2, 0.05)
    end)
end

-- Network message handlers
net.Receive("SCP330_PlaySound", function()
    local soundPath = net.ReadString()
    LocalPlayer():EmitSound(soundPath)
end)

net.Receive("SCP330_BloodEffect", function()
    local ply = LocalPlayer()
    
    -- Create blood overlay effect
    if not ply.SCP330_BloodOverlay then
        ply.SCP330_BloodOverlay = true
        
        local startTime = CurTime()
        local duration = 4
        local fadeInTime = duration * 0.5
        local fadeOutTime = duration * 0.5
        
        hook.Add("HUDPaint", "SCP330_BloodOverlay_" .. ply:EntIndex(), function()
            local elapsed = CurTime() - startTime
            if elapsed >= duration then
                hook.Remove("HUDPaint", "SCP330_BloodOverlay_" .. ply:EntIndex())
                ply.SCP330_BloodOverlay = nil
                return
            end
            
            local alpha
            if elapsed <= fadeInTime then
                alpha = 200 * (elapsed / fadeInTime)
            else
                alpha = 200 * (1 - ((elapsed - fadeInTime) / fadeOutTime))
            end
            
            -- Draw blood overlay
            surface.SetDrawColor(139, 0, 0, alpha) -- Dark red
            surface.DrawRect(0, 0, ScrW(), ScrH())
            
            -- Apply blur effect
            DrawMotionBlur(0.1, 0.5, 0.1)
        end)
        
        -- Play breathing sound
        local breathSounds = {
            "scp_330/heavy_breath_1.mp3",
            "scp_330/heavy_breath_2.mp3", 
            "scp_330/heavy_breath_3.mp3"
        }
        ply:EmitSound(breathSounds[math.random(#breathSounds)])
    end
end)

-- Clean up on entity removal
function ENT:OnRemove()
    hook.Remove("HUDPaint", "SCP330_ProximityWarning_" .. self:EntIndex())
    WARNING_SHOWN[self:EntIndex()] = nil
end 


================================================
FILE: gamemodes/breach/entities/entities/item_scp_330/init.lua
================================================
-- SCP-330 server logic dla gamemode Breach
-- Bazowany na oryginalnym kodzie SCP-330 z kompatybilnością Breach

AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

-- Sounds that will be used
local CANDY_SOUNDS = {
    pick = "scp_330/pick_candy.mp3",
    consume = "scp_330/consume_candy.mp3",
    cut_hands = "scp_330/cut_hands.mp3",
    deserve = "scp_330/you_got_what_you_deserve.mp3",
    first_contact = "scp_330/on_first_contact.mp3",
    breathing = {
        "scp_330/heavy_breath_1.mp3",
        "scp_330/heavy_breath_2.mp3",
        "scp_330/heavy_breath_3.mp3"
    }
}

-- Candy flavors
local CANDY_FLAVORS = {
    "Strawberry", "Apple", "Cherry", "Orange", "Lemon", "Banana",
    "Raspberry", "Blueberry", "Pineapple", "Melon", "Watermelon",
    "Peach", "Pear", "Apricot", "Plum", "Mango", "Kiwi", "Fig", "Grape", "Hazelnut"
}

function ENT:Initialize()
    self:SetModel("models/scp_330/scp_330.mdl")
    self:RebuildPhysics()
    
    -- Breach compatibility
    self:SetMaxHealth(100)
    self:SetHealth(100)
    self:SetSolid(SOLID_VPHYSICS)
    self:SetMoveType(MOVETYPE_VPHYSICS)
    self:SetUseType(SIMPLE_USE)
    
    -- Entity is now managed by global SCP330 system
end

function ENT:RebuildPhysics()
    self:PhysicsInit(SOLID_VPHYSICS)
    self:SetMoveType(MOVETYPE_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)
    self:SetUseType(SIMPLE_USE)
    self:PhysWake()
end

function ENT:PhysicsCollide(data, physobj)
    if data.DeltaTime > 0.2 then
        if data.Speed > 250 then
            self:EmitSound("physics/glass/glass_bottle_impact_hard" .. math.random(1, 3) .. ".wav", 75, math.random(100, 110))
        else
            self:EmitSound("physics/glass/glass_impact_soft" .. math.random(1, 3) .. ".wav", 75, math.random(100, 110))
        end
    end
end

function ENT:Use(ply)
    if not IsValid(ply) then return end
    if not ply:Alive() then return end
    
    -- Block SCP players from taking candy
    local gteam = ply.GTeam and ply:GTeam() or ply:Team()
    if gteam == TEAM_SCP then
        ply:PrintMessage(HUD_PRINTTALK, "[SCP-330] SCPs cannot take candy.")
        return
    end
    
    -- Initialize player data in global system
    SCP330:InitPlayer(ply)
    
    -- Check if player can take candy
    if not SCP330:CanTakeCandy(ply) then
        SCP330:Log("Player " .. ply:Nick() .. " tried to use SCP-330 with cut hands")
        return
    end
    
    -- Check if player has inventory space before giving candy
    local canCarry = true
    if ply.CanCarryWeapon then
        canCarry = ply:CanCarryWeapon("weapon_scp330_candy")
    else
        -- Fallback: allow up to 16 weapons in inventory
        canCarry = (#ply:GetWeapons() < 16)
    end

    if not canCarry then
        ply:PrintMessage(HUD_PRINTTALK, "[SCP-330] You need free inventory space to take candy!")
        return
    end
    
    -- Increment candy count
    local steamID = ply:SteamID64()
    SCP330.PlayerData[steamID].candyTaken = SCP330.PlayerData[steamID].candyTaken + 1
    SCP330.PlayerData[steamID].lastInteraction = CurTime()
    
    local candyCount = SCP330.PlayerData[steamID].candyTaken
    SCP330:Log("Player " .. ply:Nick() .. " is taking candy #" .. candyCount .. " (limit: " .. SCP330.Config.MaxCandies .. ")")
    
    if candyCount > SCP330.Config.MaxCandies then
        -- Cut hands punishment
        SCP330:Log("PUNISHMENT: Player " .. ply:Nick() .. " exceeded limit, cutting hands!")
        self:CutPlayerHands(ply)
    else
        -- Give candy
        SCP330:Log("SAFE: Player " .. ply:Nick() .. " receives candy safely")
        self:GiveCandy(ply)
    end
end

function ENT:CutPlayerHands(ply)
    local steamID = ply:SteamID64()
    SCP330.PlayerData[steamID].handsCut = true
    SCP330.PlayerData[steamID].bleeding = true
    
    -- Sound effects
    ply:EmitSound(CANDY_SOUNDS.cut_hands)
    
    -- Create hand props
    local rightHand = ents.Create("prop_physics")
    local leftHand = ents.Create("prop_physics")
    
    if IsValid(leftHand) then
        leftHand:SetModel("models/scp_330/scp_330_hand.mdl")
        leftHand:SetPos(ply:GetPos() + (-40 * ply:GetRight()))
        leftHand:Spawn()
        
        -- Auto-remove after configured time
        timer.Simple(SCP330.Config.HandRemovalTime, function()
            if IsValid(leftHand) then 
                leftHand:Remove() 
            end
        end)
    end
    
    if IsValid(rightHand) then
        rightHand:SetModel("models/scp_330/scp_330_hand.mdl")
        rightHand:SetPos(ply:GetPos() + (40 * ply:GetRight()))
        rightHand:Spawn()
        
        -- Auto-remove after configured time
        timer.Simple(SCP330.Config.HandRemovalTime, function()
            if IsValid(rightHand) then 
                rightHand:Remove() 
            end
        end)
    end
    
    -- Send message to player
    net.Start("SCP330_PlaySound")
        net.WriteString(CANDY_SOUNDS.deserve)
    net.Send(ply)
    
    -- Apply bleeding effect
    self:StartBleeding(ply)
    
    -- Strip weapons (hands are cut off)
    ply:StripWeapons()
    
    -- Blood decal
    util.Decal("Blood", ply:GetPos() - Vector(0, 0, 1), ply:GetPos() + Vector(0, 0, 1), ply)
    
    -- Log the event
    SCP330:Log("Player " .. ply:Nick() .. " had their hands cut by SCP-330")
end

function ENT:GiveCandy(ply)
    -- Get or create candy weapon
    local candyWeapon = ply:HasWeapon("weapon_scp330_candy") and ply:GetWeapon("weapon_scp330_candy") or ply:Give("weapon_scp330_candy")
    
    if IsValid(candyWeapon) then
        -- Add random candy flavor using global system
        local flavor = SCP330:GetRandomFlavor()
        
        if not candyWeapon.CandyPossessed then
            candyWeapon.CandyPossessed = {}
        end
        
        table.insert(candyWeapon.CandyPossessed, flavor)
        
        -- Send notification
        ply:PrintMessage(HUD_PRINTTALK, "You took a SCP-330 candy with the scent of " .. flavor .. "!")
        
        -- Play sound
        ply:EmitSound(CANDY_SOUNDS.pick, 75, math.random(90, 110))
        
        -- Log the event
        local candyCount = SCP330:GetCandyCount(ply)
        SCP330:Log("Player " .. ply:Nick() .. " took candy #" .. candyCount .. " from SCP-330")
    end
end

function ENT:StartBleeding(ply)
    if not IsValid(ply) then return end
    
    -- Use global configuration
    local bleedInterval = SCP330.Config.BleedInterval
    local bleedDuration = SCP330.Config.BleedDuration
    local bleedDamage = SCP330.Config.BleedDamage
    
    -- Start bleeding timer
    local timerName = "SCP330_Bleeding_" .. ply:EntIndex()
    local tickCount = 0
    local maxTicks = bleedDuration / bleedInterval
    
    timer.Create(timerName, bleedInterval, maxTicks, function()
        if not IsValid(ply) or not ply:Alive() then
            timer.Remove(timerName)
            return
        end
        
        ply:TakeDamage(bleedDamage)
        
        -- Blood effects
        util.Decal("Blood", ply:GetPos() - Vector(0, 0, 1), ply:GetPos() + Vector(0, 0, 1), ply)
        
        -- Send visual effects to client
        net.Start("SCP330_BloodEffect")
        net.Send(ply)
        
        tickCount = tickCount + 1
        if tickCount >= maxTicks then
            timer.Remove(timerName)
            -- Clear hand cut status after bleeding ends using global system
            local steamID = ply:SteamID64()
            if SCP330.PlayerData[steamID] then
                SCP330.PlayerData[steamID].handsCut = false
                SCP330.PlayerData[steamID].bleeding = false
            end
        end
    end)
end

-- Network messages
util.AddNetworkString("SCP330_PlaySound")
util.AddNetworkString("SCP330_BloodEffect")
util.AddNetworkString("SCP330_ProximityWarning")

-- Clean up on player disconnect
hook.Add("PlayerDisconnected", "SCP330_Entity_PlayerCleanup", function(ply)
    -- Remove any bleeding timers
    timer.Remove("SCP330_Bleeding_" .. ply:EntIndex())
end)

-- Clean up on player death/respawn
hook.Add("PlayerDeath", "SCP330_Entity_PlayerDeath", function(ply)
    timer.Remove("SCP330_Bleeding_" .. ply:EntIndex())
end)

hook.Add("PlayerSpawn", "SCP330_Entity_PlayerSpawn", function(ply)
    timer.Remove("SCP330_Bleeding_" .. ply:EntIndex())
end)

-- Note: Weapon pickup prevention is now handled by the global SCP330 module 


================================================
FILE: gamemodes/breach/entities/entities/item_scp_330/shared.lua
================================================
-- SCP-330 entity dla gamemode Breach
-- Bazowany na oryginalnym kodzie SCP-330 z kompatybilnością Breach

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Author = "Breach Team"
ENT.PrintName = "SCP-330"
ENT.Category = "Breach SCP"
ENT.Spawnable = false
ENT.AdminOnly = true
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

-- SCP-330 specific properties
ENT.MaxCandiesTaken = 2 


================================================
FILE: gamemodes/breach/entities/entities/plasma_lava/init.lua
================================================
-- SCP 313, A representation of a paranormal object on a fictional series on the game Garry's Mod.
-- Copyright (C) 2023  MrMarrant aka BIBI.

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

AddCSLuaFile("shared.lua")
include("shared.lua")

--TODO : Certains ne sont pas enflammer, j'ai pas vraiment trouver la raison qui provoquait ça, hormis quand on en spawn vraiment beaucoup à la suite.
local WaterLevelList = {
	1,
	2,
	3
}

function ENT:Initialize()
	self:SetModel( "models/hunter/tubes/circle2x2.mdl" )
	self:PhysicsInit( SOLID_VPHYSICS ) 
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid( SOLID_VPHYSICS )
	self:SetMaterial( "models/props_lab/Tank_Glass001" )
	self:Ignite(999)
	local phys = self:GetPhysicsObject()
	if (phys:IsValid()) then
		phys:Wake()
	end
	timer.Simple( 0.5, function() if (self:IsValid()) then self:SetMoveType(MOVETYPE_NONE) end end )
	timer.Simple( 30, function() if (self:IsValid()) then self:Remove() end end )
end

function ENT:Think()
	if (!self:IsOnGround() and self:GetMoveType() == MOVETYPE_NONE) then -- TODO : A revoir pour ceux qui ne sont pas sur le sol
		--self:Remove()
	end
	if (table.HasValue( WaterLevelList, self:WaterLevel() )) then
		self:Extinguish()
	end
end

hook.Add( "ShouldCollide", "ShouldCollide.PlasmaLava", function( ent1, ent2 )
	if ((ent1:GetClass() == "plasma_lava" and ent2:GetClass() == "plasma_lava") ) then return false end
end ) 


================================================
FILE: gamemodes/breach/entities/entities/plasma_lava/shared.lua
================================================
-- SCP 313, A representation of a paranormal object on a fictional series on the game Garry's Mod.
-- Copyright (C) 2023  MrMarrant aka BIBI.

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Author = "MrMarrant"
ENT.PrintName = "Plasma Lava"
ENT.Spawnable = false
ENT.Category = "" 


================================================
FILE: gamemodes/breach/entities/entities/scp106_barrier/cl_init.lua
================================================
include("shared.lua")

function ENT:Initialize()
    -- Efekt wizualny dla bariery (opcjonalnie)
end

function ENT:Draw()
    -- Nie rysuj nic - bariera jest niewidoczna
    -- self:DrawModel() -- Zakomentowane
end



================================================
FILE: gamemodes/breach/entities/entities/scp106_barrier/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

function ENT:Initialize()
    self:SetModel("models/hunter/plates/plate2x2.mdl")
    self:PhysicsInit(SOLID_VPHYSICS)
    self:SetMoveType(MOVETYPE_NONE)
    self:SetSolid(SOLID_VPHYSICS)
    self:SetUseType(SIMPLE_USE)
    
    -- Zrób barierę stałą
    local phys = self:GetPhysicsObject()
    if IsValid(phys) then
        phys:EnableMotion(false)
        phys:SetMass(50000)
    end
    
    -- NIEWIDOCZNA bariera
    self:SetColor(Color(255, 255, 255, 0)) -- Przezroczysta
    self:SetNoDraw(true) -- Nie rysuj
    self:SetRenderMode(RENDERMODE_TRANSCOLOR)
    
    print("[SCP-106 Barrier] Niewidoczna bariera SCP-106 utworzona w pozycji: " .. tostring(self:GetPos()))
end

function ENT:Touch(ent)
    if IsValid(ent) and ent:IsPlayer() then
        if ent:GetNClass() == ROLES.ROLE_SCP106 then
            -- SCP-106 może przejść - zrób barierę niekolizyjną dla niego
            self:SetCollisionGroup(COLLISION_GROUP_PASSABLE_DOOR)
            print("[SCP-106 Barrier] SCP-106 (" .. ent:Nick() .. ") przechodzi przez barierę")
            
            -- Przywróć kolizję po krótkim czasie
            timer.Simple(1, function()
                if IsValid(self) then
                    self:SetCollisionGroup(COLLISION_GROUP_NONE)
                end
            end)
        else
            -- Inny gracz - zablokuj
            self:SetCollisionGroup(COLLISION_GROUP_NONE) -- Upewnij się że kolizja jest aktywna
        end
    end
end

function ENT:StartTouch(ent)
    self:Touch(ent)
end

function ENT:EndTouch(ent)
    -- Opcjonalnie można dodać coś tutaj
end

function ENT:Use(activator, caller)
    if IsValid(activator) and activator:IsPlayer() and activator:IsAdmin() then
        activator:ChatPrint("=== SCP-106 Barrier Info ===")
        activator:ChatPrint("Pozycja: " .. tostring(self:GetPos()))
        activator:ChatPrint("Model: " .. self:GetModel())
        activator:ChatPrint("Kolor: " .. tostring(self:GetColor()))
    end
end



================================================
FILE: gamemodes/breach/entities/entities/scp106_barrier/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "SCP-106 Barrier"
ENT.Author = "Breach Gamemode"
ENT.Category = "SCP"
ENT.Spawnable = true
ENT.AdminOnly = true

ENT.Model = "models/hunter/plates/plate2x2.mdl"



================================================
FILE: gamemodes/breach/entities/entities/scp_035/cl_init.lua
================================================
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end 


================================================
FILE: gamemodes/breach/entities/entities/scp_035/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

-- Cooldown system for mask usage
local MaskCooldown = {}

function ENT:Initialize()
    self:SetModel("models/scp_035_real/scp_035_real.mdl")
    self:PhysicsInit(SOLID_VPHYSICS)
    self:SetMoveType(MOVETYPE_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)
    self:SetUseType(SIMPLE_USE)
    
    local phys = self:GetPhysicsObject()
    if IsValid(phys) then
        phys:Wake()
    end
    
    print("[SCP-035] Mask spawned at position: " .. tostring(self:GetPos()))
end

function ENT:PhysicsCollide(data, physobj)
    if data.DeltaTime > 0.2 then
        if data.Speed > 250 then
            self:EmitSound("physics/concrete/concrete_impact_hard" .. math.random(1, 3) .. ".wav", 75, math.random(100, 110))
        else
            self:EmitSound("physics/concrete/concrete_impact_soft" .. math.random(1, 3) .. ".wav", 75, math.random(100, 110))
        end
    end
end

function ENT:Use(ply)
    if not IsValid(ply) or not ply:IsPlayer() then return end
    
    print("[SCP-035 DEBUG] Player " .. ply:Nick() .. " trying to use mask")
    print("[SCP-035 DEBUG] Player team: " .. team.GetName(ply:GTeam()))
    print("[SCP-035 DEBUG] Player alive: " .. tostring(ply:Alive()))
    print("[SCP-035 DEBUG] Preparing state: " .. tostring(preparing))
    
    -- Sprawdź czy gracz jest spektatorem
    if ply:GTeam() == TEAM_SPEC then
        ply:PrintMessage(HUD_PRINTTALK, "[SCP-035] Spectators cannot use the mask!")
        print("[SCP-035 DEBUG] Blocked spectator from using mask")
        return
    end
    
    -- Sprawdź czy gracz jest żywy
    if not ply:Alive() then
        ply:PrintMessage(HUD_PRINTTALK, "[SCP-035] You must be alive to use the mask!")
        print("[SCP-035 DEBUG] Blocked dead player from using mask")
        return
    end
    
    -- Sprawdź czy runda się jeszcze nie zaczęła (preparing)
    if preparing then
        ply:PrintMessage(HUD_PRINTTALK, "[SCP-035] You cannot use the mask during preparation phase!")
        print("[SCP-035 DEBUG] Blocked mask usage during preparing")
        return
    end
    
    -- Sprawdź cooldown
    local steamID = ply:SteamID()
    if MaskCooldown[steamID] and CurTime() < MaskCooldown[steamID] then
        local timeLeft = math.ceil(MaskCooldown[steamID] - CurTime())
        ply:PrintMessage(HUD_PRINTTALK, "[SCP-035] You must wait " .. timeLeft .. " seconds before using the mask again!")
        print("[SCP-035 DEBUG] Blocked mask usage - cooldown active")
        return
    end
    
    -- Sprawdź czy gracz już jest SCP-035
    if ply:GetNClass() == ROLES.ROLE_SCP035 then 
        ply:PrintMessage(HUD_PRINTTALK, "[SCP-035] You are already wearing the mask!")
        print("[SCP-035 DEBUG] Player already is SCP-035")
        return 
    end
    
    -- Sprawdź czy gracz już jest SCP (oprócz SCP-035)
    if ply:GTeam() == TEAM_SCP then
        ply:PrintMessage(HUD_PRINTTALK, "[SCP-035] SCPs cannot wear the mask!")
        print("[SCP-035 DEBUG] Blocked SCP from using mask")
        return
    end
    
    -- Ustaw cooldown (30 sekund)
    MaskCooldown[steamID] = CurTime() + 30
    
    print("[SCP-035 DEBUG] All checks passed - transforming player")
    
    -- Transformuj gracza w SCP-035
    ply:BecomeSCP035()
    
    -- Usuń maskę
    self:Remove()
    
    print("[SCP-035] Player " .. ply:Nick() .. " successfully transformed into SCP-035")
end 


================================================
FILE: gamemodes/breach/entities/entities/scp_035/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Author = "Breach SCP Team"
ENT.PrintName = "SCP-035"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "SCP Breach"

ENT.RenderGroup = RENDERGROUP_BOTH 


================================================
FILE: gamemodes/breach/entities/entities/scp_207/init.lua
================================================
-- SCP-207, A representation of a paranormal object on a fictional series on the game Garry's Mod.
-- Copyright (C) 2023  MrMarrant aka BIBI.
-- Adapted for SCP: Breach gamemode

AddCSLuaFile("shared.lua")
include("shared.lua")

local PhysicSoundLow = Sound( "physics/glass/glass_bottle_impact_hard"..math.random(1, 3)..".wav" )
local BreakSound = Sound( "physics/glass/glass_bottle_break"..math.random(1, 2)..".wav" )
local PickUpSound = Sound( "scp_207/pickup.mp3" )

function ENT:BreakEntity()
	local effectdata = EffectData()

	effectdata:SetOrigin( self:GetPos() )
	sound.Play( BreakSound, self:GetPos(), 75, math.random( 50, 160 ) )
	util.Effect( "GlassImpact", effectdata )
	self:Remove()
end

function ENT:Initialize()
	self:SetModel( "models/scp_207/scp_207.mdl" )
	self:RebuildPhysics()
end

function ENT:RebuildPhysics( value )
	self:PhysicsInit( SOLID_VPHYSICS ) 
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid( SOLID_VPHYSICS ) 
	self:SetUseType(SIMPLE_USE)
	self:PhysWake()
end

function ENT:PhysicsCollide( data, physobj )
	if ( data.Speed > 250 and data.DeltaTime > 0.01) then
		self:BreakEntity(pos)
	elseif (data.Speed > 20 and data.DeltaTime > 0.01) then
		sound.Play( PhysicSoundLow, self:GetPos(), 75, math.random( 50, 160 ) )	
	end
end

function ENT:OnTakeDamage( dmginfo )
	local DmgReceive = dmginfo:GetDamage()
	if (DmgReceive >= 5) then
		self:BreakEntity(pos)
	else
		return 0
	end
end

function ENT:Use( ply)
	-- Basic Breach checks
	if not IsValid(ply) or not ply:IsPlayer() then return end
	if not ply:Alive() then return end
	if ply:GTeam() == TEAM_SPEC then return end
	
	-- Check if SCP-207 system allows this team/job
	if SCP_207_CONFIG and SCP_207_CONFIG.JobNotAllowed then
		local teamName = team.GetName(ply:Team())
		if SCP_207_CONFIG.JobNotAllowed[teamName] then return end
	end
	
	-- Check if player already has SCP-207
	if ply:HasWeapon("weapon_scp_207") then
		return
	end
	
	-- Check if player has free slot for weapon
	local weapons = ply:GetWeapons()
	if #weapons >= 8 then -- GMod weapon limit is usually 8
		return
	end

	-- Try to give weapon
	local weapon = ply:Give("weapon_scp_207")
	if IsValid(weapon) then
		sound.Play( PickUpSound, ply:GetPos(), 75, math.random( 50, 160 ) )	
		self:Remove()
		ply:SelectWeapon("weapon_scp_207")
	end
end 


================================================
FILE: gamemodes/breach/entities/entities/scp_207/shared.lua
================================================
-- SCP-207, A representation of a paranormal object on a fictional series on the game Garry's Mod.
-- Copyright (C) 2023  MrMarrant aka BIBI.
-- Adapted for SCP: Breach gamemode

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Author = "MrMarrant"
ENT.PrintName = "SCP-207"
ENT.Spawnable = true
ENT.Category = "SCP: Breach" 


================================================
FILE: gamemodes/breach/entities/entities/scp_294/cl_init.lua
================================================
include("shared.lua")

-- Podstawowe funkcje klienckie dla SCP-294
-- Menu system został usunięty - maszyna automatycznie losuje napój po użyciu

-- Funkcja efektu dispensowania (opcjonalna)
function ENT:CreateDispenseEffect()
    local pos = self:GetPos() + self:GetUp() * 50
    
    -- Prosty efekt cząsteczek
    local emitter = ParticleEmitter(pos)
    if emitter then
        for i = 1, 5 do
            local particle = emitter:Add("effects/splash2", pos + Vector(math.random(-3,3), math.random(-3,3), 0))
            if particle then
                particle:SetVelocity(Vector(math.random(-10,10), math.random(-10,10), math.random(5,15)))
                particle:SetLifeTime(0)
                particle:SetDieTime(0.8)
                particle:SetStartAlpha(200)
                particle:SetEndAlpha(0)
                particle:SetStartSize(1)
                particle:SetEndSize(0)
                particle:SetColor(100, 150, 255)
            end
        end
        emitter:Finish()
    end
end


================================================
FILE: gamemodes/breach/entities/entities/scp_294/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

-- Napoje i ich efekty
ENT.DrinkTypes = {
    ["full_heal"] = {
        name = "Full Health Restoration",
        model = "models/props_junk/PopCan01a.mdl",
        color = Color(255, 100, 100),
        price = 1,
        effects = function(ply)
            ply:SetHealth(ply:GetMaxHealth())
            ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] Full health restored!")
        end
    },
    ["random_heal"] = {
        name = "Random Health Potion",
        model = "models/props_junk/PopCan01a.mdl",
        color = Color(200, 150, 150),
        price = 1,
        effects = function(ply)
            local heal = math.random(1, 150)
            ply:SetHealth(math.min(ply:GetMaxHealth(), ply:Health() + heal))
            ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] Healed for " .. heal .. " HP!")
        end
    },
    ["invisibility"] = {
        name = "Invisibility Serum",
        model = "models/props_junk/PopCan01a.mdl",
        color = Color(100, 100, 255, 100),
        price = 1,
        effects = function(ply)
            ply:SetRenderMode(RENDERMODE_TRANSALPHA)
            ply:SetColor(Color(255, 255, 255, 0))
            ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] You are invisible for 60 seconds!")
            timer.Simple(60, function()
                if IsValid(ply) then
                    ply:SetRenderMode(RENDERMODE_NORMAL)
                    ply:SetColor(Color(255, 255, 255, 255))
                    ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] Invisibility wore off")
                end
            end)
        end
    },
    ["slowness"] = {
        name = "Heavy Liquid",
        model = "models/props_junk/PopCan01a.mdl",
        color = Color(50, 50, 50),
        price = 1,
        effects = function(ply)
            local oldRun = ply:GetRunSpeed()
            local oldWalk = ply:GetWalkSpeed()
            ply:SetRunSpeed(oldRun * 0.5)
            ply:SetWalkSpeed(oldWalk * 0.5)
            ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] You feel very heavy... -50% speed for 60 seconds")
            timer.Simple(60, function()
                if IsValid(ply) then
                    ply:SetRunSpeed(oldRun)
                    ply:SetWalkSpeed(oldWalk)
                    ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] You feel normal again")
                end
            end)
        end
    },
    ["near_death"] = {
        name = "Near Death Experience",
        model = "models/props_junk/PopCan01a.mdl",
        color = Color(255, 0, 0),
        price = 1,
        effects = function(ply)
            local newHP = math.max(1, math.floor(ply:GetMaxHealth() * 0.01))
            ply:SetHealth(newHP)
            ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] You barely survive! Health reduced to 1%")
        end
    },
    ["explosion"] = {
        name = "Explosive Compound",
        model = "models/props_junk/PopCan01a.mdl",
        color = Color(255, 150, 0),
        price = 1,
        effects = function(ply)
            ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] You feel unstable...")
            timer.Simple(2, function()
                if IsValid(ply) then
                    local effectdata = EffectData()
                    effectdata:SetOrigin(ply:GetPos())
                    util.Effect("Explosion", effectdata)
                    ply:EmitSound("BaseExplosionEffect.Sound")
                    util.BlastDamage(ply, ply, ply:GetPos(), 300, 200)
                end
            end)
        end
    },
    ["instant_death"] = {
        name = "Death Serum",
        model = "models/props_junk/PopCan01a.mdl",
        color = Color(0, 0, 0),
        price = 1,
        effects = function(ply)
            ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] This was a mistake...")
            timer.Simple(1, function()
                if IsValid(ply) and ply:Alive() then
                    ply:Kill()
                end
            end)
        end
    },
    ["poison_dot"] = {
        name = "Toxic Waste",
        model = "models/props_junk/PopCan01a.mdl",
        color = Color(0, 255, 0),
        price = 1,
        effects = function(ply)
            ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] You've been poisoned! -5 HP every 2 seconds for 30 seconds")
            local ticks = 0
            timer.Create("Poison_" .. ply:SteamID64(), 2, 15, function()
                if IsValid(ply) and ply:Alive() then
                    ply:TakeDamage(5, ply, ply)
                    ticks = ticks + 1
                else
                    timer.Remove("Poison_" .. ply:SteamID64())
                end
            end)
        end
    },
    ["super_speed"] = {
        name = "Hyper Accelerant",
        model = "models/props_junk/PopCan01a.mdl",
        color = Color(0, 255, 255),
        price = 1,
        effects = function(ply)
            local oldRun = ply:GetRunSpeed()
            local oldWalk = ply:GetWalkSpeed()
            ply:SetRunSpeed(oldRun * 3)
            ply:SetWalkSpeed(oldWalk * 3)
            ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] SUPER SPEED! 3x speed for 60 seconds!")
            timer.Simple(60, function()
                if IsValid(ply) then
                    ply:SetRunSpeed(oldRun)
                    ply:SetWalkSpeed(oldWalk)
                    ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] Speed boost ended")
                end
            end)
        end
    },
    ["shrink"] = {
        name = "Shrinking Formula",
        model = "models/props_junk/PopCan01a.mdl",
        color = Color(255, 255, 0),
        price = 1,
        effects = function(ply)
            ply:SetModelScale(0.5, 0)
            ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] You shrink to half size for 2 seconds!")
            timer.Simple(2, function()
                if IsValid(ply) then
                    ply:SetModelScale(1, 0)
                    ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] You return to normal size")
                end
            end)
        end
    },
    ["teleport_scp"] = {
        name = "SCP Attraction Serum",
        model = "models/props_junk/PopCan01a.mdl",
        color = Color(100, 0, 100),
        price = 1,
        effects = function(ply)
            local scps = {}
            for _, p in pairs(player.GetAll()) do
                if IsValid(p) and p:Alive() and p:GTeam() == TEAM_SCP and p != ply then
                    table.insert(scps, p)
                end
            end
            
            if #scps > 0 then
                local target = table.Random(scps)
                ply:SetPos(target:GetPos() + Vector(math.random(-100, 100), math.random(-100, 100), 0))
                ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] You've been teleported to " .. target:Nick() .. "!")
            else
                ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] No living SCPs found... Lucky you!")
            end
        end
    },
    ["delayed_death"] = {
        name = "Delayed Death Serum",
        model = "models/props_junk/PopCan01a.mdl",
        color = Color(50, 0, 50),
        price = 1,
        effects = function(ply)
            ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] You have 60 seconds to live...")
            timer.Create("DelayedDeath_" .. ply:SteamID64(), 60, 1, function()
                if IsValid(ply) and ply:Alive() then
                    ply:Kill()
                    ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] Your time is up...")
                end
            end)
        end
    },
    ["zombie_transform"] = {
        name = "SCP-049-2 Virus",
        model = "models/props_junk/PopCan01a.mdl",
        color = Color(100, 150, 50),
        price = 1,
        effects = function(ply)
            if ply:GTeam() != TEAM_SCP then
                ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] You feel... different...")
                timer.Simple(3, function()
                    if IsValid(ply) and ply:Alive() then
                        ply:SetNClass(ROLES.ROLE_SCP0492)
                        ply:SetGTeam(TEAM_SCP)
                        ply:SetModel("models/player/zombie_classic.mdl")
                        ply:SetHealth(1200)
                        ply:SetMaxHealth(1200)
                        ply:SetRunSpeed(135)
                        ply:SetWalkSpeed(135)
                        ply:StripWeapons()
                        ply:Give("weapon_scp_0492")
                        ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] You have become SCP-049-2!")
                    end
                end)
            else
                ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] No effect... You're already an SCP")
            end
        end
    },
    ["perm_speed"] = {
        name = "Permanent Enhancement",
        model = "models/props_junk/PopCan01a.mdl",
        color = Color(255, 200, 100),
        price = 1,
        effects = function(ply)
            local boost = math.random(10, 30) / 100
            local oldRun = ply:GetRunSpeed()
            local oldWalk = ply:GetWalkSpeed()
            ply:SetRunSpeed(oldRun * (1 + boost))
            ply:SetWalkSpeed(oldWalk * (1 + boost))
            ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] Permanent +" .. math.floor(boost * 100) .. "% speed boost!")
        end
    },
    ["bonus_credits"] = {
        name = "Lucky Coins",
        model = "models/props_junk/PopCan01a.mdl",
        color = Color(255, 215, 0),
        price = 1,
        effects = function(ply)
            ply:AddCredits(3, "SCP-294 Lucky Drink")
            ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] You found 3 credits in the can!")
        end
    },
    ["swap_places"] = {
        name = "Quantum Entanglement Drink",
        model = "models/props_junk/PopCan01a.mdl",
        color = Color(150, 150, 255),
        price = 1,
        effects = function(ply)
            local players = {}
            for _, p in pairs(player.GetAll()) do
                if IsValid(p) and p:Alive() and p != ply and p:GTeam() != TEAM_SPEC then
                    table.insert(players, p)
                end
            end
            
            if #players > 0 then
                local target = table.Random(players)
                local myPos = ply:GetPos()
                local targetPos = target:GetPos()
                
                ply:SetPos(targetPos)
                target:SetPos(myPos)
                
                ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] You swapped places with " .. target:Nick() .. "!")
                target:PrintMessage(HUD_PRINTTALK, "[SCP-294] You were swapped with " .. ply:Nick() .. "!")
            else
                ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] No valid targets for swap...")
            end
        end
    }
}

function ENT:Initialize()
    self:SetModel("models/vinrax/scp294/scp294.mdl")
    self:PhysicsInit(SOLID_VPHYSICS)
    self:SetMoveType(MOVETYPE_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)
    self:SetUseType(SIMPLE_USE)
    
    local phys = self:GetPhysicsObject()
    if IsValid(phys) then
        phys:Wake()
        phys:EnableMotion(false)
    end
    
    -- Inicjalizacja zmiennych
    self.UsesLeft = 10 -- Zmienione z 50 na 10
    self.LastUse = {}  -- Cooldown dla graczy
    
    -- Upewnij się że model jest widoczny
    self:SetRenderMode(RENDERMODE_NORMAL)
    self:SetColor(Color(255, 255, 255, 255))
    self:DrawShadow(true)
    
    print("[SCP-294] Coffee Machine initialized!")
end

function ENT:Use(activator, caller)
    if not IsValid(activator) or not activator:IsPlayer() then return end
    
    -- Blokuj użycie dla SCP (oprócz SCP-035)
    if activator:GTeam() == TEAM_SCP and activator:GetNClass() != ROLES.ROLE_SCP035 then
        self:EmitSound("buttons/button10.wav", 60, 80)
        return
    end
    
    -- Sprawdź cooldown gracza (5 sekund między użyciami)
    local steamID = activator:SteamID64()
    if self.LastUse[steamID] and CurTime() - self.LastUse[steamID] < 5 then
        activator:PrintMessage(HUD_PRINTTALK, "[SCP-294] Please wait " .. math.ceil(5 - (CurTime() - self.LastUse[steamID])) .. " seconds...")
        return
    end
    
    -- Sprawdź czy maszyna ma jeszcze użycia
    if self.UsesLeft <= 0 then
        self:EmitSound("buttons/button10.wav", 60, 80)
        return
    end
    
    -- Losowo wybierz napój i go wydaj
    self:DispenseRandomDrink(activator)
end

function ENT:DispenseRandomDrink(ply)
    -- Stwórz listę dostępnych napojów
    local availableDrinks = {}
    for drinkID, drinkData in pairs(self.DrinkTypes) do
        table.insert(availableDrinks, drinkID)
    end
    
    -- Losowo wybierz napój
    local randomDrink = table.Random(availableDrinks)
    
    -- Wydaj wylosowany napój
    self:DispenseDrink(ply, randomDrink)
end

function ENT:DispenseDrink(ply, drinkType)
    if not self.DrinkTypes[drinkType] then return end
    
    local drink = self.DrinkTypes[drinkType]
    local steamID = ply:SteamID64()
    
    -- Sprawdź ponownie cooldown i użycia
    if self.LastUse[steamID] and CurTime() - self.LastUse[steamID] < 5 then return end
    if self.UsesLeft <= 0 then return end
    
    -- Sprawdź czy gracz ma wystarczająco kredytów (stały koszt 1 kredyt)
    local cost = 1
    if not ply:CanAfford(cost) then
        ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] Insufficient credits! You need " .. cost .. " credit. (You have: " .. ply:GetCredits() .. ")")
        self:EmitSound("buttons/button2.wav", 60, 80)
        return
    end
    
    -- Pobierz kredyty
    ply:SpendCredits(cost, "SCP-294: " .. drink.name)
    
    -- Aktualizuj dane
    self.LastUse[steamID] = CurTime()
    self.UsesLeft = self.UsesLeft - 1
    
    -- Efekty dźwiękowe i wizualne
    self:EmitSound("ambient/machines/vending_machine_hum_loop1.wav", 75, 100)
    timer.Simple(1, function()
        if IsValid(self) then
            self:EmitSound("physics/metal/metal_canister_impact_hard2.wav", 80, 120)
        end
    end)
    
    -- Stwórz napój
    timer.Simple(1.5, function()
        if IsValid(self) and IsValid(ply) then
            self:CreateDrink(ply, drink)
            
            -- Efekt cząsteczek dispensowania
            local effectdata = EffectData()
            effectdata:SetOrigin(self:GetPos() + self:GetForward() * 20 + Vector(0,0,30))
            effectdata:SetScale(1.5)
            util.Effect("scp294_dispense", effectdata)
            

        end
    end)
end

function ENT:CreateDrink(ply, drinkData)
    local drinkEnt = ents.Create("scp_294_drink")
    if IsValid(drinkEnt) then
        drinkEnt:SetPos(self:GetPos() + self:GetForward() * 25 + Vector(0,0,20))
        drinkEnt:SetAngles(self:GetAngles())
        drinkEnt:Spawn()
        drinkEnt:Activate()
        
        -- Ustaw właściwości napoju
        drinkEnt:SetModel(drinkData.model)
        drinkEnt:SetColor(drinkData.color)
        drinkEnt.DrinkName = drinkData.name
        drinkEnt.DrinkEffects = drinkData.effects
        drinkEnt.Owner = ply
        
        -- Dodaj małą siłę wyrzutu
        local phys = drinkEnt:GetPhysicsObject()
        if IsValid(phys) then
            phys:Wake()
            phys:SetVelocity(self:GetForward() * 50 + Vector(0,0,100))
        end
    end
end

-- Network strings moved to sv_module.lua
-- Menu system removed - now uses random drink selection

-- Reset użyć na początku rundy
hook.Add("BreachPreround", "SCP294_Reset", function()
    for _, ent in pairs(ents.FindByClass("scp_294")) do
        ent.UsesLeft = 10
        ent.LastUse = {}
    end
    
    -- Menu system removed - no flags to clear
end)

-- Menu system removed - no player flags to manage


================================================
FILE: gamemodes/breach/entities/entities/scp_294/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "SCP-294"
ENT.Author = "Breach SCP"
ENT.Contact = ""
ENT.Purpose = "The Coffee Machine"
ENT.Instructions = "Press E to interact"

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "SCP Breach"

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "UsesLeft")
    self:NetworkVar("Bool", 0, "IsActive")
end 


================================================
FILE: gamemodes/breach/entities/entities/scp_294_drink/cl_init.lua
================================================
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
    
    -- Efekt świecenia napoju
    if LocalPlayer():GetPos():DistToSqr(self:GetPos()) < 40000 then -- 200 jednostek
        local pos = self:GetPos() + Vector(0, 0, 15)
        local ang = LocalPlayer():EyeAngles()
        ang:RotateAroundAxis(ang:Forward(), 90)
        ang:RotateAroundAxis(ang:Right(), 90)
        
        cam.Start3D2D(pos, ang, 0.05)
            local drinkName = self.DrinkName or "Unknown Drink"
            draw.SimpleText(drinkName, "DermaDefault", 0, -10, Color(255, 255, 255, 200), TEXT_ALIGN_CENTER)
            draw.SimpleText("Press E to drink", "DermaDefault", 0, 5, Color(200, 200, 200, 150), TEXT_ALIGN_CENTER)
        cam.End3D2D()
    end
    
    -- Małe cząsteczki unoszące się z napoju
    if math.random(1, 10) == 1 then
        local effectdata = EffectData()
        effectdata:SetOrigin(self:GetPos() + Vector(0, 0, 8) + VectorRand() * 3)
        effectdata:SetScale(0.5)
        effectdata:SetMagnitude(1)
        util.Effect("balloon_pop", effectdata)
    end
end

function ENT:Initialize()
    self.DrinkName = "Unknown Drink"
end 


================================================
FILE: gamemodes/breach/entities/entities/scp_294_drink/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")

function ENT:Initialize()
    self:SetModel("models/props_junk/PopCan01a.mdl")
    self:PhysicsInit(SOLID_VPHYSICS)
    self:SetMoveType(MOVETYPE_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)
    self:SetUseType(SIMPLE_USE)
    
    local phys = self:GetPhysicsObject()
    if IsValid(phys) then
        phys:Wake()
        phys:SetMass(5)
    end
    
    -- Właściwości napoju
    self.DrinkName = "Unknown Drink"
    self.DrinkEffects = function() end
    self.Owner = nil
    self.ConsumeTime = 0
    
    -- Auto-usuwanie po 5 minutach
    timer.Simple(300, function()
        if IsValid(self) then
            self:Remove()
        end
    end)
end

function ENT:Use(activator, caller)
    if not IsValid(activator) or not activator:IsPlayer() then return end
    
    -- Sprawdź czy gracz już pije
    if activator.IsDrinking then
        return
    end
    
    -- Rozpocznij picie
    self:StartDrinking(activator)
end

function ENT:StartDrinking(ply)
    if not IsValid(ply) then return end
    
    ply.IsDrinking = true
    
    -- Efekt picia
    ply:EmitSound("npc/barnacle/barnacle_gulp2.wav", 60, 120)
    
    -- Natychmiastowy efekt - bez blokowania ruchu
    -- Wykonaj efekty napoju
    if self.DrinkEffects and isfunction(self.DrinkEffects) then
        self.DrinkEffects(ply)
    end
    
    -- Efekt znikania
    local effectdata = EffectData()
    effectdata:SetOrigin(self:GetPos())
    effectdata:SetScale(1)
    util.Effect("balloon_pop", effectdata)
    
    ply.IsDrinking = false
    
    -- Usuń napój
    self:Remove()
end

function ENT:OnTakeDamage(dmginfo)
    -- Napój może być zniszczony
    local damage = dmginfo:GetDamage()
    if damage > 10 then
        -- Efekt rozlania
        local effectdata = EffectData()
        effectdata:SetOrigin(self:GetPos())
        effectdata:SetScale(2)
        effectdata:SetMagnitude(5)
        util.Effect("WaterSplash", effectdata)
        
        self:EmitSound("physics/glass/glass_bottle_break2.wav", 70, 100)
        self:Remove()
    end
end

function ENT:PhysicsCollide(data, phys)
    -- Dźwięk uderzenia
    if data.Speed > 60 then
        self:EmitSound("physics/metal/metal_canister_impact_soft" .. math.random(1,3) .. ".wav", 50, 100)
    end
end 


================================================
FILE: gamemodes/breach/entities/entities/scp_294_drink/shared.lua
================================================
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "SCP-294 Drink"
ENT.Author = "Breach SCP"
ENT.Contact = ""
ENT.Purpose = "Drink from SCP-294"
ENT.Instructions = "Press E to drink"

ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Category = "SCP Breach"

ENT.RenderGroup = RENDERGROUP_BOTH 


================================================
FILE: gamemodes/breach/entities/entities/scp_313/init.lua
================================================
-- SCP 313, A representation of a paranormal object on a fictional series on the game Garry's Mod.
-- Copyright (C) 2023  MrMarrant aka BIBI.

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

AddCSLuaFile("shared.lua")
include("shared.lua")

local HardImpactSoundList = {
	"physics/metal/metal_sheet_impact_hard2.wav",
	"physics/metal/metal_sheet_impact_hard6.wav",
	"physics/metal/metal_sheet_impact_hard7.wav",
	"physics/metal/metal_sheet_impact_hard8.wav"
}

local EffectUse = "Explosion"

function ENT:Precache()
	PrecacheParticleSystem( EffectUse )
end

function ENT:Initialize()
	self:Precache()
	self.NextLava = CurTime()
	self.LavaCoolDown = 0.3
	self.NextUse = CurTime()
	self.UseCoolDown = 18
	self:SetModel( "models/hand_dryer/hand_dryer.mdl" )
	self:SetModelScale( 1 )
	self:PhysicsInit( SOLID_VPHYSICS ) 
	self:SetMoveType(MOVETYPE_NONE) -- Przymocowana do ściany
	self:SetSolid( SOLID_VPHYSICS ) 
	self:SetUseType(SIMPLE_USE)
	self:AddEffects( EF_NOINTERP )
	local phys = self:GetPhysicsObject()
	if (phys:IsValid()) then
		phys:EnableMotion(false) -- Nie może się ruszać
		phys:Wake()
	end
end

function ENT:Use(ply)
	-- Breach compatibility - check if player can use
	if not IsValid(ply) or not ply:IsPlayer() then return end
	if ply:GTeam() == TEAM_SPEC then return end
	
	if CurTime() < self.NextUse then return end
	self.NextUse = CurTime() + self.UseCoolDown
	if (ply:IsValid()) then
		if (SCP_313.IsArmed()) then
			self:CreateExplosion()
		else
			self:EmitSound("scp_313/hand_dryer.mp3")
		end
	end
end

function ENT:PhysicsCollide(data, phys)
	if data.DeltaTime > 0.2 then
		if data.Speed > 250 then
			self:EmitSound(table.Random( HardImpactSoundList ), 75, math.random(90,110), 0.5)
		else
			self:EmitSound("physics/metal/metal_solid_impact_soft" .. math.random(1, 3) .. ".wav", 75, math.random(90,110), 0.2)
		end
	end
end

function ENT:Think()
	if (self.SendFarAway) then
		local phys = self:GetPhysicsObject()
		local angle = self:GetAngles()
		-- TODO : Orienté dans le même sens de poussé l'entité
		--self:SetAngles(Angle(angle.x,angle.y,180))
		phys:SetVelocity( phys:GetVelocity() * 10000 )
		if CurTime() < self.NextLava then return end
		self.NextLava = CurTime() + self.LavaCoolDown
		local ent = ents.Create( "falling_lava" )
		ent:SetPos( self:GetPos())
		ent:Spawn()
		ent:Activate()
	end
end

function ENT:BurnBabyBurn()
	local phys = self:GetPhysicsObject()
	phys:EnableMotion( true )
	phys:Wake()
	SCP_313.DisplayEffectClientSide(EffectUse, self:GetPos())
	self:GetPhysicsObject():SetVelocity( self:GetUp() * 10000 )
	self.SendFarAway = true
	self:EmitSound( "scp_313/lauch_sound.mp3")
	self:StartLoopingSound("scp_313/booster_sound.wav")
	timer.Simple( 30, function() if (self:IsValid()) then 
		self.SendFarAway = false
		self:StopSound("scp_313/booster_sound.wav")
	end end )
end

function ENT:CreateExplosion()
	local explosionPos = self:GetPos()
	
	-- Dźwięk eksplozji
	self:EmitSound("weapons/explode5.wav", 100, 100)
	
	-- Efekt wizualny eksplozji
	local effectdata = EffectData()
	effectdata:SetOrigin(explosionPos)
	effectdata:SetMagnitude(8)
	effectdata:SetScale(1)
	effectdata:SetRadius(8)
	util.Effect("Explosion", effectdata)
	
	-- Zadawaj obrażenia graczom w pobliżu
	local explosionRadius = 300
	local maxDamage = 150
	
	for k, v in pairs(ents.FindInSphere(explosionPos, explosionRadius)) do
		if v:IsPlayer() and v:Alive() and v:GTeam() != TEAM_SPEC then
			local distance = v:GetPos():Distance(explosionPos)
			local damage = math.max(20, maxDamage - (distance / explosionRadius * maxDamage))
			
			-- Tworzenie DamageInfo
			local dmgInfo = DamageInfo()
			dmgInfo:SetDamage(damage)
			dmgInfo:SetDamageType(DMG_BLAST)
			dmgInfo:SetAttacker(self)
			dmgInfo:SetInflictor(self)
			dmgInfo:SetDamagePosition(explosionPos)
			v:TakeDamageInfo(dmgInfo)
			
			-- Knockback effect
			local knockbackForce = math.max(200, 1000 - (distance / explosionRadius * 800))
			local direction = (v:GetPos() - explosionPos):GetNormalized()
			direction.z = math.max(0.3, direction.z) -- Zawsze trochę w górę
			v:SetVelocity(direction * knockbackForce)
			
			-- Efekt wizualny dla gracza
			if distance <= explosionRadius * 0.5 then
				-- Blisko eksplozji - mocniejszy efekt
				v:ScreenFade(SCREENFADE.IN, Color(255, 100, 0, 100), 2, 1)
			else
				-- Dalej - lżejszy efekt
				v:ScreenFade(SCREENFADE.IN, Color(255, 150, 0, 50), 1, 0.5)
			end
		end
	end
	
	-- Usuwaj entity po eksplozji
	timer.Simple(0.1, function()
		if IsValid(self) then
			self:Remove()
		end
	end)
end 


================================================
FILE: gamemodes/breach/entities/entities/scp_313/shared.lua
================================================
-- SCP 313, A representation of a paranormal object on a fictional series on the game Garry's Mod.
-- Copyright (C) 2023  MrMarrant aka BIBI.

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Author = "MrMarrant"
ENT.PrintName = "SCP 313"
ENT.Spawnable = false -- Breach compatibility - only spawn through gamemode
ENT.Category = "SCP" 


================================================
FILE: gamemodes/breach/entities/weapons/br_entity_remover.lua
================================================
AddCSLuaFile()

SWEP.PrintName			= "Entity Remover"			

SWEP.ViewModelFOV 		= 56
SWEP.Spawnable 			= false
SWEP.AdminOnly 			= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Delay        = 1
SWEP.Primary.Automatic	= false
SWEP.Primary.Ammo		= "None"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Delay			= 5
SWEP.Secondary.Ammo		= "None"

SWEP.droppable				= false

SWEP.Weight				= 3
SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false
SWEP.Slot					= 0
SWEP.SlotPos				= 4
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true
SWEP.ViewModel			= "models/weapons/c_toolgun.mdl"
SWEP.WorldModel			= "models/weapons/w_toolgun.mdl"
SWEP.IconLetter			= "Remover"
SWEP.SelectFont			= "DermaLarge"
SWEP.HoldType 			= "normal"

--if (CLIENT) then
	--SWEP.WepSelectIcon	= surface.GetTextureID( "vgui/entities/weapon_scp096" )
	--SWEP.BounceWeaponIcon = false
	--killicon.Add( "kill_icon_scp096", "vgui/icons/kill_icon_scp096", Color( 255, 255, 255, 255 ) )
--end

function SWEP:Initialize()
	if CLIENT then
		self.Author		= "danx91"
	end
	self:SetHoldType(self.HoldType)
end

function SWEP:Deploy()
	if self.Owner:IsValid() then
		--self.Owner:DrawWorldModel( false )
		--self.Owner:DrawViewModel( false )
	end
end

function SWEP:Holster()
	return true
end

function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	local tr = self.Owner:GetEyeTrace()
	local ent = tr.Entity
	if IsValid( ent ) then
		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
		fxdata = EffectData()
		fxdata:SetEntity( self )
		fxdata:SetAttachment( 1 )
		fxdata:SetStart( self.Owner:GetShootPos() )
		fxdata:SetOrigin( tr.HitPos )
		fxdata:SetNormal( tr.HitNormal )
		if CLIENT then
			util.Effect("tooltracer", fxdata)
		end
		self:EmitSound( "NPC_CombineBall.Impact" )
		if !SERVER then return end
		ent:Remove()
	end
end

function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	--
end

function SWEP:Reload()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	--
end

function SWEP:DrawHUD()
	/*local tr = self.Owner:GetEyeTrace()
	local pos = tr.HitPos:ToScreen()
	local spos = tr.StartPos:ToScreen()
	surface.SetDrawColor( Color( 25, 25, 200, 255 ) )
	surface.DrawLine( spos.x, spos.y, pos.x, pos.y )*/
end


================================================
FILE: gamemodes/breach/entities/weapons/br_holster.lua
================================================
AddCSLuaFile()

if CLIENT then
	SWEP.WepSelectIcon 	= surface.GetTextureID("breach/wep_holster")
	SWEP.BounceWeaponIcon = false
end

SWEP.ViewModelFOV	= 62
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/breach/keycard.mdl"
SWEP.WorldModel		= "models/breach/keycard.mdl"
SWEP.PrintName		= "Holster"
SWEP.Slot			= 0
SWEP.SlotPos		= 1
SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= true
SWEP.HoldType		= "normal"
SWEP.Spawnable		= false
SWEP.AdminSpawnable	= false

SWEP.droppable				= false
SWEP.teams					= {2,3,5,6,7}

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Ammo			=  "none"
SWEP.Primary.Automatic		= false

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Ammo			=  "none"
SWEP.Secondary.Automatic	=  false

function SWEP:Deploy()
	self.Owner:DrawViewModel( false )
end
function SWEP:DrawWorldModel()
	if !IsValid(self.Owner) then
		self:DrawModel()
	end
end

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().HOLSTER
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end
	self:SetHoldType(self.HoldType)
	self:SetSkin(0)
end
function SWEP:Think()
end
function SWEP:Reload()
end
function SWEP:PrimaryAttack()
end
function SWEP:SecondaryAttack()
end
function SWEP:CanPrimaryAttack()
end


================================================
FILE: gamemodes/breach/entities/weapons/br_id.lua
================================================
if CLIENT then
	SWEP.WepSelectIcon 	= surface.GetTextureID("breach/wep_id")
	SWEP.BounceWeaponIcon = false
end

SWEP.PrintName = "ID tag"

SWEP.Category = "Passport" 
 
SWEP.Spawnable = false
SWEP.AdminSpawnable = false

SWEP.Base = "weapon_base"

SWEP.UseHands = true

SWEP.ViewModelFOV = 54
SWEP.ViewModel = "models/weapons/kerry/passport_g.mdl"
SWEP.WorldModel = "models/weapons/kerry/w_garrys_pass.mdl"

SWEP.droppable		= false
SWEP.teams			= {2,3,5,6,7}

SWEP.Slot			= 0
SWEP.SlotPos		= 1

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
 
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.HoldType = "pistol"



SWEP.Lang = nil

function SWEP:Initialize()
    self:SetupDataTables()
	if CLIENT then
		self.Lang = GetWeaponLang().ID
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
		
		-- Hook usunięty - nie wyświetlamy nazw klas nad głowami graczy
	end
	self:SetHoldType(self.HoldType)
	if CLIENT then
		self.Passport = table.FullCopy( self.Passport )
		self:CreateModels( self.Passport )
	end
	self:SetupValue()
end

function SWEP:SetupDataTables()
    self:DTVar("Bool", 0, "ShowingID")
end

function validString( str )
	if string.len( str ) > 20 then
		return string.sub( str, 1, 20 )
	end
	return str
end

if CLIENT then
function SWEP:ViewModelDrawn()
	local vm = self.Owner:GetViewModel()
	if !IsValid(vm) then return end
		local bone = vm:LookupBone("PBase")
		if (!bone) then return end
		pos, ang = Vector(0,0,0), Angle(0,0,0)
		local m = vm:GetBoneMatrix(bone)
		if (m) then
			pos, ang = m:GetTranslation(), m:GetAngles()
		else
			return
		end
			ang:RotateAroundAxis(ang:Forward(),0)
			ang:RotateAroundAxis(ang:Right(), -130)
			ang:RotateAroundAxis(ang:Up(), 93)
			cam.Start3D2D(pos+ang:Right()*3+ang:Forward()*-1.80+ang:Up()*1.0, ang, 0.02)
			        draw.SimpleText(self.Lang.name, "PassHud2", 40, -50, Color(0,0,0,255))
					draw.SimpleText(self.Owner:Name() or "Unknown", "PassHud", 40, -40, Color(0,0,0,255))
					draw.SimpleText(self.Lang.city, "PassHud2", 40, 15, Color(0,0,0,255))
					draw.SimpleText(validString( GetHostName() ), "PassHud3", 40, 30, Color(0,0,0,255))
					draw.SimpleText("<G<<<<<<<<<<<"..self.Owner:SteamID().."<<<<", "PassHud2", -60, 60, Color(0,0,0,200))
					draw.SimpleText("<G<<<2281337<<<<777<<<<06<<<<<<<<<<", "PassHud2", -60, 75, Color(0,0,0,200))
					surface.SetDrawColor(255,255,255,250)
					surface.SetMaterial(self.mat_ply)
					surface.DrawTexturedRect( -40, -42, 80, 80 )
				cam.End3D2D()
end
end


if CLIENT then	
	SWEP.Passport = {
		["pass"] = { type = "Model", model = "models/weapons/kerry/w_garrys_pass.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(6, 3.5, -0.6), angle = Angle(0, 90, 120), size = Vector(0.699, 0.699, 0.699), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
		["info_pass"] = { type = "Quad", bone = "ValveBiped.Bip01_R_Hand", rel = "pass", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = 0.5}
	}
	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()		
		if (!self.wRenderOrder) then
			self.wRenderOrder = {}
			for k, v in pairs( self.Passport) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end
		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			-- when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.Passport[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.Passport, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.Passport, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
			elseif (v.type == "Quad") then
				if LocalPlayer():GetPos():Distance(self:GetPos()) >= 200 then return end				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * 0.08
				ang:RotateAroundAxis(ang:Up(), 180)
				
				cam.Start3D2D(drawpos, ang, 0.02)
				    draw.SimpleText(self.Lang.name, "PassHud2", 40, -50, Color(0,0,0,255))
					draw.SimpleText(self.Owner:Name() or "Unknown", "PassHud", 40, -40, Color(0,0,0,255))
					draw.SimpleText(self.Lang.city, "PassHud2", 40, 15, Color(0,0,0,255))
					draw.SimpleText(validString( GetHostName() ), "PassHud3", 40, 30, Color(0,0,0,255))
					draw.SimpleText("<G<<<<<<<<<<<"..self.Owner:SteamID().."<<<<", "PassHud2", -60, 60, Color(0,0,0,200))
					draw.SimpleText("<G<<<2281337<<<<777<<<<06<<<<<<<<<<", "PassHud2", -60, 75, Color(0,0,0,200))
					surface.SetDrawColor(255,255,255,250)
					surface.SetMaterial(self.mat_ply)
					surface.DrawTexturedRect( -40, -42, 80, 80 )
				cam.End3D2D()
			end
			
		end
		
	end
	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel ~= "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)
			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
		
		end
		
		return pos, ang
	end
	function SWEP:CreateModels( tab )
		if (!tab) then return end
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end				
			end
		end		
	end
	
	function table.FullCopy( tab )
		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) -- recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end

function SWEP:PrimaryAttack()
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
end

function SWEP:SetupValue()
	if not IsValid(self.Owner) then return end
	if not self.Owner:IsBot() then end
	if self.Owner:GTeam() == TEAM_GUARD then
		self.mat_ply = Material("breach/mtf.png")
	elseif self.Owner:GTeam() == TEAM_CHAOS then
		if self.Owner:GetNClass() == ROLES.ROLE_CHAOSSPY then
			self.mat_ply = Material("breach/mtf.png")
		else
			self.mat_ply = Material("breach/ci.png")
		end
	elseif self.Owner:GTeam() == TEAM_GOC then
		self.mat_ply = Material("breach/mtf.png") -- Używamy ikony MTF dla GOC
	else
		self.mat_ply = Material("spawnicons/" .. string.gsub(self.Owner:GetModel(), ".mdl", ".png"))
	end
end


function SWEP:Holster()
	self:SetupValue()
    if IsValid(self.Owner) then
        self.Owner:SetDTBool(0, false)
    end
	return true
end

function SWEP:Deploy()
    if IsValid(self.Owner) then
        self.Owner:SetDTBool(0, true)
    end
    return true
end

function SWEP:OnRemove()
    if IsValid(self.Owner) then
        self.Owner:SetDTBool(0, false)
    end
end



================================================
FILE: gamemodes/breach/entities/weapons/br_keycard.lua
================================================
AddCSLuaFile()

if CLIENT then
	SWEP.WepSelectIcon 	= surface.GetTextureID("breach/wep_keycard1")
	SWEP.BounceWeaponIcon = false
end

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= true
SWEP.ViewModel		= "models/breach/keycard_new.mdl"
SWEP.WorldModel		= "models/breach/keycard_new.mdl"
SWEP.PrintName		= ""
SWEP.Slot			= 1
SWEP.SlotPos		= 1
SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= true
SWEP.HoldType		= "pistol"
SWEP.Spawnable		= false
SWEP.AdminSpawnable	= false

SWEP.droppable				= true
SWEP.teams					= {2,3,5,6,7}
SWEP.Access					= 0

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Ammo			=  "none"
SWEP.Primary.Automatic		= false

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Ammo			=  "none"
SWEP.Secondary.Automatic	=  true

SWEP.BoneAttachment = "ValveBiped.Bip01_R_Hand"
SWEP.WorldModelPositionOffset = Vector( 7, -1.5, -2.9 )
SWEP.WorldModelAngleOffset = Angle( -20, 180, 190 )

function SWEP:HandleUpgrade( mode, exit )
	local t = self:GetNWBool( "K_TYPE", nil )
	if !t then
		self:SetPos( exit )
		return
	end
	local dice = math.random( 0, 99 )
	if t == "safe" then
		if mode == 0 or mode == 1 then
			if dice < 50 then
				self:Remove()
				return
			end
		elseif mode == 3 then
			if dice < 60 then self:SetKeycardType( "euclid" ) end
		elseif mode == 4 then
			if dice < 30 then self:SetKeycardType( "euclid" ) end
			if dice >= 30 and dice < 50 then self:SetKeycardType( "keter" ) end
		end
	elseif t == "euclid" then
		if mode == 0 then
			if dice < 50 then
				self:Remove()
				return
			end
		elseif mode == 1 then
			if dice < 50 then self:SetKeycardType( "safe" ) end
		elseif mode == 2 then
			if dice < 50 then self:SetKeycardType( "res" ) end
		elseif mode == 3 then
			if dice < 50 then self:SetKeycardType( "keter" ) end
		elseif mode == 4 then
			if dice < 75 then self:SetKeycardType( "keter" ) end
		end
	elseif t == "keter" then
		if mode == 0 then
			if dice < 50 then
				self:Remove()
				return
			end
			self:SetKeycardType( "safe" )
		elseif mode == 1 then
			self:SetKeycardType( "euclid" )
		elseif mode == 2 then
			self:SetKeycardType( "res" )
		elseif mode == 4 then
			if dice < 75 then 
				self:Remove()
				return
			end
			self:SetKeycardType( "com" )
		end
	elseif t == "res" then
		if mode == 0 then
			if dice < 50 then self:SetKeycardType( "safe" ) end
		elseif mode == 1 then
			if dice < 75 then self:SetKeycardType( "euclid" ) end
		elseif mode == 2 then
			self:SetKeycardType( "keter" )
		elseif mode == 3 then
			if dice < 75 then self:SetKeycardType( "cps" ) end
		elseif mode == 4 then
			if dice < 10 then self:SetKeycardType( "com" ) end
			if dice >= 10 and dice < 25 then self:SetKeycardType( "mtf" ) end
			if dice >= 25 and dice < 50 then self:SetKeycardType( "cps" ) end
		end
	elseif t == "cps" then
		if mode == 0 then
			self:SetKeycardType( "safe" )
		elseif mode == 1 then
			self:SetKeycardType( "keter" )
		elseif mode == 2 then
			self:SetKeycardType( "res" )
		elseif mode == 3 then
			if dice < 50 then self:SetKeycardType( "mtf" ) end
		elseif mode == 4 then
			if dice < 20 then self:SetKeycardType( "ci" ) end
			if dice >= 20 and dice < 40 then self:SetKeycardType( "mtf" ) end
		end
	elseif t == "mtf" then
		if mode == 0 then
			self:SetKeycardType( "keter" )
		elseif mode == 1 then
			if dice < 75 then self:SetKeycardType( "euclid" ) end
			if dice >= 75 and dice < 100 then self:SetKeycardType( "res" ) end
		elseif mode == 2 then
			self:SetKeycardType( "res" )
		elseif mode == 3 then
			if dice < 50 then self:SetKeycardType( "com" ) end
		elseif mode == 4 then
			if dice < 20 then self:SetKeycardType( "ci" ) end
			if dice >= 20 and dice < 40 then self:SetKeycardType( "com" ) end
		end	
	elseif t == "com" then
		if mode == 0 then
			self:Remove()
			return
		elseif mode == 1 then
			self:Remove()
			return
		elseif mode == 2 then
			if dice < 50 then self:SetKeycardType( "ci" ) end
		elseif mode == 3 then
			if dice < 15 then self:SetKeycardType( "omni" ) end
			if dice >= 15 and dice < 30 then self:SetKeycardType( "ci" ) end
		elseif mode == 4 then
			if dice < 50 then self:SetKeycardType( "omni" ) end
			if dice >= 50 and dice < 75 then
				self:Remove()
				return
			end
		end	
	elseif t == "omni" then
		if mode == 0 then
			self:SetKeycardType( "safe" )
		elseif mode == 1 then
			self:SetKeycardType( "cps" )
		elseif mode == 2 then
			self:SetKeycardType( "ci" )
		elseif mode == 4 then
			self:Remove()
			return
		end	
	elseif t == "ci" then
		if mode == 0 then
			self:SetKeycardType( "safe" )
		elseif mode == 1 then
			self:SetKeycardType( "keter" )
		elseif mode == 2 then
			self:SetKeycardType( "mtf" )
		elseif mode == 3 then
			if dice < 50 then self:SetKeycardType( "omni" ) end
		elseif mode == 4 then
			if dice < 75 then self:SetKeycardType( "omni" ) end
			if dice >= 75 and dice < 100 then
				self:Remove()
				return
			end
		end	
	end
	self:SetPos( exit )
end

SWEP.Lang = nil

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
	if CLIENT then
		self.Lang = GetWeaponLang().KEYCARD
		self.Author			= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose

		self.WM = ClientsideModel( self.WorldModel )
		self.WM:SetNoDraw( true )
	else
		self:SetKeycardType( "safe" )
	end
end

function SWEP:SetKeycardType( t )
	--print( "setting type: "..t )
	if SERVER then 
		self:SetNWString( "K_TYPE", t )
		self.KeycardType = t
	end

	local acc = "00000000000"
	if t == "euclid" then
		if CLIENT then
			self.PrintName = self.Lang.NAMES[2]
			self.WepSelectIcon = surface.GetTextureID( "breach/keycard_2.vmt" )
		else
			self:SetNWInt( "SKIN", 1 )
		end
		self:SetSkin( 1 )
		acc = "00000000011"
	elseif t == "keter" then
		if CLIENT then
			self.PrintName = self.Lang.NAMES[3]
			self.WepSelectIcon = surface.GetTextureID( "breach/keycard_3.vmt" )
		else
			self:SetNWInt( "SKIN", 2 )
		end
		self:SetSkin( 2 )
		acc = "00000100111"
	elseif t == "res" then
		if CLIENT then
			self.PrintName = self.Lang.NAMES[4]
			self.WepSelectIcon = surface.GetTextureID( "breach/keycard_res.vmt" )
		else
			self:SetNWInt( "SKIN", 7 )
		end
		self:SetSkin( 7 )
		acc = "00000000111"
	elseif t == "mtf" then
		if CLIENT then
			self.PrintName = self.Lang.NAMES[5]
			self.WepSelectIcon = surface.GetTextureID( "breach/keycard_guard.vmt" )
		else
			self:SetNWInt( "SKIN", 4 )
		end
		self:SetSkin( 4 )
		acc = "10001001011"
	elseif t == "com" then
		if CLIENT then
			self.PrintName = self.Lang.NAMES[6]
			self.WepSelectIcon = surface.GetTextureID( "breach/keycard_com.vmt" )
		else
			self:SetNWInt( "SKIN", 5 )
		end
		self:SetSkin( 5 )
		acc = "10101101111"
	elseif t == "omni" then
		if CLIENT then
			self.PrintName = self.Lang.NAMES[7]
			self.WepSelectIcon = surface.GetTextureID( "breach/keycard_omni.vmt" )
		else
			self:SetNWInt( "SKIN", 3 )
		end
		self:SetSkin( 3 )
		acc = "11111111111"
	elseif t == "cps" then
		if CLIENT then
			self.PrintName = self.Lang.NAMES[8]
			self.WepSelectIcon = surface.GetTextureID( "breach/keycard_cps.vmt" )
		else
			self:SetNWInt( "SKIN", 6 )
		end
		self:SetSkin( 6 )
		acc = "10000101001"
	elseif t == "ci" then
		if CLIENT then
			self.PrintName = self.Lang.NAMES[9]
			self.WepSelectIcon = surface.GetTextureID( "breach/keycard_ci.vmt" )
		else
			self:SetNWInt( "SKIN", 8 )
		end
		self:SetSkin( 8 )
		acc = "10111111011"
	else
		if CLIENT then
			self.PrintName = self.Lang.NAMES[1]
			self.WepSelectIcon = surface.GetTextureID( "breach/keycard_1.vmt" )
		else
			self:SetNWInt( "SKIN", 0 )
		end
		self:SetSkin( 0 )
		acc = "00000000001"
	end

	if CLIENT then
		local desc = { self.Lang.instructions, {} }
		local len = string.len( acc )
		for i = len, 1, -1 do
			local is = string.sub( acc, i, i ) == "1" and 1 or 2
			local ins = self.Lang.ACC[len - ( i - 1 )]
			desc[2][len - ( i - 1 )] = { ins, is }
		end
		self.AC_Doors = desc
	end

	self.Access = tonumber( acc, 2 )
	-- Synchronize access level to client
	if SERVER then
		self:SetNWInt("KeycardAccess", self.Access)
	end
end

function SWEP:Deploy()
	--self.Owner:DrawViewModel( true )
	self:SetHoldType( self.HoldType )
end

function SWEP:Equip( owner )
	self:Deploy()
	timer.Simple( 0, function()
		net.Start( "UpdateKeycard" )
		net.Send( owner )
	end )
end

function SWEP:Holster()
	return true
end

function SWEP:OnRemove()
	if CLIENT then
		if IsValid( self.WM ) then
			self.WM:Remove()
		end
	end
end

SWEP.C_Init = false
SWEP.LThink = 0
function SWEP:Think()
	if self.LThink > CurTime() then return end
	self.LThink = CurTime() + 0.5
	local t = self:GetNWBool( "K_TYPE", nil )
	if CLIENT and ( !self.C_Init or self.KeycardType != t ) then
		if t then
			self.C_Init = true
			self.KeycardType = t
			self:SetKeycardType( t )
		end
	end
end

function SWEP:Reload()
	if CLIENT then
		self.DHUD = CurTime() + 0.01
	end
	return
end

function SWEP:PrimaryAttack()
	if SERVER then
		local tr = util.TraceLine( {
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 85,
			filter = self.Owner
		} )
		if tr.Hit then
			local ent = tr.Entity
			if IsValid( ent ) then
				if gamemode.Call( "PlayerUse", self.Owner, ent ) then
					ent:Use( self.Owner, self, USE_TOGGLE, 1 )
				end
			end
		end
	end
end

function SWEP:SecondaryAttack()
	if CLIENT then
		self.DHUD = CurTime() + 0.01
	end
end

function SWEP:PreDrawViewModel( vm, wep, ply )
	vm:SetSkin( self:GetNWInt( "SKIN", 0 ) )
end

function SWEP:CalcViewModelView( vm, oldpos, oldang, pos, ang )
	if !IsValid( self.Owner ) then return end
	local angs = self.Owner:EyeAngles()
	ang.pitch = -ang.pitch
	return pos + angs:Forward() * 14 + angs:Right() * -3.5 + angs:Up() * -6, ang + Angle( 0, 180, -45 )
end

function SWEP:DrawWorldModel()
	if !IsValid( self.Owner ) then
		self:DrawModel()
	else
		if !IsValid( self.WM ) then
			self.WM = ClientsideModel( self.WorldModel )
			self.WM:SetNoDraw( true )
		end

		local boneid = self.Owner:LookupBone( self.BoneAttachment )
		if not boneid then
			return
		end

		local matrix = self.Owner:GetBoneMatrix( boneid )
		if not matrix then
			return
		end

		local newpos, newang = LocalToWorld( self.WorldModelPositionOffset, self.WorldModelAngleOffset, matrix:GetTranslation(), matrix:GetAngles() )

		self.WM:SetPos( newpos )
		self.WM:SetAngles( newang )
		self.WM:SetupBones()
		self.WM:SetSkin( self:GetNWInt( "SKIN", 0 ) )
		self.WM:DrawModel()
	end
end

SWEP.DHUD = 0
function SWEP:DrawHUD()
	if disablehud == true then return end
	if self.DHUD < CurTime() then return end

	local colors = { Color( 0, 255, 0 ), Color( 255, 0, 0 ) }
	
	if self.AC_Doors then
		local txw = draw.Text( {
			text = self.AC_Doors[1],
			pos = { ScrW() / 2, ScrH() / 3 },
			font = "173font",
			color = showcolor,
			xalign = TEXT_ALIGN_CENTER,
			yalign = TEXT_ALIGN_CENTER,
		})

		for i, v in ipairs( self.AC_Doors[2] ) do
			local wid = draw.Text( {
				text = v[1].." - ",
				pos = { ScrW() / 2 - txw / 2, ScrH() / 3 + i * 25 },
				font = "173font",
				color = Color( 255, 255, 255 ),
				xalign = TEXT_ALIGN_LEFT,
				yalign = TEXT_ALIGN_CENTER,
			})

			local st = v[2]
			draw.Text( {
				text = self.Lang.STATUS[st],
				pos = { ScrW() / 2 + wid - txw / 2, ScrH() / 3 + i * 25 },
				font = "173font",
				color = colors[st],
				xalign = TEXT_ALIGN_LEFT,
				yalign = TEXT_ALIGN_CENTER,
			})
		end
	end
end


================================================
FILE: gamemodes/breach/entities/weapons/br_tool_teleporter.lua
================================================
AddCSLuaFile()

SWEP.PrintName			= "Teleporter"			

SWEP.ViewModelFOV 		= 56
SWEP.Spawnable 			= false
SWEP.AdminOnly 			= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Delay        = 0
SWEP.Primary.Automatic	= false
SWEP.Primary.Ammo		= "None"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Delay			= 5
SWEP.Secondary.Ammo		= "None"

SWEP.droppable				= false

SWEP.Weight				= 3
SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false
SWEP.Slot					= 0
SWEP.SlotPos				= 4
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true
SWEP.ViewModel			= ""
SWEP.WorldModel			= ""
SWEP.IconLetter			= "Teleporter"
SWEP.SelectFont			= "DermaLarge"
SWEP.HoldType 			= "normal"

--if (CLIENT) then
	--SWEP.WepSelectIcon	= surface.GetTextureID( "vgui/entities/weapon_scp096" )
	--SWEP.BounceWeaponIcon = false
	--killicon.Add( "kill_icon_scp096", "vgui/icons/kill_icon_scp096", Color( 255, 255, 255, 255 ) )
--end

function SWEP:Initialize()
	if CLIENT then
		self.Author		= "danx91"
	end
	self:SetHoldType(self.HoldType)
end

function SWEP:Deploy()
	if self.Owner:IsValid() then
		if SERVER then self.Owner:DrawWorldModel( false ) end
		self.Owner:DrawViewModel( false )
	end
end

function SWEP:Holster()
	return true
end

SWEP.cPlayer = 0
function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end

	self:Teleport( 1 )
end

function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	
	self:Teleport( -1 )
end

function SWEP:Teleport( num )
	if SERVER then
		self.cPlayer = self.cPlayer + num

		if self.cPlayer > player.GetCount() then
			self.cPlayer = 1
		end

		if self.cPlayer < 1 then
			self.cPlayer = player.GetCount()
		end

		local target = player.GetAll()[self.cPlayer]

		if target == self.Owner then
			self.cPlayer = self.cPlayer + num

			if self.cPlayer > player.GetCount() then
				self.cPlayer = 1
			end

			if self.cPlayer < 1 then
				self.cPlayer = player.GetCount()
			end

			target = player.GetAll()[self.cPlayer]
		end

		if IsValid( target ) then
			local angs = target:GetAngles()
			local pos = target:GetPos() + angs:Forward() * -32 + Vector( 0, 0, 32 )

			angs:RotateAroundAxis( angs:Right(), -30 )

			self.Owner:SetEyeAngles( angs )
			self.Owner:SetPos( pos )
		end
	end
end

function SWEP:Reload()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	--
end

function SWEP:DrawHUD()
	/*local tr = self.Owner:GetEyeTrace()
	local pos = tr.HitPos:ToScreen()
	local spos = tr.StartPos:ToScreen()
	surface.SetDrawColor( Color( 25, 25, 200, 255 ) )
	surface.DrawLine( spos.x, spos.y, pos.x, pos.y )*/
end


================================================
FILE: gamemodes/breach/entities/weapons/item_cameraview.lua
================================================
--[[
STARY SYSTEM TABLETU KAMER - ZAKOMENTOWANY
ZASTĄPIONY PRZEZ PERFECTCAMS MOBILE TABLET

AddCSLuaFile()

if CLIENT then
	SWEP.WepSelectIcon 	= surface.GetTextureID("breach/wep_cameraview")
	SWEP.BounceWeaponIcon = false
end

SWEP.ViewModelFOV	= 62
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/props_junk/cardboard_box004a.mdl"
SWEP.WorldModel		= "models/props_junk/cardboard_box004a.mdl"
SWEP.PrintName		= "Camera View"
SWEP.Slot			= 1
SWEP.SlotPos		= 1
SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.HoldType		= "normal"
SWEP.Spawnable		= false
SWEP.AdminSpawnable	= false

SWEP.droppable				= true
SWEP.teams					= {2,3,5,6,7}

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Ammo			=  "none"
SWEP.Primary.Automatic		= false

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Ammo			=  "none"
SWEP.Secondary.Automatic	=  false

SWEP.Enabled = false
SWEP.NextChange = 0
SWEP.CAM = 1
SWEP.CCTV = {}

function SWEP:Deploy()
	self.Owner:DrawViewModel( false )
end

function SWEP:DrawWorldModel()
	if !IsValid( self.Owner ) then
		self:DrawModel()
	end
end

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().CV
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end

	self:SetHoldType( self.HoldType )
	self:SetSkin( 1 )
end

function SWEP:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Enabled" )
	self:NetworkVar( "Int", 0, "CAM" )

	self:SetCAM( 1 )
end

function SWEP:CalcView( ply, pos, ang, fov )
	if CCTV == nil then return end

	local CAM = self:GetCAM()
	if CCTV[CAM] == nil then return end
	if !IsValid( self.CCTV[CAM] ) then return end

	local dw = false

	if self:GetEnabled() then
		ang = CCTV[CAM].ang
		pos = CCTV[CAM].pos - Vector( 0, 0, 10 )
		fov = 90
		dw = true
	end

	return pos, ang, fov, dw
end

SWEP.snd = nil
SWEP.snden = false

function SWEP:Think()
	if #self.CCTV != #CCTV then
		for k, v in pairs( ents.FindByClass( "item_cctv" ) ) do
			//print( v, v:GetCam() )
			self.CCTV[v:GetCam()] = v
		end
	end

	-- if CLIENT then
	-- 	if !self.snd then
	-- 		sound.PlayFile( "sound/camera.ogg", "noplay", function( snd, err, e )
	-- 			if !snd then
	-- 				print( err, e )
	-- 			else
	-- 				self.snd = snd
	-- 			end
	-- 		end )
	-- 	else
	-- 		if self.Enabled and !self.snden then
	-- 			self.snd:Play()
	-- 			self.snd:EnableLooping( true )
	-- 			self.snden = true

	-- 			timer.Create("CameraCheck", 1, 0, function()
	-- 				if !IsValid( self.Owner ) then
	-- 					self.snd:Pause()
	-- 					self.Enabled = false
	-- 				end
	-- 			end )
	-- 		elseif !self.Enabled and self.snden then
	-- 			timer.Remove( "CameraCheck" )
	-- 			self.snd:Pause()
	-- 			self.snden = false
	-- 		end
	-- 	end
	-- end

	if self.CurScan + 0.2 < CurTime() then
		self.ScanEnd = 0
		self.CurScan = 0
	end
end

function SWEP:OnRemove()
	self:SetEnabled( false )
	-- timer.Remove( "CameraCheck" )

	-- if IsValid( self.snd ) then
	-- 	self.snd:Stop()
	-- 	self.snd = nil
	-- end
end

function SWEP:Holster()
	self:SetEnabled( false )
	-- timer.Remove( "CameraCheck" )
	-- self.Enabled = false

	-- if IsValid( self.snd ) then
	-- 	self.snd:Pause()
	-- end

	return true
end

function SWEP:OnDrop()
	self:SetEnabled( false )
end

SWEP.ScanCD = 0
SWEP.CurScan = 0
SWEP.ScanEnd = 0

function SWEP:Reload()
	if !self:GetEnabled() or !IsValid( self.CCTV[self:GetCAM()] ) then return end
	if self.ScanCD > CurTime() then return end
	self.ScanCD = CurTime() + 0.1

	if self.ScanEnd == 0 then 
		self.ScanEnd = CurTime() + 3
		self.CurScan = CurTime()
	else
		self.CurScan = CurTime()

		if self.CurScan > self.ScanEnd then
			self.ScanEnd = 0
			self.CurScan = 0
			self.ScanCD = CurTime() + 10

			if SERVER then
				self:Scan()
			end
		end
	end
end

function SWEP:Scan()
	local CAM = self:GetCAM()
	if !IsValid( self.CCTV[CAM] ) then return end

	local detected = {}

	local scps = gteams.GetPlayers( TEAM_SCP )
	//print( #scps )
	for k, v in pairs( scps ) do
		local tr = util.TraceLine( {
			start = CCTV[CAM].pos - Vector( 0, 0, 10 ),
			endpos = v:GetPos() + v:OBBCenter(),
			mask = MASK_SHOT_HULL,
			filter = { v }
		} )

		if !tr.Hit then
			table.insert( detected, v )
		end
	end

	BroadcastDetection( self.Owner, detected )
end

function SWEP:PrimaryAttack()
	if !SERVER then return end
	if !self:GetEnabled() then return end
	if self.NextChange > CurTime() then return end

	self:NextCamera()
	self.NextChange = CurTime() + 0.1
end

function SWEP:NextCamera()
	local CAM = self:GetCAM() + 1

	if CAM > #CCTV then
		CAM = 1
	end

	self:SetCAM( CAM )
end

function SWEP:PrevCamera()
	local CAM = self:GetCAM() - 1

	if CAM < 1 then
		CAM = #CCTV
	end

	self:SetCAM( CAM )
end

function SWEP:SecondaryAttack()
	if !SERVER then return end
	if self.NextChange > CurTime() then return end

	self:SetEnabled( !self:GetEnabled() )
	self.NextChange = CurTime() + 0.5
end

function SWEP:DrawHUD()
	if self:GetEnabled() then
		DisableHUDNextFrame()

		local CAM = self:GetCAM()

		if !IsValid( self.CCTV[CAM] ) then
			surface.SetDrawColor( 0, 0, 0 )
			surface.DrawRect( 0, 0, ScrW(), ScrH() )

			draw.Text( {
				text = "NO SIGNAL",
				font = "HUDFontBig",
				pos = { ScrW() * 0.5, ScrH() * 0.5 },
				xalign = TEXT_ALIGN_CENTER,
				yalign = TEXT_ALIGN_CENTER,
			} )

			draw.Text( {
				text = "CAM "..CAM,
				font = "HUDFontBig",
				pos = { ScrW() * 0.5, 50 },
				xalign = TEXT_ALIGN_CENTER,
				yalign = TEXT_ALIGN_CENTER,
			} )

			draw.Text( {
				text = CCTV[CAM].name,
				font = "HUDFontBig",
				pos = { ScrW() * 0.5, 100 },
				xalign = TEXT_ALIGN_CENTER,
				yalign = TEXT_ALIGN_CENTER,
			} )

			return
		end

		if blinkHUDTime < GetConVar("br_time_blinkdelay"):GetFloat() then
			surface.SetDrawColor( Color( 255, 255, 255, 255 ) )

			draw.Text( {
				text = "CAM "..CAM,
				font = "HUDFontBig",
				pos = { ScrW() * 0.5, 50 },
				xalign = TEXT_ALIGN_CENTER,
				yalign = TEXT_ALIGN_CENTER,
			} )

			draw.Text( {
				text = CCTV[CAM].name,
				font = "HUDFontBig",
				pos = { ScrW() * 0.5, 100 },
				xalign = TEXT_ALIGN_CENTER,
				yalign = TEXT_ALIGN_CENTER,
			} )

			for i = 1, 10 do
				local ry = math.random( ScrH() )
				local h = math.random( 1, 5 )
				local c = math.random( 100, 200 )
				local a = math.random( 0, 10 )

				surface.SetDrawColor( Color( c, c, c, a ) )
				surface.DrawRect( 0, ry, ScrW(), h )
			end
		end

		if self.ScanEnd != 0 then
			surface.SetDrawColor( Color( 255, 255, 255 ) )
			surface.DrawRing( ScrW() * 0.5, ScrH() * 0.5, 40, 5, 360 - 360 * (self.ScanEnd - CurTime()) / 3, 30 )

			draw.Text( {
				text = "SCANNING",
				font = "HUDFontBig",
				color = Color( 255, 255, 255, math.TimedSinWave( 0.8, 1, 255 ) ),
				pos = { ScrW() * 0.5, ScrH() * 0.5 + 55 },
				xalign = TEXT_ALIGN_CENTER,
				yalign = TEXT_ALIGN_TOP,
			} )
		end
	end
end
--]]


================================================
FILE: gamemodes/breach/entities/weapons/item_czysty.lua
================================================
[Binary file]


================================================
FILE: gamemodes/breach/entities/weapons/item_eyedrops.lua
================================================
AddCSLuaFile()

if CLIENT then
	SWEP.WepSelectIcon 	= surface.GetTextureID("breach/wep_eyedrops")
	SWEP.BounceWeaponIcon = false
end

SWEP.ViewModelFOV	= 60
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/mishka/models/eyedrops.mdl"
SWEP.WorldModel		= "models/mishka/models/eyedrops.mdl"
SWEP.PrintName		= "Eyedrops"
SWEP.Slot			= 1
SWEP.SlotPos		= 1
SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= true
SWEP.HoldType		= "normal"
SWEP.Spawnable		= false
SWEP.AdminSpawnable	= false

SWEP.droppable				= true
SWEP.teams					= {2,3,5,6,7}

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Ammo			=  "none"
SWEP.Primary.Automatic		= false

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Ammo			=  "none"
SWEP.Secondary.Automatic	=  false

function SWEP:Deploy()
	self.Owner:DrawViewModel( false )
end
function SWEP:DrawWorldModel()
	if !IsValid(self.Owner) then
		self:DrawModel()
	end
end

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().EYEDROPS
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end
	self:SetHoldType(self.HoldType)
	self:SetSkin( 1 )
end
function SWEP:Think()
end
function SWEP:Reload()
end
function SWEP:PrimaryAttack()
	-- Security Droid nie może używać eyedrops (androidy nie mają oczu biologicznych)
	if self.Owner:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		return
	end
	OnUseEyedrops(self.Owner)
end
function SWEP:SecondaryAttack()
end
function SWEP:CanPrimaryAttack()
end


================================================
FILE: gamemodes/breach/entities/weapons/item_medkit.lua
================================================
AddCSLuaFile()

if CLIENT then
	SWEP.WepSelectIcon 	= surface.GetTextureID("breach/wep_medkit")
	SWEP.BounceWeaponIcon = false
end

SWEP.ViewModelFOV	= 62
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/mishka/models/firstaidkit.mdl"
SWEP.WorldModel		= "models/mishka/models/firstaidkit.mdl"
SWEP.PrintName		= "First Aid kit"
SWEP.Slot			= 1
SWEP.SlotPos		= 1
SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= true
SWEP.HoldType		= "normal"
SWEP.Spawnable		= false
SWEP.AdminSpawnable	= false

SWEP.betterone				= "item_ultramedkit"
SWEP.droppable				= true
SWEP.teams					= {2,3,5,6,7}

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Ammo			=  "none"
SWEP.Primary.Automatic		= false

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Ammo			=  "none"
SWEP.Secondary.Automatic	=  false

function SWEP:Deploy()
	self.Owner:DrawViewModel( false )
end
function SWEP:DrawWorldModel()
	if !IsValid(self.Owner) then
		self:DrawModel()
	end
end

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().MEDKIT
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end
	self:SetHoldType(self.HoldType)
	self:SetSkin( 0 )
end
function SWEP:Think()
end
function SWEP:Reload()
end
function SWEP:PrimaryAttack()
			if self.Owner:GTeam() == TEAM_SCP and self.Owner:GetNClass() != ROLES.ROLE_SCP035 then return end
	-- Security Droid nie może używać apteczek (android nie potrzebuje biologicznego leczenia)
	if self.Owner:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		return
	end
	if self.Owner:Health() / self.Owner:GetMaxHealth() <= 0.8 then
		if SERVER then
			self.Owner:SetHealth(self.Owner:GetMaxHealth())
			self.Owner:StripWeapon("item_medkit")
		end
	else
		if SERVER then
			self.Owner:PrintMessage(HUD_PRINTTALK, "You don't need healing yet")
		end
	end
end
function SWEP:SecondaryAttack()
	if SERVER then
		local ent = self.Owner:GetEyeTrace().Entity
		if ent:IsPlayer() then
			if ent:GTeam() == TEAM_SCP and ent:GetNClass() != ROLES.ROLE_SCP035 then return end
			if ent:GTeam() == TEAM_SPEC then return end
			-- Security Droid nie może być leczony apteczkami
			if ent:GetNClass() == ROLES.ROLE_SECURITY_DROID then
				return
			end
			if(ent:GetPos():Distance(self.Owner:GetPos()) < 95) then
				if ent:Health() / ent:GetMaxHealth() <= 0.8 then
					ent:SetHealth(ent:GetMaxHealth())
					self.Owner:StripWeapon("item_medkit")
				else
					self.Owner:PrintMessage(HUD_PRINTTALK, ent:Nick() .. " doesn't need healing yet")
				end
			end
		end
	end
end
function SWEP:CanPrimaryAttack()
end


================================================
FILE: gamemodes/breach/entities/weapons/item_nvg.lua
================================================
AddCSLuaFile()

if CLIENT then
	SWEP.WepSelectIcon 	= surface.GetTextureID("breach/wep_nvg")
	SWEP.BounceWeaponIcon = false
end

SWEP.ViewModelFOV	= 62
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/mishka/models/nvg.mdl"
SWEP.WorldModel		= "models/mishka/models/nvg.mdl"
SWEP.PrintName		= "NVG"
SWEP.Slot			= 1
SWEP.SlotPos		= 1
SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.HoldType		= "normal"
SWEP.Spawnable		= false
SWEP.AdminSpawnable	= false

SWEP.droppable				= true
SWEP.teams					= {2,3,5,6,7}

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Ammo			=  "none"
SWEP.Primary.Automatic		= false

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Ammo			=  "none"
SWEP.Secondary.Automatic	=  false

-- Network string for NVG toggle
if SERVER then
	util.AddNetworkString("NVG_Toggle")
end

function SWEP:Deploy()
	self.Owner:DrawViewModel( false )
end

function SWEP:DrawWorldModel()
	if !IsValid(self.Owner) then
		self:DrawModel()
	end
end

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().NVG
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end
	self:SetHoldType(self.HoldType)
	self:SetSkin( 2 )
end

function SWEP:Think()
end

function SWEP:Reload()
end

function SWEP:PrimaryAttack()
	if CLIENT then return end
	
	-- Toggle NVG state
	local owner = self.Owner
	if IsValid(owner) then
		-- Initialize NVG state if not exists
		if owner.NVGActive == nil then
			owner.NVGActive = false
		end
		
		-- Toggle state
		owner.NVGActive = !owner.NVGActive
		
		-- Send to client
		net.Start("NVG_Toggle")
			net.WriteBool(owner.NVGActive)
		net.Send(owner)
		
		-- Feedback message
		if owner.NVGActive then
			owner:ChatPrint("NVG activated")
		else
			owner:ChatPrint("NVG deactivated")
		end
		
		self:SetNextPrimaryFire(CurTime() + 0.5)
	end
end

function SWEP:OnRemove()
	-- Clear NVG state when weapon is removed/dropped
	if SERVER and IsValid(self.Owner) then
		self.Owner.NVGActive = false
		net.Start("NVG_Toggle")
			net.WriteBool(false)
		net.Send(self.Owner)
	end
end

function SWEP:OnDrop()
	-- Clear NVG state when weapon is dropped
	if SERVER and IsValid(self.Owner) then
		self.Owner.NVGActive = false
		net.Start("NVG_Toggle")
			net.WriteBool(false)
		net.Send(self.Owner)
	end
end

function SWEP:Holster()
	return true
end

function SWEP:SecondaryAttack()
end

function SWEP:CanPrimaryAttack()
	return true
end





================================================
FILE: gamemodes/breach/entities/weapons/item_radio.lua
================================================
AddCSLuaFile()

if CLIENT then
	SWEP.WepSelectIcon 	= surface.GetTextureID("breach/wep_radio")
	SWEP.BounceWeaponIcon = false
end

SWEP.ViewModelFOV	= 62
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/mishka/models/radio.mdl"
SWEP.WorldModel		= "models/mishka/models/radio.mdl"
SWEP.PrintName		= "Radio"
SWEP.Slot			= 1
SWEP.SlotPos		= 1
SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.HoldType		= "normal"
SWEP.Spawnable		= false
SWEP.AdminSpawnable	= false

SWEP.droppable				= true
SWEP.teams					= {2,3,5,6,7}

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Ammo			=  "none"
SWEP.Primary.Automatic		= false

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Ammo			=  "none"
SWEP.Secondary.Automatic	=  false

SWEP.Channel = 5
SWEP.Enabled = false
SWEP.NextChange = 0
SWEP.IsPlayingFor = nil
function SWEP:Deploy()
	self.Owner:DrawViewModel( false )
end
function SWEP:DrawWorldModel()
	if !IsValid(self.Owner) then
		self:DrawModel()
	end
end

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().RADIO
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end
	self:SetHoldType(self.HoldType)
	self:SetSkin(1)
end

function SWEP:PlaySound(name, volume, looping)
	if CLIENT then
		//print("Starting playing a sound " .. name .. " with volume: " .. tostring(volume) .. " and looping is: " .. tostring(looping))
		sound.PlayFile( name, "mono noblock", function( station, errorID, errorName )
			if ( IsValid( station ) ) then
				station:SetPos( LocalPlayer():GetPos() )
				station:SetVolume( volume )
				if looping then
					station:EnableLooping( looping )
					station:SetTime( 360 )
				end
				station:Play()
				LocalPlayer().channel = station
			else
				print("station not found")
				print(errorName)
			end
		end )
	end
end

function SWEP:RemoveSounds()
	if CLIENT then
		if LocalPlayer().channel != nil then
			LocalPlayer().channel:EnableLooping( false )
			LocalPlayer().channel:Stop()
			LocalPlayer().channel = nil
		end
	end
end

function SWEP:StopSounds()
	if CLIENT then
		if LocalPlayer().channel != nil then
			//LocalPlayer().channel:EnableLooping( false )
			LocalPlayer().channel:SetVolume(0)
			//LocalPlayer().channel = nil
		end
	end
end

SWEP.LastSound = 0
function SWEP:CheckSounds()
	if CLIENT then
		local r = "sound/radio/"
		if self.Channel == 1 then
			self:PlaySound(r .. "radioalarm.ogg", 1, true)
			self.IsLooping = true
		elseif self.Channel == 2 then
			self:PlaySound(r .. "radioalarm2.ogg", 1, false)
			self.NextSoundCheck = CurTime() + 12
			self.IsLooping = false
		elseif self.Channel == 3 then
			self.LastSound = self.LastSound + 1
			if self.LastSound == 0 then
				self.NextSoundCheck = CurTime() + 24
			elseif self.LastSound == 1 then
				self.NextSoundCheck = CurTime() + 15
			elseif self.LastSound == 2 then
				self.NextSoundCheck = CurTime() + 21
			elseif self.LastSound == 3 then
				self.NextSoundCheck = CurTime() + 25
			elseif self.LastSound == 4 then
				self.NextSoundCheck = CurTime() + 28
			elseif self.LastSound == 5 then
				self.NextSoundCheck = CurTime() + 35
			elseif self.LastSound == 6 then
				self.NextSoundCheck = CurTime() + 46
			elseif self.LastSound == 7 then
				self.NextSoundCheck = CurTime() + 20
			elseif self.LastSound == 8 then
				self.NextSoundCheck = CurTime() + 24
			elseif self.LastSound == 9 then
				self.LastSound = 0
				self.NextSoundCheck = CurTime() + 24
			end
			local sound = "scpradio" .. self.LastSound
			self:PlaySound(r .. sound .. ".ogg", 1, false)
			self.IsLooping = false
		elseif self.Channel == 4 then
			if #RADIO4SOUNDS > 0 then
				if math.random(1,4) == 4 then
					local rndtbl = table.Random(RADIO4SOUNDS)
					//print("playing " .. rndtbl[1])
					self:PlaySound(r .. rndtbl[1] .. ".ogg", 1, false)
					self.NextSoundCheck = CurTime() + rndtbl[2] + 5
					self.IsLooping = false
					table.RemoveByValue(RADIO4SOUNDS, rndtbl)
				else
					//print("waiting 5 secs")
					self.NextSoundCheck = CurTime() + 5
					self.IsLooping = false
				end
			else
				self.IsLooping = true
			end
		end
	end
end

SWEP.IsLooping = false
SWEP.NextSoundCheck = 0
function SWEP:Think()
	if SERVER then return end
	if self.Enabled then
		if self.IsLooping == false then
			if self.NextSoundCheck < CurTime() then
				self:CheckSounds()
			end
		end
	end
end
function SWEP:Reload()
end
function SWEP:PrimaryAttack()
	if self.NextChange > CurTime() then return end
	self.Channel = self.Channel + 1
	if self.Channel > 10 then
		self.Channel = 1
	end
	self.IsLooping = false
	self:RemoveSounds()
	if self.Enabled then
		self:CheckSounds()
	end
	self.NextChange = CurTime() + 0.1
end
function SWEP:OnRemove()
	if CLIENT then
		self.IsLooping = false
		self:StopSounds()
		self.Enabled = false
	end
end
function SWEP:Holster()
	//if CLIENT then
	//	self.IsLooping = false
	//	self:StopSounds()
	//	self.Enabled = false
	//end
	return true
end
function SWEP:SecondaryAttack()
	if self.NextChange > CurTime() then return end
	self.Enabled = !self.Enabled
	self.NextChange = CurTime() + 0.1
	if CLIENT then
		if self.Enabled then
			//self:CheckSounds()
			if IsValid(LocalPlayer().channel) then
				LocalPlayer().channel:SetVolume(1)
			end
		else
			self:StopSounds()
		end
	end
	//self.Owner.RadioEnabled = self.Enabled
	//print(self.NextChange)
	//print(self.Owner:Nick() .. " " .. tostring(self.Enabled))
end
function SWEP:CanPrimaryAttack()
end

local ourMat = Material( "breach/RadioHUD.png" )
function SWEP:DrawHUD()
	if disablehud == true then return end
	local rw = ScrW() / 7.6
	local rh = (rw * 2) * 1.1
	surface.SetDrawColor( 255, 255, 255, 255 )
	surface.SetMaterial( ourMat	)
	surface.DrawTexturedRect( ScrW() - rw, ScrH() - rh, rw, rh )
	local showtext = ""
	local showcolor = Color(17, 145, 66)
	
	if self.Enabled then
		showtext = self.Lang.channel.." "..self.Channel
		showcolor = Color(0, 255, 0)
	else
		showtext = self.Lang.disabled
		showcolor = Color(255, 0, 0)
	end
	showcolor = color_white
	//local rx = ScrW() - rw
	//local ry = ScrH() - rh
	local rx = ScrW() / 2
	local ry = ScrH() / 2 + 50
	draw.Text( {
		text = showtext,
		//pos = { rx + 52, ry * 1.79 },
		pos = { rx + 2, ry + 2},
		font = "RadioFont",
		color = color_black,
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_CENTER,
	})
	draw.Text( {
		text = showtext,
		//pos = { rx + 52, ry * 1.79 },
		pos = { rx, ry },
		font = "RadioFont",
		color = showcolor,
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_CENTER,
	})
end






================================================
FILE: gamemodes/breach/entities/weapons/item_scp_268.lua
================================================
[Binary file]


================================================
FILE: gamemodes/breach/entities/weapons/item_scp_420j.lua
================================================
AddCSLuaFile()

SWEP.ViewModelFOV	= 60
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/mishka/models/scp420.mdl"
SWEP.WorldModel		= "models/mishka/models/scp420.mdl"
SWEP.PrintName		= "SCP-420-J"
SWEP.Slot			= 3
SWEP.SlotPos			= 1
SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= true
SWEP.HoldType		= "normal"
SWEP.Spawnable		= false
SWEP.AdminSpawnable	= false

SWEP.droppable				= true
SWEP.teams					= {2,3,5,6,7}

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Ammo			=  "none"
SWEP.Primary.Automatic		= false

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Ammo			=  "none"
SWEP.Secondary.Automatic	=  false

function SWEP:Deploy()
	if not IsFirstTimePredicted() then return end
	self.Owner:DrawViewModel( false )
end

function SWEP:DrawWorldModel()
	if !IsValid(self.Owner) then
		self:DrawModel()
	end
end

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().SCP_420j
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end
	self:SetHoldType(self.HoldType)
end

function SWEP:Think()
	if not IsFirstTimePredicted() then return end
end

function SWEP:OnUse()
	self.Owner:SetHealth( math.Clamp( self.Owner:Health() + 15, 0,  self.Owner:GetMaxHealth() ) )
	self.Owner:StripWeapon( self:GetClass() )
end

function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if CLIENT then surface.PlaySound( "scp/420J/420J.ogg" ) end
	self.Owner.n420endtime = CurTime() + 15
	if !SERVER then return end
	self:OnUse()
end

function SWEP:SecondaryAttack()
end

function SWEP:PlayerShouldDie()
	self.OnUse()
end


================================================
FILE: gamemodes/breach/entities/weapons/item_scp_500.lua
================================================
AddCSLuaFile()

SWEP.ViewModelFOV	= 60
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/scp500/scp500model.mdl"
SWEP.WorldModel		= "models/weapons/scp500/scp500model.mdl"
SWEP.PrintName		= "SCP-500"
SWEP.Slot			= 3
SWEP.SlotPos			= 1
SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= true
SWEP.HoldType		= "normal"
SWEP.Spawnable		= false
SWEP.AdminSpawnable	= false

SWEP.droppable				= true
SWEP.teams					= {2,3,5,6,7}

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Ammo			=  "none"
SWEP.Primary.Automatic		= false

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Ammo			=  "none"
SWEP.Secondary.Automatic	=  false

function SWEP:Deploy()
	if not IsFirstTimePredicted() then return end
	self.Owner:DrawViewModel( false )
end

function SWEP:DrawWorldModel()
	if !IsValid(self.Owner) then
		self:DrawModel()
	end
end

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().SCP_500
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end
	self:SetHoldType(self.HoldType)
end

function SWEP:Think()
	if not IsFirstTimePredicted() then return end
end

function SWEP:OnUse()
	self.Owner:SetHealth( self.Owner:GetMaxHealth() )
	self.Owner:StripWeapon( self:GetClass() )
end

function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if !SERVER then return end
	-- Security Droid nie może używać SCP-500 (bilogiczne leki nie działają na androidy)
	if self.Owner:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		return
	end
	if self.Owner:Health() > self.Owner:GetMaxHealth() * 0.75 then return end
	self:OnUse()
end

function SWEP:SecondaryAttack()
end

function SWEP:PlayerShouldDie()
	self.OnUse()
end


================================================
FILE: gamemodes/breach/entities/weapons/item_scp_714.lua
================================================
AddCSLuaFile()

SWEP.ViewModelFOV	= 60
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/mishka/models/scp714.mdl"
SWEP.WorldModel		= "models/mishka/models/scp714.mdl"
SWEP.PrintName		= "SCP-714"
SWEP.Slot			= 3
SWEP.SlotPos			= 1
SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= true
SWEP.HoldType		= "normal"
SWEP.Spawnable		= false
SWEP.AdminSpawnable	= false

SWEP.droppable				= true
SWEP.teams					= {2,3,5,6,7}

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Ammo			=  "none"
SWEP.Primary.Automatic		= false

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Ammo			=  "none"
SWEP.Secondary.Automatic	=  false

SWEP.InUse = false
SWEP.Durability = 100
SWEP.IsActive = false

function SWEP:Deploy()
	if not IsFirstTimePredicted() then return end
	-- Security Droid nie może używać SCP-714 (pierścień biologiczny, android go nie potrzebuje)
	if self.Owner:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		if SERVER then
			self.Owner:PrintMessage(HUD_PRINTTALK, "[SYSTEM] ERROR: Anomalous biological enhancement item incompatible with android systems")
			-- Automatycznie usuń przedmiot
			timer.Simple(0.1, function()
				if IsValid(self.Owner) then
					self.Owner:StripWeapon("item_scp_714")
				end
			end)
		end
		return
	end
	self.Owner:DrawViewModel( false )
	if SERVER then
		self.Owner:SetNWBool("SCP714_Active", self.IsActive)
		self.Owner:SetNWFloat("SCP714_Durability", self.Durability)
	end
end

function SWEP:Holster()
	if not IsFirstTimePredicted() then return end
	return true
end

function SWEP:Equip()
	if not IsFirstTimePredicted() then return end
end

function SWEP:DrawWorldModel()
	if !IsValid(self.Owner) then
		self:DrawModel()
	end
end

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().SCP_714
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end
	self:SetHoldType(self.HoldType)
end

SWEP.LastTime = 0

function SWEP:Think()
	if not IsFirstTimePredicted() then return end
	
	-- Sync z serwerem (tylko synchronizacja, bez logiki działania)
	if SERVER then
		self.Owner:SetNWBool("SCP714_Active", self.IsActive)
		self.Owner:SetNWFloat("SCP714_Durability", self.Durability)
	else
		self.IsActive = self.Owner:GetNWBool("SCP714_Active", false)
		self.Durability = self.Owner:GetNWFloat("SCP714_Durability", 100)
	end
end

function SWEP:OnRemove() 
	if SERVER and IsValid(self.Owner) then
		self.Owner:SetNWBool("SCP714_Active", false)
		self.Owner.Using714 = false
		-- Usuń timer jeśli istnieje
		timer.Remove("SCP714_Background_" .. self.Owner:SteamID64())
	end
end

function SWEP:Reload()
end

function SWEP:OwnerChanged()
	-- Nie resetuj stanu przy zmianie właściciela
end

-- Hook dla działania w tle
if SERVER then
	hook.Add("Think", "SCP714_Background", function()
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply:HasWeapon("item_scp_714") then
				local wep = ply:GetWeapon("item_scp_714")
				if IsValid(wep) and wep.IsActive then
					-- Działaj w tle nawet gdy nie trzyma broni
					if not ply.SCP714_LastBgTime then ply.SCP714_LastBgTime = 0 end
					
					if ply.SCP714_LastBgTime <= CurTime() then
						ply.SCP714_LastBgTime = CurTime() + 0.9
						wep.Durability = wep.Durability - 0.5
						
						if wep.Durability > 0 then
							if ply:GetMaxHealth() > ply:Health() then
								ply:SetHealth(ply:Health() + 1)
							end
							ply.Using714 = true
						else
							wep.IsActive = false
							ply.Using714 = false
							if wep.Durability < 0 then
								ply:StripWeapon("item_scp_714")
							end
						end
						
						-- Natychmiastowa synchronizacja po zmianie
						ply:SetNWFloat("SCP714_Durability", wep.Durability)
					end
				end
			else
				ply.SCP714_LastBgTime = nil
			end
		end
	end)
end

-- Globalny HUD hook dla pokazywania statusu gdy nie trzyma SCP-714
if CLIENT then
	hook.Add("HUDPaint", "SCP714_GlobalStatus", function()
		local ply = LocalPlayer()
		if not IsValid(ply) then return end
		
		-- Sprawdź czy ma SCP-714 ale nie trzyma go aktualnie
		if ply:HasWeapon("item_scp_714") then
			local currentWep = ply:GetActiveWeapon()
			if not IsValid(currentWep) or currentWep:GetClass() ~= "item_scp_714" then
				-- Ma SCP-714 ale nie trzyma go - pokaż status
				local isActive = ply:GetNWBool("SCP714_Active", false)
				local durability = ply:GetNWFloat("SCP714_Durability", 100)
				
				if isActive and durability > 0 then
					-- Pozycja na samej górze ekranu
					local x = ScrW() / 2
					local y = 30
					
					-- Prosty tekst bez tła
					local text = "SCP-714: " .. math.floor(durability) .. "% [ACTIVE]"
					draw.SimpleText(text, "SCP714_Small", x, y, Color(100, 255, 100), TEXT_ALIGN_CENTER)
					
					-- Pasek postępu
					local barWidth = 100
					local barHeight = 4
					local progress = durability / 100
					
					-- Tło paska
					surface.SetDrawColor(0, 0, 0, 150)
					surface.DrawRect(x - barWidth/2, y + 20, barWidth, barHeight)
					
					-- Wypełnienie paska
					surface.SetDrawColor(100, 255, 100, 255)
					surface.DrawRect(x - barWidth/2, y + 20, barWidth * progress, barHeight)
				end
			end
		end
	end)
end

function SWEP:PrimaryAttack()
	if not IsFirstTimePredicted() then return end
	if preparing or postround then return end
	
	self.IsActive = not self.IsActive
	
	if SERVER then
		if self.IsActive then
			self.Owner:PrintMessage(HUD_PRINTTALK, "SCP-714 ENABLED")
			self.Owner.Using714 = true
		else
			self.Owner:PrintMessage(HUD_PRINTTALK, "SCP-714 DISABLED")
			self.Owner.Using714 = false
		end
	end
end

function SWEP:SecondaryAttack()
end

function SWEP:CanPrimaryAttack()
end

if CLIENT then
	surface.CreateFont("SCP714_Small", {
		font = "Trebuchet24", 
		size = 18,
		weight = 500,
		antialias = true,
		shadow = true
	})
end

function SWEP:DrawHUD()
	if disablehud == true then return end
	
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local x = ScrW() / 2
	local y = ScrH() / 2 - 50
	
	local barWidth = 100
	local barHeight = 4
	
	local isActive = ply:GetNWBool("SCP714_Active", false)
	local durability = ply:GetNWFloat("SCP714_Durability", 100)
	
	local color
	if isActive then
		color = Color(100, 255, 100) -- Jasny zielony gdy aktywny
	else
		color = Color(150, 150, 150) -- Szary gdy nieaktywny
	end
	
	local text = durability .. "%" .. (isActive and " [ON]" or " [OFF]")
	draw.SimpleText(text, "SCP714_Small", x, y - 20, color, TEXT_ALIGN_CENTER)
	
	if not isActive then
		draw.SimpleText("LMB: Enable", "SCP714_Small", x, y - 35, Color(100, 100, 100), TEXT_ALIGN_CENTER)
	end
	
	local progress = durability / 100
	
	surface.SetDrawColor(0, 0, 0, 150)
	surface.DrawRect(x - barWidth/2, y, barWidth, barHeight)
	
	if isActive then
		surface.SetDrawColor(100, 255, 100, 255) -- Jasny zielony gdy aktywny
	else
		surface.SetDrawColor(150, 150, 150, 255) -- Szary gdy nieaktywny
	end
	surface.DrawRect(x - barWidth/2, y, barWidth * progress, barHeight)
end


================================================
FILE: gamemodes/breach/entities/weapons/item_snav_300.lua
================================================
AddCSLuaFile()

if CLIENT then
	SWEP.WepSelectIcon 	= surface.GetTextureID("breach/wep_snav_300")
	SWEP.BounceWeaponIcon = false
end

SWEP.ViewModelFOV	= 62
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/mishka/models/snav.mdl"
SWEP.WorldModel		= "models/mishka/models/snav.mdl"
SWEP.PrintName		= "S-Nav 300"
SWEP.Slot			= 1
SWEP.SlotPos		= 1
SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.HoldType		= "normal"
SWEP.Spawnable		= false
SWEP.AdminSpawnable	= false

SWEP.betterone = "item_snav_ultimate"
SWEP.droppable				= true
SWEP.teams					= {2,3,5,6,7}

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Ammo			=  "none"
SWEP.Primary.Automatic		= false

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Ammo			=  "none"
SWEP.Secondary.Automatic	=  false

SWEP.Enabled = false
SWEP.NextChange = 0
function SWEP:Deploy()
	self.Owner:DrawViewModel( false )
end
function SWEP:DrawWorldModel()
	if !IsValid(self.Owner) then
		self:DrawModel()
	end
end

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().SNAV
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end
	self:SetHoldType(self.HoldType)
	self:SetSkin(1)
end
function SWEP:CalcView( ply, pos, ang, fov )
	if self.Enabled then
		ang = Vector(90,0,0)
		pos = pos + Vector(0,0,650)
		fov = 90
	end
	return pos, ang, fov
end
function SWEP:Think()
end
function SWEP:Reload()
end
function SWEP:PrimaryAttack()
end
function SWEP:OnRemove()
	if CLIENT then
		for k,v in pairs(player.GetAll()) do
			v:SetNoDraw( false )
		end
	end
end
function SWEP:Holster()
	if CLIENT then
		for k,v in pairs(player.GetAll()) do
			v:SetNoDraw( false )
		end
	end
	return true
end
function SWEP:SecondaryAttack()
	if SERVER then return end
	if self.NextChange > CurTime() then return end
	self.Enabled = !self.Enabled
	if self.Enabled then
		for k,v in pairs(player.GetAll()) do
			v:SetNoDraw( true )
		end
	else
		for k,v in pairs(player.GetAll()) do
			v:SetNoDraw( false )
		end
	end
	self.NextChange = CurTime() + 0.25
end
function SWEP:CanPrimaryAttack()
end





================================================
FILE: gamemodes/breach/entities/weapons/item_snav_ultimate.lua
================================================
AddCSLuaFile()

if CLIENT then
	SWEP.WepSelectIcon 	= surface.GetTextureID("breach/wep_snav_ult")
	SWEP.BounceWeaponIcon = false
end

SWEP.ViewModelFOV	= 62
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/mishka/models/snav.mdl"
SWEP.WorldModel		= "models/mishka/models/snav.mdl"
SWEP.PrintName		= "S-Nav Ultimate"
SWEP.Slot			= 1
SWEP.SlotPos		= 1
SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.HoldType		= "normal"
SWEP.Spawnable		= false
SWEP.AdminSpawnable	= false

SWEP.droppable				= true
SWEP.teams					= {2,3,5,6,7}

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Ammo			=  "none"
SWEP.Primary.Automatic		= false

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Ammo			=  "none"
SWEP.Secondary.Automatic	=  false

SWEP.Enabled = false
SWEP.NextChange = 0
function SWEP:Deploy()
	self.Owner:DrawViewModel( false )
end
function SWEP:DrawWorldModel()
	if !IsValid(self.Owner) then
		self:DrawModel()
	end
end

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().SNAV_ULT
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end
	self:SetHoldType(self.HoldType)
end

function SWEP:CalcView( ply, pos, ang, fov )
	if self.Enabled then
		ang = Vector(90,0,0)
		pos = pos + Vector(0,0,900)
		fov = 90
	end
	return pos, ang, fov
end

SWEP.warnings = {}
SWEP.scps = {}
SWEP.toshow = {}
SWEP.ScanDelay = 0
function SWEP:Think()
	if CLIENT then
		if self.Enabled then
			for k,v in pairs(player.GetAll()) do
				v:SetNoDraw( true )
			end
		else
			for k,v in pairs(player.GetAll()) do
				v:SetNoDraw( false )
			end
		end
		if self.ScanDelay > CurTime() then return end
		self.ScanDelay = CurTime() + 1
		self.warnings = {}
		self.scps = {}
		self.toshow = {}
		local lp = LocalPlayer()
		for k,v in pairs(ents.FindInSphere( lp:GetPos(), 1000 )) do
			if v:IsPlayer() then
				if v == lp then continue end
				if v:GTeam() != TEAM_SPEC then
					if v:GTeam() == TEAM_GUARD then
						table.ForceInsert(self.warnings, self.Lang.mtfdetect)
						continue
					elseif v:GTeam() == TEAM_CHAOS then
						if lp:GTeam() == TEAM_CHAOS then
							table.ForceInsert(self.warnings, self.Lang.cidetect)
							continue
						else
							table.ForceInsert(self.warnings, self.Lang.mtfdetect)
							continue
						end
					elseif v:GTeam() == TEAM_SCI then
						table.ForceInsert(self.warnings, self.Lang.resdetect)
						continue
					elseif v:GTeam() == TEAM_CLASSD then
						table.ForceInsert(self.warnings, self.Lang.ddetect)
						continue
					elseif v:GTeam() == TEAM_SCP then
						if not v.GetNClass then
							player_manager.RunClass( v, "SetupDataTables" )
						end
						--table.ForceInsert(self.warnings, v:GetNClass().." "..self.Lang.detect)
						table.ForceInsert( self.scps, v )
					else
						table.ForceInsert(self.warnings, self.Lang.unkdetect)
					end
				end
			elseif v:IsWeapon() then
				local found = false
				local nowarn = false
				if IsValid(v.Owner) then
					found = true
				end
				/*if v.ISSCP != nil then
					if v.ISSCP == true then
						table.ForceInsert( self.scps, v )
						found = true
						nowarn = true
					end
				end*/
				if !found then
					table.ForceInsert(self.toshow, v)
					if !nowarn then
						table.ForceInsert( self.warnings, language.GetPhrase( v:GetPrintName() ).." "..self.Lang.detect )
					end
				end
			end
		end
	end
end
function SWEP:Reload()
end
function SWEP:PrimaryAttack()
end
function SWEP:OnRemove()
	if CLIENT then
		for k,v in pairs(player.GetAll()) do
			v:SetNoDraw( false )
		end
	end
end
function SWEP:Holster()
	if CLIENT then
		for k,v in pairs(player.GetAll()) do
			v:SetNoDraw( false )
		end
	end
	return true
end
function SWEP:SecondaryAttack()
	if SERVER then return end
	if self.NextChange > CurTime() then return end
	self.Enabled = !self.Enabled
	self.NextChange = CurTime() + 0.25
end
function SWEP:CanPrimaryAttack()
end

function SWEP:DrawHUD()
	if self.Enabled then
		local w, h = ScrW(), ScrH()
		--surface.DrawCircle( w * 0.5, h * 0.5, 3, Color( 0, 255, 0, 255 ) )
		/*
		if BUTTONS != nil then
			for k,v in pairs(BUTTONS) do
				DrawInfo(v.pos, v.name, Color(0,255,50))
			end
			for k,v in pairs(SPAWN_KEYCARD2) do
				DrawInfo(v, "Keycard2", Color(255,255,0))
			end
			for k,v in pairs(SPAWN_KEYCARD3) do
				DrawInfo(v, "Keycard3", Color(255,120,0))
			end
			for k,v in pairs(SPAWN_KEYCARD4) do
				DrawInfo(v, "Keycard4", Color(255,0,0))
			end
			for k,v in pairs(SPAWN_ITEMS) do
				DrawInfo(v, "Item", Color(255,255,255))
			end
		end
		*/
		for k,v in pairs(self.toshow) do
			if IsValid(v) then
				if v:GetPos():Distance(LocalPlayer():GetPos()) < 400 then
					local pos = v:GetPos():ToScreen()
					local npos = v:GetPos()
					npos.x = npos.x - 25
					DrawInfo(npos, v:GetPrintName(), Color(255,255,255))
					surface.DrawCircle( pos.x, pos.y, 3, Color( 0, 255, 0, 255 ) )
				end
			end
		end
		if #self.warnings > 0 then
			draw.Text( {
				text = self.Lang.items,
				pos = { ScrW() * 0.8, ScrH() * 0.4 - 25 },
				font = "173font",
				color = Color(150,0,150),
				xalign = TEXT_ALIGN_CENTER,
				yalign = TEXT_ALIGN_CENTER,
			})
		end
		for i,v in ipairs(self.warnings) do
			draw.Text( {
				text = v,
				pos = { ScrW() * 0.9, ScrH() * 0.4 + i * 25 },
				font = "173font",
				color = Color(200,0,100),
				xalign = TEXT_ALIGN_RIGHT,
				yalign = TEXT_ALIGN_CENTER,
			})
		end
		if #self.scps > 0 then
			draw.Text( {
				text = "SCP:",
				pos = { ScrW() * 0.5, ScrH() * 0.045 },
				font = "173font",
				color = Color(255,0,0),
				xalign = TEXT_ALIGN_CENTER,
				yalign = TEXT_ALIGN_CENTER,
			})
		end
		for i, v in ipairs( self.scps ) do
			if IsValid( v ) then
				draw.Text( {
					text = v:GetNClass(),
					pos = { ScrW() * 0.5, ScrH() * 0.05 + i * 25 },
					font = "173font",
					color = Color(255,0,0),
					xalign = TEXT_ALIGN_CENTER,
					yalign = TEXT_ALIGN_CENTER,
				})
				--surface.DrawRect( v:GetPos():ToScreen().x - 10, v:GetPos():ToScreen().y - 10, 20, 20 )
				--local dist = self.Owner:GetPos():Distance( v:GetPos() )
				local dist = distance( self.Owner:GetPos():ToScreen(), v:GetPos():ToScreen() )
				local r = math.ceil( dist / 100 ) * 100
				for i = 0, 3 do
					surface.DrawCircle( w * 0.5, h * 0.5, r - i, Color( 255, 255, 255, 255 ) )
				end
			end
		end
	end
end

function distance( coords1, coords2 )
	local dx, dy = coords1.x - coords2.x, coords1.y - coords2.y
	local dist = math.sqrt( math.pow( dx, 2 ) + math.pow( dy, 2 ), 2 )
	return dist
end


================================================
FILE: gamemodes/breach/entities/weapons/item_ultramedkit.lua
================================================
AddCSLuaFile()

if CLIENT then
	SWEP.WepSelectIcon 	= surface.GetTextureID("breach/wep_medkit")
	SWEP.BounceWeaponIcon = false
end

SWEP.ViewModelFOV	= 62
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/mishka/models/firstaidkit.mdl"
SWEP.WorldModel		= "models/mishka/models/firstaidkit.mdl"
SWEP.PrintName		= "Ultra First Aid kit"
SWEP.Slot			= 1
SWEP.SlotPos		= 1
SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= true
SWEP.HoldType		= "normal"
SWEP.Spawnable		= false
SWEP.AdminSpawnable	= false

SWEP.Uses					= 3
SWEP.droppable				= true
SWEP.teams					= {2,3,5,6,7}

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Ammo			=  "none"
SWEP.Primary.Automatic		= false

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Ammo			=  "none"
SWEP.Secondary.Automatic	=  false

function SWEP:Deploy()
	self.Owner:DrawViewModel( false )
end
function SWEP:DrawWorldModel()
	if !IsValid(self.Owner) then
		self:DrawModel()
	end
end

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().MEDKIT
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end
	self:SetHoldType(self.HoldType)
	self:SetSkin( 1 )
end
function SWEP:Think()
end
function SWEP:Reload()
end
function SWEP:PrimaryAttack()
	-- Security Droid nie może używać apteczek (android nie potrzebuje biologicznego leczenia)
	if self.Owner:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		return
	end
	if self.Owner:Health() / self.Owner:GetMaxHealth() <= 0.8 then
		self.Uses = self.Uses - 1
		if SERVER then
			self.Owner:SetHealth(self.Owner:GetMaxHealth())
			if self.Uses < 1 then
				self.Owner:StripWeapon("item_ultramedkit")
			end
		end
	else
		if CLIENT then
			if !(IsFirstTimePredicted()) then return end
			//self.Owner:PrintMessage(HUD_PRINTTALK, "You don't need healing yet")
			chat.AddText("You don't need healing yet")
		end
	end
end
function SWEP:SecondaryAttack()
	if SERVER then
		local ent = self.Owner:GetEyeTrace().Entity
		if ent:IsPlayer() then
			if ent:GTeam() == TEAM_SCP and ent:GetNClass() != ROLES.ROLE_SCP035 then return end
			if ent:GTeam() == TEAM_SPEC then return end
			-- Security Droid nie może być leczony apteczkami
			if ent:GetNClass() == ROLES.ROLE_SECURITY_DROID then
				return
			end
			if(ent:GetPos():Distance(self.Owner:GetPos()) < 95) then
				if ent:Health() / ent:GetMaxHealth() <= 0.8 then
					ent:SetHealth(ent:GetMaxHealth())
					self.Uses = self.Uses - 1
					if self.Uses < 1 then
						self.Owner:StripWeapon("item_ultramedkit")
					end
				else
					self.Owner:PrintMessage(HUD_PRINTTALK, ent:Nick() .. " doesn't need healing yet")
				end
			end
		end
	end
end
function SWEP:CanPrimaryAttack()
end


================================================
FILE: gamemodes/breach/entities/weapons/swep_czysty.lua
================================================
AddCSLuaFile()

SWEP.PrintName			= ""			

SWEP.ViewModelFOV 		= 56
SWEP.Spawnable 			= false
SWEP.AdminOnly 			= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Delay        = 1
SWEP.Primary.Automatic	= false
SWEP.Primary.Ammo		= "None"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Delay			= 5
SWEP.Secondary.Ammo		= "None"

SWEP.ISSCP 				= true
SWEP.droppable				= false
SWEP.CColor					= Color(0,255,0)
SWEP.teams					= {1}

SWEP.Weight				= 3
SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false
SWEP.Slot					= 0
SWEP.SlotPos				= 4
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true
SWEP.ViewModel			= ""
SWEP.WorldModel			= ""
SWEP.IconLetter			= "w"
SWEP.HoldType 			= "normal"

--if (CLIENT) then
	--SWEP.WepSelectIcon	= surface.GetTextureID( "vgui/entities/weapon_scp096" )
	--SWEP.BounceWeaponIcon = false
	--killicon.Add( "kill_icon_scp096", "vgui/icons/kill_icon_scp096", Color( 255, 255, 255, 255 ) )
--end

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().SCP_096
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end
	self:SetHoldType(self.HoldType)
end

function SWEP:Deploy()
	if self.Owner:IsValid() then
		self.Owner:DrawWorldModel( false )
		self.Owner:DrawViewModel( false )
	end
end

function SWEP:Holster()
	return true
end

SWEP.Freeze = false

function SWEP:Think()
	if !SERVER then return end
	if preparing and (self.Freeze == false) then
		self.Freeze = true
		self.Owner:SetJumpPower(0)
		self.Owner:SetCrouchedWalkSpeed(0)
		self.Owner:SetWalkSpeed(0)
		self.Owner:SetRunSpeed(0)
	end
	if preparing or postround then return end
	if self.Freeze == true then
		self.Freeze = false
		self.Owner:SetCrouchedWalkSpeed(0.6)
		self.Owner:SetJumpPower(200)
		self.Owner:SetWalkSpeed(150)
		self.Owner:SetRunSpeed(150)
	end
	--
end

function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	--
end

function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	--
end

function SWEP:Reload()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	--
end

function SWEP:DrawHUD()
	if disablehud == true then return end
	
	local showtext = self.Lang.HUD.attackReady
	local showcolor = Color(0,255,0)
	
	if self.NextAttackW > CurTime() then
		showtext = self.Lang.HUD.attackCD.." ".. math.Round(self.NextAttackW - CurTime())
		showcolor = Color(255,0,0)
	end
	
	draw.Text( {
		text = showtext,
		pos = { ScrW() / 2, ScrH() - 30 },
		font = "173font",
		color = showcolor,
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_CENTER,
	})
	
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0

	local scale = 0.3
	surface.SetDrawColor( 0, 255, 0, 255 )
	
	local gap = 5
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_bodycam_tablet.lua
================================================
SWEP.PrintName = "Tactical Bodycam Tablet"
SWEP.Author = "Antek"
SWEP.Category = "[Antke] Bodycam Tablet"
SWEP.Purpose = "RMB – Attach camera | R – Open tablet"

SWEP.Spawnable = true

SWEP.UseHands = true
SWEP.ViewModel = "models/v_item_pda.mdl"
SWEP.WorldModel = "models/v_item_pda.mdl"
SWEP.ViewModelFOV = 80
SWEP.SwayScale = 0.1
SWEP.BobScale = 0.1

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

local lastAngles = Angle(0, 0, 0)

function SWEP:Initialize()
    self:SetHoldType("camera")
    self.BodyCamPeople = {}
    self.PDAOpen = false
    
    -- Zabezpieczenie dla ConVars - tworzenie jeśli nie istnieją
    if SERVER and not GetConVar("bodycam_max_people") then
        CreateConVar("bodycam_max_people", "3", FCVAR_ARCHIVE + FCVAR_REPLICATED + FCVAR_SERVER_CAN_EXECUTE, "", 1)
        CreateConVar("bodycam_time_to_attach", "10", FCVAR_ARCHIVE + FCVAR_REPLICATED + FCVAR_SERVER_CAN_EXECUTE, "", 1)
    end
end


function SWEP:Deploy()
    self:SendWeaponAnim(ACT_VM_HOLSTER)
    self:ResetSequence(self:LookupSequence("Holster"))
    self:EmitSound("Stalker2.PDAEquip")
    self.PDAOpen = false
    self:SetNWBool("PDAOpen", false)
    return true
end

function SWEP:OpenAnim()
    self:SendWeaponAnim(ACT_VM_DRAW)
    self:ResetSequence(self:LookupSequence("Draw"))
    self:EmitSound("Stalker2.PDAEquip")
end

function SWEP:Reload()
    if self:GetNextPrimaryFire() > CurTime() then return end
    self:SetNextPrimaryFire(CurTime() + 2)
    self.PDAOpen = not self.PDAOpen

    if self.PDAOpen then
        self:OpenAnim()
    else
        self:Deploy()
    end

    for i = #self.BodyCamPeople, 1, -1 do
        local ent = self.BodyCamPeople[i]
        if not IsValid(ent) then
            table.remove(self.BodyCamPeople, i)
        end
    end

    net.Start("BodycamPlayers")
        net.WriteTable(self.BodyCamPeople)
    net.Send(self.Owner)

    self.Owner:Freeze(true)
    self:SetNWBool("PDAOpen", self.PDAOpen)
    self.Owner:SetNWBool("BodycamTabletOpen", self.PDAOpen)

    timer.Simple(1, function()
        self.Owner:Freeze(false)
    end)
end

if SERVER then 
    util.AddNetworkString("BodycamPlayers")
    util.AddNetworkString("Bodycam_Voice")
    util.AddNetworkString("Bodycam_Micro")
    util.AddNetworkString("Bodycam_SelectedTarget")
    util.AddNetworkString("Frame_Remove")
end

function SWEP:Holster()
    if self.PDAOpen and IsValid(self.Owner) and self.Owner:Alive() then
        timer.Simple(1, function()
            self.PDAOpen = false
            self:Holster()
        end)
        self:SendWeaponAnim(ACT_VM_HOLSTER)
        self:EmitSound("Stalker2.PDAUnequip")
        return false
    end
    return true
end

function SWEP:SecondaryAttack()
    if self:GetNextSecondaryFire() > CurTime() then return end
    self:SetNextSecondaryFire(CurTime() + 2)

    local trace = util.QuickTrace(self.Owner:EyePos(), self.Owner:GetAimVector() * 80, self.Owner)
    local tr = trace.Entity

    if not IsValid(tr) or (not tr:IsPlayer() and not tr:IsNPC()) then return end

    for _,v in ipairs(self.BodyCamPeople) do
        if v == tr then
                self.Owner:ChatPrint("You have already set up a Bodycam") 
            return 
        end 
    end

    if IsValid(tr:GetNWEntity("BodyCam")) then self.Owner:ChatPrint("Already has a Bodycam") return end

    for i = #self.BodyCamPeople, 1, -1 do
        local ent = self.BodyCamPeople[i]
        if not IsValid(ent) then
            table.remove(self.BodyCamPeople, i)
        end
    end



    local attname = "eyes"
    local head = tr:LookupAttachment(attname)

        if head == 0 then
            attname = "Eye"
            head = tr:LookupAttachment(attname)
        end
    
    if head == 0 then self.Owner:ChatPrint("This target can't have bodycam") return end

    local maxPeople = GetConVar("bodycam_max_people")
    local attachTime = GetConVar("bodycam_time_to_attach")
    
    if not maxPeople or not attachTime then
        self.Owner:ChatPrint("Bodycam ConVars not loaded")
        return
    end
    
    if table.Count(self.BodyCamPeople) >= maxPeople:GetInt() then self.Owner:ChatPrint("All Bodycams is in use") return end

    self:SetNWEntity("HoldingTarget", tr)
    self:SetNWFloat("HoldingTime", CurTime() + attachTime:GetInt())
    self:SetNWInt("bodycam_time_to_attach_cl", attachTime:GetInt())

    timer.Create("SWEPHOLDING" .. self:EntIndex(), attachTime:GetInt(), 1, function()
        if not IsValid(self) or not IsValid(self.Owner) then return end
        local ent = self:GetNWEntity("HoldingTarget")
        if not IsValid(ent) then return end

        if self:GetNWFloat("HoldingTime") > CurTime() then return end

        table.insert(self.BodyCamPeople,ent)
        ent:SetNWEntity("BodyCam", self)
    end)
end



function SWEP:Think()
    local owner = self:GetOwner()
    local target = self:GetNWEntity("HoldingTarget")

    if self:GetNWFloat("HoldingTime") > CurTime() then
        if not owner:KeyDown(IN_ATTACK2) or not IsValid(target) or owner:GetEyeTrace().Entity ~= target then 
            self:SetNWEntity("HoldingTarget", NULL)
            self:SetNWFloat("HoldingTime", CurTime())
            timer.Remove("SWEPHOLDING" .. self:EntIndex())
            return
        end
    end
end

function SWEP:PrimaryAttack()
end

if CLIENT then
    function SWEP:DrawHUD()
        local target = self:GetNWEntity("HoldingTarget")
        if not IsValid(target) then return end

        local endTime = self:GetNWFloat("HoldingTime")
        local timeLeft = endTime - CurTime()
        if timeLeft <= 0 then return end

        local bodycam_time_to_attach_cl = self:GetNWInt("bodycam_time_to_attach_cl")
        local maxTime = bodycam_time_to_attach_cl
        local progress = 1 - (timeLeft / maxTime)
        progress = math.Clamp(progress, 0, 1)

        local x, y = ScrW(), ScrH()

        local r = 255 * (1 - progress)
        local g = 255 * progress
        local b = 0
        local barColor = Color(r, g, b)

        surface.SetDrawColor(0, 0, 0, 255)
        surface.DrawOutlinedRect(x * 0.4, y * 0.5 + 206, 400, 40, 2)

        surface.SetDrawColor(68, 68, 68, 200)
        surface.DrawRect(x * 0.4 + 1, y * 0.5 + 207, 398, 38)

        surface.SetDrawColor(barColor)
        surface.DrawRect(x * 0.4 + 1, y * 0.5 + 208, 398 * progress, 36)
    end
end




if SERVER then
    hook.Add("SetupPlayerVisibility", "AddRTCamera", function(ply, viewEntity)
        local wpn = ply:GetActiveWeapon()
        if not IsValid(wpn) or wpn:GetClass() ~= "weapon_bodycam_tablet" then return end
        local target = wpn:GetNWEntity("BodyCam")
        if not IsValid(target) then return end
        if ply:TestPVS(target:GetPos()) then return end

        AddOriginToPVS(target:GetPos())
    end)
end

hook.Add("PlayerDeath", "bodycam_target_death", function(target, wpn, ply)
    if not IsValid(target) then return end
    local watcher_wpn = target:GetNWEntity("BodyCam")
    if not IsValid(watcher_wpn) then return end
    
    -- Usuń gracza z listy kamer
    table.RemoveByValue(watcher_wpn.BodyCamPeople, target)
    target:SetNWEntity("BodyCam", NULL)
    
    -- Wyślij zaktualizowaną listę do klienta
    if IsValid(watcher_wpn.Owner) then
        net.Start("BodycamPlayers")
            net.WriteTable(watcher_wpn.BodyCamPeople)
        net.Send(watcher_wpn.Owner)
    end

    -- Zamknij tablet jeśli był otwarty, aby odświeżyć UI
    if watcher_wpn.PDAOpen then
        watcher_wpn:Deploy()
    end
end)

function SWEP:CalcView(player, pos, viewAngles, fov)
    local VModel = self:GetOwner():GetViewModel()
    local attachmentID = self:LookupAttachment("1")
    local attachment = self:GetAttachment(attachmentID)

    if attachment then
        local seqAct = VModel:GetSequenceActivity(VModel:GetSequence())
        if seqAct == ACT_VM_DRAW then
            local newAngle = attachment.Ang - self:GetAngles()
            lastAngles = LerpAngle(0.1, lastAngles, newAngle)
            viewAngles:Add(lastAngles)
        elseif seqAct == ACT_VM_HOLSTER then
            local newAngle = Angle(0, 0, 0)
            lastAngles = LerpAngle(0.1, lastAngles, newAngle)
            viewAngles:Add(lastAngles)
        end
    end

    return pos, viewAngles, fov
end

if CLIENT then
    local WorldModel = ClientsideModel(SWEP.WorldModel)
    WorldModel:SetNoDraw(true)

    function SWEP:DrawWorldModel()
        local _Owner = self:GetOwner()

        if IsValid(_Owner) then
            local offsetVec = Vector(-1, -4, -1.6)
            local offsetAng = Angle(15, -10, -165)
            local boneid = _Owner:LookupBone("ValveBiped.Bip01_R_Hand")
            if not boneid then return end

            local matrix = _Owner:GetBoneMatrix(boneid)
            if not matrix then return end

            local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())
            WorldModel:SetPos(newPos)
            WorldModel:SetAngles(newAng)
            WorldModel:SetupBones()
        else
            WorldModel:SetPos(self:GetPos())
            WorldModel:SetAngles(self:GetAngles())
        end

        WorldModel:DrawModel()
    end
end

net.Receive("Frame_Remove", function(len, ply)
    if IsValid(ply) and IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon():GetClass() == "weapon_bodycam_tablet" then
        ply:GetActiveWeapon():Reload()
    end
end)

-- Zabezpieczenie dla net receivers
if SERVER then
    net.Receive("Bodycam_Voice", function(_, ply)
        if IsValid(ply) then
            ply:SetNWBool("Bodycam_AllowVoice", net.ReadBool())
        end
    end)

    net.Receive("Bodycam_Micro", function(_, ply)
        if IsValid(ply) then
            ply:SetNWBool("Bodycam_AllowMic", net.ReadBool())
        end
    end)

    net.Receive("Bodycam_SelectedTarget", function(_, ply)
        if IsValid(ply) then
            ply:SetNWEntity("Bodycam_SelectedTarget", net.ReadEntity())
        end
    end)
end

if CLIENT then
    frejmus = frejmus or {}
    target_index = 1

    ffff_b = Color(30,30,30,200)
    fff_b  = Color(35,35,35,255)
    ff_b   = Color(40,40,40,255)
    f_b    = Color(47,47,47,255)
    w_f_b  = Color(52,52,52,255)
    white_col = Color(255,255,255,255)
    ww_f_b = Color(60,60,60)

    surface.CreateFont("Antek4", {
        font      = "Tahoma",
        extended  = true,
        size      = ScreenScale(35)
    })

    surface.CreateFont("CameraFont", {
        font      = "Monaspace Krypton",
        extended  = true,
        size      = 25,
        weight    = 500,
        blursize  = 0,
        scanlines = 0,
        antialias = true,
    })

    function GetName(target)
        if not IsValid(target) then return "ERROR" end
            if target:IsNPC() then
                local class = target:GetClass()
                local info = list.Get("NPC")[class]
                    return info and info.Name or class or "ERROR"
                elseif target:IsPlayer() then
                    return target:GetName()
            end
    end

    net.Receive("BodycamPlayers",function()
        target_tbl = net.ReadTable()
    end)

    -- Inicjalizuj target_tbl jako pustą tabelę
    target_tbl = target_tbl or {}

        function Dermas()
            if IsValid(frejmus.frame) then return end

                -- Zabezpieczenie dla target_tbl
                target_tbl = target_tbl or {}
                local max_index = table.Count(target_tbl)
                
                -- Popraw indeks jeśli wykracza poza zakres lub lista jest pusta
                if max_index == 0 then
                    target_index = 1
                elseif target_index > max_index then
                    target_index = math.max(1, max_index)
                end
                
                -- Sprawdź czy target_tbl istnieje i nie jest puste
                local target = nil
                if target_tbl and max_index > 0 then
                    target = target_tbl[target_index]
                end

                -- Wyślij informację o wybranym celu tylko jeśli istnieje
                if IsValid(target) then
                    net.Start("Bodycam_SelectedTarget")
                        net.WriteEntity(target)
                    net.SendToServer()
                end

            frejmus.frame = vgui.Create("DPanel")
            local frame = frejmus.frame
            local x, y = ScrW()/1920, ScrH()/1080
            frame:SetSize(x*1570, y*865)
            frame:SetPos(x*180, y*100)
            frame:MakePopup()
            frame:SetZPos(-1000)
            frame:SetPopupStayAtBack(true)
            frame:SetDrawOnTop(false)
            frame:SetKeyboardInputEnabled(false) 
            frame:SetMouseInputEnabled(true)

            frame.Paint = function(self, w, h)
                draw.RoundedBox(8, 0, 0, w, h, ffff_b)
                draw.SimpleText( target and IsValid(target) and "" or "No Connection..", "Antek4", w * 0.5, h * 0.5, Color(228,228,228), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            end

            LocalPlayer():SetNWBool("BodycamTabletOpen", true)


            if IsValid(target) then

                local shouldDrawPlayer = false

                hook.Add("ShouldDrawLocalPlayer", "drawplayer_tablet", function()
                    return shouldDrawPlayer
                end)

                local render_vi = vgui.Create("DFrame", frame)
                render_vi:SetPos(0, 0)
                render_vi:SetSize(frame:GetWide(), frame:GetTall())
                render_vi:ShowCloseButton(false)
                render_vi:SetZPos(-50)
                render_vi:SetTitle("")
                render_vi:SetDraggable(false)

                local light = false

                render_vi.Paint = function(me, w, h)

                    if not target.LookupAttachment then return end

                    local attname = "eyes"
                    local head = target:LookupAttachment(attname)

                    if head == 0 then
                        attname = "Eye"
                        head = target:LookupAttachment(attname)
                    end

                    if not IsValid(target) or not target:Alive() or not LocalPlayer():Alive() or not IsValid(LocalPlayer()) or (head == 0) then
                        if head == 0 then 
                            LocalPlayer():ChatPrint("This target can't have bodycam")
                        end
                        frame:Remove()
                        if IsValid(LocalPlayer()) then
                            local wep = LocalPlayer():GetActiveWeapon()
                            if IsValid(wep) then
                                wep:SetNWEntity("BodyCam", nil)
                                LocalPlayer():SetNWBool("BodycamTabletOpen", false)
                            end
                        end

                        return
                    end

                    shouldDrawPlayer = true
                    draw.RoundedBox(8, 0, 0, w, h, Color(0,0,0,100))

                    local posx, posy = me:GetX() + frame:GetX(), me:GetY() + frame:GetY()

                    if not target.GetAttachment then return end
                    local attachment = target:GetAttachment(head)
                    if not attachment or not attachment.Pos or not attachment.Ang then
                        return
                    end

                    if w <= 0 or h <= 0 then return end

                    local old = DisableClipping( true )

                    render.RenderView({
                        origin = attachment.Pos,
                        angles = attachment.Ang,
                        x = posx, y = posy,
                        w = w, h = h,
                        fov = 125,
                        drawviewmodel = false,
                        drawhud = true,
                    })

                    DisableClipping( old )

                    shouldDrawPlayer = false

                    local time = os.date("%Y-%m-%d %H:%M:%S")
                    draw.SimpleText("CAM-0".. target_index .. " " .. time, "CameraFont", w * 0.97, h * 0.03, Color(255,255,255), TEXT_ALIGN_RIGHT, TEXT_ALIGN_RIGHT)
                    draw.SimpleText(GetName(target), "CameraFont", w * 0.97, h * 0.07, Color(255,255,255), TEXT_ALIGN_RIGHT, TEXT_ALIGN_RIGHT)

                    local dlight = DynamicLight(target:EntIndex())
                    if dlight and light then
                        dlight.pos = target:EyePos()
                        dlight.r, dlight.g, dlight.b = 0, 10, 0
                        dlight.brightness = 5
                        dlight.Decay = 1000
                        dlight.Size = 10000
                        dlight.DieTime = CurTime() + 0.1
                        dlight.noworld = false
                    end

                end

                local nightBtn = vgui.Create("DButton", render_vi)
                nightBtn:SetText("")
                nightBtn:SetPos(render_vi:GetWide() * 0.93, render_vi:GetTall() * 0.9)
                nightBtn:SetSize(render_vi:GetWide() * 0.06, render_vi:GetTall() * 0.1)
                nightBtn:SetZPos(100)

                    local nightIcon = Material("materials/vgui/night.png")
                    nightBtn.Paint = function(me, w, h)
                        local col = me:IsHovered() and Color(39, 57, 138) or Color(255,255,255)
                        surface.SetMaterial(nightIcon)
                        surface.SetDrawColor(light and Color(0,0,0) or col)
                        surface.DrawTexturedRect(10, 10, w - 20, h - 20)
                    end
                    nightBtn.DoClick = function() light = not light end
                    
                local voiceBtn = vgui.Create("DButton", render_vi)
                voiceBtn:SetText("")
                voiceBtn:SetPos(render_vi:GetWide() * 0.87, render_vi:GetTall() * 0.9)
                voiceBtn:SetSize(render_vi:GetWide() * 0.06, render_vi:GetTall() * 0.1)
                voiceBtn:SetZPos(100)

                    local voice = true

                        local voicephicon = Material("materials/vgui/voice.png")
                        local voicephicon_muted = Material("materials/vgui/voice_muted.png")

                    voiceBtn.Paint = function(me, w, h)
                        surface.SetMaterial(voice and voicephicon or voicephicon_muted)
                        surface.SetDrawColor(voice and Color(255,255,255) or Color(237, 66, 69))
                        surface.DrawTexturedRect(10, 10, w - 20, h - 20)
                    end

                    voiceBtn.DoClick = function() 
                        voice = not voice
                        net.Start("Bodycam_Voice")
                            net.WriteBool(voice)
                        net.SendToServer()
                    end

                if not target:IsNPC() then
                    local microphBtn = vgui.Create("DButton", render_vi)
                    microphBtn:SetText("")
                    microphBtn:SetPos(render_vi:GetWide() * 0.81, render_vi:GetTall() * 0.9)
                    microphBtn:SetSize(render_vi:GetWide() * 0.06, render_vi:GetTall() * 0.1)
                    microphBtn:SetZPos(100)

                        local micro = false

                            local microphicon = Material("materials/vgui/microphone.png")
                            local microphicon_muted = Material("materials/vgui/microphone_muted.png")

                        microphBtn.Paint = function(me, w, h)
                            surface.SetMaterial(micro and microphicon or microphicon_muted)
                            surface.SetDrawColor(micro and Color(255,255,255) or Color(237, 66, 69))
                            surface.DrawTexturedRect(10, 10, w - 20, h - 20)
                        end

                        microphBtn.DoClick = function() 
                            micro = not micro
                            net.Start("Bodycam_Micro")
                                net.WriteBool(micro)
                            net.SendToServer()
                        end
                end

                local last_index = #target_tbl

                local function CreateArrowButton(dir, xPos, iconPath)
                    local btn = vgui.Create("DButton", render_vi)
                    btn:SetText("")
                    btn:SetPos(xPos, render_vi:GetTall() * 0.375)
                    btn:SetSize(render_vi:GetWide() * 0.1, render_vi:GetTall() * 0.25)
                    btn:SetZPos(100)

                    local icon = Material(iconPath)
                    btn.Paint = function(self, w, h)
                        surface.SetMaterial(icon)
                        surface.SetDrawColor(self:IsHovered() and Color(255, 255, 255) or Color(255, 255, 255, 50))
                        surface.DrawTexturedRect(10, 10, w - 20, h - 20)
                    end

                    btn.DoClick = function()
                        -- Zabezpieczenie dla aktualnej liczby celów
                        local current_max = table.Count(target_tbl or {})
                        if current_max > 0 then
                            target_index = math.Clamp(target_index + (dir == "right" and 1 or -1), 1, current_max)
                            frame:Remove()
                            timer.Simple(0.05, Dermas)
                        end
                    end
                end

                -- Twórz przyciski tylko jeśli są dostępne cele
                if last_index > 1 then
                    if target_index == 1 then
                        CreateArrowButton("right", render_vi:GetWide() * 0.92, "materials/vgui/rightarrow.png")
                    elseif target_index == last_index then
                        CreateArrowButton("left", -33, "materials/vgui/leftarrow.png")
                    else
                        CreateArrowButton("left", -33, "materials/vgui/leftarrow.png")
                        CreateArrowButton("right", render_vi:GetWide() * 0.92, "materials/vgui/rightarrow.png")
                    end
                end



            end

            local btn = vgui.Create("DButton", frame)
            btn:SetText("")
            btn:SetPos(frame:GetWide()*0.007, frame:GetTall()*0.01)
            btn:SetSize(frame:GetWide()*0.075, frame:GetTall()*0.12)
            btn:SetZPos(1)
            local turnIcon = Material("materials/vgui/icon_turn.png")
            btn.Paint = function(me, w, h)
                local col = me:IsHovered() and Color(255,0,0) or Color(255,255,255,100)
                surface.SetMaterial(turnIcon)
                surface.SetDrawColor(col)
                surface.DrawTexturedRect(10, 10, w - 20, h - 20)
            end
            btn.DoClick = function()
                net.Start("Frame_Remove")
                net.SendToServer()
                LocalPlayer():SetNWBool("BodycamTabletOpen", false)
            end


            local comp_name = vgui.Create( "DLabel", frame)
            comp_name:SetPos( 0,0 )
            comp_name:SetSize(frame:GetWide(),frame:GetTall())
            comp_name:SetText( "" )
            comp_name.Paint = function(me,w,h) 
                draw.SimpleText("Antke Inc. Version 1.7.10", "CameraFont", 10, h - 10, Color(200, 200, 200, 180), TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
            end

            
        end



    function SWEP:PostDrawViewModel(vm, ply, weapon)
        local bone = vm:LookupBone("jnt_root")
        if not bone then return end

        local opened = self:GetNWBool("PDAOpen")

        if opened and vm:GetCycle() > 0.9 then
            if not IsValid(frejmus.frame) then
                Dermas()

            end
        else
            if IsValid(frejmus.frame) then
                frejmus.frame:Remove()
            end
        end
    end

    function SWEP:PrimaryAttack() end
    function SWEP:SecondaryAttack() end
    function SWEP:Reload() end

    local model = ClientsideModel("models/almodels/items/actioncam.mdl")
    model:SetNoDraw(true)

    hook.Add("PostDrawOpaqueRenderables", "manual_model_draw_example", function()
        for _, ent in ipairs(ents.GetAll()) do
            if not IsValid(ent) then continue end
            if not ent:IsPlayer() and not ent:IsNPC() then continue end
            if ent:IsPlayer() and not ent:Alive() then continue end
            if ent == LocalPlayer() then continue end
            if not IsValid(ent:GetNWEntity("BodyCam")) then continue end

            local attach_id = ent:LookupBone("ValveBiped.Bip01_Spine2")
            if not attach_id then continue end

            local pos, ang = ent:GetBonePosition(attach_id)
            if not pos or not ang then continue end

            model:SetModelScale(0.8, 0)
            pos = pos + (ang:Right() * -9)
            ang:RotateAroundAxis(ang:Right(), -90)
            ang:RotateAroundAxis(ang:Up(), 90)

            model:SetPos(pos)
            model:SetAngles(ang)
            model:SetupBones()
            model:DrawModel()
        end
    end)
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_br_zombie.lua
================================================
AddCSLuaFile()

if CLIENT then
	SWEP.WepSelectIcon 	= surface.GetTextureID("breach/wep_zombie")
	SWEP.BounceWeaponIcon = false
end

SWEP.Author			= "Kanade"
SWEP.Contact		= "Look at this gamemode in workshop and search for creators"
SWEP.Purpose		= "Kill humens"
SWEP.Instructions	= "Click left to attack"
SWEP.Base			= "weapon_breach_basemelee"

SWEP.ViewModelFOV	= 75
SWEP.ViewModelFlip	= false
SWEP.HoldType		= "knife"
SWEP.ViewModel		= "models/weapons/v_zombiearms.mdl"
SWEP.WorldModel		= ""
SWEP.PrintName		= "Zombie"
SWEP.DrawCrosshair	= false
SWEP.Slot			= 0

SWEP.Spawnable			= false
SWEP.AdminOnly			= false
SWEP.ISSCP				= true

SWEP.droppable				= false
SWEP.Primary.Automatic		= false
SWEP.Primary.NextAttack		= 0.25
SWEP.Primary.AttackDelay	= 0.4
SWEP.Primary.Damage			= 26
SWEP.Primary.Force			= 3250
SWEP.Primary.AnimSpeed		= 2.8

SWEP.Secondary.Automatic	= true
SWEP.Secondary.NextAttack	= 0.7
SWEP.Secondary.AttackDelay	= 1.6
SWEP.Secondary.Damage		= 82
SWEP.Secondary.Force		= 6000
SWEP.Secondary.AnimSpeed	= 2.4

SWEP.Range					= 100

SWEP.UseHands				= false
SWEP.DrawCustomCrosshair	= true
SWEP.DeploySpeed			= 1
SWEP.AttackTeams			= {2,3,5,6} // Attack only humans
SWEP.AttackNPCs				= false

SWEP.ZombieWeapon			= true

SWEP.SoundMiss 			= "npc/zombie/claw_miss1.wav"
SWEP.SoundWallHit		= "npc/zombie/claw_strike1.wav"
SWEP.SoundFleshSmall	= "npc/zombie/claw_strike2.wav"
SWEP.SoundFleshLarge	= "npc/zombie/claw_strike3.wav"

function SWEP:SecondaryAttack()
	self:SetHoldType("knife")
	//if ( !self:CanSecondaryAttack() ) then return end
	//if not IsFirstTimePredicted() then return end
	if self:GetNextSecondaryFire() > CurTime() then return end
	self.Owner:GetViewModel():SetPlaybackRate( self.Secondary.AnimSpeed )
	self:SendWeaponAnim(ACT_VM_SECONDARYATTACK)
	self.Owner:DoAnimationEvent(ACT_GMOD_GESTURE_RANGE_ZOMBIE)
	timer.Create("AttackDelay" .. self.Owner:SteamID(), self.Secondary.NextAttack, 1, function()
		if IsValid(self) == false then return end
		self.AttackType = 2
		self:Stab(2, self.Range)
	end)
	self:SetNextPrimaryFire( CurTime() + self.Secondary.AttackDelay)
	self:SetNextSecondaryFire( CurTime() + self.Secondary.AttackDelay)
end



================================================
FILE: gamemodes/breach/entities/weapons/weapon_br_zombie_infect.lua
================================================
AddCSLuaFile()

if CLIENT then
	SWEP.WepSelectIcon 	= surface.GetTextureID("breach/wep_zombie")
	SWEP.BounceWeaponIcon = false
end

SWEP.Base			= "weapon_breach_basemelee"

SWEP.ViewModelFOV	= 75
SWEP.ViewModelFlip	= false
SWEP.HoldType		= "knife"
SWEP.ViewModel		= "models/weapons/v_zombiearms.mdl"
SWEP.WorldModel		= ""
SWEP.PrintName		= "Zombie"
SWEP.DrawCrosshair	= false
SWEP.Slot			= 0

SWEP.Spawnable			= false
SWEP.AdminOnly			= false
SWEP.ISSCP 				= true

SWEP.droppable				= false
SWEP.Primary.Automatic		= false
SWEP.Primary.NextAttack		= 0.25
SWEP.Primary.AttackDelay	= 0.4
SWEP.Primary.Damage			= 15
SWEP.Primary.Force			= 3250
SWEP.Primary.AnimSpeed		= 2.8

SWEP.Secondary.Automatic	= true
SWEP.Secondary.NextAttack	= 0.7
SWEP.Secondary.AttackDelay	= 1.6
SWEP.Secondary.Damage		= 15
SWEP.Secondary.Force		= 6000
SWEP.Secondary.AnimSpeed	= 2.4

SWEP.Range					= 100

SWEP.UseHands				= false
SWEP.DrawCustomCrosshair	= true
SWEP.DeploySpeed			= 1
SWEP.AttackTeams			= {2,3,5,6} // Attack only humans
SWEP.AttackNPCs				= false

SWEP.ZombieWeapon			= true

SWEP.SoundMiss 			= "npc/zombie/claw_miss1.wav"
SWEP.SoundWallHit		= "npc/zombie/claw_strike1.wav"
SWEP.SoundFleshSmall	= "npc/zombie/claw_strike2.wav"
SWEP.SoundFleshLarge	= "npc/zombie/claw_strike3.wav"

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().SCP_0082
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end
	self:SetHoldType(self.HoldType)
end

function SWEP:SecondaryAttack()
	//if not IsFirstTimePredicted() then return end
	if self:GetNextSecondaryFire() > CurTime() then return end
	self.Owner:GetViewModel():SetPlaybackRate( self.Secondary.AnimSpeed )
	self:SendWeaponAnim(ACT_VM_SECONDARYATTACK)
	self.Owner:DoAnimationEvent(ACT_GMOD_GESTURE_RANGE_ZOMBIE)
	timer.Create("AttackDelay" .. self.Owner:SteamID(), self.Secondary.NextAttack, 1, function()
		if IsValid(self) == false then return end
		self.AttackType = 2
		self:Stab(2, self.Range)
	end)
	self:SetNextPrimaryFire( CurTime() + self.Secondary.AttackDelay)
	self:SetNextSecondaryFire( CurTime() + self.Secondary.AttackDelay)
end

function SWEP:OnAttackedPlayer(attacktype, ply)
		if SERVER then
			if ply:GTeam() != TEAM_SCP and ply:GTeam() != TEAM_SPEC then
				if ply:Health() <= 18 then
					ply:SetSCP0082( 250, 190 )
				end
			end
		end
		if attacktype == 1 then
			self:EmitSound(self.SoundFleshSmall)
		else
			self:EmitSound(self.SoundFleshLarge)
		end
end



================================================
FILE: gamemodes/breach/entities/weapons/weapon_breach_basemelee.lua
================================================
AddCSLuaFile()

SWEP.Author			= "Kanade"
SWEP.Contact		= "Steam"
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.HoldType		= "knife"
SWEP.ViewModel		= "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel		= "models/weapons/w_knife_t.mdl"
SWEP.PrintName		= "Base Melee"
SWEP.DrawCrosshair	= false
SWEP.Slot			= 0
SWEP.Base			= "weapon_base"

SWEP.Spawnable			= false
SWEP.AdminOnly			= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= 0
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"
SWEP.Primary.NumShots		= 1
SWEP.Primary.Cone			= 0
SWEP.Primary.NextAttack		= 0.2
SWEP.Primary.AttackDelay	= 0.6
SWEP.Primary.Damage			= 35
SWEP.Primary.Force			= 3250
SWEP.Primary.AnimSpeed		= 1

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"
SWEP.Secondary.NumShots		= 1
SWEP.Secondary.Cone			= 0
SWEP.Secondary.NextAttack	= 0.2
SWEP.Secondary.AttackDelay	= 0.85
SWEP.Secondary.Damage		= 70
SWEP.Secondary.Force		= 6000
SWEP.Secondary.AnimSpeed	= 1

SWEP.AttackType				= 1
SWEP.Range					= 75

SWEP.UseHands				= true
SWEP.DrawCustomCrosshair	= true
SWEP.DeploySpeed			= 1
SWEP.AttackTeams			= {}
SWEP.AttackNPCs				= true

SWEP.ZombieWeapon			= false

SWEP.SoundDeploy		=  "weapons/knife/knife_deploy1.wav"
SWEP.SoundMiss 			=  "weapons/knife/knife_slash1.wav"
SWEP.SoundWallHit		=  "weapons/knife/knife_hitwall1.wav"
SWEP.SoundFleshSmall	=  "weapons/knife/knife_hit1.wav"
SWEP.SoundFleshLarge	=  "weapons/knife/knife_stab.wav"

function SWEP:Deploy()
	self.NeedtoAttack = false
	timer.Destroy("AttackDelay" .. self.Owner:SteamID())
	if self.SoundDeploy != nil then
		self:EmitSound(self.SoundDeploy)
	end
	return true
end

function SWEP:SetDeploySpeed( speed )
	self.m_WeaponDeploySpeed = tonumber( speed )
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
	self:SetDeploySpeed(self.DeploySpeed)
end

function SWEP:OnAttackedPlayer(attacktype, ply)
	if attacktype == 1 then
		//self:StabDamage(ent, self.Primary.Damage )
		self:EmitSound(self.SoundFleshSmall)
	else
		//self:StabDamage(ent, self.Secondary.Damage )
		self:EmitSound(self.SoundFleshLarge)
	end
end

function CanAttackTypes(typ)
	local types = {"prop_physics", "prop_dynamic", "func_breakable"}
	if types[typ] != nil then
		return true
	else
		return false
	end
end

function SWEP:Stab(atype, range)
	local tracedata = {}

	tracedata.start = self.Owner:GetShootPos()
	tracedata.endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 95
	tracedata.filter = self.Owner
	tracedata.mins = Vector( -12 , -12 , -12 )
	tracedata.maxs = Vector( 12 , 12 , 12 )

	if ( self.Owner:IsPlayer() ) then
		self.Owner:LagCompensation( true )
	end

	local tr = util.TraceHull( tracedata )

	if ( self.Owner:IsPlayer() ) then
		self.Owner:LagCompensation( false )
	end
	
	//local tr = self.Owner:GetEyeTrace()
	local ent = tr.Entity
	//print(ent)
	//if !IsValid(tr.Entity) then ent = nil end
	if (not ent or !IsValid(ent)) and !ent:IsWorld() then
		self:EmitSound(self.SoundMiss)
	elseif ent:IsWorld() then
		self:EmitSound(self.SoundWallHit)
		self:DoImpactEffect(tr)
		//print("wlr")
	else
		local damagetodeal = self.Primary.Damage
		if atype == 2 then
			damagetodeal = self.Secondary.Damage
		end
		local cattack = true
		if ent:IsNPC() or ent:IsPlayer() then
			if ent:IsPlayer() then
				if table.HasValue(self.AttackTeams, ent:GTeam()) then
					cattack = true
					self:OnAttackedPlayer(atype, ent)
				else
					cattack = false
					self:EmitSound(self.SoundFleshSmall)
				end
			end
		else
			self:EmitSound(self.SoundWallHit)
			self:DoImpactEffect(tr)
			/*
			local force = 3000
			if atype == 1 then
				force = self.Primary.Force
			else
				force = self.Secondary.Force
			end
			if IsValid(ent:GetPhysicsObject()) then
				local phys = ent:GetPhysicsObject( )
				local pushvec = tr.Normal * force
				local pushpos = tr.HitPos
				
				phys:ApplyForceOffset( pushvec, pushpos )
			end
			*/
		end
		if ent:IsPlayer() and (ent:GTeam() == TEAM_SPEC or (ent:GTeam() == TEAM_SCP and ent:GetNClass() != ROLES.ROLE_SCP035)) then return end
		if cattack	then
			local force = 3000
			if atype == 1 then
				force = self.Primary.Force
			else
				force = self.Secondary.Force
			end
			local dmg = DamageInfo()
			dmg:SetDamage(damagetodeal)
			dmg:SetAttacker(self.Owner)
			dmg:SetInflictor(self.Weapon or self)
			dmg:SetDamageForce(self.Owner:GetAimVector() * force)
			dmg:SetDamagePosition(self.Owner:GetPos())
			dmg:SetDamageType(DMG_CLUB)
			
			local spos = self.Owner:GetShootPos()
			local sdest = spos + (self.Owner:GetAimVector() * 70)
			local posdid = spos + (self.Owner:GetAimVector() * 3)
			posdid = tr.HitNormal
			ent:DispatchTraceAttack(dmg, tr, posdid)
		end
	end
end

function SWEP:StabDamage(entity, damage)
	local dmginfo = DamageInfo()
	dmginfo:SetDamage( damage )
	dmginfo:SetDamageType( DMG_SLASH )
	dmginfo:SetAttacker( self.Owner )
	dmginfo:SetInflictor( self )
	dmginfo:SetDamageForce( self.Owner:GetForward() )
	if SERVER then
		self.Owner:GetEyeTrace().Entity:TakeDamageInfo( dmginfo )
	end
end

local hits = 0
function SWEP:PrimaryAttack()
	if ( !self:CanPrimaryAttack() ) then return end
	//if not IsFirstTimePredicted() then return end
	timer.Destroy("AttackDelay" .. self.Owner:SteamID())
	self.Owner:GetViewModel():SetPlaybackRate( self.Primary.AnimSpeed )
	self:SendWeaponAnim(ACT_VM_HITCENTER)
	self.Owner:SetAnimation(PLAYER_ATTACK1)
	self.Owner:GetViewModel():SetPlaybackRate( self.Primary.AnimSpeed )
	self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
	timer.Create("AttackDelay" .. self.Owner:SteamID(), self.Primary.NextAttack, 1, function()
		if IsValid(self) == false then return end
		self.AttackType = 1
		self:Stab(1, self.Range)
	end)
	self:SetNextPrimaryFire( CurTime() + self.Primary.AttackDelay)
	self:SetNextSecondaryFire( CurTime() + self.Primary.AttackDelay)
end

function SWEP:SecondaryAttack()
	//if ( !self:CanSecondaryAttack() ) then return end
	//if not IsFirstTimePredicted() then return end
	if self:GetNextSecondaryFire() > CurTime() then return end
	self.Owner:GetViewModel():SetPlaybackRate( self.Secondary.AnimSpeed )
	self:SendWeaponAnim(ACT_VM_HITCENTER)
	self.Owner:SetAnimation(PLAYER_ATTACK1)
	self.Owner:GetViewModel():SetPlaybackRate( self.Secondary.AnimSpeed )
	self:SendWeaponAnim(ACT_VM_SECONDARYATTACK)
	timer.Create("AttackDelay" .. self.Owner:SteamID(), self.Secondary.NextAttack, 1, function()
		if IsValid(self) == false then return end
		self.AttackType = 2
		self:Stab(2, self.Range)
	end)
	self:SetNextPrimaryFire( CurTime() + self.Secondary.AttackDelay)
	self:SetNextSecondaryFire( CurTime() + self.Secondary.AttackDelay)
end

function SWEP:Reload()
end

function SWEP:Holster( wep )
	return true
end

function SWEP:Deploy()
	self:SetDeploySpeed(self.DeploySpeed)
	return true
end

function SWEP:ShootEffects()
	self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK ) 
	self.Owner:MuzzleFlash()
	self.Owner:SetAnimation( PLAYER_ATTACK1 )

end

function SWEP:CanPrimaryAttack()
	if self:GetNextPrimaryFire() > CurTime() then return false end
	self:SetNextPrimaryFire( CurTime() + self.Primary.NextAttack )
	return true

end

function SWEP:CanSecondaryAttack()
	if self:GetNextSecondaryFire() > CurTime() then return false end
	self:SetNextSecondaryFire( CurTime() + self.Secondary.NextAttack )
	return true

end

function SWEP:OnRemove()
	self:SetHoldType(self.HoldType)
end

function SWEP:OwnerChanged()
	
end

function SWEP:SetDeploySpeed( speed )
	self.m_WeaponDeploySpeed = tonumber( speed )
end

function SWEP:DoImpactEffect( tr, nDamageType )

	if ( tr.HitSky ) then return end

	local effectdata = EffectData()
	effectdata:SetOrigin( tr.HitPos + tr.HitNormal )
	effectdata:SetNormal( tr.HitNormal )
	util.Decal("ManhackCut", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal )

end




================================================
FILE: gamemodes/breach/entities/weapons/weapon_breach_syringe.lua
================================================
AddCSLuaFile()

SWEP.DrawAmmo = true
SWEP.DrawCrosshair = false
SWEP.ViewModelFOV = 60
SWEP.UseHands = true

SWEP.PrintName = "Medical Syringe"
SWEP.Slot = 5
SWEP.SlotPos = 2
SWEP.Author = "Darky (Modified for Breach)"
SWEP.Instructions = "LMB - Heal yourself/others (+15 HP + regen). RMB - Inject deadly poison (10 DMG + poison)"

-- Breach specific settings
SWEP.droppable = true
SWEP.teams = {2,3,5,6,7,8} -- Scientists, Class D, MTF, CI, GOC, but not SCP

SWEP.Spawnable = false
SWEP.AdminSpawnable = true
SWEP.Category = "Breach Medical"

SWEP.ViewModel = "models/weapons/darky_m/c_syringe_v2.mdl"
SWEP.WorldModel = "models/weapons/darky_m/w_syringe_v2.mdl"

SWEP.HealAmount = 15
SWEP.RegenAmount = 20
SWEP.InitialDamage = 10 -- Initial damage on injection
SWEP.PoisonDamage = 1   -- Damage per tick

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 1  -- Only 1 use total
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "Syringes"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.HoldType = "slam"

SWEP.Insert = 0
SWEP.IdleTimer = CurTime()
SWEP.InsertTimer = CurTime()

function SWEP:Initialize()
    self:SetWeaponHoldType(self.HoldType)
end

function SWEP:Deploy()
    self:SendWeaponAnim(ACT_VM_DRAW)
    self.IdleTimer = CurTime() + self:GetOwner():GetViewModel():SequenceDuration()
    return true
end

function SWEP:Holster()
    self.Insert = 0
    self.IdleTimer = CurTime()
    self.InsertTimer = CurTime()
    return true
end

function SWEP:PrimaryAttack()
    local Owner = self:GetOwner()
    if Owner:GetAmmoCount(self.Primary.Ammo) <= 0 then return end
    if self.Insert != 0 then return end

    Owner:DoAnimationEvent(ACT_HL2MP_GESTURE_RELOAD_PISTOL)
    if CLIENT then return end
    local CT = CurTime()

    self:SendWeaponAnim(ACT_VM_THROW)
    self.Insert = 1
    self.InsertTimer = CT + Owner:GetViewModel():SequenceDuration()
    self.SoundTimer = CT + 0.3
end

function SWEP:SecondaryAttack()
    local Owner = self:GetOwner()
    if Owner:GetAmmoCount(self.Primary.Ammo) <= 0 then return end
    if self.Insert != 0 then return end

    local Traced = self:CheckTrace()

    if IsValid(Traced) and Traced:IsPlayer() then
        -- Block Security Droid from being poisoned
        if Traced:GetNClass() == ROLES.ROLE_SECURITY_DROID then
            if SERVER then
                Owner:PrintMessage(HUD_PRINTTALK, "[SYRINGE] ERROR: Biological agents incompatible with android systems!")
                Owner:EmitSound("buttons/button10.wav", 50, 50)
            end
            return
        end

        -- RMB ONLY DAMAGES - inject deadly poison IMMEDIATELY!
        Owner:DoAnimationEvent(ACT_GMOD_GESTURE_MELEE_SHOVE_1HAND)
        if CLIENT then return end
        
        -- Poison immediately without waiting for animation
        self:Poison(Traced)
        
        -- Still play animation and sound
        self:SendWeaponAnim(ACT_VM_SECONDARYATTACK)
        Owner:EmitSound("npc/headcrab_poison/ph_hiss1.wav")
        
        self.IdleTimer = CurTime() + Owner:GetViewModel():SequenceDuration()
    end
end

function SWEP:CheckTrace()
    local Owner = self:GetOwner()
    Owner:LagCompensation(true)

    local Trace = util.TraceLine({
        start = Owner:GetShootPos(),
        endpos = Owner:GetShootPos() + Owner:GetAimVector() * 64,
        filter = Owner
    })

    Owner:LagCompensation(false)

    return Trace.Entity
end

function SWEP:Heal(target)
    local Owner = self:GetOwner()
    self.Insert = 0
    self.IdleTimer = CurTime()
    Owner:RemoveAmmo(1, self.Primary.Ammo)
    target:SetHealth(math.min(target:GetMaxHealth(), target:Health() + self.HealAmount))

    target.DHPRegen = (target.DHPRegen and target.DHPRegen or 0) + self.RegenAmount
    target.LastDHPRegen = CurTime()
    if not DHPRegenList then DHPRegenList = {} end
    DHPRegenList[target] = true

    if IsValid(target) and target:IsPlayer() then
        target:PrintMessage(HUD_PRINTTALK, "[MEDICAL] You received healing injection (+15 HP + regen)")
    end

    if Owner:GetAmmoCount(self.Primary.Ammo) <= 0 then
        Owner:StripWeapon("weapon_breach_syringe")
    end
end

function SWEP:Poison(target)
    local Owner = self:GetOwner()
    self.Insert = 0
    self.IdleTimer = CurTime()
    Owner:RemoveAmmo(1, self.Primary.Ammo)
    
    -- Initial damage
    local dmginfo = DamageInfo()
    dmginfo:SetDamage(self.InitialDamage)
    dmginfo:SetAttacker(Owner)
    dmginfo:SetInflictor(self)
    dmginfo:SetDamageType(DMG_DIRECT)
    
    target:TakeDamageInfo(dmginfo)

    -- Apply poison effect
    if not SyringePoisonList then SyringePoisonList = {} end
    target.SyringePoison = true
    target.SyringePoisonNext = CurTime() + 2 -- First tick in 2 seconds
    target.SyringePoisonAttacker = Owner
    SyringePoisonList[target] = true

    if IsValid(target) and target:IsPlayer() then
        target:PrintMessage(HUD_PRINTTALK, "[POISON] You were injected with deadly poison! (-10 HP + poison effect)")
    end
    
    if IsValid(Owner) and Owner:IsPlayer() then
        Owner:PrintMessage(HUD_PRINTTALK, "[SYRINGE] Deadly poison injected into " .. target:Nick())
    end

    if Owner:GetAmmoCount(self.Primary.Ammo) <= 0 then
        Owner:StripWeapon("weapon_breach_syringe")
    end
end

function SWEP:CancelHeal()
    self.Insert = 0
    self.IdleTimer = CurTime()
end

function SWEP:Think()
    local CT = CurTime()
    local Owner = self:GetOwner()

    if self.IdleTimer <= CT then
        self:IdleAnimation()
    end

    if CLIENT then return end

    if self.SoundTimer and self.SoundTimer <= CT then
        if self.Insert == 1 then
            Owner:EmitSound("items/medshot4.wav")  -- Heal sound
            self.SoundTimer = nil
        end
    end

    if self.Insert == 1 and self.InsertTimer <= CT then
        self:Heal(Owner)
    end
end

function SWEP:IdleAnimation()
    if SERVER and self.Insert == 0 then
        self:SendWeaponAnim(ACT_VM_IDLE)
        self.IdleTimer = CurTime() + self:GetOwner():GetViewModel():SequenceDuration()
    end
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_broom.lua
================================================
AddCSLuaFile()

if SERVER then
	util.AddNetworkString( "BreachBroomSweep" )
	util.AddNetworkString( "BreachBroomCleanEXP" )
	
	-- Handle EXP for cleaning
	net.Receive("BreachBroomCleanEXP", function(len, ply)
		if not IsValid(ply) or not ply:Alive() then return end
		if not ply:HasWeapon("weapon_broom") then return end
		
		-- Give EXP for cleaning
		if ply.AddExp then
			ply:AddExp(1) -- 1 EXP per cleaning action
		end
	end)
else -- CLIENT
	net.Receive("BreachBroomSweep",function()
		local ply = LocalPlayer()
		local wep = ply:GetActiveWeapon()
		if IsValid( wep ) and wep:GetClass() == "weapon_broom" then
			wep:PrimaryAttack(true)
		end
	end)
end

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("breach/wep_broom")
	SWEP.BounceWeaponIcon = false
end

SWEP.Base = "weapon_base"
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.PrintName = "Broom"
SWEP.Author = "Breach Team"
SWEP.Instructions = "Hold left click to sweep decals and clean the facility."
SWEP.ViewModel = "models/props_c17/pushbroom.mdl"
SWEP.WorldModel = "models/props_c17/pushbroom.mdl"
SWEP.HoldType = "passive"

SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Secondary.Ammo = "none"

SWEP.Slot = 0
SWEP.SlotPos = 6

-- Breach gamemode integration
SWEP.droppable = true
SWEP.teams = {TEAM_SCI}

SWEP.ViewModelDefPos = Vector(2,25,30) -- viewmodel
SWEP.ViewModelDefAng = Vector(22,12,140)
SWEP.MoveToPos = Vector(2,25,30)
SWEP.MoveToAng = Vector(45,20,150)

SWEP.Pos = Vector(-3,-3,3) -- worldmodel
SWEP.Ang = Angle(70, 180, 0)

CreateConVar("broom_clearamount", 2, FCVAR_ARCHIVE, "The amount of decals to wipe for Breach Broom SWEP" )

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
	self:SetWeaponHoldType(self.HoldType)
	
	self.mul = 1
	self.sweepmul = 0.1
	self.sweep = false
	self.raise = false
	self.flip = false
end

function SWEP:PrimaryAttack(bool)
	if math.sin(CurTime()*5) > math.Rand(0.5,0.7) or bool then

		if SERVER then
			net.Start( "BreachBroomSweep" )
			net.Send( self.Owner )
		end
	
		local tr = self.Owner:GetEyeTrace()
		if self:GetOwner():GetPos():Distance(tr.HitPos) > 100 then return end
		
		-- Check if we hit a player for damage
		if SERVER and IsValid(tr.Entity) and tr.Entity:IsPlayer() then
			local dmginfo = DamageInfo()
			dmginfo:SetDamage(1)
			dmginfo:SetAttacker(self.Owner)
			dmginfo:SetInflictor(self)
			dmginfo:SetDamageType(DMG_CLUB)
			dmginfo:SetDamageForce(self.Owner:GetAimVector() * 100)
			tr.Entity:TakeDamageInfo(dmginfo)
		end
		
		if CLIENT then
			-- Check if there are decals to clean (for EXP)
			local decalsFound = false
			local decalTrace = util.TraceLine({
				start = tr.HitPos + tr.HitNormal * 5,
				endpos = tr.HitPos - tr.HitNormal * 5,
				filter = self.Owner
			})
			
			-- Simple check if there might be decals (not perfect but works)
			if decalTrace.Hit then
				decalsFound = true
			end
			
			util.RemoveDecalsAt( tr.HitPos, 16, GetConVar("broom_clearamount"):GetInt(), false)
		
			if self.sweep ~= true then
				self.mul = self.mul - 0.5
				self.sweep = true
			else
				self.mul = self.mul + 0.5
				self.sweep = false
			end
			
			-- Send to server that we cleaned something (for EXP)
			if decalsFound then
				net.Start("BreachBroomCleanEXP")
				net.SendToServer()
			end
		end

		if IsValid(tr.Entity) then
			tr.Entity:RemoveAllDecals()
		end
		
		local info = EffectData();
		info:SetNormal( tr.HitNormal );
		for i=0, 4 do
			info:SetOrigin( tr.HitPos + VectorRand()*10 )
			info:SetScale(math.random( 0.01, 0.5))
			util.Effect( "WheelDust", info );
		end
		
		for k, v in pairs(ents.FindInSphere(tr.HitPos,math.random(45,64))) do 
			local phys = v:GetPhysicsObject()
			if IsValid(phys) then
				phys:ApplyForceCenter(self.Owner:GetForward()*math.random(20,50)*10)
			end
		end
	end
	self:SetNextPrimaryFire( CurTime() + 0.7 )
end

function SWEP:SecondaryAttack()
	-- No secondary attack
end

function SWEP:Deploy()
	self.mul = 0.7
	self.sweepmul = 0.1
	self.sweep = false
	self.raise = true
	
	self:SetNextPrimaryFire( CurTime() + 1 )
	self:SetNextSecondaryFire( CurTime() + 1 )
	return true
end

function SWEP:GetViewModelPosition(pos, ang)
	local vel = math.Clamp(self.Owner:GetVelocity():Length()/500000,0,100)
	
	if self.flip == true then
		if self.raise == true then
			self.mul = self.mul + 0.01*math.Rand(0.1,1)+vel
		else
			self.mul = self.mul + 0.000005*math.Rand(0.1,1)+vel
		end
		
		if self.mul > 1.05 then
			self.flip = false
			self.raise = false
		end
	else
		self.mul = self.mul - 0.000005*math.Rand(0.1,1)-vel
		if self.mul < 1 then
			self.flip = true
		end
	end
    
    --this is always applied
    local DefPos = self.ViewModelDefPos
    local DefAng = self.ViewModelDefAng
    
    if DefAng then
        ang = ang * 1
        ang:RotateAroundAxis (ang:Right(),         DefAng.x)
        ang:RotateAroundAxis (ang:Up(),         DefAng.y)
        ang:RotateAroundAxis (ang:Forward(),     DefAng.z)
    end

    if DefPos then
        local Right     = ang:Right()
        local Up         = ang:Up()
        local Forward     = ang:Forward()
    
        pos = pos + DefPos.x * Right
        pos = pos + DefPos.y * Forward
        pos = pos + DefPos.z * Up
    end
    
    --and some more
    local AddPos = self.MoveToPos - self.ViewModelDefPos
    local AddAng = self.MoveToAng - self.ViewModelDefAng
    
    if AddAng then
        ang = ang * 1
        ang:RotateAroundAxis (ang:Right(),         AddAng.x * self.mul)
        ang:RotateAroundAxis (ang:Up(),         AddAng.y * self.mul)
        ang:RotateAroundAxis (ang:Forward(),     AddAng.z * self.mul)
    end

    if AddPos then
        local Right     = ang:Right()
        local Up         = ang:Up()
        local Forward     = ang:Forward()
    
        pos = pos + AddPos.x * Right * self.mul
        pos = pos + AddPos.y * Forward * self.mul
        pos = pos + AddPos.z * Up * self.mul
    end
    
    return pos, ang
end

function SWEP:CreateWorldModel()
	if !self.WModel then
		self.WModel = ClientsideModel(self.WorldModel, RENDERGROUP_OPAQUE)
		self.WModel:SetNoDraw(true)
		self.WModel:SetBodygroup(1, 1)
	end
	return self.WModel
end

function SWEP:DrawWorldModel()
	local wm = self:CreateWorldModel()
	if self.Owner != NULL then
		local bone = self.Owner:LookupBone("ValveBiped.Bip01_L_Hand")
		local pos, ang = self.Owner:GetBonePosition(bone)
			
		if bone then
			ang:RotateAroundAxis(ang:Right(), self.Ang.p)
			ang:RotateAroundAxis(ang:Forward(), self.Ang.y)
			ang:RotateAroundAxis(ang:Up(), self.Ang.r)
			wm:SetRenderOrigin(pos + ang:Right() * self.Pos.x + ang:Forward() * self.Pos.y + ang:Up() * self.Pos.z)
			wm:SetRenderAngles(ang)
			wm:DrawModel()
			wm:SetModelScale( 0.8, 0 )
		end
	else
		wm:DrawModel()
	end
end

-- Dodaj do systemu językowego
if CLIENT then
	local function AddBroomLanguage()
		if LANG and LANG.english then
			LANG.english.WEAPON_BROOM = {
				name = "Broom",
				desc = "A janitor's trusty broom for cleaning the facility"
			}
		end
	end
	
	hook.Add("InitPostEntity", "BroomLanguage", AddBroomLanguage)
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_doner_ayran.lua
================================================
AddCSLuaFile()
local isdarkrp
if string.lower(engine.ActiveGamemode()) == "darkrp" then
isdarkrp = true
else
isdarkrp = false
end




SWEP.PrintName			="Kebab + Ayran"
SWEP.Author			= "elt @ kralking067" 
SWEP.Instructions		= ""
SWEP.Spawnable = false
SWEP.Category = "Breach Food"

-- Breach specific settings
SWEP.droppable = true
SWEP.teams = {1,2,3,4,5,6,7,8,9,10} -- All teams can use food

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		= "none"

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.Slot = 3
SWEP.ViewModel = "models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/doner_makinesi/ekmek.mdl"
SWEP.ShowViewModel = false
SWEP.ShowWorldModel = true
SWEP.ViewModelBoneMods = {
	["ValveBiped.Grenade_body"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["doner"] = { type = "Model", model = "models/doner_makinesi/ekmek.mdl", bone = "ValveBiped.Grenade_body", rel = "", pos = Vector(0.4, -0.091, 0.704), angle = Angle(-115.709, 62.819, 8.619), size = Vector(0.356, 0.356, 0.356), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["ayran"] = { type = "Model", model = "models/doner_makinesi/ayran.mdl", bone = "ValveBiped.Bip01_L_Hand", rel = "", pos = Vector(4.129, 2.647, 0.716), angle = Angle(0, 0, 0), size = Vector(0.46, 0.46, 0.569), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["doner"] = { type = "Model", model = "models/doner_makinesi/ekmek.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.154, 4.392, 0), angle = Angle(-57.424, 61.395, 21.7), size = Vector(0.4285, 0.4285, 0.4285), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["ayran"] = { type = "Model", model = "models/doner_makinesi/ayran.mdl", bone = "ValveBiped.Bip01_L_Hand", rel = "", pos = Vector(3.93, 1.861, 1.236), angle = Angle(0, 0, 0), size = Vector(0.465, 0.465, 0.56), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

hook.Add( "PlayerCanPickupWeapon", "noDoublePickup", function( ply, wep )
	if ply:HasWeapon("doner_ayran") and wep:GetClass() == "doner_ayran" then return false end
end )




local function AddHealth(v,ply)
	
	if ply:Health()+v > ply:GetMaxHealth() then
		ply:SetHealth(ply:GetMaxHealth())
	else
		ply:SetHealth(ply:Health()+v)
	end
	
	
	
end

local function AddHunger(v,ply)

local hung =  ply.DarkRPVars.energy or  ply.DarkRPVars.Energy
if hung == nil then

AddHealth(v,ply)
return
end
	if hung == 100 then
		AddHealth(v,ply)
	elseif hung + v < 100 then
		ply:setDarkRPVar("Energy",hung+v)
	else
		AddHealth(v-(100-hung),ply) 
	    ply:setDarkRPVar("Energy",hung+(100-hung))
	end
	
end

local eat = Sound("kebab/kebab_eat.mp3")

function SWEP:PrimaryAttack()

local ply = self.Owner




 
self.att = true

	ply:ManipulateBoneAngles( ply:LookupBone("ValveBiped.Bip01_R_Forearm"), Angle(-10,-20,0) )
	ply:ManipulateBoneAngles( ply:LookupBone("ValveBiped.Bip01_R_UpperArm"), Angle(-10,-55,0) )
	ply:ManipulateBoneAngles( ply:LookupBone("ValveBiped.Bip01_R_Hand"), Angle(20,0,0) )

self.Weapon:EmitSound(eat)
timer.Simple(3,function()
	if IsValid(self) and self.att	then
		self:SetHoldType("slam")
		self.att = false
	
			ply:ManipulateBoneAngles( ply:LookupBone("ValveBiped.Bip01_R_Forearm"), Angle(0,0,0) )
			ply:ManipulateBoneAngles( ply:LookupBone("ValveBiped.Bip01_R_UpperArm"), Angle(0,0,0) )
			ply:ManipulateBoneAngles( ply:LookupBone("ValveBiped.Bip01_R_Hand"), Angle(0,0,0) )
	
	
	
		if SERVER then
		
			if isdarkrp then
				AddHunger(self.heal,self.Owner)
			else
				AddHealth(self.heal,self.Owner)
			end
		
		
		
		
	    self.Owner:Give("doner_ayran_ayran")
		
		self.Owner:SelectWeapon( "doner_ayran_ayran")
		self.Owner:StripWeapon(self:GetClass())
		end
		
	
	end
end)



self:SetNextPrimaryFire(CurTime()+3.1) 
end 
 
 local t = 0
function SWEP:CalcViewModelView( vm, oldPos, oldAng,pos, ang )

if self.att then
t = t+0.02

	
	if t > 1 then
		t = 1
	end
		
elseif t >0 then
t = t-0.02
end
 
return  pos+LerpVector(t,Vector(0,0,0),-vm:GetForward()*20) , oldAng + LerpAngle(t,Angle(0,0,0),Angle(0,31,0))



end 
 
 

function SWEP:SecondaryAttack()
	--self.Owner:ManipulateBoneAngles( self.Owner:LookupBone("ValveBiped.Bip01_R_Forearm"), Angle(0,0,0) )
end



function SWEP:Deploy()
self:SendWeaponAnim(ACT_VM_DRAW)
	self.ShowWorldModel = false;
	self:SetHoldType("slam")
end


function SWEP:Initialize()
	if IsValid(self.Owner) then
		self.ShowWorldModel = false;
	end
	

	// other initialize code goes here
	self.heal = 30
	self.att = false
	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

function SWEP:Holster()
	

	
	if CLIENT and IsValid(self.Owner) then
	
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone("ValveBiped.Bip01_R_Forearm"), Angle(0,0,0) )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone("ValveBiped.Bip01_R_UpperArm"), Angle(0,0,0) )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone("ValveBiped.Bip01_R_Hand"), Angle(0,0,0) )
	
	
	
	
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	
	end

	self:StopSound("kebab/kebab_eat.mp3")
		self.att = false
		
			
	
		
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end




================================================
FILE: gamemodes/breach/entities/weapons/weapon_doner_ayran_ayran.lua
================================================
AddCSLuaFile()


local isdarkrp
if string.lower(engine.ActiveGamemode()) == "darkrp" then
isdarkrp = true
else
isdarkrp = false
end


SWEP.PrintName			="Ayran"
SWEP.Author			= "elt @ kralking067" 
SWEP.Instructions		= ""
SWEP.Spawnable = false
SWEP.Category = "Breach Food"

-- Breach specific settings
SWEP.droppable = true
SWEP.teams = {1,2,3,4,5,6,7,8,9,10} -- All teams can use food

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		= "none"

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.Slot = 3
SWEP.ViewModel = "models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/doner_makinesi/ayran.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true
SWEP.ViewModelBoneMods = {
	["ValveBiped.Grenade_body"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["ayran"] = { type = "Model", model = "models/doner_makinesi/ayran.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.955, 1.881, 0), angle = Angle(180, 15.619, 15.973), size = Vector(0.46, 0.46, 0.569), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["ayran"] = { type = "Model", model = "models/doner_makinesi/ayran.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.296, 2.801, 0), angle = Angle(-163.941, 0, 0),size = Vector(0.465, 0.465, 0.56), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}






local function AddHealth(v,ply)
	
	if ply:Health()+v > ply:GetMaxHealth() then
		ply:SetHealth(ply:GetMaxHealth())
	else
		ply:SetHealth(ply:Health()+v)
	end
	
	
	
end

local function AddHunger(v,ply)

local hung =  ply.DarkRPVars.energy or  ply.DarkRPVars.Energy
if hung == nil then

AddHealth(v,ply)
return
end
	if hung == 100 then
		AddHealth(v,ply)
	elseif hung + v < 100 then
		ply:setDarkRPVar("Energy",hung+v)
	else
		AddHealth(v-(100-hung),ply) 
	    ply:setDarkRPVar("Energy",hung+(100-hung))
	end
	
end

function SWEP:PrimaryAttack()

local ply = self.Owner

self.att = true

	ply:ManipulateBoneAngles( ply:LookupBone("ValveBiped.Bip01_R_Forearm"), Angle(-10,-20,0) )
	ply:ManipulateBoneAngles( ply:LookupBone("ValveBiped.Bip01_R_UpperArm"), Angle(-10,-55,0) )
	ply:ManipulateBoneAngles( ply:LookupBone("ValveBiped.Bip01_R_Hand"), Angle(20,0,0) )


timer.Simple(3,function()
	if IsValid(self) and self.att then
		self:SetHoldType("slam")
		self.att = false
		
			
			ply:ManipulateBoneAngles( ply:LookupBone("ValveBiped.Bip01_R_Forearm"), Angle(0,0,0) )
			ply:ManipulateBoneAngles( ply:LookupBone("ValveBiped.Bip01_R_UpperArm"), Angle(0,0,0) )
			ply:ManipulateBoneAngles( ply:LookupBone("ValveBiped.Bip01_R_Hand"), Angle(0,0,0) )
	
		
		
		
		if SERVER then
		
			if isdarkrp then
				AddHunger(self.heal,self.Owner)
			else
				AddHealth(self.heal,self.Owner)
			end
		
		
		
		self.Owner:StripWeapon(self:GetClass())
		end
	end
end)

self:SetNextPrimaryFire(CurTime()+3.1) 
end 
 
 local t = 0
function SWEP:CalcViewModelView( vm, oldPos, oldAng,pos, ang )

if self.att then
t = t+0.02

	
	if t > 1 then
		t = 1
	end
		
elseif t >0 then
t = t-0.02
end
 
return  pos+LerpVector(t,Vector(0,0,0),-vm:GetForward()*20) , oldAng + LerpAngle(t,Angle(0,0,0),Angle(0,31,0))



end 
 
 
 

function SWEP:SecondaryAttack()

end



function SWEP:Deploy()
self:SendWeaponAnim(ACT_VM_DRAW)
	self.ShowWorldModel = false;
	self:SetHoldType("slam")
end


function SWEP:Initialize()

	if IsValid(self.Owner) then
		self.ShowWorldModel = false;
	end


	// other initialize code goes here
	self.heal = 15
	self.att = false
	if CLIENT then
		

		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

function SWEP:Holster()
	

	
	
	if CLIENT and IsValid(self.Owner) then
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone("ValveBiped.Bip01_R_Forearm"), Angle(0,0,0) )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone("ValveBiped.Bip01_R_UpperArm"), Angle(0,0,0) )
			self.Owner:ManipulateBoneAngles(self.Owner:LookupBone("ValveBiped.Bip01_R_Hand"), Angle(0,0,0) )
	
	
	
	
	
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
			
	end
	
		
	
	
	
self.att = false
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end




================================================
FILE: gamemodes/breach/entities/weapons/weapon_doner_knife.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_base"
SWEP.PrintName = "Döner Kebab Knife"
SWEP.Instructions = [[Professional chef's knife used for cutting döner kebab.
Sharp blade excellent for food preparation and self-defense.

LMB - Light cut (15-20 dmg)
RMB - Heavy stab (45 dmg, 80 backstab)
R - Inspect]]

SWEP.Spawnable = false
SWEP.AdminSpawnable = true

-- Breach specific settings
SWEP.droppable = true
SWEP.teams = {2,3,5,6,7} -- Scientists, Class D, MTF, etc

SWEP.ViewModel = "models/weapons/v_donerkebabknife.mdl"
SWEP.WorldModel = "models/weapons/w_donerkebabknife.mdl"
SWEP.ViewModelFOV = 77
SWEP.UseHands = false

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.Weight = 2
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.Slot = 1
SWEP.SlotPos = 3
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true

-- Animation sequences
SWEP.StabAnim = "stab"
SWEP.SlashAnim = "midslash1"
SWEP.InspectAnim = "inspect"
SWEP.DrawAnim = "draw"

-- Attack settings (balanced for gamemode)
SWEP.Distance = 80
SWEP.LightDamageMin = 15
SWEP.LightDamageMax = 20
SWEP.HeavyDamage = 45
SWEP.BackstabDamage = 80 -- reduced from 195

SWEP.Lang = nil

function SWEP:Initialize()
    if CLIENT then
        self.Lang = GetWeaponLang().DONER_KNIFE
        if self.Lang then
            self.Author = self.Lang.author
            self.Contact = self.Lang.contact
            self.Purpose = self.Lang.purpose
            self.Instructions = self.Lang.instructions
        end
    end
    self:SetHoldType("knife")
    self.AnimCD = 0
end

function SWEP:Deploy()
    self:PlayAnim(self.DrawAnim)
    timer.Simple(0.45, function()
        if IsValid(self) then
            self:EmitSound("Weapon_Knife.Deploy")
        end
    end)
	return true
end

function SWEP:PrimaryAttack()
    if self.AnimCD > CurTime() then return end
    
    local attackCD = self:PlayAnim(self.SlashAnim) - 0.2
    self.AnimCD = CurTime() + attackCD
    self:SetNextPrimaryFire(CurTime() + attackCD)
    self:SetNextSecondaryFire(CurTime() + attackCD)
    
    self:GetOwner():SetAnimation(PLAYER_ATTACK1)
    
    timer.Simple(0.1, function()
        if IsValid(self) then
            local damage = math.random(self.LightDamageMin, self.LightDamageMax)
            self:SendDamage(damage, DMG_SLASH)
        end
    end)
end

function SWEP:SecondaryAttack()
    if self.AnimCD > CurTime() then return end
    
    local attackCD = self:PlayAnim(self.StabAnim) - 0.2
    self.AnimCD = CurTime() + attackCD
    self:SetNextPrimaryFire(CurTime() + attackCD)
    self:SetNextSecondaryFire(CurTime() + attackCD)
    
    self:GetOwner():SetAnimation(PLAYER_ATTACK1)
    
    timer.Simple(0.1, function()
        if IsValid(self) then
            self:SendHeavyDamage()
        end
    end)
end

function SWEP:Reload()
    if self.AnimCD > CurTime() then return end
    
    local cd = self:PlayAnim(self.InspectAnim)
    self.AnimCD = CurTime() + cd
end

function SWEP:EntityFaceBack(ent)
    if not IsValid(ent) then return false end
    if not ent:IsPlayer() then return false end
    
    local angle = self:GetOwner():GetAngles().y - ent:GetAngles().y
    if angle < -180 then angle = 360 + angle end
    if angle > 180 then angle = angle - 360 end
    return math.abs(angle) <= 90
end

function SWEP:IsSoftEnt(ent)
    return ent:GetMaterialType() == MAT_FLESH
end

function SWEP:SendDamage(dmg, dmgType)
    local owner = self:GetOwner()
    if not IsValid(owner) then return end
    
    owner:LagCompensation(true)
    
    local trace = owner:GetEyeTrace()
    local hitPos = trace.HitPos
    local attackPos = owner:GetShootPos()
    local distance = hitPos:Distance(attackPos)
    
    if distance <= self.Distance then
        local ent = trace.Entity
        
        if IsValid(ent) and ent.TakeDamageInfo then
            local dmginfo = DamageInfo()
            dmginfo:SetDamage(dmg)
            dmginfo:SetAttacker(owner)
            dmginfo:SetInflictor(self)
            dmginfo:SetDamageType(dmgType or DMG_SLASH)
            dmginfo:SetDamageForce(owner:GetAimVector() * 200)
            dmginfo:SetDamagePosition(hitPos)
            
            ent:TakeDamageInfo(dmginfo)
            
            if SERVER then
                if self:IsSoftEnt(ent) or ent:IsNPC() or ent:IsPlayer() or ent:IsRagdoll() then
                    owner:EmitSound("Weapon_Knife.Hit", 65, math.random(90, 110))
                else
                    owner:EmitSound("Weapon_Knife.HitWall", 65, math.random(90, 110))
                end
            end
		end
	else
        if SERVER then
            owner:EmitSound("Weapon_Knife.Slash", 65, math.random(90, 110))
	end
end

    owner:LagCompensation(false)
end

function SWEP:SendHeavyDamage()
    local owner = self:GetOwner()
    if not IsValid(owner) then return end
    
    owner:LagCompensation(true)
    
    local trace = owner:GetEyeTrace()
    local hitPos = trace.HitPos
    local attackPos = owner:GetShootPos()
    local distance = hitPos:Distance(attackPos)
    
    if distance <= self.Distance then
        local ent = trace.Entity
        
        if IsValid(ent) and ent.TakeDamageInfo then
            local damage = self.HeavyDamage
            
            -- Check for backstab bonus
            if ent:IsPlayer() and self:EntityFaceBack(ent) then
                damage = self.BackstabDamage
            end
            
            local dmginfo = DamageInfo()
            dmginfo:SetDamage(damage)
            dmginfo:SetAttacker(owner)
            dmginfo:SetInflictor(self)
            dmginfo:SetDamageType(DMG_SLASH)
            dmginfo:SetDamageForce(owner:GetAimVector() * 300)
            dmginfo:SetDamagePosition(hitPos)
            
            ent:TakeDamageInfo(dmginfo)
            
            if SERVER then
                if self:IsSoftEnt(ent) or ent:IsNPC() or ent:IsPlayer() or ent:IsRagdoll() then
                    owner:EmitSound("Weapon_Knife.Stab", 65, math.random(90, 110))
                else
                    owner:EmitSound("Weapon_Knife.HitWall", 65, math.random(90, 110))
                end
            end
        end
    else
        if SERVER then
            owner:EmitSound("Weapon_Knife.Slash", 65, math.random(90, 110))
        end
    end
    
    owner:LagCompensation(false)
end

function SWEP:PlayAnim(seqName)
    local vm = self:GetOwner():GetViewModel()
    if not IsValid(vm) then return 0 end
    
    -- Try to find sequence by name, fallback to basic animations
    local seq = vm:LookupSequence(seqName)
    if seq == -1 then
        -- Fallback animations
        if seqName == self.StabAnim then
            seq = vm:LookupSequence("stab") or ACT_VM_HITCENTER
        elseif seqName == self.SlashAnim then
            seq = vm:LookupSequence("slash") or ACT_VM_MISSCENTER
        elseif seqName == self.InspectAnim then
            seq = vm:LookupSequence("inspect") or ACT_VM_IDLE
        elseif seqName == self.DrawAnim then
            seq = vm:LookupSequence("draw") or ACT_VM_DRAW
        end
    end
    
    if seq and seq > -1 then
        vm:SendViewModelMatchingSequence(seq)
        return vm:SequenceDuration(seq)
    else
        -- Final fallback to basic weapon anims
        if seqName == self.StabAnim then
            self:SendWeaponAnim(ACT_VM_HITCENTER)
        elseif seqName == self.SlashAnim then
            self:SendWeaponAnim(ACT_VM_MISSCENTER)
        elseif seqName == self.DrawAnim then
            self:SendWeaponAnim(ACT_VM_DRAW)
        else
            self:SendWeaponAnim(ACT_VM_IDLE)
        end
        return 1.0
    end
end

function SWEP:Holster()
    return true
end

function SWEP:OnRemove()
    return true
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_doorcontrol.lua
================================================
CreateConVar("doorcontrol_admin_only", "0", FCVAR_ARCHIVE, "Only allow admins to equip the door control SWEP. You must restart the server to apply the changes")
CreateConVar("doorcontrol_max_distance", "1000", FCVAR_ARCHIVE, "Maximum distance to interact with doors (units)")
CreateConVar("doorcontrol_multipart_range", "100", FCVAR_ARCHIVE, "Range to search for additional door parts (units)")
CreateConVar("doorcontrol_block_time", "10", FCVAR_ARCHIVE, "Time in seconds to block doors with RMB")

local function SetViewModelSkin(ply, skinIndex)
	local vm = ply:GetViewModel()
	if not IsValid(vm) then return end
	vm:SetSkin(skinIndex)
	timer.Simple(0.65, function()
		if IsValid(vm) and vm:GetSkin() == skinIndex then
		vm:SetSkin(0)
		end
	end)
end


SWEP.PrintName = "Door Controller"
SWEP.Author = "Echo"
SWEP.Instructions = "LMB: Open Door\nRMB: Block Door (Timed)"
SWEP.Category = "Other"

SWEP.Spawnable = true
SWEP.AdminOnly = GetConVar("doorcontrol_admin_only"):GetBool()

SWEP.UseHands = true
SWEP.DrawAmmo = false
SWEP.ViewModelFOV = 60
SWEP.ViewModel = "models/weapons/c_door_opener.mdl"
SWEP.WorldModel = "models/weapons/w_door_opener.mdl"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary = SWEP.Primary

SWEP.SharedCooldown = 0.8

function SWEP:CanUse()
	if not self.NextUse then self.NextUse = 0 end
	return CurTime() >= self.NextUse
end

function SWEP:CanUseRMB()
	if not self.NextRMBUse then self.NextRMBUse = 0 end
	return CurTime() >= self.NextRMBUse
end

function SWEP:SetSharedCooldown()
	self.NextUse = CurTime() + self.SharedCooldown
end

function SWEP:SetRMBCooldown()
	self.NextRMBUse = CurTime() + 30.0 -- 3 sekundy cooldown dla RMB
end

function SWEP:Initialize()
	self:SetHoldType("pistol")
end

local function IsDoor(ent)
	if not IsValid(ent) then return false end
	local class = ent:GetClass()
	return class == "prop_door_rotating" or class == "func_door" or class == "func_door_rotating"
end

-- Funkcja do znajdowania wszystkich części drzwi w pobliżu
local function GetAllDoorParts(mainDoor, searchRadius)
	if not IsValid(mainDoor) then return {} end
	
	local doorParts = {mainDoor}
	local mainPos = mainDoor:GetPos()
	local searchRange = searchRadius or GetConVar("doorcontrol_multipart_range"):GetFloat()
	
	-- Znajdź wszystkie entity w pobliżu
	local nearbyEnts = ents.FindInSphere(mainPos, searchRange)
	
	for _, ent in pairs(nearbyEnts) do
		if IsValid(ent) and ent ~= mainDoor then
			local class = ent:GetClass():lower()
			local isDoorEntity = false
			
			-- Sprawdź czy to entity drzwiowe
			if class:find("door") or class == "func_door" or class == "func_door_rotating" or class == "prop_door_rotating" then
				isDoorEntity = true
			elseif ent.IsDoor and ent:IsDoor() then
				isDoorEntity = true
			end
			
			-- Jeśli to część drzwi, sprawdź czy nie jest zablokowana
			if isDoorEntity then
				if ent.ignoredoorcontroller ~= false then -- Dozwolone jeśli nie jest explicite zablokowane dla Door Controller
					-- Sprawdź czy już nie ma tego w tablicy
					local alreadyAdded = false
					for _, existingDoor in pairs(doorParts) do
						if existingDoor == ent then
							alreadyAdded = true
							break
						end
					end
					
					if not alreadyAdded then
						table.insert(doorParts, ent)
					end
				end
			end
		end
	end
	
	return doorParts
end

local function GetDoor(ply)
	local tr = ply:GetEyeTrace()
	local ent = tr.Entity

	local maxDist = GetConVar("doorcontrol_max_distance"):GetFloat()
	if not IsValid(ent) or tr.HitPos:DistToSqr(ply:GetShootPos()) > maxDist * maxDist then return nil end

	local class = ent:GetClass():lower()
	local mainDoor = nil

	if class:find("door") or class == "func_door" or class == "func_door_rotating" or class == "prop_door_rotating" then
		-- Sprawdź czy drzwi nie są zablokowane dla Door Controller
		if ent.ignoredoorcontroller == false then
			-- Te drzwi są zablokowane - Door Controller nie może na nich działać
			return nil
		end
		mainDoor = ent
	elseif ent.IsDoor and ent:IsDoor() then
		-- Sprawdź czy custom door nie jest zablokowany dla Door Controller
		if ent.ignoredoorcontroller == false then
			return nil
		end
		mainDoor = ent
	else
		local parent = ent:GetParent()
		if IsValid(parent) then
			local parentClass = parent:GetClass():lower()
			if parentClass:find("door") or parentClass == "func_door" or parentClass == "func_door_rotating" or parentClass == "prop_door_rotating" then
				-- Sprawdź czy parent door nie jest zablokowany dla Door Controller
				if parent.ignoredoorcontroller == false then
					return nil
				end
				mainDoor = parent
			elseif parent.IsDoor and parent:IsDoor() then
				-- Sprawdź czy parent door nie jest zablokowany dla Door Controller
				if parent.ignoredoorcontroller == false then
					return nil
				end
				mainDoor = parent
			end
		end

		if not mainDoor and (ent:GetClass() == "prop_dynamic" or ent:GetClass() == "prop_physics") then
			local constraints = constraint.GetAllConstrainedEntities(ent)
			for _, constrainedEnt in pairs(constraints) do
				local class = constrainedEnt:GetClass():lower()
				if class:find("door") or constrainedEnt.IsDoor and constrainedEnt:IsDoor() then
					-- Sprawdź czy constrained door nie jest zablokowany dla Door Controller
					if constrainedEnt.ignoredoorcontroller == false then
						return nil
					end
					mainDoor = constrainedEnt
					break
				end
			end
		end
	end

	-- Jeśli znaleźliśmy główne drzwi, znajdź wszystkie części
	if mainDoor then
		return GetAllDoorParts(mainDoor)
	end

	return nil
end


local function PlayCustomAnim(wep, sequence)
	local ply = wep:GetOwner()
	local vm = ply:GetViewModel()
	if not IsValid(vm) then return end

	local seq = vm:LookupSequence(sequence)
	if not seq or seq < 0 then
	seq = vm:LookupSequence("fire") //fallback sequence lol
	if not seq or seq < 0 then return end
	end

	vm:SendViewModelMatchingSequence(seq)
	ply:SetAnimation(PLAYER_ATTACK1)

	local duration = vm:SequenceDuration(seq)
	if duration > 0 then
		timer.Simple(duration, function()
			if not IsValid(wep) or not IsValid(ply) then return end
			if ply:GetActiveWeapon() ~= wep then return end

				local idleSeq = vm:LookupSequence("idle01")
				if idleSeq and idleSeq >= 0 then
				vm:SendViewModelMatchingSequence(idleSeq)
			end
		end)
	end
end

local function PlaySound(ply, snd)
	if IsValid(ply) then ply:EmitSound(snd) end
end

function SWEP:PrimaryAttack()
if CLIENT then return end
if not self:CanUse() then return end

	self:SetSharedCooldown()
	PlayCustomAnim(self, "open")

	local ply = self:GetOwner()

	timer.Simple(0.3, function()
	if not IsValid(self) or not IsValid(ply) then return end

        local doorParts = GetDoor(ply)

	if not doorParts or #doorParts == 0 then
		PlaySound(self:GetOwner(), "echo/button_fail.mp3")
		SetViewModelSkin(ply, 5)
	return
        end

        -- Otwórz wszystkie części drzwi
        local openedCount = 0
        local totalParts = #doorParts
        local initialStates = {}
        local blockedParts = 0
        
        -- Sprawdź czy któreś części są czasowo zablokowane
        for _, door in pairs(doorParts) do
        	if IsValid(door) and door._IsTemporarilyBlocked and door._BlockedUntil and CurTime() < door._BlockedUntil then
        		blockedParts = blockedParts + 1
        	end
        end
        
        -- Jeśli wszystkie części są zablokowane, nie pozwól otworzyć
        if blockedParts == totalParts then
        	PlaySound(self:GetOwner(), "echo/button_fail.mp3")
        	SetViewModelSkin(ply, 6)
        	local remainingTime = math.ceil(doorParts[1]._BlockedUntil - CurTime())
        	return
        end
        
        -- Zapisz początkowe stany wszystkich części
        for i, door in pairs(doorParts) do
        	if IsValid(door) then
        		initialStates[i] = {
        			angles = door:GetAngles(),
        			pos = door:GetPos()
        		}
        	end
        end
        
        for _, door in pairs(doorParts) do
        	if IsValid(door) then
        		-- Sprawdź czy ta część nie jest czasowo zablokowana
        		if not (door._IsTemporarilyBlocked and door._BlockedUntil and CurTime() < door._BlockedUntil) then
        			door:Fire("Open")
        			openedCount = openedCount + 1
        		end
        	end
        end

        -- Sprawdź czy którakolwiek część się otworzyła
        timer.Simple(0.1, function()
            if not IsValid(self) then return end
            
            local anyMoved = false
            local anyUnlocked = false
            local movedCount = 0
            
            for i, door in pairs(doorParts) do
            	if IsValid(door) then
            		local doorClass = door:GetClass()
            		local fallbackOpen = doorClass:find("door") and door:GetInternalVariable("m_bLocked") == false
            		
            		if fallbackOpen then
            			anyUnlocked = true
            		end
            		
            		-- Sprawdź czy ta część się ruszyła
            		if initialStates[i] then
            			local moved = door:GetAngles() ~= initialStates[i].angles or door:GetPos() ~= initialStates[i].pos
            			if moved then
            				anyMoved = true
            				movedCount = movedCount + 1
            			end
            		end
            		
            		door._IsLocked = false
            	end
            end

            if anyMoved or anyUnlocked then
				PlaySound(self:GetOwner(), "echo/button_activate1.mp3")
				SetViewModelSkin(ply, 1)
				-- Komunikat usunięty
			else
				for _, door in pairs(doorParts) do
					if IsValid(door) then
						door._IsLocked = true
					end
				end
				PlaySound(self:GetOwner(), "echo/button_fail.mp3")
				SetViewModelSkin(ply, 6)
				-- Komunikat usunięty
			end
		end)
	end)
end

function SWEP:SecondaryAttack()
	if CLIENT then return end
	if not self:CanUse() then return end
	
	-- Sprawdź cooldown RMB i pokaż komunikat jeśli jest aktywny
	if not self:CanUseRMB() then
		local ply = self:GetOwner()
		if IsValid(ply) then
			local remainingTime = math.ceil(self.NextRMBUse - CurTime())
			ply:PrintMessage(HUD_PRINTCENTER, "Door Controller: RMB Cooldown (" .. remainingTime .. "s)")
		end
		return
	end
	
	self:SetSharedCooldown()
	self:SetRMBCooldown()

	local ply = self:GetOwner()
	PlayCustomAnim(self, "lock")

	timer.Simple(0.3, function()
	if not IsValid(self) or not IsValid(ply) then return end
	
	local doorParts = GetDoor(ply)
	if not doorParts or #doorParts == 0 then
		PlaySound(self:GetOwner(), "echo/button_fail.mp3")
		SetViewModelSkin(ply, 5)
		return
	end

	-- Sprawdź czy którekolwiek drzwi są już zablokowane
	local alreadyBlockedCount = 0
	local totalParts = #doorParts
	
	for _, door in pairs(doorParts) do
		if IsValid(door) and door._IsTemporarilyBlocked and door._BlockedUntil and CurTime() < door._BlockedUntil then
			alreadyBlockedCount = alreadyBlockedCount + 1
		end
	end
	
	-- Antyspam - jeśli wszystkie części są już zablokowane
	if alreadyBlockedCount == totalParts then
		PlaySound(self:GetOwner(), "echo/button_fail.mp3")
		SetViewModelSkin(ply, 6)
		local remainingTime = math.ceil(doorParts[1]._BlockedUntil - CurTime())
		-- Komunikat usunięty
		return
	end

	local blockTime = GetConVar("doorcontrol_block_time"):GetFloat()
	local blockedCount = 0
	
	-- Zablokuj wszystkie części drzwi
	for _, door in pairs(doorParts) do
		if IsValid(door) then
			-- Pomiń jeśli już zablokowane
			if door._IsTemporarilyBlocked and door._BlockedUntil and CurTime() < door._BlockedUntil then
				continue
			end
			
			-- Zapisz oryginalny stan
			if not door._OriginalLocked then
				door._OriginalLocked = door._IsLocked or false
			end
			
			-- Zapisz oryginalny kolor
			if not door._OriginalColor then
				door._OriginalColor = door:GetColor()
			end
			
			-- Zapisz oryginalny materiał
			if not door._OriginalMaterial then
				door._OriginalMaterial = door:GetMaterial()
			end

			-- Zapisz oryginalny skin
			if not door._OriginalSkin then
				door._OriginalSkin = door:GetSkin()
			end
			
			-- Zablokuj drzwi
			door:Fire("Lock")
			door._IsLocked = true
			door._BlockedUntil = CurTime() + blockTime
			door._IsTemporarilyBlocked = true
			
			blockedCount = blockedCount + 1
			
			-- Unikalna nazwa timera dla każdego drzwi
			local timerName = "DoorBlock_" .. door:EntIndex() .. "_" .. CurTime()
			
			-- Timer do odblokowania
			timer.Create(timerName, blockTime, 1, function()
				if IsValid(door) then
					-- Przywróć oryginalny stan blokady
					if door._OriginalLocked then
						door:Fire("Lock")
						door._IsLocked = true
					else
						door:Fire("Unlock")
						door._IsLocked = false
					end
					
					-- Usuń blokadę czasową
					door._BlockedUntil = nil
					door._IsTemporarilyBlocked = nil
					door._OriginalLocked = nil
				end
			end)
		end
	end

	-- Feedback dla gracza
	PlaySound(self:GetOwner(), "echo/button_activate3.mp3")
	SetViewModelSkin(ply, 4)
	
	-- Komunikaty usunięte
	end)
end

-- Funkcja do czyszczenia czasowych blokad
local function ClearTemporaryBlocks()
	for _, ent in pairs(ents.GetAll()) do
		if IsValid(ent) and ent._IsTemporarilyBlocked then
			-- Przywróć oryginalny stan
			if ent._OriginalLocked then
				ent:Fire("Lock")
				ent._IsLocked = true
			else
				ent:Fire("Unlock") 
				ent._IsLocked = false
			end
			
			-- Usuń blokadę czasową
			ent._BlockedUntil = nil
			ent._IsTemporarilyBlocked = nil
			ent._OriginalLocked = nil
		end
	end
end

-- Wyczyść blokady przy restarcie rundy
if SERVER then
	hook.Add("PostCleanupMap", "DoorController_ClearBlocks", ClearTemporaryBlocks)
	hook.Add("BreachPreRound", "DoorController_ClearBlocks", ClearTemporaryBlocks)
end



function SWEP:Deploy()
	local ply = self:GetOwner()
	if not IsValid(ply) then return true end
	if ply:GetActiveWeapon() ~= self then return true end

	PlayCustomAnim(self, "draw")

	local vm = ply:GetViewModel()
	if IsValid(vm) then
		vm:SetSkin(0)
	end

	self:EmitSound("echo/button_enable.mp3", 75, 100, 1, CHAN_ITEM)

	return true
end

function SWEP:Holster()
if CLIENT then return true end

local vm = self:GetOwner():GetViewModel()
	if IsValid(vm) then
	local seq = vm:LookupSequence("holster")
	if not seq or seq < 0 then
	seq = vm:LookupSequence("holster")
	end

	if seq and seq >= 0 then
	vm:SendViewModelMatchingSequence(seq)
	self:GetOwner():SetAnimation(PLAYER_IDLE)
	end
end
return true
end

-- Funkcja do wyświetlania informacji o drzwiach
function SWEP:Think()
	if CLIENT then return end
	
	local ply = self:GetOwner()
	if not IsValid(ply) then return end
	
	-- Sprawdź co jest przed graczem co sekundę
	if not self.NextDoorCheck then self.NextDoorCheck = 0 end
	if CurTime() < self.NextDoorCheck then return end
	self.NextDoorCheck = CurTime() + 0.5
	
	local doorParts = GetDoor(ply)
	if doorParts and #doorParts > 0 then
		local blockedParts = 0
		local minBlockTime = 9999
		
		-- Sprawdź ile części jest czasowo zablokowanych
		for _, door in pairs(doorParts) do
			if IsValid(door) and door._IsTemporarilyBlocked and door._BlockedUntil and CurTime() < door._BlockedUntil then
				blockedParts = blockedParts + 1
				local remainingTime = door._BlockedUntil - CurTime()
				if remainingTime < minBlockTime then
					minBlockTime = remainingTime
				end
			end
		end
		
		if blockedParts > 0 then
			local timeLeft = math.ceil(minBlockTime)
			if blockedParts == #doorParts then
				ply:PrintMessage(HUD_PRINTCENTER, "Door Controller: BLOCKED (" .. timeLeft .. "s)")
			else
				ply:PrintMessage(HUD_PRINTCENTER, "Door Controller: " .. blockedParts .. "/" .. #doorParts .. " BLOCKED (" .. timeLeft .. "s)")
			end
		elseif #doorParts > 1 then
			ply:PrintMessage(HUD_PRINTCENTER, "Door Controller: OPEN or BLOCK")
		else
			ply:PrintMessage(HUD_PRINTCENTER, "Door Controller: Ready")
		end
	else
		ply:PrintMessage(HUD_PRINTCENTER, "Door Controller: No door found")
	end
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_house_canebar.lua
================================================
AddCSLuaFile()

SWEP.Category			= "Other"
SWEP.IconOverride 		= "vgui/hud/killicon/greg_icon"
SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true
SWEP.PrintName			= "House Canebar"	
SWEP.Base				= "weapon_base"
SWEP.Author				= "Opal, Bunny"
SWEP.Instructions		= "Left click, right click, reload."

SWEP.ViewModel			= "models/canebar/v_house_canebar.mdl"
SWEP.WorldModel			= "models/canebar/w_house_canebar.mdl"
SWEP.ViewModelFOV 		= 65
SWEP.HoldType 			= "melee"
SWEP.UseHands 			= true
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true

SWEP.Slot					= 0
SWEP.SlotPos				= 1
SWEP.FiresUnderwater 		= true

SWEP.Primary.Ammo			= -1
SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Delay 			= 0.4
SWEP.Primary.Damage 		= 25

SWEP.Secondary.Ammo			= "none"
SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
	
SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false
SWEP.droppable			= false

SWEP.Holstered = false  -- Track holster state
SWEP.NextToggleTime = 0 -- Cooldown to prevent input issues

-- list.Add( "NPCUsableWeapons", { class = "weapon_house_canebar", title = SWEP.PrintName } )

function SWEP:Initialize()
	self:SetHoldType(self.HoldType) -- SetWeaponHoldType
end


function SWEP:PlayWeaponSound(snd)
	if (CLIENT) then return end
	self.Owner:EmitSound(snd)
end


function SWEP:Deploy()
	self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
	self:SetHoldType(self.HoldType) -- SetWeaponHoldType
end


function SWEP:PrimaryAttack()
	
	if self.Holstered then return end -- Prevent attacking while holstered

	local tr = {}
	tr.start = self.Owner:GetShootPos()
	tr.endpos = self.Owner:GetShootPos() + (self.Owner:GetAimVector() * 100) -- Increase range from 75 to 100
	tr.filter = self.Owner
	tr.mask = MASK_SHOT
	local trace = util.TraceLine(tr)
	
		-- Hit
		if (trace.Hit) then
			self.Weapon:SendWeaponAnim(ACT_VM_HITCENTER)
			bullet = {}
			bullet.Num    = 1
			bullet.Src    = self.Owner:GetShootPos()
			bullet.Dir    = self.Owner:GetAimVector()
			bullet.Spread = Vector(0, 0, 0)
			bullet.Tracer = 0
			bullet.Force  = 8
			bullet.Damage = self.Primary.Damage
			self.Owner:FireBullets( bullet )
			self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
			self.Owner:SetAnimation(PLAYER_ATTACK1)
				
		-- Miss
		else
			self.Weapon:EmitSound(Sound("weapons/iceaxe/iceaxe_swing1.wav"))
			self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
			self.Weapon:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
			timer.Simple(0, function()
			self.Owner:SetAnimation(PLAYER_ATTACK1)
			end)	
		end
		
	timer.Create("Idle", self:SequenceDuration(), 1, function() 
	if (!IsValid(self)) then 
		return 
	end 
			self:SendWeaponAnim( ACT_VM_IDLE ) 
	end )
end


function SWEP:SecondaryAttack()
	self:EmitSound(Sound("weapons/canebar/canebar_emit-0"..math.random(1,7)..".mp3"), 75, 100, 1, CHAN_VOICE)
end


if CLIENT then
    killicon.Add("weapon_house_canebar", "vgui/hud/killicon/greg_icon", Color(255, 255, 255, 255))
end


function SWEP:Think()
    if self.Owner:KeyPressed(IN_ZOOM) and CurTime() > self.NextToggleTime then
        self:ToggleHolster()
        self.NextToggleTime = CurTime() + 0.2 -- Add a short delay to prevent input issues
    end
end


function SWEP:ToggleHolster()
    self.Holstered = not self.Holstered

    if self.Holstered then
        self:SetHoldType("normal")
        if IsValid(self.Owner) and IsValid(self.Owner:GetViewModel()) then
            self.Owner:GetViewModel():SetNoDraw(true) -- Hide hands when holstered
        end
    else
        self:SetHoldType("melee") -- Arm raised when unholstered
        if IsValid(self.Owner) and IsValid(self.Owner:GetViewModel()) then
            self.Owner:GetViewModel():SetNoDraw(false) -- Show hands
        end
    end
end

function SWEP:Kill(victim, attacker, inflictor)
	local math_stuff = math.random(1,10)
	if math_stuff >= 7 then
    	attacker:EmitSound(Sound("weapons/canebar/ax_cane.mp3"), 75, 100, 1, CHAN_VOICE)
    end
end

hook.Add("OnNPCKilled", "WeaponKill_NPC", function(victim, inflictor, attacker)
    if not IsValid(attacker) or not attacker:IsPlayer() then return end -- Ensure attacker is valid and a player

    local weapon = inflictor -- Assume inflictor is the weapon

    -- Check if the inflictor is our SWEP
    if IsValid(weapon) and weapon:GetClass() == "weapon_house_canebar" then
        weapon:Kill(victim, attacker, weapon)
        --print("[DEBUG] Kill registered with correct SWEP: " .. weapon:GetClass())

    -- If the inflictor isn't our SWEP, check the attacker's active weapon
    elseif IsValid(attacker:GetActiveWeapon()) and attacker:GetActiveWeapon():GetClass() == "weapon_house_canebar" then
        weapon = attacker:GetActiveWeapon()
        weapon:Kill(victim, attacker, weapon)
        --print("[DEBUG] Kill registered with active SWEP: " .. weapon:GetClass())
    else
        --print("[DEBUG] Kill ignored: Inflictor not our SWEP.")
    end
end)

hook.Add("PlayerDeath", "WeaponKill_Player", function(victim, inflictor, attacker)
    if not IsValid(attacker) or not attacker:IsPlayer() then return end -- Ensure attacker is valid and a player

    local weapon = inflictor -- Assume inflictor is the weapon

    -- Check if the inflictor is our SWEP
    if IsValid(weapon) and weapon:GetClass() == "weapon_house_canebar" then
        weapon:Kill(victim, attacker, weapon)
        --print("[DEBUG] Kill registered with correct SWEP: " .. weapon:GetClass())

    -- If the inflictor isn't our SWEP, check the attacker's active weapon
    elseif IsValid(attacker:GetActiveWeapon()) and attacker:GetActiveWeapon():GetClass() == "weapon_house_canebar" then
        weapon = attacker:GetActiveWeapon()
        weapon:Kill(victim, attacker, weapon)
        --print("[DEBUG] Kill registered with active SWEP: " .. weapon:GetClass())
    else
        --print("[DEBUG] Kill ignored: Inflictor not our SWEP.")
    end
end) 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_house_canebar_holstered.lua
================================================
AddCSLuaFile()

-- weapon_house_canebar_holstered.lua
SWEP.Category			= "Other"
SWEP.IconOverride 		= "vgui/hud/killicon/greg_icon"
SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true
SWEP.PrintName			= "House Canebar (Holstered)"	
SWEP.Base				= "weapon_base"
SWEP.Author				= "Opal, Bunny"
SWEP.Instructions		= "Holstered version of the House canebar."

SWEP.ViewModel			= "models/canebar/v_house_canebar.mdl"
SWEP.WorldModel			= "models/canebar/w_house_canebar.mdl"
SWEP.ViewModelFOV 		= 65
SWEP.HoldType 			= "normal"
SWEP.UseHands 			= true
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= false

SWEP.Slot					= 0
SWEP.SlotPos				= 1
SWEP.FiresUnderwater 		= false

SWEP.Primary.Ammo			= -1
SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Delay 			= 0.4
SWEP.Primary.Damage 		= 0

SWEP.Secondary.Ammo			= "none"
SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
	
SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false
SWEP.droppable			= false

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
end

function SWEP:Deploy()
	if IsValid(self.Owner) and IsValid(self.Owner:GetViewModel()) then
		self.Owner:GetViewModel():SetNoDraw(true) -- Hide viewmodel when holstered
	end
	self:SetHoldType(self.HoldType)
end

function SWEP:PrimaryAttack()
	-- Holstered weapon doesn't attack
	return false
end

function SWEP:SecondaryAttack()
	-- Holstered weapon doesn't have secondary attack
	return false
end

function SWEP:Think()
	-- Add any holstered-specific thinking here if needed
end

if CLIENT then
    killicon.Add("weapon_house_canebar_holstered", "vgui/hud/killicon/greg_icon", Color(255, 255, 255, 255))
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_house_canebar_recall.lua
================================================
AddCSLuaFile()

SWEP.Category = "Other"
SWEP.IconOverride = "vgui/hud/killicon/greg_icon"
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.PrintName = "House Canebar (Recall)"	
SWEP.Base = "weapon_base"
SWEP.Author = "Opal, Bunny"
SWEP.Instructions = "Left click, right click, reload."

SWEP.ViewModel = "models/canebar/v_house_canebar.mdl"
SWEP.WorldModel = "models/canebar/w_house_canebar.mdl"
SWEP.ViewModelFOV = 65
SWEP.HoldType = "melee"
SWEP.UseHands = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true

SWEP.Slot = 0
SWEP.SlotPos = 1
SWEP.FiresUnderwater = true

SWEP.Primary.Ammo = -1
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Delay = 0.4
SWEP.Primary.Damage = 25

SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
	
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.droppable = false

SWEP.Holstered = false
SWEP.NextToggleTime = 0

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
end

function SWEP:PlayWeaponSound(snd)
	if (CLIENT) then return end
	self.Owner:EmitSound(snd)
end

function SWEP:Deploy()
	self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
	self:SetHoldType(self.HoldType)
end

function SWEP:PrimaryAttack()
	if self.Holstered then return end

	local tr = {}
	tr.start = self.Owner:GetShootPos()
	tr.endpos = self.Owner:GetShootPos() + (self.Owner:GetAimVector() * 100)
	tr.filter = self.Owner
	tr.mask = MASK_SHOT
	local trace = util.TraceLine(tr)
	
	if (trace.Hit) then
		self.Weapon:SendWeaponAnim(ACT_VM_HITCENTER)
		bullet = {}
		bullet.Num = 1
		bullet.Src = self.Owner:GetShootPos()
		bullet.Dir = self.Owner:GetAimVector()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force = 8
		bullet.Damage = self.Primary.Damage
		self.Owner:FireBullets( bullet )
		self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		self.Owner:SetAnimation(PLAYER_ATTACK1)
	else
		self.Weapon:EmitSound(Sound("weapons/iceaxe/iceaxe_swing1.wav"))
		self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
		self.Weapon:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
		timer.Simple(0, function()
		self.Owner:SetAnimation(PLAYER_ATTACK1)
		end)	
	end
		
	timer.Create("Idle", self:SequenceDuration(), 1, function() 
	if (!IsValid(self)) then 
		return 
	end 
		self:SendWeaponAnim( ACT_VM_IDLE ) 
	end )
end

function SWEP:SecondaryAttack()
	self:EmitSound(Sound("weapons/canebar/canebar_emit-0"..math.random(1,7)..".mp3"), 75, 100, 1, CHAN_VOICE)
end

if CLIENT then
    killicon.Add("weapon_house_canebar_recall", "vgui/hud/killicon/greg_icon", Color(255, 255, 255, 255))
end

function SWEP:Think()
    if self.Owner:KeyPressed(IN_ZOOM) and CurTime() > self.NextToggleTime then
        self:ToggleHolster()
        self.NextToggleTime = CurTime() + 0.2
    end
end

function SWEP:ToggleHolster()
    self.Holstered = not self.Holstered

    if self.Holstered then
        self:SetHoldType("normal")
        if IsValid(self.Owner) and IsValid(self.Owner:GetViewModel()) then
            self.Owner:GetViewModel():SetNoDraw(true)
        end
    else
        self:SetHoldType("melee")
        if IsValid(self.Owner) and IsValid(self.Owner:GetViewModel()) then
            self.Owner:GetViewModel():SetNoDraw(false)
        end
    end
end

function SWEP:Kill(victim, attacker, inflictor)
	local math_stuff = math.random(1,10)
	if math_stuff >= 7 then
    	attacker:EmitSound(Sound("weapons/canebar/ax_cane.mp3"), 75, 100, 1, CHAN_VOICE)
    end
end

hook.Add("OnNPCKilled", "WeaponKill_NPC_recall", function(victim, inflictor, attacker)
    if not IsValid(attacker) or not attacker:IsPlayer() then return end

    local weapon = inflictor

    if IsValid(weapon) and weapon:GetClass() == "weapon_house_canebar_recall" then
        weapon:Kill(victim, attacker, weapon)
    elseif IsValid(attacker:GetActiveWeapon()) and attacker:GetActiveWeapon():GetClass() == "weapon_house_canebar_recall" then
        weapon = attacker:GetActiveWeapon()
        weapon:Kill(victim, attacker, weapon)
    end
end)

hook.Add("PlayerDeath", "WeaponKill_Player_recall", function(victim, inflictor, attacker)
    if not IsValid(attacker) or not attacker:IsPlayer() then return end

    local weapon = inflictor

    if IsValid(weapon) and weapon:GetClass() == "weapon_house_canebar_recall" then
        weapon:Kill(victim, attacker, weapon)
    elseif IsValid(attacker:GetActiveWeapon()) and attacker:GetActiveWeapon():GetClass() == "weapon_house_canebar_recall" then
        weapon = attacker:GetActiveWeapon()
        weapon:Kill(victim, attacker, weapon)
    end
end) 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_jailbird.lua
================================================
if SERVER then
   AddCSLuaFile()
end

if CLIENT then 
    SWEP.WepSelectIcon = surface.GetTextureID( "vgui/hud/vgui_jailbird" )
	SWEP.BounceWeaponIcon = true 
    SWEP.DrawWeaponInfoBox = true
end

SWEP.PrintName = "Jailbird"
SWEP.Author = "Craft_Pig - Breach Adapted"
SWEP.Category = "Breach SCP"
SWEP.Purpose = "Electroshock weapon from SCP: Secret Laboratory"

SWEP.ViewModel = "models/weapons/sweps/scpsl/jailbird/v_jailbird.mdl"
SWEP.WorldModel = "models/weapons/sweps/scpsl/jailbird/w_jailbird.mdl"
SWEP.ViewModelFOV = 77
SWEP.UseHands = true
SWEP.DrawCrosshair = false 

SWEP.Spawnable = true
SWEP.Slot = 0
SWEP.SlotPos = 0

SWEP.DrawAmmo = true
SWEP.Primary.Ammo = "JailbirdDurability"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 1
SWEP.Primary.Automatic = false 
 
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipSize = 1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false

SWEP.HitDistance = 90
SWEP.PrimaryCD = 1
SWEP.PrimaryHitTime = 0.3
SWEP.SecondaryHitTime = 0.1
SWEP.SecondaryIdleTime = 2.7
SWEP.Durability = 10

-- Breach compatibility: Effects replacement system
SWEP.BreachEffects = {
    Haste = {
        walkSpeed = 1.3,
        runSpeed = 1.3,
        duration = 2.5
    },
    Discharge = {
        damageOverTime = 25,
        duration = 2,
        interval = 0.5
    },
    Hindered = {
        walkSpeed = 0.2,
        runSpeed = 0.2,
        duration = 3
    }
}

function SWEP:Initialize()
	self:SetHoldType("melee2")
	
	self.Ready = 1
	self.Durability = 10
	self.IsCritical = 0
	
end

function SWEP:Deploy()
    if self:GetOwner():GetAmmoCount(self.Primary.Ammo) <= 0 then -- Delete weapon if durability = 0
	    owner:StripWeapon("weapon_jailbird")
	end
	
	if SERVER then
        if self.Ready == 0 then -- First pickup
            self:SendWeaponAnim(ACT_VM_DRAW)
	    else
	        self:SendWeaponAnim(ACT_VM_PICKUP)
		    self:GetOwner():GiveAmmo(9, "JailbirdDurability", true) -- true means to set the ammo limit to the maximum value for this weapon
	    end
	end
	
	self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
	
	self.Ready = 0
	self.Idle = 0
	self.SetupCharge = 0
	self.ReadyCharge = 0
	self.StartCharge = 0
	self.ForceStopCharge = 0
	self.ForceCharge = 0 
	self.Charging = 0
	self.SwingRight = 1
	
	return true
end

-- Global storage for original speeds per player
SWEP.OriginalSpeeds = SWEP.OriginalSpeeds or {}

-- Breach Effect System replacement functions
function SWEP:ApplyBreachEffect(ply, effectName, duration, intensity, damageType)
    if not IsValid(ply) or not ply:IsPlayer() then return end
    
    local effect = self.BreachEffects[effectName]
    if not effect then return end
    
    local steamID = ply:SteamID64()
    
    if effectName == "Haste" then
        -- For Haste, we should already have speeds stored (it's applied to weapon owner)
        if self.OriginalSpeeds[steamID] then
            -- Apply speed boost based on stored original speeds
            local originalWalk = self.OriginalSpeeds[steamID].walk
            local originalRun = self.OriginalSpeeds[steamID].run
            
            ply:SetWalkSpeed(originalWalk * effect.walkSpeed)
            ply:SetRunSpeed(originalRun * effect.runSpeed)
            
            -- Set timer to restore original speeds
            timer.Create("JailbirdHaste_" .. ply:EntIndex(), duration or effect.duration, 1, function()
                if IsValid(ply) and self.OriginalSpeeds[steamID] then
                    print("[Jailbird] Timer restoring speeds for " .. ply:Nick() .. " to " .. self.OriginalSpeeds[steamID].walk .. "/" .. self.OriginalSpeeds[steamID].run)
                    ply:SetWalkSpeed(self.OriginalSpeeds[steamID].walk)
                    ply:SetRunSpeed(self.OriginalSpeeds[steamID].run)
                    self.OriginalSpeeds[steamID] = nil -- Clean up
                else
                    print("[Jailbird] Timer failed to restore speeds for " .. (IsValid(ply) and ply:Nick() or "invalid player"))
                end
            end)
        else
            -- Fallback: store current speeds
            self.OriginalSpeeds[steamID] = {
                walk = ply:GetWalkSpeed(),
                run = ply:GetRunSpeed()
            }
            
            local originalWalk = self.OriginalSpeeds[steamID].walk
            local originalRun = self.OriginalSpeeds[steamID].run
            
            ply:SetWalkSpeed(originalWalk * effect.walkSpeed)
            ply:SetRunSpeed(originalRun * effect.runSpeed)
            
                         timer.Create("JailbirdHaste_" .. ply:EntIndex(), duration or effect.duration, 1, function()
                 if IsValid(ply) and self.OriginalSpeeds[steamID] then
                     print("[Jailbird] Fallback timer restoring speeds for " .. ply:Nick() .. " to " .. self.OriginalSpeeds[steamID].walk .. "/" .. self.OriginalSpeeds[steamID].run)
                     ply:SetWalkSpeed(self.OriginalSpeeds[steamID].walk)
                     ply:SetRunSpeed(self.OriginalSpeeds[steamID].run)
                     self.OriginalSpeeds[steamID] = nil -- Clean up
                 else
                     print("[Jailbird] Fallback timer failed to restore speeds for " .. (IsValid(ply) and ply:Nick() or "invalid player"))
                 end
             end)
        end
        
    elseif effectName == "Discharge" then
        -- Electric damage over time
        local totalDamage = intensity or effect.damageOverTime
        local tickInterval = effect.interval
        local ticks = math.floor((duration or effect.duration) / tickInterval)
        local damagePerTick = totalDamage / ticks
        
        timer.Create("JailbirdDischarge_" .. ply:EntIndex(), tickInterval, ticks, function()
            if IsValid(ply) and ply:Alive() then
                local dmginfo = DamageInfo()
                dmginfo:SetDamage(damagePerTick)
                dmginfo:SetAttacker(self:GetOwner())
                dmginfo:SetInflictor(self)
                dmginfo:SetDamageType(DMG_SHOCK)
                ply:TakeDamageInfo(dmginfo)
                
                -- Electric effect
                local effectData = EffectData()
                effectData:SetOrigin(ply:GetPos() + Vector(0, 0, 40))
                util.Effect("ElectricSpark", effectData)
            end
        end)
        
    elseif effectName == "Hindered" then
        -- Store original speeds if not already stored
        if not self.OriginalSpeeds[steamID] then
            self.OriginalSpeeds[steamID] = {
                walk = ply:GetWalkSpeed(),
                run = ply:GetRunSpeed()
            }
        end
        
        -- Apply slow effect
        local originalWalk = self.OriginalSpeeds[steamID].walk
        local originalRun = self.OriginalSpeeds[steamID].run
        
        ply:SetWalkSpeed(originalWalk * effect.walkSpeed)
        ply:SetRunSpeed(originalRun * effect.runSpeed)
        
        -- Set timer to restore original speeds
        timer.Create("JailbirdHindered_" .. ply:EntIndex(), duration or effect.duration, 1, function()
            if IsValid(ply) and self.OriginalSpeeds[steamID] then
                ply:SetWalkSpeed(self.OriginalSpeeds[steamID].walk)
                ply:SetRunSpeed(self.OriginalSpeeds[steamID].run)
                self.OriginalSpeeds[steamID] = nil -- Clean up
            end
        end)
    end
end

function SWEP:RemoveBreachEffect(ply, effectName)
    if not IsValid(ply) then return end
    
    local steamID = ply:SteamID64()
    
    if effectName == "Haste" then
        timer.Remove("JailbirdHaste_" .. ply:EntIndex())
        
        -- Restore original speeds if we have them stored
        if self.OriginalSpeeds[steamID] then
            ply:SetWalkSpeed(self.OriginalSpeeds[steamID].walk)
            ply:SetRunSpeed(self.OriginalSpeeds[steamID].run)
            self.OriginalSpeeds[steamID] = nil -- Clean up
            print("[Jailbird] Restored original speeds for " .. ply:Nick() .. " (" .. self.OriginalSpeeds[steamID] and "from stored" or "cleaned up" .. ")")
        else
            -- Don't use fallback - let Breach systems handle it
            print("[Jailbird] Warning: No original speeds stored for " .. ply:Nick() .. ", letting Breach handle reset")
        end
    end
end

function SWEP:Think()
    local owner = self:GetOwner()
	
	-- self.Owner:ConCommand("-forward")
	-- self.Owner:ConCommand("-speed")
	
    if self.Idle == 0 and self.IdleTimer <= CurTime() then -- Idle Sequence
		self:SendWeaponAnim(ACT_VM_IDLE)  
        self.Idle = 1
    end

	if self:GetOwner():GetAmmoCount(self.Primary.Ammo) <= 2 and self.IsCritical == 0 then -- Change texture
	    self:GetOwner():GetViewModel():SetBodygroup(0, 1)
		self.IsCritical = 1
	end
	
	if SERVER then
	    if self:GetOwner():GetAmmoCount(self.Primary.Ammo) <= 0 and self.IdleTimer <= CurTime() then -- Strip Weapon Active
		    owner:StripWeapon("weapon_jailbird")
        end
	    if owner:KeyPressed(IN_RELOAD) and self.IdleTimer <= CurTime() then  -- Inspect
	        if self:GetOwner():GetAmmoCount(self.Primary.Ammo) >= 9 then
		    	self:SendWeaponAnim(ACT_VM_FIDGET)
		    elseif self:GetOwner():GetAmmoCount(self.Primary.Ammo) >= 8 then
			    self:SendWeaponAnim(ACT_VM_RECOIL1)
		    elseif self:GetOwner():GetAmmoCount(self.Primary.Ammo) >= 6 then
			    self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
		    elseif self:GetOwner():GetAmmoCount(self.Primary.Ammo) == 4 then
			    self:SendWeaponAnim(ACT_VM_RECOIL2)
		    elseif self:GetOwner():GetAmmoCount(self.Primary.Ammo) <= 2 then
			    self:SendWeaponAnim(ACT_VM_SECONDARYATTACK)
	        end    
			
		        self:SetNextPrimaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration()) 
		        self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
		        self.Idle = 0     
	    end
	end
    
	if SERVER then
        if self.SetupCharge == 1 then -- Setup Charge
	        if self.IdleTimer <= CurTime() then
		        self:SendWeaponAnim(ACT_VM_PULLBACK) -- Charge Idle
			    self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration() 
			    self.ReadyCharge = 1
			    timer.Create("TimerForceCharge", 2.5, 1, function()
                    self.ForceCharge = 1
                end)
		    elseif (not self.Owner:KeyDown(IN_ATTACK2) and self.ReadyCharge == 1) or self.ForceCharge == 1 then
			    self.IdleTimer = CurTime() + 0
			    self.StartCharge = 1
                self.SetupCharge = 0	
			    self.Owner:EmitSound("swep_scpsl_charge")
			    
			    -- Store owner's speed before applying Haste
			    local steamID = owner:SteamID64()
			    if not self.OriginalSpeeds[steamID] then
			        self.OriginalSpeeds[steamID] = {
			            walk = owner:GetWalkSpeed(),
			            run = owner:GetRunSpeed()
			        }
			        print("[Jailbird] Stored original speeds for " .. owner:Nick() .. ": " .. self.OriginalSpeeds[steamID].walk .. "/" .. self.OriginalSpeeds[steamID].run)
			    else
			        print("[Jailbird] Already have stored speeds for " .. owner:Nick() .. ": " .. self.OriginalSpeeds[steamID].walk .. "/" .. self.OriginalSpeeds[steamID].run)
			    end
			    
			    -- Apply Haste effect using Breach system
			    self:ApplyBreachEffect(owner, "Haste", 2.5, 300)
			    timer.Create("TimerBreakChargeUp", 2.5, 1, function()
                    self.ForceStopCharge = 1
                end)		
		    end
	    end
	
	
	    if self.ReadyCharge == 1 or self.ForceCharge == 1 then -- Forward Charge and Swing
	        if self.IdleTimer <= CurTime() then
		        self:SendWeaponAnim(ACT_VM_HAULBACK)		
		        self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
			    self.Owner:ConCommand("+forward")
			    self.Owner:ConCommand("+speed")
		    end
		
		    self.Charging = 1
	    
		    if self.Owner:KeyPressed(IN_ATTACK) or self.ForceStopCharge == 1 then
		
		        self.Owner:ConCommand("-forward")
	            self.Owner:ConCommand("-speed")
			
			    -- DON'T manually remove Haste - let the timer do it automatically
			    -- This preserves the stored speeds for proper restoration
			
			    self.ForceStopCharge = 0
			    self.StartCharge = 0	
			    self.Idle = 0
			    self.ReadyCharge = 0
			    self.ForceCharge = 0
			    self.Charging = 0
			    timer.Remove("TimerBreakChargeUp")
			    timer.Remove("TimerForceCharge")
		
			    if self:GetOwner():GetAmmoCount(self.Primary.Ammo) <= 2 then -- Decide attack sequence
			        self:SendWeaponAnim(ACT_VM_MISSCENTER)	
                    self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
				    -- PrintMessage(HUD_PRINTTALK, "SWING!")
			    	self.Owner:ConCommand("-forward")
				    self.Owner:ConCommand("-speed")	
			    else
		    	    self:SendWeaponAnim(ACT_VM_SWINGHARD)	
                    self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
				-- PrintMessage(HUD_PRINTTALK, "SWING!")
		    		self.Owner:ConCommand("-forward")
		    		self.Owner:ConCommand("-speed")	
                    self.Owner:EmitSound("swep_scpsl_chargeswing")				
		    	end
			
		    	self:SetNextPrimaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration())
			

                timer.Create("TimerHitChargeWhen", self.SecondaryHitTime, 1, function() -- Impact Timer
			
			        self.Owner:RemoveAmmo(2, "JailbirdDurability")
			
	                local tr = util.TraceLine( {
		                start = owner:GetShootPos(),
		                endpos = owner:GetShootPos() + owner:GetAimVector() * self.HitDistance,
		                filter = owner,
		                mask = MASK_SHOT_HULL
	                } )
	                if ( !IsValid( tr.Entity ) ) then
		                tr = util.TraceHull( {
		    	        start = owner:GetShootPos(),
		    	        endpos = owner:GetShootPos() + owner:GetAimVector() * self.HitDistance,
		    	        filter = owner,
		    	        mins = Vector( -10, -10, -8 ),
		    	        maxs = Vector( 10, 10, 8 ),
		                mask = MASK_SHOT_HULL
		                } )
	                end
	                if SERVER then
		    		    self.Owner:SetAnimation( PLAYER_ATTACK1 )
		    		    if tr.Entity:IsPlayer() then
		    	            -- Apply Breach effects instead of SCP:SL effects
		    	            self:ApplyBreachEffect(tr.Entity, "Discharge", 2, 50, 1)
			    		    self:ApplyBreachEffect(tr.Entity, "Hindered", 3, 80)
			            end
	                    if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
		                    local dmginfo = DamageInfo()
			            
                            dmginfo:SetDamage(200)
                            dmginfo:SetAttacker(self.Owner)
                            dmginfo:SetInflictor(self)
                            dmginfo:SetDamageType(DMG_DISSOLVE)
                            tr.Entity:TakeDamageInfo(dmginfo)
			    	        self:EmitSound("swep_scpsl_hit")
						
			    			local effect = EffectData()
		                    effect:SetOrigin(tr.HitPos)
		                    effect:SetNormal( tr.HitNormal )
		                    util.Effect("ElectricSpark", effect) 
				            util.Effect("ManhackSparks", effect)
		                end
	                end        
                end)			
	    	end
		end
	end
end
 
function SWEP:PrimaryAttack() 
	local owner = self:GetOwner()
	local tr2 = util.TraceLine( {
		    start = owner:GetShootPos(),
		    endpos = owner:GetShootPos() + owner:GetAimVector() * self.HitDistance,
		    filter = owner,
		    mask = MASK_SHOT_HULL
	    } )
	    if ( !IsValid( tr2.Entity ) ) then
		    tr2 = util.TraceHull( {
			    start = owner:GetShootPos(),
			    endpos = owner:GetShootPos() + owner:GetAimVector() * self.HitDistance,
			    filter = owner,
			    mins = Vector( -10, -10, -8 ),
			    maxs = Vector( 10, 10, 8 ),
		        mask = MASK_SHOT_HULL
		    } )
	    end
	local DumbTracerCheck = (tr2.Entity:IsPlayer() or tr2.Entity:IsNPC() or tr2.Entity:IsNextBot())
	
	if self.ReadyCharge == 1 then return end
	self.Owner:SetAnimation( PLAYER_ATTACK1 )
	
	if SERVER then -- Decide attack sequence
	    if self:GetOwner():GetAmmoCount(self.Primary.Ammo) == 1 and DumbTracerCheck then
	        self:SendWeaponAnim(ACT_VM_HITCENTER2)
		    self:SetNextPrimaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration())
            self.Owner:EmitSound("swep_scpsl_swingr")			
	    else
            if self.SwingRight == 1 then
                self:SendWeaponAnim(ACT_VM_MISSRIGHT)
				self.Owner:EmitSound("swep_scpsl_swingr")
		        self.SwingRight = 0
	        else
	            self:SendWeaponAnim(ACT_VM_MISSLEFT)
				self.Owner:EmitSound("swep_scpsl_swingl")
		        self.SwingRight = 1	
	        end
		    self.Idle = 0
			self.SetupCharge = 0
		    self:SetNextPrimaryFire(CurTime() + self.PrimaryCD + 0)
	    end
		
    self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration() 
	
	end
   	
	timer.Create("TimerHitWhen", self.PrimaryHitTime, 1, function() -- Impact Timer
	    if SERVER then
		    local dmginfo = DamageInfo()
			local tr = util.TraceLine( {
		    start = owner:GetShootPos(),
		    endpos = owner:GetShootPos() + owner:GetAimVector() * self.HitDistance,
		    filter = owner,
		    mask = MASK_SHOT_HULL
	        } )
	        if ( !IsValid( tr.Entity ) ) then
		        tr = util.TraceHull( {
			        start = owner:GetShootPos(),
			        endpos = owner:GetShootPos() + owner:GetAimVector() * self.HitDistance,
			        filter = owner,
			        mins = Vector( -10, -10, -8 ),
			        maxs = Vector( 10, 10, 8 ),
		            mask = MASK_SHOT_HULL
		        } )
	        end
		    if tr.Entity:IsPlayer() then
			    -- Apply Breach effect instead of SCP:SL effect
			    self:ApplyBreachEffect(tr.Entity, "Discharge", 2, 25, 1)
			end
			-- if IsValid(tr.Entity) and (tr.Entity:GetClass() == "prop_physics") then
				-- dmginfo:SetDamage(50)	
				-- dmginfo:SetAttacker(self.Owner)
                -- dmginfo:SetInflictor(self)
                -- dmginfo:SetDamageType(DMG_CRUSH, DMG_SHOCK)
                -- tr.Entity:TakeDamageInfo(dmginfo)
				
				-- self:EmitSound("swep_scpsl_hit")
	        if ( SERVER and IsValid( tr.Entity ) and ( tr.Entity:IsNPC() or tr.Entity:IsPlayer() or tr.Entity:Health() > 0 ) ) then
                dmginfo:SetDamage(50)
                dmginfo:SetAttacker(self.Owner)
                dmginfo:SetInflictor(self)
                dmginfo:SetDamageType(DMG_CRUSH, DMG_SHOCK)
                tr.Entity:TakeDamageInfo(dmginfo)
				
				self:EmitSound("swep_scpsl_hit")
				self.Owner:RemoveAmmo(1, "JailbirdDurability")
				
				local effect = EffectData()
		        effect:SetOrigin(tr.HitPos)
		        effect:SetNormal( tr.HitNormal )
		        util.Effect("ManhackSparks", effect)	
		    end
	    end        
    end)
 end
 
function SWEP:SecondaryAttack()
	
    if self.SetupCharge == 0 and self.IdleTimer <= CurTime() then -- Initialize charge up
        self:SendWeaponAnim(ACT_VM_PULLBACK_HIGH)
        self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
        self.Idle = 1
        self.SetupCharge = 1
		self.ReadyCharge = 0
		self.ForceStopCharge = 0
		self.Owner:EmitSound("swep_scpsl_chargestart")
		self:SetNextPrimaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration() + self.SecondaryHitTime + 0.9)
	end
end

function SWEP:OnRemove()
   if self.ReadyCharge == 1 or self.ForceCharge == 1 then
	    self.Owner:ConCommand("-forward")
		self.Owner:ConCommand("-speed")	
	end
	
	-- Clean up any active effects
	if IsValid(self:GetOwner()) then
	    local ply = self:GetOwner()
	    local steamID = ply:SteamID64()
	    
	    timer.Remove("JailbirdHaste_" .. ply:EntIndex())
	    timer.Remove("JailbirdDischarge_" .. ply:EntIndex())
	    timer.Remove("JailbirdHindered_" .. ply:EntIndex())
	    
	    -- Restore original speeds if stored
	    if self.OriginalSpeeds[steamID] then
	        ply:SetWalkSpeed(self.OriginalSpeeds[steamID].walk)
	        ply:SetRunSpeed(self.OriginalSpeeds[steamID].run)
	        self.OriginalSpeeds[steamID] = nil
	    end
	end
end

function SWEP:Holster()
    
    if self.StartCharge == 1 or self.SetupCharge == 1 or self.ReadyCharge == 1 then return end
	timer.Remove("TimerHitWhen")
	timer.Remove("TimerHitChargeWhen")
	timer.Remove("TimerBreakChargeUp")
	timer.Remove("TimerForceCharge")
	
    return true
end

function SWEP:PostDrawViewModel( vm )
    local attachment = vm:GetAttachment(1)
    if attachment then
        self.vmcamera = vm:GetAngles() - attachment.Ang
    else
        self.vmcamera = Angle(0, 0, 0) 
    end
end

function SWEP:CalcView( ply, pos, ang, fov )
	self.vmcamera = self.vmcamera or Angle(0, 0, 0)  
    return pos, ang + self.vmcamera, fov
end

if CLIENT then -- Worldmodel offset
	local WorldModel = ClientsideModel(SWEP.WorldModel)

	WorldModel:SetSkin(0)
	WorldModel:SetNoDraw(true)

	function SWEP:DrawWorldModel()
		local owner = self:GetOwner()

		if (IsValid(owner)) then
			local offsetVec = Vector(3, -1.5, -6)
			local offsetAng = Angle(-0, 0, 90)
			
			local boneid = owner:LookupBone("ValveBiped.Bip01_R_Hand") -- Right Hand
			if !boneid then return end

			local matrix = owner:GetBoneMatrix(boneid)
			if !matrix then return end

			local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())

			WorldModel:SetPos(newPos)
			WorldModel:SetAngles(newAng)

            WorldModel:SetupBones()
		else
			
			WorldModel:SetPos(self:GetPos())
			WorldModel:SetAngles(self:GetAngles())
			self:DrawModel()
		end

		WorldModel:DrawModel()

	end
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_jarate.lua
================================================
AddCSLuaFile()

SWEP.DrawWeaponInfoBox = false
SWEP.BounceWeaponIcon = true

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID( "models/orange_blossom/piss/piss_icon" )
	SWEP.BounceWeaponIcon = false
end

SWEP.Slot = 4
SWEP.SlotPos = 8

SWEP.Category = "Breach SCP"
SWEP.PrintName = "Jarate"
SWEP.Spawnable = true

SWEP.ViewModel = Model( "models/orange_blossom/piss/piss.mdl" )
SWEP.WorldModel = Model( "models/orange_blossom/piss/piss_world.mdl" )
SWEP.ViewModelFOV = 50
SWEP.BobScale = 2
SWEP.UseHands = true

-- Breach gamemode compatibility
SWEP.droppable = true
SWEP.teams = {2,3,5,6,7} -- MTF, Scientists, Guards, etc.

SWEP.Primary.Ammo = "jarate"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = GetConVar and GetConVar("blossomJarateCount") and GetConVar("blossomJarateCount"):GetInt() or 1
SWEP.Primary.Automatic = false

SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false

SWEP.DrawAmmo = true

SWEP.soundAttack = "orange_blossom/piss/swoosh.wav"
SWEP.soundDeploy = "orange_blossom/piss/bottle.wav"
SWEP.speed = GetConVar and GetConVar("sv_defaultdeployspeed") and GetConVar("sv_defaultdeployspeed"):GetFloat() or 1

SWEP.timers = { --these are reset at OnRemove()
	["hitTime"] = 999999,
	["idleTime"] = 999999,
	["cool"] = 999999,
}

SWEP.time = 0
SWEP.isIdle = false
SWEP.myPos = Vector( 0, 0, 0 )
SWEP.hold = false
SWEP.throwForce = GetConVar and GetConVar("blossomJarateThrow") and GetConVar("blossomJarateThrow"):GetInt() or 650

function SWEP:Initialize()
	self.time = CurTime()
	self:SetHoldType( "grenade" )
	self.throwForce = GetConVar and GetConVar("blossomJarateThrow") and GetConVar("blossomJarateThrow"):GetInt() or 650
	self.Primary.DefaultClip = GetConVar and GetConVar("blossomJarateCount") and GetConVar("blossomJarateCount"):GetInt() or 1
end

function SWEP:Deploy()
	self.time = CurTime()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	vm:SetPlaybackRate( self.speed )

	self.timers["idleTime"] = self.time + vm:SequenceDuration() / self.speed
	self.timers["cool"] = self.time

	self:CallOnClient( "DeployClientside" )

	return true
end

function SWEP:DeployClientside()
	self.time = CurTime()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	vm:SetPlaybackRate( self.speed )

	self.timers["idleTime"] = self.time + vm:SequenceDuration() / self.speed
	self.timers["cool"] = self.time

	sound.Play( self.soundDeploy, LocalPlayer():GetPos(), 75, 100, 1 )
end

function SWEP:CanPrimaryAttack()
	if SERVER and self.Owner:GetAmmoCount( self.Primary.Ammo ) > 0 and self.timers["cool"] < self.time and !self.hold then
		return true
	else
		return false
	end
end

function SWEP:PrimaryAttack()
	if !self:CanPrimaryAttack() or !IsFirstTimePredicted() then return end

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "drawbackhigh" ) )
	self.hold = true
end

function SWEP:ClientThrow()
	self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:SecondaryAttack()
	return
end

function SWEP:Holster()
	self:ResetTimers()
	return true
end

function SWEP:OnDrop()
	self:ResetTimers()
end

function SWEP:OnRemove()
	self:ResetTimers()
end

function SWEP:Think()
	if CLIENT then return end

	local vm = self.Owner:GetViewModel()
	self.time = CurTime()
	self.myPos = self.Owner:GetPos()

	if self.hold then
		local down = self.Owner:KeyDown( IN_ATTACK )

		if down then
			self.timers["cool"] = self.time + 0.7
			return
		else
			self.Owner:SetAnimation( PLAYER_ATTACK1 )
			vm:SendViewModelMatchingSequence( vm:LookupSequence( "throw" ) )
			self.timers["hitTime"] = self.time + 0.2
			self.hold = false
			self:CallOnClient( "ClientThrow" )
		end
	end

	if self.timers["hitTime"] < self.time then --primary attack
		local ange = self.Owner:LocalEyeAngles()

		local side = Vector( 8, -8, 0 )
		side:Rotate(ange)
		local offsetFix = Vector( 0, 0.02, 0 )
		offsetFix:Rotate( ange )

		local proj = ents.Create( "breach_jarate_projectile" )
		local dir = self.Owner:GetAimVector() + Vector( 0, 0, 0.2 ) + offsetFix
		local parent = self.Owner
		local force = self.throwForce

		proj:MyInfo( dir, parent, force )
		proj:SetPos( self.Owner:GetPos() + side + Vector( 0, 0, 60 ) )
		proj:Spawn()

		sound.Play( self.soundAttack, self.myPos, 75, math.random( 90, 110 ), 1 )

		self.Owner:RemoveAmmo( 1, self.Primary.Ammo )
		self.timers["hitTime"] = 999999
		self.timers["idleTime"] = self.time + 0.5

		if self.Owner:GetAmmoCount( self.Primary.Ammo ) <= 0 then
			self.Owner:StripWeapon( "weapon_jarate" )
			return
		end

		return
	end

	if !self.hold and self.timers["idleTime"] < self.time then --loop idle
		vm:SendViewModelMatchingSequence( vm:LookupSequence( "idle01" ) )
		self.timers["idleTime"] = self.time + vm:SequenceDuration()
		return
	end
end

function SWEP:ResetTimers()
	for k,v in pairs( self.timers ) do --timers won't progress when wep is not active
		self.timers[k] = 999999
	end
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_kapkan_placer.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_base"

SWEP.PrintName = "Kapkan Mines Placer"
SWEP.Category = "Arsen's Gadgets"
SWEP.Icon = "entities/weapon_kapkan_placer.png"
SWEP.Author = "Arsen"
SWEP.Instructions = "LMB - place mine, RMB - change direction"

SWEP.Slot = 4            
SWEP.DrawAmmo = false      
SWEP.DrawCrosshair = true 
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapons/c_slam.mdl"
SWEP.WorldModel = "models/weapons/w_slam.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true

SWEP.ViewModelBoneMods = {
    ["ValveBiped.Bip01_L_Finger1"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(36.575, -21.084, -52.669) },
    ["ValveBiped.Bip01_L_Finger11"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -15.877, 0) },
    ["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-11.183, 4.473, 1.958), angle = Angle(4.281, 16.481, -23.729) },
    ["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 1.606, 2.686), angle = Angle(0, 0, 0) },
    ["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-10.254, -1.499, 14.039) },
    ["Detonator"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, -30), angle = Angle(0, 0, 0) },
    ["ValveBiped.Bip01_L_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(-0.213, -0.352, 1.108), angle = Angle(10.994, -5.578, -20.146) },
    ["ValveBiped.Bip01_L_Finger4"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(5.682, 0, 0) },
    ["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(0.172, -0.935, 0), angle = Angle(3.621, 3.484, 1.598) },
    ["Slam_base"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(-30, -30, -30), angle = Angle(10, 0, 0) },
    ["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(32.2, 41.077, 0.694) }
}

SWEP.VElements = {
    ["Trimpine"] = { type = "Model", model = "models/arsen/Tripmine.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.454, 5.084, 1.241), angle = Angle(-101.689, 80.649, 78.311), size = Vector(0.61, 0.61, 0.61), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
    ["Tripmine"] = { type = "Model", model = "models/arsen/Tripmine.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.22, 4.419, -1.759), angle = Angle(50.432, 0, 0), size = Vector(0.791, 0.791, 0.791), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.DrawAmmo = false

local lastToggleTime = 0
local SOUND_TOGGLE = "buttons/lightswitch2.wav"
local SOUND_PLACE = "buttons/button19.wav"

function SWEP:SetupDataTables()
    self:NetworkVar("Int", 0, "PlaceSide")
    self:NetworkVar("Int", 1, "RemainingUses")
    
    if SERVER then
        self:SetPlaceSide(1)
        self:SetRemainingUses(KAPKAN_CONFIG.MaxUses)
    end
end

function SWEP:Initialize()
    self:SetHoldType(self.HoldType)
    
    if CLIENT then
        self:CreateModels(self.VElements)
        self:CreateModels(self.WElements)
        
        if IsValid(self.Owner) then
            local vm = self.Owner:GetViewModel()
            if IsValid(vm) then
                self:ResetBonePositions(vm)
            end
        end
    end
end

function SWEP:PrimaryAttack()
    if CLIENT then return end
    
    local ply = self:GetOwner()
    if self:GetRemainingUses() <= 0 then
        ply:ChatPrint("Out of charges!")
        return
    end

    if self.NextPlacement and self.NextPlacement > CurTime() then
        return
    end

    local tr = ply:GetEyeTrace()
    if not tr.Hit or not tr.HitNormal or tr.HitPos:DistToSqr(ply:GetPos()) > KAPKAN_CONFIG.MaxPlaceDistance * KAPKAN_CONFIG.MaxPlaceDistance then 
        return 
    end

    local ent = ents.Create("ent_kapkan_mine")
    if not IsValid(ent) then return end

    local spawnPos = tr.HitPos + tr.HitNormal * 1
    local ang = tr.HitNormal:Angle()
    ang:RotateAroundAxis(ang:Up(), self:GetPlaceSide())

    ent:SetPos(spawnPos)
    ent:SetAngles(ang)
    ent:Spawn()
    ent:SetNWInt("ExplosionDamage", KAPKAN_CONFIG.ExplosionDamage)
    ent:GetPhysicsObject():EnableMotion(false)

    if KAPKAN_CONFIG.AllowUndo and undo and undo.Create and undo.AddEntity and undo.SetPlayer and undo.Finish then
        undo.Create("Kapkan Mine")
            undo.AddEntity(ent)
            undo.SetPlayer(ply)
        undo.Finish()
    end

    self:EmitSound(SOUND_PLACE)
    self:SetRemainingUses(self:GetRemainingUses() - 1)
    
    if self:GetRemainingUses() <= 0 then
        timer.Simple(0.1, function()
            if IsValid(ply) and IsValid(self) then
                ply:StripWeapon(self:GetClass())
            end
        end)
    end
    
    self:SetNextPrimaryFire(CurTime() + 0.1)
    self.NextPlacement = CurTime() + KAPKAN_CONFIG.PlacementDelay
end

function SWEP:SecondaryAttack()
    if CurTime() - lastToggleTime < 0.2 then return end
    lastToggleTime = CurTime()
    
    local currentSide = self:GetPlaceSide()
    self:SetPlaceSide(currentSide == 1 and 180 or 1)
    self:EmitSound(SOUND_TOGGLE)
    self:SetNextSecondaryFire(CurTime() + 0.3)
end

function SWEP:Reload()
    return
end

if CLIENT then
    function SWEP:DrawHUD()
        local ply = LocalPlayer()
        local tr = ply:GetEyeTrace()
        if not tr.Hit or tr.HitPos:DistToSqr(ply:GetPos()) > KAPKAN_CONFIG.MaxPlaceDistance * KAPKAN_CONFIG.MaxPlaceDistance then return end

        cam.Start3D(EyePos(), EyeAngles())
            render.SetColorMaterial()
            local ang = tr.HitNormal:Angle()
            ang:RotateAroundAxis(ang:Up(), self:GetPlaceSide())
            local pos = tr.HitPos + tr.HitNormal * 1

            render.DrawWireframeBox(pos, ang, Vector(-8, -8, -8), Vector(8, 8, 8), Color(255, 0, 0, 200), true)
            render.DrawLine(pos, pos + ang:Right() * 10, Color(0,255,0), true)
            
            cam.Start2D()
                draw.SimpleText("Charges: "..self:GetRemainingUses(), "DermaDefault", ScrW()/2, ScrH()/2 + 50, Color(255,255,255), TEXT_ALIGN_CENTER)
            cam.End2D()
        cam.End3D()
    end

    -- Create convars
    if not ConVarExists("kapkan_max_uses") then
        CreateClientConVar("kapkan_max_uses", KAPKAN_CONFIG.MaxUses, true, false)
        CreateClientConVar("kapkan_explosion_dmg", KAPKAN_CONFIG.ExplosionDamage, true, false)
        CreateClientConVar("kapkan_explosion_delay", KAPKAN_CONFIG.ExplosionDelay, true, false)
        CreateClientConVar("kapkan_laser_length", KAPKAN_CONFIG.LaserLength, true, false)
        CreateClientConVar("kapkan_mine_health", KAPKAN_CONFIG.MineHealth, true, false)
        CreateClientConVar("kapkan_allow_undo", KAPKAN_CONFIG.AllowUndo and 1 or 0, true, false)
        CreateClientConVar("kapkan_placement_delay", KAPKAN_CONFIG.PlacementDelay, true, false)
        CreateClientConVar("kapkan_player_collisions", KAPKAN_CONFIG.PlayerCollisions and 1 or 0, true, false)
    end

    -- Utilities Menu
    hook.Add("PopulateToolMenu", "KapkanSettingsMenu", function()
        spawnmenu.AddToolMenuOption("Utilities", "Admin", "KapkanConfig", "Kapkan Mines", "", "", function(panel)
            panel:ClearControls()
            
            panel:Help("Configure Kapkan Mine settings")
            
            panel:NumSlider("Max Uses", "kapkan_max_uses", 1, 10, 0)
            GetConVar("kapkan_max_uses"):SetInt(KAPKAN_CONFIG.MaxUses)
            panel:ControlHelp("Number of mines each placer can deploy")
            
            panel:NumSlider("Explosion Damage", "kapkan_explosion_dmg", 50, 500, 0)
            GetConVar("kapkan_explosion_dmg"):SetInt(KAPKAN_CONFIG.ExplosionDamage)
            panel:ControlHelp("Damage dealt when mine explodes")
            
            panel:NumSlider("Explosion Delay", "kapkan_explosion_delay", 0.1, 5, 1)
            GetConVar("kapkan_explosion_delay"):SetFloat(KAPKAN_CONFIG.ExplosionDelay)
            panel:ControlHelp("Delay before explosion after trigger (seconds)")
            
            panel:NumSlider("Laser Length", "kapkan_laser_length", 50, 300, 0)
            GetConVar("kapkan_laser_length"):SetInt(KAPKAN_CONFIG.LaserLength)
            panel:ControlHelp("Length of the detection laser")
            
            panel:NumSlider("Mine Health", "kapkan_mine_health", 1, 50, 0)
            GetConVar("kapkan_mine_health"):SetInt(KAPKAN_CONFIG.MineHealth)
            panel:ControlHelp("How much damage the mine can take")
            
            panel:CheckBox("Allow Undo", "kapkan_allow_undo")
            GetConVar("kapkan_allow_undo"):SetBool(KAPKAN_CONFIG.AllowUndo)
            panel:ControlHelp("Allow players to undo placements")
            
            panel:CheckBox("Player Collisions", "kapkan_player_collisions")
			GetConVar("kapkan_player_collisions"):SetBool(KAPKAN_CONFIG.PlayerCollisions)
			panel:ControlHelp("Whether mines collide with players")
            
            panel:NumSlider("Placement Delay", "kapkan_placement_delay", 0, 5, 2)
            GetConVar("kapkan_placement_delay"):SetFloat(KAPKAN_CONFIG.PlacementDelay)
            panel:ControlHelp("Delay between placing mines (seconds)")
            
            panel:Button("Apply Settings", "kapkan_apply_settings")
            panel:Button("Reset to Default", "kapkan_reset_settings")
        end)
    end)

    concommand.Add("kapkan_apply_settings", function()
        if not LocalPlayer():IsAdmin() then return end
        
        net.Start("UpdateKapkanConfig")
            net.WriteTable({
                MaxUses = GetConVar("kapkan_max_uses"):GetInt(),
                ExplosionDamage = GetConVar("kapkan_explosion_dmg"):GetInt(),
                ExplosionDelay = GetConVar("kapkan_explosion_delay"):GetFloat(),
                LaserLength = GetConVar("kapkan_laser_length"):GetInt(),
                MineHealth = GetConVar("kapkan_mine_health"):GetInt(),
                AllowUndo = GetConVar("kapkan_allow_undo"):GetBool(),
                PlayerCollisions = GetConVar("kapkan_player_collisions"):GetBool(),
                MaxPlaceDistance = 150,
                PlacementDelay = GetConVar("kapkan_placement_delay"):GetFloat()
            })
        net.SendToServer()
        
        LocalPlayer():ChatPrint("Kapkan Mines settings applied!")
    end)

    concommand.Add("kapkan_reset_settings", function()
        if not LocalPlayer():IsAdmin() then return end
        
        GetConVar("kapkan_max_uses"):SetInt(4)
        GetConVar("kapkan_explosion_dmg"):SetInt(95)
        GetConVar("kapkan_explosion_delay"):SetFloat(0.5)
        GetConVar("kapkan_laser_length"):SetInt(80)
        GetConVar("kapkan_mine_health"):SetInt(10)
        GetConVar("kapkan_allow_undo"):SetBool(true)
        GetConVar("kapkan_player_collisions"):SetBool(false)
        GetConVar("kapkan_placement_delay"):SetFloat(0.9)
    end)

    SWEP.WepSelectIcon = surface.GetTextureID("vgui/weapons/arsen/weapon_kapkan_placer")
    SWEP.BounceWeaponIcon = false 
    killicon.Add("weapon_hdevice", "gui/weapons/arsen/weapon_kapkan_placer", Color(255, 255, 255, 255))
end

/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = tab.bone
			
			if (!bone) then bone = bone_override end
			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(ent:LookupBone(bone))
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite..".vmt"
				v.spriteMaterial = Material(name)
				v.createdSprite = v.sprite
			end
		end
		
	end
	
	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!self.ViewModelBoneModData) then
				self.ViewModelBoneModData = {}
			end
			
			for k, v in pairs( self.ViewModelBoneMods ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!self.ViewModelBoneModData[bone]) then
					self.ViewModelBoneModData[bone] = { 
						s = ms,
						p = p, 
						ms = ms
					}
				end
				
				local d = self.ViewModelBoneModData[bone]
				
				if (d.s != s) then vm:ManipulateBoneScale( bone, s ) d.s = s end
				if (d.p != p) then vm:ManipulateBonePosition( bone, p ) d.p = p end
				if (d.ms != ms) then vm:ManipulateBoneScale( bone, ms ) d.ms = ms end
			end
			
		else
			self:ResetBonePositions(vm)
		end
		   
	end
		 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( t )

		if (!t) then return end
		
		local res = {}
		for k, v in pairs( t ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_pencil.lua
================================================
AddCSLuaFile()

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("breach/wep_pencil")
	SWEP.BounceWeaponIcon = false
end

SWEP.Base = "weapon_base"
SWEP.Category = "Breach SWEPs"
SWEP.Spawnable = false
SWEP.AdminSpawnable = true
SWEP.PrintName = "Pencil"
SWEP.Author = "Michael Conway, Mr.KobraX (Adapted for Breach)"
SWEP.Instructions = [[Therapeutic writing implement for psychological documentation.
Used by psychologists for note-taking and stress relief.

LMB - Stab attack (38 dmg)
RMB - Disabled
Reload - Disabled]]

-- Breach specific settings
SWEP.droppable = true
SWEP.teams = {2,3,5,6,7} -- Scientists, Class D, MTF, etc

SWEP.HoldType = "knife"
SWEP.ViewModel = "models/weapons/v_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ShowWorldModel = false
SWEP.DrawCrosshair = true
SWEP.ViewModelFOV = 80
SWEP.ViewModelFlip = false

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Damage = 5
SWEP.Primary.Delay = 1
SWEP.Primary.Force = 1000000000

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Damage = 0

SWEP.Weight = 1
SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = false

SWEP.Slot = 1
SWEP.SlotPos = 3
SWEP.DrawAmmo = false

SWEP.ViewModelBoneMods = {
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.Irons = {
    Normal = {
        Pos = Vector(-7.52, -2.126, -4.801),
        Ang = Vector(0, 0, -70),
        BlendTime = 0,
    }
}

SWEP.VElements = {
	["bowie_knife"] = { type = "Model", model = "models/PENCILs/c_models/c_eternal_reward/c_eternal_rewardjohnwick.mdl", bone = "v_weapon.knife_Parent", rel = "", pos = Vector(0.326, -0.102, 1.825), angle = Angle(60.569, 0, 0), size = Vector(0.5, 0.5, 0.5), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["bowie_knife"] = { type = "Model", model = "models/PENCILs/c_models/c_eternal_reward/c_eternal_rewardjohnwick.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.91, 1.753, 0), angle = Angle(0, -32.132, -90), size = Vector(0.68, 0.68, 0.68), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.MissSound = Sound("weapons/knife/knife_slash1.wav")
SWEP.WallSound = Sound("weapons/knife/knife_hitwall1.wav")

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().PENCIL
		if self.Lang then
			self.Author = self.Lang.author
			self.Contact = self.Lang.contact
			self.Purpose = self.Lang.purpose
			self.Instructions = self.Lang.instructions
		end
	end
	
	self:SetWeaponHoldType(self.HoldType)
	
	if CLIENT then
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					vm:SetColor(Color(255,255,255,1))
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
	end
end

function SWEP:GetViewModelPosition( pos, ang )
    local b, r, u, f, n, x, y, z
    
    self.BobScale = 0.4
    self.SwayScale = 0.8
    
    r, u, f = ang:Right( ), ang:Up( ), ang:Forward( )
    
    x = self.Irons.Normal.Ang.x
    y = self.Irons.Normal.Ang.y
    z = self.Irons.Normal.Ang.z
    
    ang:RotateAroundAxis( r, x )
    ang:RotateAroundAxis( u, y )
    ang:RotateAroundAxis( f, z )
        
    r, u, f = ang:Right( ), ang:Up( ), ang:Forward( )
    
    x = self.Irons.Normal.Pos.x
    y = self.Irons.Normal.Pos.y
    z = self.Irons.Normal.Pos.z
        
    pos = pos + x * r
    pos = pos + y * f
    pos = pos + z * u
    
    return pos, ang
end

function SWEP:PrimaryAttack()
	local tr = {}
	tr.start = self.Owner:GetShootPos()
	tr.endpos = self.Owner:GetShootPos() + ( self.Owner:GetAimVector() * 37 ) -- Reduced from 100 to 75
	tr.filter = self.Owner
	tr.mask = MASK_SHOT
	local trace = util.TraceLine( tr )

	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	if ( trace.Hit ) then
		if trace.Entity:IsPlayer() or string.find(trace.Entity:GetClass(),"npc") or string.find(trace.Entity:GetClass(),"prop_ragdoll") then
			self.Weapon:SendWeaponAnim(ACT_VM_MISSCENTER)
			bullet = {}
			bullet.Num    = 1
			bullet.Src    = self.Owner:GetShootPos()
			bullet.Dir    = self.Owner:GetAimVector()
			bullet.Spread = Vector(0, 0, 0)
			bullet.Tracer = 0
			bullet.Force  = 1
			bullet.Damage = self.Primary.Damage
			self.Owner:FireBullets(bullet) 
		else
			self.Weapon:SendWeaponAnim(ACT_VM_HITCENTER)
			bullet = {}
			bullet.Num    = 1
			bullet.Src    = self.Owner:GetShootPos()
			bullet.Dir    = self.Owner:GetAimVector()
			bullet.Spread = Vector(0, 0, 0)
			bullet.Tracer = 0
			bullet.Force  = 1
			bullet.Damage = self.Primary.Damage
			self.Owner:FireBullets(bullet) 
			self.Weapon:EmitSound( self.WallSound )		
			util.Decal("ManhackCut", trace.HitPos + trace.HitNormal, trace.HitPos - trace.HitNormal)
		end
	else
		self.Weapon:EmitSound(self.MissSound,100,math.random(90,120))
		self.Weapon:SendWeaponAnim(ACT_VM_HITCENTER)
	end
	
	-- ViewPunch removed for smoother camera experience
end

function SWEP:SecondaryAttack()
	return false
end

function SWEP:Reload()
	return false
end



function SWEP:Deploy()
   self.Weapon:SendWeaponAnim(ACT_VM_DRAW);
   return true
end

function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
	return true
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r -- Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) 
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_pocket_knife.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_base"
SWEP.PrintName = "Pocket Knife"
SWEP.Instructions = [[Compact folding knife for Scout D personnel.
Useful for cutting tape or self-defense.

LMB - Stab attack
RMB - Slash attack
R - Inspect]]

SWEP.Spawnable = false
SWEP.AdminSpawnable = true

-- Breach specific settings
SWEP.droppable = true
SWEP.teams = {2,3,5,6,7}

SWEP.ViewModel = "models/weapons/salat/reanim/c_s&wch0014.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFOV = 60
SWEP.UseHands = true

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.Weight = 1
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.Slot = 1
SWEP.SlotPos = 2
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true

-- Animation sequences
SWEP.StabAnim = "stab"
SWEP.SlashAnim = "midslash1"
SWEP.InspectAnim = "inspect"
SWEP.DrawAnim = "draw"

-- Attack settings
SWEP.Distance = 50
SWEP.StabDamage = 10
SWEP.SlashDamage = 7

SWEP.Lang = nil

function SWEP:Initialize()
    if CLIENT then
        self.Lang = GetWeaponLang().POCKET_KNIFE
        if self.Lang then
            self.Author = self.Lang.author
            self.Contact = self.Lang.contact
            self.Purpose = self.Lang.purpose
            self.Instructions = self.Lang.instructions
        end
    end
    self:SetHoldType("knife")
    self.AnimCD = 0
end

function SWEP:Deploy()
    self:PlayAnim(self.DrawAnim)
    timer.Simple(0.45, function()
        if IsValid(self) then
            self:EmitSound("Weapon_Knife.Deploy")
        end
    end)
    return true
end

function SWEP:PrimaryAttack()
    if self.AnimCD > CurTime() then return end
    
    local attackCD = self:PlayAnim(self.StabAnim) - 0.2
    self.AnimCD = CurTime() + attackCD
    self:SetNextPrimaryFire(CurTime() + attackCD)
    self:SetNextSecondaryFire(CurTime() + attackCD)
    
    self:GetOwner():SetAnimation(PLAYER_ATTACK1)
    
    timer.Simple(0.1, function()
        if IsValid(self) then
            self:SendDamage(self.StabDamage)
        end
    end)
end

function SWEP:SecondaryAttack()
    if self.AnimCD > CurTime() then return end
    
    local attackCD = self:PlayAnim(self.SlashAnim) - 0.2
    self.AnimCD = CurTime() + attackCD
    self:SetNextPrimaryFire(CurTime() + attackCD)
    self:SetNextSecondaryFire(CurTime() + attackCD)
    
    self:GetOwner():SetAnimation(PLAYER_ATTACK1)
    
    timer.Simple(0.1, function()
        if IsValid(self) then
            self:SendDamage(self.SlashDamage)
        end
    end)
end

function SWEP:Reload()
    if self.AnimCD > CurTime() then return end
    
    local cd = self:PlayAnim(self.InspectAnim)
    self.AnimCD = CurTime() + cd
end

function SWEP:IsSoftEnt(ent)
    return ent:GetMaterialType() == MAT_FLESH
end

function SWEP:SendDamage(dmg)
    local owner = self:GetOwner()
    if not IsValid(owner) then return end
    
    owner:LagCompensation(true)
    
    local trace = owner:GetEyeTrace()
    local hitPos = trace.HitPos
    local attackPos = owner:GetShootPos()
    local distance = hitPos:Distance(attackPos)
    
    if distance <= self.Distance then
        local ent = trace.Entity
        
        if IsValid(ent) and ent.TakeDamageInfo then
            local dmginfo = DamageInfo()
            dmginfo:SetDamage(dmg)
            dmginfo:SetAttacker(owner)
            dmginfo:SetInflictor(self)
            dmginfo:SetDamageType(DMG_SLASH)
            dmginfo:SetDamageForce(owner:GetAimVector() * 100)
            dmginfo:SetDamagePosition(hitPos)
            
            ent:TakeDamageInfo(dmginfo)
            
            if SERVER then
                if self:IsSoftEnt(ent) or ent:IsNPC() or ent:IsPlayer() or ent:IsRagdoll() then
                    owner:EmitSound("weapons/knife/knife_stab.wav", 65, math.random(90, 110))
                else
                    owner:EmitSound("weapons/knife/knife_hitwall1.wav", 65, math.random(90, 110))
                end
            end
        end
    else
        if SERVER then
            owner:EmitSound("Weapon_Knife.Slash", 65, math.random(90, 110))
        end
    end
    
    owner:LagCompensation(false)
end

function SWEP:PlayAnim(seqName)
    local vm = self:GetOwner():GetViewModel()
    if not IsValid(vm) then return 0 end
    
    local seq = vm:LookupSequence(seqName)
    if seq and seq > -1 then
        vm:SendViewModelMatchingSequence(seq)
        return vm:SequenceDuration(seq)
    else
        return 0
    end
end

function SWEP:Holster()
    return true
end

function SWEP:OnRemove()
    return true
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp330_candy.lua
================================================
-- SCP-330 Candy weapon dla gamemode Breach
-- Bazowany na oryginalnym kodzie candy_scp330 z kompatybilnością Breach

AddCSLuaFile()

SWEP.Base = "weapon_base"
SWEP.PrintName = "SCP-330 Candy"
SWEP.Author = "Breach Team"
SWEP.Category = "Breach SCP"
SWEP.Instructions = "Left click to eat candy, Right click to check your candies"

SWEP.Slot = 0
SWEP.SlotPos = 1
SWEP.Spawnable = false
SWEP.AdminOnly = true

SWEP.ViewModel = Model("models/weapons/scp_330/v_scp_330.mdl")
SWEP.WorldModel = Model("models/weapons/scp_330/w_scp_330.mdl")

SWEP.ViewModelFOV = 65
SWEP.HoldType = "slam"
SWEP.UseHands = true

-- Ammo settings
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.AutoSwitch = false

-- Cooldowns
SWEP.PrimaryCD = 1
SWEP.SecondaryCD = 2

-- Candy storage
SWEP.CandyPossessed = {}

function SWEP:Initialize()
    self:SetWeaponHoldType(self.HoldType)
    self:SetHoldType(self.HoldType)
    
    if not self.CandyPossessed then
        self.CandyPossessed = {}
    end
end

function SWEP:PrimaryAttack()
    if #self.CandyPossessed == 0 then return end
    
    local ply = self:GetOwner()
    if not IsValid(ply) then return end
    
    -- Get the last candy (newest)
    local candyIndex = #self.CandyPossessed
    local candyFlavor = self.CandyPossessed[candyIndex]
    
    -- Play animation
    self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
    
    -- Calculate animation duration
    local viewModel = ply:GetViewModel()
    local animDuration = viewModel:SequenceDuration() / viewModel:GetPlaybackRate()
    
    -- Notify player
    if CLIENT then
        ply:ChatPrint("You eat the candy with the taste of " .. candyFlavor .. ".")
    end
    
    -- Set cooldown
    self:SetNextPrimaryFire(CurTime() + animDuration + self.PrimaryCD)
    
    -- Remove candy
    self.CandyPossessed[candyIndex] = nil
    
    -- Delay the removal/deploy animation
    timer.Simple(animDuration, function()
        if not IsValid(self) then return end
        
        if #self.CandyPossessed == 0 then
            -- No more candies, remove weapon
            if SERVER then
                self:Remove()
            end
        else
            -- Still have candies, play deploy animation
            self:PlayDeployAnimation()
        end
    end)
    
    -- Play eating sound
    ply:EmitSound("scp_330/consume_candy.mp3")
    
    -- Heal player by configured amount
    if SERVER then
        local healAmount = SCP330 and SCP330.Config and SCP330.Config.CandyHealAmount or 10
        local currentHP = ply:Health()
        local maxHP = ply:GetMaxHealth()
        local newHP = math.min(currentHP + healAmount, maxHP)
        local actualHeal = newHP - currentHP
        
        ply:SetHealth(newHP)
        
        -- Notify player about healing
        if actualHeal > 0 then
            ply:PrintMessage(HUD_PRINTTALK, "[SCP-330] The candy healed you for " .. actualHeal .. " HP!")
        else
            ply:PrintMessage(HUD_PRINTTALK, "[SCP-330] You are already at full health!")
        end
        
        SCP330:Log("Player " .. ply:Nick() .. " ate a " .. candyFlavor .. " candy and healed " .. actualHeal .. " HP (current: " .. newHP .. "/" .. maxHP .. ")")
    end
end

function SWEP:SecondaryAttack()
    local ply = self:GetOwner()
    if not IsValid(ply) then return end
    
    if CLIENT then
        local candyCount = #self.CandyPossessed
        ply:ChatPrint("You have " .. candyCount .. " candies in your possession.")
        
        for i, flavor in ipairs(self.CandyPossessed) do
            ply:ChatPrint("Candy #" .. i .. ": " .. flavor)
        end
    end
    
    self:SetNextSecondaryFire(CurTime() + self.SecondaryCD)
end

function SWEP:OnDrop()
    -- Remove weapon when dropped (candies are consumed or lost)
    self:Remove()
end

function SWEP:Deploy()
    self:PlayDeployAnimation()
    return true
end

function SWEP:PlayDeployAnimation()
    local ply = self:GetOwner()
    if not IsValid(ply) then return end
    
    local deploySpeed = GetConVarNumber("sv_defaultdeployspeed")
    
    -- Play deploy animation
    self:SendWeaponAnim(ACT_VM_DRAW)
    self:SetPlaybackRate(deploySpeed)
    
    -- Calculate animation duration
    local viewModel = ply:GetViewModel()
    local animDuration = viewModel:SequenceDuration() / viewModel:GetPlaybackRate()
    
    -- Set cooldowns
    self:SetNextPrimaryFire(CurTime() + animDuration + 0.1)
    self:SetNextSecondaryFire(CurTime() + animDuration)
    
    -- Play idle animation after deploy
    timer.Simple(animDuration, function()
        if not IsValid(self) then return end
        self:SendWeaponAnim(ACT_VM_IDLE)
    end)
end

function SWEP:Holster()
    -- Allow holstering
    return true
end

function SWEP:OnRemove()
    -- Clean up any timers or hooks if needed
end

-- Breach compatibility functions
if SERVER then
    function SWEP:AddCandy(flavor)
        if not self.CandyPossessed then
            self.CandyPossessed = {}
        end
        
        table.insert(self.CandyPossessed, flavor)
    end
    
    function SWEP:GetCandyCount()
        return #(self.CandyPossessed or {})
    end
    
    function SWEP:GetCandyFlavors()
        return self.CandyPossessed or {}
    end
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_005.lua
================================================
if CLIENT then
SWEP.DrawWeaponInfoBox	= false
SWEP.BounceWeaponIcon	= false 

SWEP.WepSelectIcon = surface.GetTextureID("vgui/entities/weapon_scp-005") 

language.Add("weapon_scp-005", "SCP-005")
end

SWEP.PrintName = "SCP-005"
SWEP.Category = "SCP: Breach"
SWEP.Spawnable= false
SWEP.AdminSpawnable= false
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 70
SWEP.ViewModel = "models/weapons/c_invisstick2.mdl"
SWEP.WorldModel = "models/weapons/w_pistol.mdl"
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 1
SWEP.UseHands = true

SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 3
SWEP.SlotPos = 1
SWEP.HoldType = "pistol"
SWEP.FiresUnderwater = true
SWEP.DrawCrosshair = true
SWEP.DrawAmmo = true
SWEP.CSMuzzleFlashes = 1
SWEP.Base = "weapon_base"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.Delay = 0.8

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Delay = 1

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(-3.754, 4.111, 11.953), angle = Angle(0, -11.072, 0) }
}

SWEP.VElements = {
	["v_element"] = { type = "Model", model = "models/scp/005/scp005.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(9.958, 3.131, -0.251), angle = Angle(0, 156.085, -93.541), size = Vector(0.8, 0.8, 0.8), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["w_element"] = { type = "Model", model = "models/scp/005/scp005.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(8.206, 1.649, 0), angle = Angle(0, 164.302, -92.001), size = Vector(0.699, 0.699, 0.699), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

function SWEP:Initialize()
	self:SetWeaponHoldType( self.HoldType )
	self:SetHoldType( self.HoldType )
	
	self.Idle = 0
	self.IdleTimer = CurTime() + 1
	
	if CLIENT then
	
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
        self:SetWeaponHoldType( self.HoldType )
		
		self:CreateModels(self.VElements) -- create viewmodels
		self:CreateModels(self.WElements) -- create worldmodels
		
		-- init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				-- Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
	end
end

----------------------------------------------------
if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			-- when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			

			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r -- Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				-- make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			-- !! WORKAROUND !! --
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			-- !! ----------- !! --
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				-- !! WORKAROUND !! --
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				-- !! ----------- !! --
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end


	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v)
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
----------------------------------------------------

function SWEP:Think()
	if self.Idle == 0 and self.IdleTimer <= CurTime() then
		if SERVER then
			self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
		end
		self.Idle = 1
	end
end

-- Funkcja do znajdowania wszystkich części drzwi w pobliżu (skopiowana z Door Controller)
local function GetAllDoorParts(mainDoor, searchRadius)
	if not IsValid(mainDoor) then return {} end
	
	local doorParts = {mainDoor}
	local mainPos = mainDoor:GetPos()
	local searchRange = searchRadius or 20 -- Domyślny zasięg dla SCP-005
	
	-- Znajdź wszystkie entity w pobliżu
	local nearbyEnts = ents.FindInSphere(mainPos, searchRange)
	
	for _, ent in pairs(nearbyEnts) do
		if IsValid(ent) and ent ~= mainDoor then
			local class = ent:GetClass():lower()
			local isDoorEntity = false
			
			-- Sprawdź czy to entity drzwiowe
			if class:find("door") or class == "func_door" or class == "func_door_rotating" or class == "prop_door_rotating" then
				isDoorEntity = true
			elseif ent.IsDoor and ent:IsDoor() then
				isDoorEntity = true
			end
			
			-- Jeśli to część drzwi, dodaj do listy
			if isDoorEntity then
				-- Sprawdź czy już nie ma tego w tablicy
				local alreadyAdded = false
				for _, existingDoor in pairs(doorParts) do
					if existingDoor == ent then
						alreadyAdded = true
						break
					end
				end
				
				if not alreadyAdded then
					table.insert(doorParts, ent)
				end
			end
		end
	end
	
	return doorParts
end

local function GetDoor(ply)
	local tr = ply:GetEyeTrace()
	local ent = tr.Entity

	local maxDist = 70 -- Zasięg SCP-005
	if not IsValid(ent) or tr.HitPos:DistToSqr(ply:GetShootPos()) > maxDist * maxDist then return nil end

	local class = ent:GetClass():lower()
	local mainDoor = nil

	if class:find("door") or class == "func_door" or class == "func_door_rotating" or class == "prop_door_rotating" then
		mainDoor = ent
	elseif ent.IsDoor and ent:IsDoor() then
		mainDoor = ent
	else
		local parent = ent:GetParent()
		if IsValid(parent) then
			local parentClass = parent:GetClass():lower()
			if parentClass:find("door") or parentClass == "func_door" or parentClass == "func_door_rotating" or parentClass == "prop_door_rotating" then
				mainDoor = parent
			elseif parent.IsDoor and parent:IsDoor() then
				mainDoor = parent
			end
		end

		if not mainDoor and (ent:GetClass() == "prop_dynamic" or ent:GetClass() == "prop_physics") then
			local constraints = constraint.GetAllConstrainedEntities(ent)
			for _, constrainedEnt in pairs(constraints) do
				local class = constrainedEnt:GetClass():lower()
				if class:find("door") or constrainedEnt.IsDoor and constrainedEnt:IsDoor() then
					mainDoor = constrainedEnt
					break
				end
			end
		end
	end

	-- Jeśli znaleźliśmy główne drzwi, znajdź wszystkie części
	if mainDoor then
		return GetAllDoorParts(mainDoor)
	end

	return nil
end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire(CurTime()+1)
	
	if CLIENT then return end
	
	local ply = self.Owner
	if not IsValid(ply) then return end
	
	local doorOpened = false
	
	-- Użyj nowego systemu dobierania drzwi
	local doorParts = GetDoor(ply)
	
	if not doorParts or #doorParts == 0 then
		-- Sprawdź czy to przycisk lub prop_dynamic (zachowaj oryginalną funkcjonalność)
		local tr = {}
		tr.start = ply:GetShootPos()
		tr.endpos = ply:GetShootPos() + ( ply:GetAimVector() * 70 )
		tr.filter = ply
		tr.mask = MASK_SHOT_HULL

		local trace = util.TraceLine( tr )
		
		if trace.Hit then
			local v = trace.Entity
			if v:GetClass():find("func_button") then
				self.Weapon:SendWeaponAnim(ACT_VM_HITCENTER)
				self:SetNextPrimaryFire(CurTime()+1)
				v:Input("Unlock")
				v:Input("Use")
				doorOpened = true
			elseif v:GetClass():find("prop_dynamic") then
				if v:GetModel():find("door") or v:GetModel():find("fence") or v:GetModel():find("gate") then
					self.Weapon:SendWeaponAnim(ACT_VM_HITCENTER)
					self:SetNextPrimaryFire(CurTime()+6)
					if v:GetSequence() == 1 or v:GetSequence() == 0 or v:GetSequence() == 3 then
						v:Fire("setanimation","open","0")
						sound.Play("ambient/levels/outland/ol12a_slidergate_open.wav", v:GetPos() + Vector(0,0,30), 75, 100)
					elseif v:GetSequence() == 2 then
						v:Fire("setanimation","close","0")
						sound.Play("ambient/levels/outland/ol12a_slidergate_close.wav", v:GetPos() + Vector(0,0,30), 75, 100)
					end
					sound.Play("plats/hall_elev_door.wav", v:GetPos() + Vector(0,0,30), 75, 100)
					sound.Play("plats/hall_elev_door.wav", v:GetPos() + Vector(0,0,30), 75, 100)
					sound.Play("plats/hall_elev_door.wav", v:GetPos() + Vector(0,0,30), 75, 100)
					sound.Play("plats/hall_elev_door.wav", v:GetPos() + Vector(0,0,30), 75, 100)
					sound.Play("ambient/levels/outland/ol11_blastdoorlatch.wav", v:GetPos() + Vector(0,0,30), 75, 100)
					local noor = v:GetParent()
					if IsValid(noor) then
						noor:Input("Unlock")
						noor:Input("Use")
					end
					doorOpened = true
				end
			end
		end
	else
		-- Otwórz wszystkie części drzwi
		self.Weapon:SendWeaponAnim(ACT_VM_HITCENTER)
		self:SetNextPrimaryFire(CurTime()+1)
		
		for _, door in pairs(doorParts) do
			if IsValid(door) then
				door:Input("Unlock")
				door:Input("Open")
				sound.Play("ambient/levels/outland/ol11_blastdoorlatch.wav", door:GetPos() + Vector(0,0,30), 75, 100)
			end
		end
		doorOpened = true
	end
	
	-- Jeśli drzwi zostały otwarte, zniszcz SCP-005
	if doorOpened then
		timer.Simple(0.5, function()
			if IsValid(self) and IsValid(ply) then
				ply:PrintMessage(HUD_PRINTCENTER, "SCP-005 has been destroyed after use")
				ply:StripWeapon("weapon_scp_005")
			end
		end)
	end
	
	ply:SetAnimation( PLAYER_ATTACK1 )
	self.Idle = 0
	self.IdleTimer = CurTime() + ply:GetViewModel():SequenceDuration()
end

function SWEP:SecondaryAttack()
end

function SWEP:Deploy()
	self:SendWeaponAnim(ACT_VM_DRAW)
	self.Idle = 0
	self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:Holster()
	self.Idle = 0
	self.IdleTimer = CurTime()

	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
			self.Owner:SetFOV( 0, 0.25 )
		end
	end
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

function SWEP:OnDrop()
	self:Holster()
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_018.lua
================================================
if CLIENT then
SWEP.DrawWeaponInfoBox	= false
SWEP.BounceWeaponIcon	= false 

SWEP.WepSelectIcon = surface.GetTextureID("vgui/entities/weapon_scp-018") 

language.Add("weapon_scp_018", "SCP-018")
language.Add("ball_ammo", "Super Ball")
end
AddCSLuaFile()

game.AddAmmoType({name = "ball", maxcarry = 1})

SWEP.PrintName = "SCP-018"
SWEP.Category = "SCP"
SWEP.Spawnable= false
SWEP.AdminSpawnable= false
SWEP.AdminOnly = false

SWEP.droppable = true -- Breach compatibility
SWEP.teams = {2,3,5,6,7} -- Available for all human teams
SWEP.betterone = "weapon_scp_018" -- Doesn't upgrade to anything else

SWEP.ViewModelFOV = 80
SWEP.ViewModel = "models/weapons/c_bugbait.mdl"
SWEP.WorldModel = "models/weapons/w_bugbait.mdl"
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 1
SWEP.UseHands = true

SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 3
SWEP.SlotPos = 1
SWEP.HoldType = "grenade"
SWEP.FiresUnderwater = true
SWEP.DrawCrosshair = true
SWEP.DrawAmmo = true
SWEP.CSMuzzleFlashes = 1
SWEP.Base = "weapon_base"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false

SWEP.Primary.ClipSize = 1
SWEP.Primary.DefaultClip = 1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "ball"
SWEP.Primary.Delay = 0.8

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Delay = 1

SWEP.ViewModelBoneMods = {
	["ValveBiped.cube1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.cube2"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.cube3"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.cube"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["v_element"] = { type = "Model", model = "models/SCP_Secret_Lab/SCP-018.mdl", bone = "ValveBiped.cube3", rel = "", pos = Vector(-0.565, 2.45, -1.729), angle = Angle(42.755, -102.52, 0), size = Vector(1.2, 1.2, 1.2), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["w_element"] = { type = "Model", model = "models/SCP_Secret_Lab/SCP-018.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.726, 1.968, -1.732), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().SCP_018 or {}
		self.Author		= self.Lang.author or "Unknown"
		self.Contact		= self.Lang.contact or ""
		self.Purpose		= self.Lang.purpose or "Super bouncy ball"
		self.Instructions	= self.Lang.instructions or "Primary: Throw the ball"
	end
	
	self:SetWeaponHoldType( self.HoldType )
	self:SetHoldType( self.HoldType )
	
	self.Idle = 0
	self.IdleTimer = CurTime() + 1
	
	if CLIENT then
	
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
        self:SetWeaponHoldType( self.HoldType )
		
		self:CreateModels(self.VElements) -- create viewmodels
		self:CreateModels(self.WElements) -- create worldmodels
		
		-- init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				-- Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
	end
end

----------------------------------------------------
if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			-- when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			

			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r -- Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				-- make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			-- !! WORKAROUND !! --
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			-- !! ----------- !! --
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				-- !! WORKAROUND !! --
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				-- !! ----------- !! --
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end


	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v)
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
----------------------------------------------------

function SWEP:Think()
	if self.Idle == 0 and self.IdleTimer <= CurTime() then
		if SERVER then
			self.Weapon:SendWeaponAnim( ACT_SLAM_STICKWALL_IDLE )
		end
		self.Idle = 1
	end
end

function SWEP:PrimaryAttack()
	-- Breach compatibility - check if player can attack
	if IsValid(self.Owner) and self.Owner:IsPlayer() then
		if self.Owner:GTeam() == TEAM_SPEC then return end
		if self.Owner:GetNClass() == ROLES.ROLE_SCP173 and self.Owner.isblinking then return end
	end
	
	self:SetNextPrimaryFire(CurTime()+1)
	
	self:TakePrimaryAmmo(1)
	
	if SERVER then
		if self:Ammo1() == 0 then self:Remove() end
		
		local Forward = self.Owner:EyeAngles():Forward()
		local Up = self.Owner:EyeAngles():Up()

		local ent = ents.Create( "ent_scp_018" )
		if ( IsValid( ent ) ) then

			ent:SetPos( self.Owner:GetShootPos() + Forward * 20 + Up * - 15 )
			ent:SetAngles( self.Owner:EyeAngles() )
			ent:Spawn()
			--ent:SetOwner(self.Owner)
			ent:SetNWEntity("BallOwner", self.Owner )
			--ent:EmitSound( "qe_weaponry_rocketcrowbar.missile" )
			ent:NextThink(CurTime())
			
			local phys = ent:GetPhysicsObject()
			if ( IsValid( phys ) ) then
				local velocity = self.Owner:GetAimVector()
				velocity = velocity * 500 + Up * 100
				velocity = velocity + (VectorRand() * 10) 
				phys:SetMass(5)
				phys:SetVelocity( velocity )
				phys:AddAngleVelocity(Vector(math.random(-10,10),math.random(-10,10),math.random(-10,10))*10)
			end
		end
	end
	
	self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	self.Owner:SetAnimation( PLAYER_ATTACK1 )
	
	self.Idle = 0
	self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:SecondaryAttack()
end

function SWEP:Deploy()
	self:SendWeaponAnim(ACT_SLAM_DETONATOR_THROW_DRAW)
	self.Idle = 0
	self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:Holster()
	self.Idle = 0
	self.IdleTimer = CurTime()

	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
			self.Owner:SetFOV( 0, 0.25 )
		end
	end
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

function SWEP:OnDrop()
	self:Holster()
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_023.lua
================================================
AddCSLuaFile()

SWEP.Base 			= "weapon_scp_base"
SWEP.PrintName		= "SCP-023"
SWEP.DrawCrosshair	= true
SWEP.HoldType 		= "normal"

SWEP.Primary.Sound			= "scp/023/attack.mp3"
SWEP.Primary.Delay			= 1.0
SWEP.Secondary.Automatic 	= false

-- Cooldowny
SWEP.MarkCooldown = 180 -- 3 minuty cooldown na oznaczenie
SWEP.DashCooldown = 15 -- 15 sekund cooldown na dash

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_023" )
	self:SetHoldType( self.HoldType )
	
	-- Inicjalizacja zmiennych
	self.NextMark = 0
	self.NextDash = 0
	self.MarkedPlayer = nil
	self.MarkedDeathTime = 0
	self.CurrentMarkedName = ""
	
	if SERVER then
		local hookID = "SCP023_" .. self:EntIndex()
		
		-- Hook na śmierć gracza
		hook.Add("PlayerDeath", "Death_" .. hookID, function(victim, inflictor, attacker)
			-- Sprawdź czy oznaczony gracz zabił kogoś - może się uratować
			if IsValid(self) and IsValid(self.MarkedPlayer) and IsValid(attacker) and attacker == self.MarkedPlayer and victim != self.MarkedPlayer then
				-- Oznaczony gracz zabił kogoś innego - ratuje się!
				net.Start("SCP023_MarkRemoved")
				net.Send(self.MarkedPlayer)
				
				-- Usuń oznaczenie
				self.MarkedPlayer = nil
				self.MarkedDeathTime = 0
				self.CurrentMarkedName = ""
				-- NIE resetuj cooldownu - SCP-023 musi czekać
				self:UpdateMarkedList()
				
				-- Efekt dźwiękowy ratowania
				attacker:EmitSound("buttons/button14.wav", 75, 150)
				return
			end
			
			-- Standardowa śmierć oznaczonego gracza
			if IsValid(self) and IsValid(self.MarkedPlayer) and victim == self.MarkedPlayer then
				-- Konkretnie oznaczony gracz umarł, zresetuj cooldown
				self.MarkedPlayer = nil
				self.MarkedDeathTime = 0
				self.CurrentMarkedName = ""
				self.NextMark = 0
				self:UpdateMarkedList()
			end
		end)
		
		-- Hook na disconnect gracza
		hook.Add("PlayerDisconnected", "Disconnect_" .. hookID, function(ply)
			if IsValid(self) and IsValid(self.MarkedPlayer) and ply == self.MarkedPlayer then
				-- Gracz oznaczony się rozłączył, zresetuj cooldown
				self.MarkedPlayer = nil
				self.MarkedDeathTime = 0
				self.CurrentMarkedName = ""
				self.NextMark = 0
				self:UpdateMarkedList()
			end
		end)
	end
end

function SWEP:OnRemove()
	if SERVER then
		local hookID = "SCP023_" .. self:EntIndex()
		hook.Remove("PlayerDeath", "Death_" .. hookID)
		hook.Remove("PlayerDisconnected", "Disconnect_" .. hookID)
	end
end

function SWEP:Deploy()
	self:HideModels()

	if SERVER then
		-- Ustaw prędkość na 200
		self.Owner:SetWalkSpeed(200)
		self.Owner:SetRunSpeed(200)
	end
end

SWEP.NextSpec = 0
function SWEP:Think()
	self:PlayerFreeze()
	if !SERVER then return end
	
	-- Sprawdzanie oznaczonego gracza
	if self.NextSpec > CurTime() then return end
	self.NextSpec = CurTime() + 0.1
	
	-- Sprawdź oznaczonego gracza
	if IsValid(self.MarkedPlayer) then
		-- Sprawdź czy gracz nadal jest valid i żywy
		if !self.MarkedPlayer:Alive() or self.MarkedPlayer:GTeam() == TEAM_SCP or self.MarkedPlayer:GTeam() == TEAM_SPEC then
			-- Gracz nie żyje lub zmienił team - usuń z listy i zresetuj cooldown
			self.MarkedPlayer = nil
			self.MarkedDeathTime = 0
			self.CurrentMarkedName = ""
			self.NextMark = 0 -- Reset cooldown
			self:UpdateMarkedList()
		elseif self.MarkedDeathTime > 0 and self.MarkedDeathTime <= CurTime() then
			-- Czas minął, zabij konkretnego gracza
			-- Najpierw efekt dźwiękowy (przed zabiciem)
			if IsValid(self.MarkedPlayer) then
				self.MarkedPlayer:EmitSound("ambient/fire/ignite.wav", 75, 50)
			end
			
			-- Teraz zabij gracza
			local dmginfo = DamageInfo()
			dmginfo:SetDamage(9999)
			dmginfo:SetAttacker(self.Owner)
			dmginfo:SetInflictor(self)
			dmginfo:SetDamageType(DMG_DIRECT)
			self.MarkedPlayer:TakeDamageInfo(dmginfo)
			
			-- Daj exp właścicielowi
			if IsValid(self.Owner) then
				self.Owner:AddExp(250, true)
			end
			
			-- Usuń z listy (bez resetu cooldownu)
			self.MarkedPlayer = nil
			self.MarkedDeathTime = 0
			self.CurrentMarkedName = ""
			
			-- Wyślij aktualizację do klienta
			self:UpdateMarkedList()
		end
	end
end

SWEP.NextPrimary = 0
function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextPrimary > CurTime() then return end
	self.NextPrimary = CurTime() + self.Primary.Delay
	
	self:EmitSound( self.Primary.Sound )
	
	if !SERVER then return end
	
	local trace = util.TraceHull( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 45,
		filter = self.Owner,
		mask = MASK_SHOT,
		maxs = Vector( 6, 6, 6 ),
		mins = Vector( -6, -6, -6 ),
	} )
	
	local ent = trace.Entity
	if IsValid( ent ) then
		if ent:IsPlayer() then
			if ent:GTeam() == TEAM_SPEC then return end
			if ent:GTeam() == TEAM_SCP and ent:GetNClass() != ROLES.ROLE_SCP035 then return end
			ent:TakeDamage( math.random( 10, 20 ), self.Owner, self.Owner )
		else
			self:SCPDamageEvent( ent, 10 )
		end
	end
end

-- PPM - Oznaczenie gracza do śmierci
function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextMark > CurTime() then return end
	
	if !SERVER then return end
	
	local trace = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 2000,
		filter = self.Owner,
		mask = MASK_SHOT
	} )
	
	local ent = trace.Entity
	if IsValid( ent ) and ent:IsPlayer() then
		if ent:GTeam() == TEAM_SPEC then return end
						if ent:GTeam() == TEAM_SCP and ent:GetNClass() != ROLES.ROLE_SCP035 then return end
		
		-- Oznacz gracza
		self.NextMark = CurTime() + self.MarkCooldown
		
		-- Zapisz gracza
		self.MarkedPlayer = ent
		self.MarkedDeathTime = CurTime() + 120 -- 2 minuty
		self.CurrentMarkedName = ent:Nick()
		
		-- Efekty
		ent:EmitSound("ambient/atmosphere/cave_hit5.wav", 75, 100)
		self.Owner:EmitSound("npc/scanner/scanner_photo1.wav", 75, 100)
		
		-- Powiadom gracza że został oznaczony
		net.Start("SCP023_MarkedForDeath")
			net.WriteFloat(self.MarkedDeathTime) -- Wyślij czas śmierci
		net.Send(ent)
		
		-- Aktualizuj listę oznaczonych dla HUD
		self:UpdateMarkedList()
	end
end

-- Klawisz R - Dash
function SWEP:Reload()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextDash > CurTime() then return end
	
	self.NextDash = CurTime() + self.DashCooldown
	
	if SERVER then
		-- Dash do przodu z większą siłą
		local forward = self.Owner:GetAimVector()
		forward.z = 0
		forward:Normalize()
		
		-- Dodaj siłę poziomą i pionową
		local vel = forward * 1500 + Vector(0, 0, 400)
		
		self.Owner:SetVelocity(vel)
		
		-- Efekt cząsteczkowy
		local effectdata = EffectData()
		effectdata:SetOrigin(self.Owner:GetPos())
		effectdata:SetNormal(self.Owner:GetAimVector())
		effectdata:SetScale(1)
		util.Effect("ManhackSparks", effectdata)
	end
	
	return false -- Zapobiega przeładowaniu
end

-- Aktualizacja listy oznaczonych graczy
function SWEP:UpdateMarkedList()
	if !SERVER then return end
	
	net.Start("SCP023_UpdateMarked")
		net.WriteEntity(self)
		net.WriteFloat(self.NextMark)
		net.WriteString(self.CurrentMarkedName)
		net.WriteFloat(self.MarkedDeathTime)
	net.Send(self.Owner)
end

-- Client-side
if CLIENT then
	-- Hook na śmierć gracza - usuń timer
	hook.Add("PlayerDeath", "SCP023_RemoveTimerOnDeath", function(victim, inflictor, attacker)
		if victim == LocalPlayer() and LocalPlayer().SCP023_DeathTime then
			-- Usuń timer i oznaczenie
			LocalPlayer().SCP023_DeathTime = nil
			hook.Remove("HUDPaint", "SCP023_DeathWarning")
		end
	end)
	
	-- Odbieranie informacji o oznaczeniu
	net.Receive("SCP023_MarkedForDeath", function()
		local deathTime = net.ReadFloat()
		
		LocalPlayer():PrintMessage(HUD_PRINTTALK, "You have been marked for death by SCP-023! Kill someone within 2 minutes to save yourself!")
		surface.PlaySound("ambient/alarms/warningbell1.wav")
		
		-- Zapisz czas śmierci globalnie dla gracza
		LocalPlayer().SCP023_DeathTime = deathTime
		
		-- Pokaż większe ostrzeżenie z licznikiem
		hook.Add("HUDPaint", "SCP023_DeathWarning", function()
			-- Sprawdź czy gracz nadal jest oznaczony i żywy
			if not LocalPlayer().SCP023_DeathTime or not LocalPlayer():Alive() then
				hook.Remove("HUDPaint", "SCP023_DeathWarning")
				LocalPlayer().SCP023_DeathTime = nil
				return
			end
			
			local timeLeft = LocalPlayer().SCP023_DeathTime - CurTime()
			if timeLeft <= 0 then
				hook.Remove("HUDPaint", "SCP023_DeathWarning")
				LocalPlayer().SCP023_DeathTime = nil
				return
			end
			
			-- Główny tekst
			local text = "MARKED FOR DEATH - KILL TO SURVIVE!"
			surface.SetFont("DermaLarge")
			local tw, th = surface.GetTextSize(text)
			local x, y = ScrW()/2 - tw/2, ScrH()/2 - 100
			
			-- Pulsujący efekt
			local pulse = math.sin(CurTime() * 4) * 0.5 + 0.5
			local alpha = 150 + pulse * 105
			
			-- Tło dla głównego tekstu
			surface.SetDrawColor(0, 0, 0, alpha * 0.8)
			surface.DrawRect(x - 10, y - 5, tw + 20, th + 10)
			
			-- Główny tekst
			surface.SetTextColor(255, 50 + pulse * 205, 50, alpha)
			surface.SetTextPos(x, y)
			surface.DrawText(text)
			
			-- LICZNIK CZASU
			local timerText = string.format("TIME LEFT: %d:%02d", math.floor(timeLeft / 60), math.floor(timeLeft % 60))
			surface.SetFont("DermaLarge")
			local timerW, timerH = surface.GetTextSize(timerText)
			local timerX, timerY = ScrW()/2 - timerW/2, y + th + 20
			
			-- Kolor zależny od czasu
			local timerColor = Color(255, 255, 255, 255)
			if timeLeft < 30 then
				-- Czerwony gdy mało czasu
				timerColor = Color(255, 50, 50, 255)
			elseif timeLeft < 60 then
				-- Żółty gdy średnio czasu
				timerColor = Color(255, 255, 50, 255)
			end
			
			-- Tło dla licznika
			surface.SetDrawColor(0, 0, 0, 200)
			surface.DrawRect(timerX - 10, timerY - 5, timerW + 20, timerH + 10)
			
			-- Obramowanie licznika
			surface.SetDrawColor(timerColor.r, timerColor.g, timerColor.b, 255)
			surface.DrawOutlinedRect(timerX - 10, timerY - 5, timerW + 20, timerH + 10)
			
			-- Tekst licznika
			surface.SetTextColor(timerColor.r, timerColor.g, timerColor.b, 255)
			surface.SetTextPos(timerX, timerY)
			surface.DrawText(timerText)
			
			-- Dodatkowy pasek postępu
			local barY = timerY + timerH + 15
			local barWidth = 300
			local barHeight = 10
			local barX = ScrW()/2 - barWidth/2
			
			-- Tło paska
			surface.SetDrawColor(50, 50, 50, 200)
			surface.DrawRect(barX, barY, barWidth, barHeight)
			
			-- Pasek postępu
			local progress = timeLeft / 120 -- 120 sekund = 2 minuty
			surface.SetDrawColor(timerColor.r, timerColor.g, timerColor.b, 255)
			surface.DrawRect(barX, barY, barWidth * progress, barHeight)
			
			-- Obramowanie paska
			surface.SetDrawColor(100, 100, 100, 255)
			surface.DrawOutlinedRect(barX, barY, barWidth, barHeight)
		end)
		
		-- Nie usuwaj automatycznie - hook sam się usunie gdy czas się skończy
	end)
	
	-- Odbieranie informacji o usunięciu oznaczenia
	net.Receive("SCP023_MarkRemoved", function()
		LocalPlayer():PrintMessage(HUD_PRINTTALK, "You have been saved! The mark of death has been lifted!")
		surface.PlaySound("buttons/button9.wav")
		
		-- Usuń oznaczenie i ostrzeżenie
		LocalPlayer().SCP023_DeathTime = nil
		hook.Remove("HUDPaint", "SCP023_DeathWarning")
		
		-- Pokaż komunikat o ocaleniu
		hook.Add("HUDPaint", "SCP023_SavedNotice", function()
			local text = "YOU HAVE BEEN SAVED!"
			surface.SetFont("DermaLarge")
			local tw, th = surface.GetTextSize(text)
			local x, y = ScrW()/2 - tw/2, ScrH()/2 - 100
			
			-- Zielony tekst
			surface.SetTextColor(50, 255, 50, 255)
			surface.SetTextPos(x, y)
			surface.DrawText(text)
		end)
		
		timer.Simple(3, function()
			hook.Remove("HUDPaint", "SCP023_SavedNotice")
		end)
	end)
	
	-- Odbieranie listy oznaczonych graczy
	net.Receive("SCP023_UpdateMarked", function()
		local wep = net.ReadEntity()
		if !IsValid(wep) then return end
		
		wep.NextMark = net.ReadFloat()
		wep.CurrentMarkedName = net.ReadString()
		wep.MarkedDeathTime = net.ReadFloat()
	end)
end

function SWEP:DrawHUD()
	if disablehud == true then return end
	
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD (tak jak w SCP-069)
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-023")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-023")
	
	-- Cooldowny (wszystkie w jednej linii: LMB, R, PPM)
	local cooldownY = hudY + 60
	local barWidth = 120
	local barHeight = 8
	local totalWidth = barWidth * 3 + 60 -- 3 paski + odstępy
	local startX = centerX - totalWidth / 2
	
	-- LMB (Bite) Cooldown - pierwszy
	local lpmBarX = startX
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lpmBarX, cooldownY - 15)
	surface.DrawText("LMB - Bite")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lpmBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lpmBarX, cooldownY, barWidth, barHeight)
	
	local lpmCooldown = 0
	if self.NextPrimary and self.NextPrimary > CurTime() then
		lpmCooldown = self.NextPrimary - CurTime()
	end
	
	if lpmCooldown > 0 then
		local progress = 1 - (lpmCooldown / self.Primary.Delay)
		surface.SetDrawColor(255, 100, 100, 255)
		surface.DrawRect(lpmBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(lpmBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", lpmCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(lpmBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(lpmBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- R (Dash) - środkowy
	local dashBarX = startX + barWidth + 30
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(dashBarX, cooldownY - 15)
	surface.DrawText("R - Dash")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(dashBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(dashBarX, cooldownY, barWidth, barHeight)
	
	local dashCooldown = 0
	if self.NextDash and self.NextDash > CurTime() then
		dashCooldown = self.NextDash - CurTime()
	end
	
	if dashCooldown > 0 then
		local progress = 1 - (dashCooldown / self.DashCooldown)
		surface.SetDrawColor(100, 200, 255, 255)
		surface.DrawRect(dashBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 200, 255, 255)
		surface.SetTextPos(dashBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", dashCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(dashBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(dashBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- RMB (Mark) Cooldown - trzeci
	local ppmBarX = startX + (barWidth + 30) * 2
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(ppmBarX, cooldownY - 15)
	surface.DrawText("RMB - Mark")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(ppmBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(ppmBarX, cooldownY, barWidth, barHeight)
	
	local markCooldown = 0
	if self.NextMark and self.NextMark > CurTime() then
		markCooldown = self.NextMark - CurTime()
	end
	
	if markCooldown > 0 then
		local progress = 1 - (markCooldown / self.MarkCooldown)
		surface.SetDrawColor(255, 215, 0, 255)
		surface.DrawRect(ppmBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 255, 150, 255)
		surface.SetTextPos(ppmBarX, cooldownY + 10)
		surface.DrawText(string.format("%.0fs", markCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(ppmBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(ppmBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- Informacja o oznaczonym graczu z timerem (na dole HUD-u po środku)
	if self.CurrentMarkedName and self.CurrentMarkedName != "" then
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 215, 0, 255)
		
		local timeLeft = 0
		if self.MarkedDeathTime and self.MarkedDeathTime > CurTime() then
			timeLeft = self.MarkedDeathTime - CurTime()
		end
		
		local markedText = string.format("Marked: %s - %ds", self.CurrentMarkedName, math.ceil(timeLeft))
		local tw, th = surface.GetTextSize(markedText)
		surface.SetTextPos(centerX - tw/2, hudY + hudHeight - 20)
		surface.DrawText(markedText)
	end
	
	-- Celownik
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	
	local scale = 0.3
	surface.SetDrawColor( 255, 0, 0, 255 )
	
	local gap = 5
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )
end

if SERVER then
	util.AddNetworkString("SCP023_UpdateMarked")
	util.AddNetworkString("SCP023_MarkedForDeath")
	util.AddNetworkString("SCP023_MarkRemoved")
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_049.lua
================================================
AddCSLuaFile()

SWEP.Base 		= "weapon_scp_base"
SWEP.PrintName	= "SCP-049 Rework"
SWEP.HoldType	= "normal"

SWEP.AttackDelay			= 3
SWEP.NextAttackW			= 0
SWEP.GasCooldown			= 60 -- Cooldown dla gazu w sekundach (1 minuta)
SWEP.GasDuration			= 10 -- Czas trwania gazu
SWEP.GasRadius				= 300 -- Promień gazu

-- Typy zombie
SWEP.ZombieTypes = {
	{
		name = "Normal Zombie",
		model = "models/player/zombie_classic.mdl",
		health = 750,
		speed = 180,
		color = Color(100, 255, 100)
	},
	{
		name = "Fast Zombie", 
		model = "models/player/zombie_fast.mdl",
		health = 500,
		speed = 280,
		color = Color(255, 100, 100)
	},
	{
		name = "Heavy Zombie",
		model = "models/player/zombie_soldier.mdl", 
		health = 1000,
		speed = 120,
		color = Color(100, 100, 255)
	}
}

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_049" )
	self:SetHoldType( self.HoldType )
	
	self.CurrentZombieType = 1
	self.NextGas = 0
	self.NextModeSwitch = 0
	self.ActiveGases = {}
	
	-- Networking
	if SERVER then
		util.AddNetworkString("SCP049_UpdateZombieType")
		util.AddNetworkString("SCP049_UpdateGas")
		util.AddNetworkString("SCP049_CreateGas")
	end
	
	if CLIENT then
		self.WepSelectIcon = surface.GetTextureID("breach/wep_049")
		self.GasParticles = {}
	end
	
	-- Dźwięki
	for i=0, 4 do
		sound.Add({
			name = "attack"..i,
			channel = CHAN_STATIC,
			volume = 1.0,
			level = 130,
			pitch = 100,
			sound = "scp/049/attack"..i..".ogg"
		})
	end
end

-- LMB - Zarażenie żywych graczy
function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextAttackW > CurTime() then return end
	
	self.NextAttackW = CurTime() + self.AttackDelay
	
	if SERVER then
		self.Owner:EmitSound("attack"..math.random(0, 4))
		
		local tr = util.TraceHull({
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + (self.Owner:GetAimVector() * 100),
			filter = self.Owner,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			mask = MASK_SHOT_HULL
		})
		
		local ent = tr.Entity
		
		-- Zarażenie żywego gracza
		if IsValid(ent) and ent:IsPlayer() then
			if (ent:GTeam() == TEAM_SCP and ent:GetNClass() != ROLES.ROLE_SCP035) or ent:GTeam() == TEAM_SPEC then return end
			if ent.Using714 then return end
			
			-- Zamień w wybrany typ zombie
			local zombieType = self.ZombieTypes[self.CurrentZombieType]
			local scp = GetSCP("SCP0492")
			
			if scp then
				scp:SetupPlayer(ent)
				
				-- Ustaw parametry zombie
				timer.Simple(0.1, function()
					if IsValid(ent) and ent:Alive() then
						-- Ustaw model
						ent:SetModel(zombieType.model)
						
						-- Ustaw HP
						ent:SetHealth(zombieType.health)
						ent:SetMaxHealth(zombieType.health)
						
						-- Ustaw prędkość (walk speed = run speed)
						ent:SetRunSpeed(zombieType.speed)
						ent:SetWalkSpeed(zombieType.speed)
						
						-- Dodaj identyfikator typu
						ent.ZombieType = self.CurrentZombieType
						
						-- Upewnij się, że gracz jest aktywny (naprawia widoczność nicku)
						ent:SetNActive(true)
						ent.ActivePlayer = true
					end
				end)
			end
			
			self.Owner:AddExp(200, true)
			roundstats.zombies = roundstats.zombies + 1
		elseif IsValid(ent) then
			-- Większe obrażenia dla szyb
			if ent:GetClass() == "func_breakable" then
				self:SCPDamageEvent(ent, 100)
			else
				self:SCPDamageEvent(ent, 10)
			end
		end
	end
end

-- PPM - Gaz trujący
function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextGas > CurTime() then return end
	
	if SERVER then
		self.NextGas = CurTime() + self.GasCooldown
		
		-- Stwórz chmurę gazu
		local gasPos = self.Owner:GetPos()
		local gasData = {
			pos = gasPos,
			endtime = CurTime() + self.GasDuration,
			owner = self.Owner
		}
		
		table.insert(self.ActiveGases, gasData)
		
		-- Wyślij do klientów
		net.Start("SCP049_CreateGas")
			net.WriteEntity(self)
			net.WriteVector(gasPos)
			net.WriteFloat(self.GasDuration)
		net.Broadcast()
		
		-- Stwórz entity dla dźwięku gazu
		local soundEnt = ents.Create("info_target")
		soundEnt:SetPos(gasPos)
		soundEnt:Spawn()
		soundEnt:EmitSound("ambient/gas/steam2.wav", 75, 80)
		gasData.soundEnt = soundEnt
		
		-- Usuń dźwięk po zakończeniu gazu
		timer.Simple(self.GasDuration, function()
			if IsValid(soundEnt) then
				soundEnt:StopSound("ambient/gas/steam2.wav")
				soundEnt:Remove()
			end
		end)
		
		-- Timer do sprawdzania graczy w gazie
		local timerID = "SCP049_Gas_" .. self:EntIndex() .. "_" .. #self.ActiveGases
		timer.Create(timerID, 0.5, self.GasDuration * 2, function()
			if not IsValid(self) or not IsValid(self.Owner) then
				timer.Remove(timerID)
				return
			end
			
			-- Sprawdź czy gaz nadal aktywny
			if CurTime() > gasData.endtime then
				timer.Remove(timerID)
				return
			end
			
			-- Znajdź graczy w zasięgu
			for _, ply in pairs(player.GetAll()) do
				if IsValid(ply) and ply:Alive() and ply:GTeam() != TEAM_SCP and ply:GTeam() != TEAM_SPEC then
					local dist = ply:GetPos():Distance(gasPos)
					if dist <= self.GasRadius then
						-- Zadaj obrażenia
						local dmg = DamageInfo()
						dmg:SetDamage(5)
						dmg:SetAttacker(self.Owner)
						dmg:SetInflictor(self)
						dmg:SetDamageType(DMG_POISON)
						ply:TakeDamageInfo(dmg)
						
						-- Spowolnij gracza
						if not ply.GasSlowed then
							ply.GasSlowed = true
							ply.OriginalSpeed = ply:GetRunSpeed()
							ply:SetRunSpeed(ply.OriginalSpeed * 0.5)
							ply:SetWalkSpeed(ply:GetWalkSpeed() * 0.5)
							
							-- Przywróć prędkość po wyjściu z gazu
							timer.Create("GasRestore_" .. ply:SteamID(), 2, 1, function()
								if IsValid(ply) then
									ply:SetRunSpeed(ply.OriginalSpeed or 240)
									ply:SetWalkSpeed((ply.OriginalSpeed or 240) * 0.5)
									ply.GasSlowed = false
								end
							end)
						else
							-- Odśwież timer
							timer.Adjust("GasRestore_" .. ply:SteamID(), 2)
						end
					end
				end
			end
		end)
		
		-- Wyślij update cooldownu
		self:UpdateGas()
	end
end

-- R - Zmiana trybu zombie
function SWEP:Reload()
	if not IsFirstTimePredicted() then return end
	if self.NextModeSwitch > CurTime() then return end
	
	self.NextModeSwitch = CurTime() + 0.5
	
	if SERVER then
		-- Przełącz na następny typ
		self.CurrentZombieType = self.CurrentZombieType + 1
		if self.CurrentZombieType > #self.ZombieTypes then
			self.CurrentZombieType = 1
		end
		
		-- Dźwięk przełączenia - wyłączony
		-- self.Owner:EmitSound("buttons/button14.wav", 65, 100)
		
		-- Wyślij update do klienta
		net.Start("SCP049_UpdateZombieType")
			net.WriteEntity(self)
			net.WriteUInt(self.CurrentZombieType, 8)
		net.Send(self.Owner)
	end
end

-- Server: Aktualizacje
if SERVER then
	function SWEP:UpdateGas()
		net.Start("SCP049_UpdateGas")
			net.WriteEntity(self)
			net.WriteFloat(self.NextGas)
		net.Send(self.Owner)
	end
	
	function SWEP:Think()
		-- Czyszczenie nieaktywnych gazów
		for i = #self.ActiveGases, 1, -1 do
			if CurTime() > self.ActiveGases[i].endtime then
				table.remove(self.ActiveGases, i)
			end
		end
	end
end

-- Client: Odbieranie aktualizacji
if CLIENT then
	net.Receive("SCP049_UpdateZombieType", function()
		local wep = net.ReadEntity()
		local zombieType = net.ReadUInt(8)
		
		if IsValid(wep) then
			wep.CurrentZombieType = zombieType
		end
	end)
	
	net.Receive("SCP049_UpdateGas", function()
		local wep = net.ReadEntity()
		local nextGas = net.ReadFloat()
		
		if IsValid(wep) then
			wep.NextGas = nextGas
		end
	end)
	
	net.Receive("SCP049_CreateGas", function()
		local wep = net.ReadEntity()
		local pos = net.ReadVector()
		local duration = net.ReadFloat()
		
		-- Stwórz globalny efekt gazu widoczny dla wszystkich
		local gas = {
			pos = pos,
			endtime = CurTime() + duration,
			emitter = ParticleEmitter(pos),
			radius = 300 -- Promień gazu
		}
		
		-- Dodaj do globalnej tablicy gazów
		SCP049_ActiveGases = SCP049_ActiveGases or {}
		table.insert(SCP049_ActiveGases, gas)
	end)
	
	-- Hook do rysowania gazu dla wszystkich graczy
	hook.Add("PostDrawTranslucentRenderables", "SCP049_DrawGas", function()
		if not SCP049_ActiveGases then return end
		
		-- Rysuj wszystkie aktywne gazy
		for i = #SCP049_ActiveGases, 1, -1 do
			local gas = SCP049_ActiveGases[i]
			
			if CurTime() > gas.endtime then
				if gas.emitter then
					gas.emitter:Finish()
				end
				table.remove(SCP049_ActiveGases, i)
			else
				-- Rysuj cząsteczki gazu
				if gas.emitter then
					local particle = gas.emitter:Add("particle/smokesprites_0001", gas.pos + Vector(math.random(-gas.radius, gas.radius), math.random(-gas.radius, gas.radius), math.random(0, 50)))
					if particle then
						particle:SetVelocity(Vector(math.random(-20, 20), math.random(-20, 20), math.random(10, 30)))
						particle:SetDieTime(3)
						particle:SetStartAlpha(100)
						particle:SetEndAlpha(0)
						particle:SetStartSize(50)
						particle:SetEndSize(100)
						particle:SetRoll(math.random(0, 360))
						particle:SetRollDelta(math.random(-0.5, 0.5))
						particle:SetColor(100, 200, 100)
						particle:SetAirResistance(50)
						particle:SetGravity(Vector(0, 0, -20))
					end
				end
			end
		end
	end)
end

-- HUD
function SWEP:DrawHUD()
	if disablehud == true then return end
	
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD (tak jak w SCP-023)
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-049")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-049")
	
	-- Pobierz typ zombie dla późniejszego użycia
	local zombieType = self.ZombieTypes[self.CurrentZombieType]
	
	-- Cooldowny (wszystkie w jednej linii: LMB, R, RMB)
	local cooldownY = hudY + 60
	local barWidth = 120
	local barHeight = 8
	local totalWidth = barWidth * 3 + 60 -- 3 paski + odstępy
	local startX = centerX - totalWidth / 2
	
	-- LMB (Infect) Cooldown - pierwszy
	local lmbBarX = startX
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lmbBarX, cooldownY - 15)
	surface.DrawText("LMB - Infect")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
	
	local attackCooldown = 0
	if self.NextAttackW and self.NextAttackW > CurTime() then
		attackCooldown = self.NextAttackW - CurTime()
	end
	
	if attackCooldown > 0 then
		local progress = 1 - (attackCooldown / self.AttackDelay)
		surface.SetDrawColor(255, 100, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", attackCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- R (Mode) - środkowy
	local modeBarX = startX + barWidth + 30
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(modeBarX, cooldownY - 15)
	surface.DrawText("R - Mode")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(modeBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(modeBarX, cooldownY, barWidth, barHeight)
	
	-- Mode zawsze gotowy
	surface.SetDrawColor(zombieType.color.r, zombieType.color.g, zombieType.color.b, 255)
	surface.DrawRect(modeBarX, cooldownY, barWidth, barHeight)
	
	surface.SetFont("DermaDefault")
	surface.SetTextColor(255, 255, 255, 255)
	surface.SetTextPos(modeBarX, cooldownY + 10)
	surface.DrawText("SWITCH")
	
	-- RMB (Gas) Cooldown - trzeci
	local gasBarX = startX + (barWidth + 30) * 2
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(gasBarX, cooldownY - 15)
	surface.DrawText("RMB - Gas")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(gasBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(gasBarX, cooldownY, barWidth, barHeight)
	
	local gasCooldown = 0
	if self.NextGas and self.NextGas > CurTime() then
		gasCooldown = self.NextGas - CurTime()
	end
	
	if gasCooldown > 0 then
		local progress = 1 - (gasCooldown / self.GasCooldown)
		surface.SetDrawColor(255, 255, 0, 255) -- Żółty kolor podczas cooldownu
		surface.DrawRect(gasBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 255, 150, 255)
		surface.SetTextPos(gasBarX, cooldownY + 10)
		surface.DrawText(string.format("%.0fs", gasCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(gasBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(gasBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- Celownik
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	
	local scale = 0.3
	surface.SetDrawColor(zombieType.color.r, zombieType.color.g, zombieType.color.b, 255)
	
	local gap = 5
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )
	
	-- Informacja o aktualnym trybie zombie (na dole HUD-u po środku)
	surface.SetFont("DermaDefault")
	surface.SetTextColor(zombieType.color.r, zombieType.color.g, zombieType.color.b, 255)
	local modeText = "Zombie Mode: " .. zombieType.name
	local tw, th = surface.GetTextSize(modeText)
	surface.SetTextPos(centerX - tw/2, hudY + hudHeight - 20)
	surface.DrawText(modeText)
	
	-- Efekty gazu przeniesione do hooka PostDrawTranslucentRenderables
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_054.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_scp_base"
SWEP.PrintName = "SCP-054"

SWEP.HoldType = "none"
SWEP.DrawCrosshair = true

-- Cooldowns
SWEP.Primary.Delay = 5 -- Water laser cooldown
SWEP.Secondary.Delay = 80 -- Steam explosion cooldown

-- Timers
SWEP.NextPrimary = 0
SWEP.NextSecondary = 0

function SWEP:OnRemove()
	if IsValid(self.Owner) then
		self.Owner:SetCustomCollisionCheck(false)
	end
end

function SWEP:Deploy()
	if IsValid(self.Owner) then
		self.Owner:SetCustomCollisionCheck(true)
	end
	self:HideModels()
end

function SWEP:Initialize()
	self:InitializeLanguage("SCP_054")
	self:SetHoldType("none")
	
	self.NextPrimary = 0
	self.NextSecondary = 0

	if SERVER then
			util.AddNetworkString("SCP054_CreateSteam")
			util.AddNetworkString("SCP054_PuddleState")
		end

	if CLIENT then
		net.Receive("SCP054_CreateSteam", function()
			local pos = net.ReadVector()
			local emitter = ParticleEmitter(pos)
			for i = 1, 50 do
				local particle = emitter:Add("particle/smokesprites_0001", pos + Vector(math.random(-50, 50), math.random(-50, 50), math.random(0, 80)))
				if particle then
					particle:SetVelocity(Vector(math.random(-30, 30), math.random(-30, 30), math.random(20, 40)))
					particle:SetDieTime(2)
					particle:SetStartAlpha(150)
					particle:SetEndAlpha(0)
					particle:SetStartSize(30)
					particle:SetEndSize(60)
					particle:SetRoll(math.random(0, 360))
					particle:SetRollDelta(math.random(-0.5, 0.5))
					particle:SetColor(255, 255, 255)
					particle:SetAirResistance(100)
					particle:SetGravity(Vector(0, 0, -10))
				end
			end
			emitter:Finish()
		end)
	end
end

function SWEP:DrawWorldModel()
	-- Nie rysuj modelu broni
end

function SWEP:DrawWorldModelTranslucent()
	-- Nie rysuj modelu broni
end

function SWEP:DrawViewModel()
	-- Nie rysuj viewmodelu
end

function SWEP:PreDrawViewModel()
	return true -- Zapobiega rysowaniu
end

SWEP.ShowViewModel = false
SWEP.ShowWorldModel = false

-- LMB - Water Laser
function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if self.NextPrimary > CurTime() then return end
	self.NextPrimary = CurTime() + self.Primary.Delay
	
	local owner = self.Owner
	local tr = util.TraceLine({
		start = owner:GetShootPos(),
		endpos = owner:GetShootPos() + owner:GetAimVector() * 1200,
		filter = owner,
		mask = MASK_SHOT
	})
	
	-- Tworzenie efektów wizualnych (działa po stronie klienta i serwera)
	-- Water laser beam effect - widoczny niebieski promień
	-- Główny efekt promienia (standardowy efekt GMod)
	local tracerEffect = EffectData()
	tracerEffect:SetStart(owner:GetShootPos())
	tracerEffect:SetOrigin(tr.HitPos)
	tracerEffect:SetEntity(owner)
	util.Effect("ToolTracer", tracerEffect)
	
	-- Dodatkowe efekty wodne wzdłuż promienia
	local distance = owner:GetShootPos():Distance(tr.HitPos)
	local direction = (tr.HitPos - owner:GetShootPos()):GetNormalized()
	
	-- Dodaj kilka małych efektów wody wzdłuż promienia
	for i = 1, 5 do
		local pos = owner:GetShootPos() + direction * (distance * (i / 6))
		local waterEffect = EffectData()
		waterEffect:SetOrigin(pos)
		waterEffect:SetScale(0.5)
		util.Effect("watersplash", waterEffect)
	end
	
	-- Dodatkowy efekt świecenia
	local gloweffect = EffectData()
	gloweffect:SetOrigin(tr.HitPos)
	gloweffect:SetScale(2)
	gloweffect:SetRadius(2)
	gloweffect:SetMagnitude(2)
	util.Effect("WaterSplash", gloweffect)
	
	-- Dodatkowy efekt na końcu promienia
	local effectdata = EffectData()
	effectdata:SetStart(owner:GetShootPos())
	effectdata:SetOrigin(tr.HitPos)
	effectdata:SetEntity(owner)
	effectdata:SetScale(2)
	util.Effect("watersplash", effectdata)
	
	-- Kontynuuj tylko po stronie serwera dla logiki obrażeń
	if !SERVER then return end
	
	-- Laser sound effect - krótki dźwięk zamiast zapętlonego
	owner:EmitSound("ambient/water/water_splash2.wav", 80, 120)
	
	local ent = tr.Entity
	if IsValid(ent) and ent:IsPlayer() then
		if ent:GTeam() == TEAM_SPEC or (ent:GTeam() == TEAM_SCP and ent:GetNClass() != ROLES.ROLE_SCP035) then return end
		
		-- Damage
		ent:TakeDamage(35, owner, self)
		
		-- Strong knockback
		local knockback = owner:GetAimVector() * 900
		knockback.z = knockback.z + 100 -- Add upward force
		ent:SetVelocity(knockback)
		
		-- Apply water effects (blur + slow)
		self:ApplyWaterEffects(ent)
		
		self:SCPDamageEvent(ent, 35)
	end
end

-- RMB - Steam Explosion
function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if self.NextSecondary > CurTime() then return end
	self.NextSecondary = CurTime() + self.Secondary.Delay
	
	local owner = self.Owner
	
	-- Początkowy dźwięk pary
	owner:EmitSound("ambient/gas/steam2.wav", 100, 100)
	
	-- Zatrzymaj dźwięk po 2 sekundach
	timer.Simple(2, function()
		if IsValid(owner) then
			owner:StopSound("ambient/gas/steam2.wav")
		end
	end)
	
	-- Zatrzymaj poprzedni timer jeśli istnieje
	timer.Remove("SCP054_SteamEffect_" .. self:EntIndex())
	
	-- Utwórz timer dla efektu pary (podobny do berserka SCP-076, ale w białym)
	timer.Create("SCP054_SteamEffect_" .. self:EntIndex(), 0.1, 20, function()
		if not IsValid(self) or not IsValid(owner) then
			timer.Remove("SCP054_SteamEffect_" .. self:EntIndex())
			return
		end
		
		local currentPos = owner:GetPos()
		
		-- Efekty pary widoczne dla wszystkich graczy (używamy util.Effect)
		local headPos = currentPos + Vector(0, 0, 70)
		
		-- Wyślij efekt do wszystkich klientów
		if SERVER then
			net.Start("SCP054_CreateSteam")
				net.WriteVector(owner:GetPos())
			net.Broadcast()
		end
	end)
	
	-- Po 2 sekundach następuje wybuch
	timer.Simple(2, function()
		if !IsValid(owner) then return end
		
		local currentPos = owner:GetPos() -- Aktualna pozycja gracza
		
		if SERVER then
			-- Dźwięk eksplozji
			owner:EmitSound("ambient/explosions/explode_4.wav", 90, 120)
			
			-- Find all players in explosion radius
			for _, ent in pairs(ents.FindInSphere(currentPos, 350)) do
				if IsValid(ent) and ent:IsPlayer() and ent != owner then
					-- Only damage non-SCP players (except SCP-035 can be damaged)
					if not (ent:GTeam() == TEAM_SPEC or (ent:GTeam() == TEAM_SCP and ent:GetNClass() != ROLES.ROLE_SCP035)) then
						-- Check line of sight (prevent damage through walls)
						local trace = util.TraceLine({
							start = currentPos + Vector(0, 0, 36),
							endpos = ent:GetPos() + Vector(0, 0, 36),
							filter = {owner, ent}
						})
						
						-- Only damage if no wall blocking
						if not trace.Hit then
							-- Calculate damage based on distance
							local distance = currentPos:Distance(ent:GetPos())
							local damage = math.max(30, 120 - (distance / 2.5))
							
							-- Damage
							ent:TakeDamage(damage, owner, self)
							
							-- Strong knockback
							local dir = (ent:GetPos() - currentPos):GetNormalized()
							dir.z = 0.6
							ent:SetVelocity(dir * 500)
							
							self:SCPDamageEvent(ent, damage)
						end
					end
				end
			end
		end
		
		-- Steam explosion effect (widoczny dla wszystkich)
		local effectdata = EffectData()
		effectdata:SetOrigin(currentPos)
		effectdata:SetMagnitude(350)
		effectdata:SetScale(3)
		util.Effect("Explosion", effectdata)
		
		-- Additional steam effects
		for i = 1, 8 do
			timer.Simple(i * 0.1, function()
				if IsValid(owner) then
					local currentEffectPos = owner:GetPos() -- Aktualna pozycja dla efektów
					local steamEffect = EffectData()
					steamEffect:SetOrigin(currentEffectPos + Vector(math.random(-50, 50), math.random(-50, 50), math.random(0, 100)))
					steamEffect:SetScale(1.5)
					util.Effect("watersplash", steamEffect)
				end
			end)
		end
	end)
end

-- Apply water effects to target
function SWEP:ApplyWaterEffects(target)
	if !SERVER then return end
	if !IsValid(target) then return end
	
	-- Apply 50% slow effect for 2 seconds
	local oldWalkSpeed = target:GetWalkSpeed()
	local oldRunSpeed = target:GetRunSpeed()
	
	target:SetWalkSpeed(oldWalkSpeed * 0.5)
	target:SetRunSpeed(oldRunSpeed * 0.5)
	
	-- Send water screen effect to client (blur + water overlay)
	net.Start("SCP054_WaterEffect")
	net.Send(target)
	
	-- Remove slow effect after 2 seconds
	timer.Simple(2, function()
		if IsValid(target) then
			target:SetWalkSpeed(oldWalkSpeed)
			target:SetRunSpeed(oldRunSpeed)
		end
	end)
end

-- Passive: 50% damage reduction from CW2 weapons
function SWEP:Think()
	self:PlayerFreeze()
	
	if SERVER then
		local owner = self.Owner
		if IsValid(owner) and !owner.SCP054_PassiveApplied then
			owner.SCP054_PassiveApplied = true
			
			-- Hook for damage reduction
			hook.Add("EntityTakeDamage", "SCP054_DamageReduction_" .. owner:SteamID64(), function(target, dmginfo)
				if target == owner then
					local attacker = dmginfo:GetAttacker()
					local weapon = nil
					
					if IsValid(attacker) and attacker:IsPlayer() then
						weapon = attacker:GetActiveWeapon()
					end
					
					-- Check if damage is from CW2 weapon
					if IsValid(weapon) and weapon.CW20_Weapon then
						dmginfo:ScaleDamage(0.5) -- 50% damage reduction
					end
				end
			end)
		end
	end
end

-- Network string for water effect
if SERVER then
	util.AddNetworkString("SCP054_WaterEffect")
end

-- Client-side water screen effect
if CLIENT then
	local waterEffectEnd = 0
	
	net.Receive("SCP054_WaterEffect", function()
		waterEffectEnd = CurTime() + 2 -- 2 seconds of water effect
	end)
	
	hook.Add("RenderScreenspaceEffects", "SCP054_WaterScreen", function()
		if waterEffectEnd > CurTime() then
			local timeLeft = waterEffectEnd - CurTime()
			local intensity = timeLeft / 2 -- Fade out over time
			
			-- Strong water overlay effect
			local tab = {
				["$pp_colour_addr"] = 0,
				["$pp_colour_addg"] = 0.15 * intensity,
				["$pp_colour_addb"] = 0.4 * intensity,
				["$pp_colour_brightness"] = -0.2 * intensity,
				["$pp_colour_contrast"] = 1 + (0.3 * intensity),
				["$pp_colour_colour"] = 1 - (0.3 * intensity),
				["$pp_colour_mulr"] = 1 - (0.4 * intensity),
				["$pp_colour_mulg"] = 1 - (0.2 * intensity),
				["$pp_colour_mulb"] = 1 + (0.3 * intensity)
			}
			
			DrawColorModify(tab)
			
			-- Strong blur effect
			DrawMotionBlur(0.6 * intensity, 1.0 * intensity, 0.02)
		end
	end)
end

-- Clear water effects on player death
if CLIENT then
	hook.Add("PlayerDeath", "SCP054_ClearWaterEffects", function(victim, inflictor, attacker)
		local ply = LocalPlayer()
		if victim == ply then
			-- Clear water effect
			waterEffectEnd = 0
		end
	end)
end

-- HUD Display (dokładnie jak SCP-069)
if CLIENT then
	function SWEP:DrawHUD()
		if disablehud == true then return end
		
		local ply = LocalPlayer()
		if not IsValid(ply) then return end
		
		local scrW, scrH = ScrW(), ScrH()
		local centerX = scrW / 2
		local hudY = scrH - 150
		
		-- HUD Background (identyczny jak SCP-069)
		local hudWidth = 500
		local hudHeight = 120
		local hudX = centerX - hudWidth / 2
		
		-- Tło HUD
		surface.SetDrawColor(20, 20, 20, 180)
		surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Obramowanie
		surface.SetDrawColor(100, 100, 100, 200)
		surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Linia dekoracyjna
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
		
		-- Tytuł SCP
		surface.SetFont("DermaLarge")
		surface.SetTextColor(200, 200, 200, 255)
		local titleW, titleH = surface.GetTextSize("SCP-054")
		surface.SetTextPos(centerX - titleW / 2, hudY + 10)
		surface.DrawText("SCP-054")
		
		-- Cooldowny
		local lmbCooldown = 0
		local rmbCooldown = 0
		
		if self.NextPrimary and self.NextPrimary > CurTime() then
			lmbCooldown = self.NextPrimary - CurTime()
		end
		
		if self.NextSecondary and self.NextSecondary > CurTime() then
			rmbCooldown = self.NextSecondary - CurTime()
		end
		
		local cooldownY = hudY + 60
		local barWidth = 120
		local barHeight = 8
		local barSpacing = 20
		
		-- LMB (Water Laser) Cooldown
		local lmbBarX = centerX - barWidth - barSpacing
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		surface.SetTextPos(lmbBarX, cooldownY - 15)
		surface.DrawText("LMB - Water Laser")
		
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
		
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		if lmbCooldown > 0 then
			local progress = 1 - (lmbCooldown / self.Primary.Delay)
			surface.SetDrawColor(255, 100, 100, 255)
			surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(255, 150, 150, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText(string.format("%.1fs", lmbCooldown))
		else
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 255, 150, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText("READY")
		end
		
		-- RMB (Steam Explosion) Cooldown
		local rmbBarX = centerX + barSpacing
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		surface.SetTextPos(rmbBarX, cooldownY - 15)
		surface.DrawText("RMB - Steam Explosion")
		
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
		
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		if rmbCooldown > 0 then
			local progress = 1 - (rmbCooldown / self.Secondary.Delay)
			surface.SetDrawColor(255, 100, 100, 255)
			surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(255, 150, 150, 255)
			surface.SetTextPos(rmbBarX, cooldownY + 10)
			surface.DrawText(string.format("%.1fs", rmbCooldown))
		else
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 255, 150, 255)
			surface.SetTextPos(rmbBarX, cooldownY + 10)
			surface.DrawText("READY")
		end
		

	end
end

function SWEP:Holster()
	if SERVER then
		local owner = self.Owner
		if IsValid(owner) and owner.SCP054_PassiveApplied then
			hook.Remove("EntityTakeDamage", "SCP054_DamageReduction_" .. owner:SteamID64())
			owner.SCP054_PassiveApplied = nil
		end
	end
	return true
end

function SWEP:OnRemove()
	if SERVER then
		local owner = self.Owner
		if IsValid(owner) and owner.SCP054_PassiveApplied then
			hook.Remove("EntityTakeDamage", "SCP054_DamageReduction_" .. owner:SteamID64())
			owner.SCP054_PassiveApplied = nil
		end
	end
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_066.lua
================================================
AddCSLuaFile()

SWEP.Base 				= "weapon_scp_base"
SWEP.PrintName			= "SCP-066 Rework"			

SWEP.Primary.Delay0		= 3
SWEP.Primary.Delay1		= 30

SWEP.Primary.Eric		= "scp/066/eric.ogg"
SWEP.Primary.Beethoven	= "scp/066/beethoven.ogg"

SWEP.ShockwaveCooldown	= 60 -- Cooldown dla fali uderzeniowej
SWEP.ShockwaveRadius	= 400 -- Promień fali
SWEP.ShockwaveDamage	= 50 -- Obrażenia fali
SWEP.ShockwaveForce		= 1000 -- Siła wyrzucenia

SWEP.HoldType 			= "normal"

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_066" )

	self:SetHoldType( self.HoldType )
	
	sound.Add( {
		name = "eric",
		channel = CHAN_STATIC,
		volume = 1.0,
		level = 300,
		pitch = 100,
		sound = self.Primary.Eric
	} )
	
	sound.Add( {
		name = "beethoven",
		channel = CHAN_STATIC,
		volume = 1.0,
		level = 511,
		pitch = 100,
		sound = self.Primary.Beethoven
	} )
	
	-- Inicjalizacja zmiennych
	self.Eric = false
	self.NextPrimary = 0
	self.NextShockwave = 0
	self.NextGlassBreak = 0
	
	-- Networking dla efektów
	if SERVER then
		util.AddNetworkString("SCP066_ScreenEffect")
		util.AddNetworkString("SCP066_Shockwave")
	end
	
	if CLIENT then
		self.WepSelectIcon = surface.GetTextureID("breach/wep_066")
		self.ScreenShakeTime = 0
		self.ScreenBlurTime = 0
	end
end

-- LMB - Eric/Beethoven z efektami
function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextPrimary > CurTime() then return end
	
	if !self.Eric then
		self.NextPrimary = CurTime() + self.Primary.Delay0
		self.Eric = true
		if !SERVER then return end
		self.Owner:EmitSound( "eric" )
	else
		self.NextPrimary = CurTime() + self.Primary.Delay1
		self.Eric = false
		if !SERVER then return end
		self.Owner:EmitSound( "beethoven" )
		
		timer.Create( "DMGTimer" .. self:EntIndex(), 1, self.Primary.Delay1 - 10, function()
			if !IsValid( self ) or !IsValid( self.Owner ) then
				timer.Remove( "DMGTimer" .. self:EntIndex() )
				return
			end
			
			local fent = ents.FindInSphere( self.Owner:GetPos(), 400 )
			for k, v in pairs( fent ) do
				if IsValid( v ) then
					if v:IsPlayer() then
						if (v:GTeam() != TEAM_SCP or v:GetNClass() == ROLES.ROLE_SCP035) and v:GTeam() != TEAM_SPEC then
							v:TakeDamage( 2, self.Owner, self.Owner )
							
							-- Wyślij efekt do klienta
							net.Start("SCP066_ScreenEffect")
								net.WriteFloat(CurTime() + 2) -- Czas trwania efektu
							net.Send(v)
						end
					end
				end
			end
		end )
	end
end

-- RMB - Fala uderzeniowa
function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextShockwave > CurTime() then return end
	
	self.NextShockwave = CurTime() + self.ShockwaveCooldown
	
	if SERVER then
		-- Dźwięk fali
		self.Owner:EmitSound("ambient/explosions/explode_" .. math.random(1,5) .. ".wav", 100, 80)
		
		-- Efekt wizualny
		local effectdata = EffectData()
		effectdata:SetOrigin(self.Owner:GetPos())
		effectdata:SetNormal(Vector(0,0,1))
		effectdata:SetMagnitude(self.ShockwaveRadius)
		effectdata:SetScale(1)
		effectdata:SetRadius(self.ShockwaveRadius)
		util.Effect("cball_explode", effectdata)
		
		-- Znajdź graczy w zasięgu
		local targets = ents.FindInSphere(self.Owner:GetPos(), self.ShockwaveRadius)
		for _, ent in pairs(targets) do
			if IsValid(ent) then
				if ent:IsPlayer() and ent != self.Owner then
					if (ent:GTeam() != TEAM_SCP or ent:GetNClass() == ROLES.ROLE_SCP035) and ent:GTeam() != TEAM_SPEC then
						-- Zadaj obrażenia
						local dmg = DamageInfo()
						dmg:SetDamage(self.ShockwaveDamage)
						dmg:SetAttacker(self.Owner)
						dmg:SetInflictor(self)
						dmg:SetDamageType(DMG_SONIC)
						ent:TakeDamageInfo(dmg)
						
						-- Wyrzuć gracza
						local dir = (ent:GetPos() - self.Owner:GetPos()):GetNormalized()
						dir.z = 0.5
						ent:SetVelocity(dir * self.ShockwaveForce)
						
						-- Ogłusz
						ent:ViewPunch(Angle(math.random(-25, 25), math.random(-25, 25), 0))
					end
				elseif ent:GetClass() == "prop_physics" then
					-- Wyrzuć obiekty fizyczne
					local phys = ent:GetPhysicsObject()
					if IsValid(phys) then
						local dir = (ent:GetPos() - self.Owner:GetPos()):GetNormalized()
						phys:ApplyForceCenter(dir * self.ShockwaveForce * 100)
					end
				end
			end
		end
		
		-- Wyślij efekt do klientów
		net.Start("SCP066_Shockwave")
			net.WriteVector(self.Owner:GetPos())
		net.Broadcast()
	end
end

-- Odbieranie efektów po stronie klienta
if CLIENT then
	net.Receive("SCP066_ScreenEffect", function()
		local endTime = net.ReadFloat()
		local ply = LocalPlayer()
		if IsValid(ply) then
			ply.SCP066_ScreenEffect = endTime
		end
	end)
	
	-- Tablica dla efektów shockwave
	local shockwaveEffects = {}
	
	net.Receive("SCP066_Shockwave", function()
		local pos = net.ReadVector()
		
		-- Efekt dźwiękowy dla wszystkich
		sound.Play("ambient/explosions/explode_" .. math.random(1,5) .. ".wav", pos, 100, 80)
		
		-- Wstrząśnij ekranem jeśli blisko
		local ply = LocalPlayer()
		local dist = ply:GetPos():Distance(pos)
		if dist < 600 then
			util.ScreenShake(pos, 10, 10, 2, 600)
		end
		
		-- Dodaj nowy efekt shockwave
		table.insert(shockwaveEffects, {
			pos = pos,
			startTime = CurTime(),
			duration = 1.5,
			maxRadius = 400
		})
	end)
	
	-- Hook do rysowania efektu shockwave
	hook.Add("PostDrawTranslucentRenderables", "SCP066_ShockwaveEffect", function()
		for i = #shockwaveEffects, 1, -1 do
			local effect = shockwaveEffects[i]
			local elapsed = CurTime() - effect.startTime
			
			if elapsed > effect.duration then
				table.remove(shockwaveEffects, i)
			else
				-- Oblicz aktualny promień
				local progress = elapsed / effect.duration
				local radius = effect.maxRadius * progress
				local alpha = 255 * (1 - progress)
				
				-- Rysuj pierścień shockwave
				render.SetColorMaterial()
				
				-- Zewnętrzny pierścień
				render.StartBeam(32)
				for j = 0, 31 do
					local angle = (j / 31) * math.pi * 2
					local x = effect.pos.x + math.cos(angle) * radius
					local y = effect.pos.y + math.sin(angle) * radius
					local z = effect.pos.z + 10
					
					render.AddBeam(Vector(x, y, z), radius * 0.1, j / 31, Color(100, 150, 255, alpha))
				end
				render.EndBeam()
				
				-- Drugi pierścień (mniejszy)
				if progress < 0.7 then
					local radius2 = radius * 0.7
					local alpha2 = alpha * 0.6
					
					render.StartBeam(24)
					for j = 0, 23 do
						local angle = (j / 23) * math.pi * 2
						local x = effect.pos.x + math.cos(angle) * radius2
						local y = effect.pos.y + math.sin(angle) * radius2
						local z = effect.pos.z + 5
						
						render.AddBeam(Vector(x, y, z), radius2 * 0.08, j / 23, Color(150, 200, 255, alpha2))
					end
					render.EndBeam()
				end
				
				-- Efekt zniekształcenia (refraction)
				if progress < 0.5 then
					cam.Start3D()
					render.SetMaterial(Material("models/spawn_effect"))
					render.DrawSphere(effect.pos, radius, 20, 20, Color(255, 255, 255, alpha * 0.3))
					cam.End3D()
				end
			end
		end
	end)
	
	-- Hook do rysowania efektów
	hook.Add("RenderScreenspaceEffects", "SCP066_Effects", function()
		local ply = LocalPlayer()
		if ply.SCP066_ScreenEffect and ply.SCP066_ScreenEffect > CurTime() then
			-- Silne rozmazanie
			DrawMotionBlur(0.8, 0.95, 0.05)
			
			-- Efekt nieostrego widzenia
			DrawSharpen(0.5, 2)
			
			-- Lekkie przyciemnienie bez czerwieni
			local tab = {
				["$pp_colour_addr"] = 0,
				["$pp_colour_addg"] = 0,
				["$pp_colour_addb"] = 0,
				["$pp_colour_brightness"] = -0.3,
				["$pp_colour_contrast"] = 0.7,
				["$pp_colour_colour"] = 0.5,
				["$pp_colour_mulr"] = 1,
				["$pp_colour_mulg"] = 1,
				["$pp_colour_mulb"] = 1
			}
			DrawColorModify(tab)
			
			-- Losowe wstrząsy widoku
			if math.random() > 0.85 then
				ply:ViewPunch(Angle(math.random(-8, 8), math.random(-8, 8), 0))
			end
		else
			-- Czyść efekt gdy czas minął
			ply.SCP066_ScreenEffect = nil
		end
	end)
end

-- HUD w stylu innych SCP
function SWEP:DrawHUD()
	if disablehud == true then return end
	
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-066")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-066")
	
	-- Cooldowny (LMB i RMB)
	local cooldownY = hudY + 60
	local barWidth = 180
	local barHeight = 8
	local spacing = 60
	local totalWidth = barWidth * 2 + spacing
	local startX = centerX - totalWidth / 2
	
	-- LMB Cooldown
	local lmbBarX = startX
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lmbBarX, cooldownY - 15)
	surface.DrawText("LMB - Sound Attack")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
	
	local primaryCooldown = 0
	local maxCooldown = self.Eric and self.Primary.Delay0 or self.Primary.Delay1
	if self.NextPrimary and self.NextPrimary > CurTime() then
		primaryCooldown = self.NextPrimary - CurTime()
	end
	
	if primaryCooldown > 0 then
		local progress = 1 - (primaryCooldown / maxCooldown)
		surface.SetDrawColor(255, 100, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", primaryCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText(self.Eric and "ERIC READY" or "BEETHOVEN READY")
	end
	
	-- RMB Cooldown
	local rmbBarX = startX + barWidth + spacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rmbBarX, cooldownY - 15)
	surface.DrawText("RMB - Shockwave")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
	
	local shockwaveCooldown = 0
	if self.NextShockwave and self.NextShockwave > CurTime() then
		shockwaveCooldown = self.NextShockwave - CurTime()
	end
	
	if shockwaveCooldown > 0 then
		local progress = 1 - (shockwaveCooldown / self.ShockwaveCooldown)
		surface.SetDrawColor(255, 255, 0, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", shockwaveCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- Celownik
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	
	local scale = 0.3
	local color = self.Eric and Color(255, 100, 100) or Color(100, 100, 255)
	surface.SetDrawColor(color.r, color.g, color.b, 255)
	
	local gap = 5
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )
	
	-- Info o rozbijaniu szyb
	surface.SetFont("DermaDefault")
	surface.SetTextColor(150, 150, 150, 255)
	local glassText = "[E] - Break Glass"
	local glassW, glassH = surface.GetTextSize(glassText)
	surface.SetTextPos(centerX - glassW / 2, hudY + hudHeight - 25)
	surface.DrawText(glassText)
end

-- Rozbijanie szyb na klawisz E dla SCP-066
if SERVER then
	hook.Add("KeyPress", "SCP066_GlassBreak", function(ply, key)
		if !IsValid(ply) or !ply:Alive() then return end
		local wep = ply:GetActiveWeapon()
		if !IsValid(wep) or wep:GetClass() != "weapon_scp_066" then return end
		
		-- Sprawdź czy to E (32)
		if key != 32 then return end
		
		-- Cooldown
		if wep.NextGlassBreak and wep.NextGlassBreak > CurTime() then return end
		wep.NextGlassBreak = CurTime() + 0.5
		
		-- Znajdź szybę przed graczem
		local tr = util.TraceLine({
			start = ply:GetShootPos(),
			endpos = ply:GetShootPos() + ply:GetAimVector() * 100,
			filter = ply
		})
		
		local ent = tr.Entity
		if IsValid(ent) then
			if ent:GetClass() == "func_breakable" or ent:GetClass() == "func_breakable_surf" then
				ent:Fire("Break")
				-- Usunięto dźwięk rozbijania szyby
				
				-- Usunięto efekt wizualny szyby
			elseif string.find(ent:GetClass(), "door") then
				-- Możliwość rozbicia drzwi ze szkłem
				wep:SCPDamageEvent(ent, 100)
			end
		end
	end)
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_069.lua
================================================
AddCSLuaFile()

SWEP.Base 		= "weapon_scp_base"
SWEP.PrintName 	= "SCP-069"

SWEP.Primary.Delay        = 1.5

SWEP.DrawCrosshair		= true
SWEP.HoldType 			= "none"

SWEP.KilledVictims = {}

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_069" )
	self:SetHoldType("none")
	
	if SERVER then
		self.KilledVictims = {}
	end
end

function SWEP:DrawWorldModel()
	-- Nie rysuj modelu broni
end

function SWEP:DrawWorldModelTranslucent()
	-- Nie rysuj modelu broni
end

function SWEP:DrawViewModel()
	-- Nie rysuj viewmodelu
end

function SWEP:PreDrawViewModel()
	return true -- Zapobiega rysowaniu
end

function SWEP:ViewModelDrawn()
	-- Nic nie rób
end

function SWEP:GetViewModelPosition(pos, ang)
	return pos, ang
end

SWEP.ShowViewModel = false
SWEP.ShowWorldModel = false

SWEP.NextPrimary = 0
function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if self.NextPrimary > CurTime() then return end
	self.NextPrimary = CurTime() + self.Primary.Delay
	
	if !SERVER then return end
	
	local tr = util.TraceHull( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 75,
		maxs = Vector( 10, 10, 10 ),
		mins = Vector( -10, -10, -10 ),
		filter = self.Owner,
		mask = MASK_SHOT
	} )
	
	local ent = tr.Entity
	if IsValid( ent ) then
		if ent:IsPlayer() then
			if ent:GTeam() == TEAM_SPEC then return end
			if ent:GTeam() == TEAM_SCP and ent:GetNClass() != ROLES.ROLE_SCP035 then return end
			
			-- Zapisz informacje o ofierze przed zabiciem
			local victimData = {
				name = ent:Nick(),
				model = ent:GetModel(),
				steamid = ent:SteamID()
			}
			
			-- Zabij ofiarę
			ent:TakeDamage( 9999, self.Owner, self.Owner )
			
			-- Dodaj do listy zabitych
			table.insert(self.KilledVictims, victimData)
			
			-- Wyślij aktualizację do klienta
			self:UpdateVictimList()
		else
			self:SCPDamageEvent( ent, 50 )
		end	
	end
end

function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if CLIENT then
		self:OpenDisguiseMenu()
	end
end

function SWEP:UpdateVictimList()
	if !SERVER then return end
	
	net.Start("SCP069_UpdateVictims")
		net.WriteEntity(self)
		net.WriteUInt(#self.KilledVictims, 8)
		for i, victim in ipairs(self.KilledVictims) do
			net.WriteString(victim.name)
			net.WriteString(victim.model)
			net.WriteString(victim.steamid)
		end
	net.Send(self.Owner)
end

if CLIENT then
	function SWEP:OpenDisguiseMenu()
		if IsValid(self.DisguiseMenu) then
			self.DisguiseMenu:Remove()
		end
		
		self.DisguiseMenu = vgui.Create("DFrame")
		self.DisguiseMenu:SetSize(650, 550)
		self.DisguiseMenu:Center()
		self.DisguiseMenu:SetTitle("SCP-069 - Disguise Selection")
		self.DisguiseMenu:SetDraggable(true)
		self.DisguiseMenu:ShowCloseButton(true)
		self.DisguiseMenu:MakePopup()
		
		-- Zakładki
		local sheet = vgui.Create("DPropertySheet", self.DisguiseMenu)
		sheet:Dock(FILL)
		
		-- ZAKŁADKA 1: Zabici gracze
		local victimsPanel = vgui.Create("DPanel", sheet)
		victimsPanel.Paint = function(self, w, h)
			draw.RoundedBox(0, 0, 0, w, h, Color(40, 40, 40, 255))
		end
		
		local victimsScroll = vgui.Create("DScrollPanel", victimsPanel)
		victimsScroll:Dock(FILL)
		
		-- Domyślny model SCP-069
		local defaultPanel = vgui.Create("DPanel", victimsScroll)
		defaultPanel:SetSize(580, 100)
		defaultPanel:Dock(TOP)
		defaultPanel:DockMargin(5, 5, 5, 5)
		defaultPanel.Paint = function(self, w, h)
			draw.RoundedBox(4, 0, 0, w, h, Color(60, 60, 60, 255))
		end
		
		-- Model preview dla domyślnego
		local defaultModel = vgui.Create("DModelPanel", defaultPanel)
		defaultModel:SetSize(100, 100)
		defaultModel:Dock(LEFT)
		defaultModel:SetModel("models/player/kerry/class_d_1.mdl")
		defaultModel:SetFOV(45)
		defaultModel:SetCamPos(Vector(50, 50, 50))
		defaultModel:SetLookAt(Vector(0, 0, 40))
		
		function defaultModel:LayoutEntity(Entity) return end
		
		local defaultBtn = vgui.Create("DButton", defaultPanel)
		defaultBtn:SetText("Default SCP-069 Form")
		defaultBtn:SetSize(460, 90)
		defaultBtn:Dock(FILL)
		defaultBtn:DockMargin(5, 5, 5, 5)
		defaultBtn:SetFont("DermaLarge")
		defaultBtn.DoClick = function()
			net.Start("SCP069_ChangeDisguise")
				net.WriteString("")
			net.SendToServer()
			self.DisguiseMenu:Close()
			-- Dźwięk tylko dla gracza
			surface.PlaySound("ambient/energy/weld1.wav")
		end
		
		-- Lista ofiar
		if self.VictimList then
			for i, victim in ipairs(self.VictimList) do
				local victimPanel = vgui.Create("DPanel", victimsScroll)
				victimPanel:SetSize(580, 100)
				victimPanel:Dock(TOP)
				victimPanel:DockMargin(5, 5, 5, 5)
				victimPanel.Paint = function(self, w, h)
					draw.RoundedBox(4, 0, 0, w, h, Color(80, 60, 60, 255))
				end
				
				-- Model preview
				local modelPanel = vgui.Create("DModelPanel", victimPanel)
				modelPanel:SetSize(100, 100)
				modelPanel:Dock(LEFT)
				modelPanel:SetModel(victim.model)
				modelPanel:SetFOV(45)
				modelPanel:SetCamPos(Vector(50, 50, 50))
				modelPanel:SetLookAt(Vector(0, 0, 40))
				
				function modelPanel:LayoutEntity(Entity) return end
				
				local btn = vgui.Create("DButton", victimPanel)
				btn:SetText(victim.name)
				btn:SetSize(460, 90)
				btn:Dock(FILL)
				btn:DockMargin(5, 5, 5, 5)
				btn:SetFont("DermaLarge")
				btn.DoClick = function()
					net.Start("SCP069_ChangeDisguise")
						net.WriteString(victim.model)
					net.SendToServer()
					self.DisguiseMenu:Close()
					-- Dźwięk tylko dla gracza
					surface.PlaySound("ambient/energy/weld1.wav")
				end
			end
		end
		
		-- ZAKŁADKA 2: Modele SCP
		local scpPanel = vgui.Create("DPanel", sheet)
		scpPanel.Paint = function(self, w, h)
			draw.RoundedBox(0, 0, 0, w, h, Color(40, 40, 40, 255))
		end
		
		local scpScroll = vgui.Create("DScrollPanel", scpPanel)
		scpScroll:Dock(FILL)
		
		-- Lista modeli SCP
		local scpModels = {
			{name = "SCP-023", model = "models/Novux/023/Novux_SCP-023.mdl"},
			{name = "SCP-049", model = "models/vinrax/player/scp049_player.mdl"},
			{name = "SCP-049-2", model = "models/player/zombie_classic.mdl"},
			{name = "SCP-054", model = "models/xiali/scp_054/ctg/scp_054.mdl"},
			{name = "SCP-066", model = "models/player/mrsilver/scp_066pm/scp_066_pm.mdl"},
			{name = "SCP-076", model = "models/abel/abel.mdl"},
			{name = "SCP-082", model = "models/models/konnie/savini/savini.mdl"},
			{name = "SCP-096", model = "models/scp096anim/player/scp096pm_raf.mdl"},
			{name = "SCP-106", model = "models/scp/106/unity/unity_scp_106_player.mdl"},
			{name = "SCP-173", model = "models/jqueary/scp/unity/scp173/scp173unity.mdl"},
			{name = "SCP-239", model = "models/cultist/scp/scp_239.mdl"},
			{name = "SCP-457", model = "models/player/corpse1.mdl"},
			{name = "SCP-682", model = "models/danx91/scp/scp_682.mdl"},
			{name = "SCP-689", model = "models/dwdarksouls/models/darkwraith.mdl"},
			{name = "SCP-860-2", model = "models/props/forest_monster/forest_monster2.mdl"},
			{name = "SCP-939", model = "models/scp/939/unity/unity_scp_939.mdl"},
			{name = "SCP-957", model = "models/immigrant/outlast/walrider_pm.mdl"},
			{name = "SCP-966", model = "models/player/mishka/966_new.mdl"},
			{name = "SCP-999", model = "models/scp/999/jq/scp_999_pmjq.mdl"},
			{name = "SCP-1048-A", model = "models/1048/tdyear/tdybrownearpm.mdl"},
			{name = "SCP-1048-B", model = "models/player/teddy_bear/teddy_bear.mdl"},
			{name = "SCP-1316", model = "models/yevocore/cat/cat.mdl"},
			{name = "SCP-1471", model = "models/burd/scp1471/scp1471.mdl"},
			{name = "SCP-2137-J", model = "models/t37/papaj.mdl"},
			{name = "SCP-2521", model = "models/cultist/scp/scp_no1.mdl"},
			{name = "SCP-3166", model = "models/nickelodeon_all_stars/garfield/garfield.mdl"},
			{name = "SCP-3199", model = "models/washton/3199.mdl"},
			{name = "SCP-Doom Guy-J", model = "models/player/doom_fn_pm.mdl"},
			{name = "SCP-Steve-J", model = "models/minecraft/steve/steve.mdl"},
			{name = "SCP-TTT-SAHUR", model = "models/gacommissions/tungtungtungsahur.mdl"}
		}
		
		for i, scp in ipairs(scpModels) do
			local scpModelPanel = vgui.Create("DPanel", scpScroll)
			scpModelPanel:SetSize(580, 100)
			scpModelPanel:Dock(TOP)
			scpModelPanel:DockMargin(5, 5, 5, 5)
			scpModelPanel.Paint = function(self, w, h)
				draw.RoundedBox(4, 0, 0, w, h, Color(60, 40, 40, 255))
			end
			
			-- Model preview
			local modelPanel = vgui.Create("DModelPanel", scpModelPanel)
			modelPanel:SetSize(100, 100)
			modelPanel:Dock(LEFT)
			modelPanel:SetModel(scp.model)
			modelPanel:SetFOV(45)
			modelPanel:SetCamPos(Vector(50, 50, 50))
			modelPanel:SetLookAt(Vector(0, 0, 40))
			
			function modelPanel:LayoutEntity(Entity) return end
			
			local btn = vgui.Create("DButton", scpModelPanel)
			btn:SetText(scp.name)
			btn:SetSize(460, 90)
			btn:Dock(FILL)
			btn:DockMargin(5, 5, 5, 5)
			btn:SetFont("DermaLarge")
			btn.DoClick = function()
				net.Start("SCP069_ChangeDisguise")
					net.WriteString(scp.model)
				net.SendToServer()
				self.DisguiseMenu:Close()
				-- Dźwięk tylko dla gracza
				surface.PlaySound("ambient/energy/weld1.wav")
			end
		end
		
		-- Dodaj zakładki
		sheet:AddSheet("Killed Players", victimsPanel, "icon16/user_delete.png")
		sheet:AddSheet("SCP Models", scpPanel, "icon16/bug.png")
	end
	
	net.Receive("SCP069_UpdateVictims", function()
		local wep = net.ReadEntity()
		if !IsValid(wep) then return end
		
		wep.VictimList = {}
		local count = net.ReadUInt(8)
		for i = 1, count do
			table.insert(wep.VictimList, {
				name = net.ReadString(),
				model = net.ReadString(),
				steamid = net.ReadString()
			})
		end
	end)
end

if SERVER then
	util.AddNetworkString("SCP069_UpdateVictims")
	util.AddNetworkString("SCP069_ChangeDisguise")
	
	net.Receive("SCP069_ChangeDisguise", function(len, ply)
		local model = net.ReadString()
		
		if IsValid(ply) and ply:GetActiveWeapon() and ply:GetActiveWeapon():GetClass() == "weapon_scp_069" then
			if model == "" then
				-- Przywróć domyślny model SCP-069
				ply:SetModel("models/player/kerry/class_d_1.mdl")
			else
				-- Zmień na model ofiary
				ply:SetModel(model)
			end
		end
	end)
end

function SWEP:DrawHUD()
	if disablehud == true then return end
	
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	-- Pozycja HUD (dokładnie jak SCP-069)
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-069")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-069")
	
	-- Cooldowny
	local lpmCooldown = 0
	local ppmCooldown = 0
	
	if self.NextPrimary and self.NextPrimary > CurTime() then
		lpmCooldown = self.NextPrimary - CurTime()
	end
	
	local cooldownY = hudY + 60
	local barWidth = 120
	local barHeight = 8
	local barSpacing = 20
	
	-- LMB (Kill) Cooldown
	local lpmBarX = centerX - barWidth - barSpacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lpmBarX, cooldownY - 15)
	surface.DrawText("LMB - Kill")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lpmBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lpmBarX, cooldownY, barWidth, barHeight)
	
	if lpmCooldown > 0 then
		local progress = 1 - (lpmCooldown / self.Primary.Delay)
		surface.SetDrawColor(255, 100, 100, 255)
		surface.DrawRect(lpmBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(lpmBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", lpmCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(lpmBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(lpmBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- RMB (Disguise) Status
	local ppmBarX = centerX + barSpacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(ppmBarX, cooldownY - 15)
	surface.DrawText("RMB - Disguise")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(ppmBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(ppmBarX, cooldownY, barWidth, barHeight)
	
	-- Liczba ofiar
	local victimCount = 0
	if self.VictimList then
		victimCount = #self.VictimList
	end
	
	if victimCount > 0 then
		surface.SetDrawColor(255, 215, 0, 255)
		surface.DrawRect(ppmBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 255, 150, 255)
		surface.SetTextPos(ppmBarX, cooldownY + 10)
		surface.DrawText("VICTIMS: " .. victimCount)
	else
		surface.SetDrawColor(100, 100, 100, 255)
		surface.DrawRect(ppmBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 150, 150, 255)
		surface.SetTextPos(ppmBarX, cooldownY + 10)
		surface.DrawText("NO VICTIMS")
	end
	
	-- Renderowanie aktualnego modelu po prawej stronie ekranu
	if not self.ModelPanel then
		self.ModelPanel = vgui.Create("DModelPanel")
		self.ModelPanel:SetSize(200, 300)
		self.ModelPanel:SetPos(ScrW() - 220, ScrH() / 2 - 150)
		self.ModelPanel:SetFOV(45)
		self.ModelPanel:SetCamPos(Vector(80, 80, 60))
		self.ModelPanel:SetLookAt(Vector(0, 0, 40))
		self.ModelPanel:SetAlpha(255)
		self.ModelPanel.LayoutEntity = function(self, ent)
			ent:SetAngles(Angle(0, RealTime() * 30, 0))
		end
	end
	
	-- Aktualizuj model jeśli się zmienił
	if self.ModelPanel then
		local currentModel = ply:GetModel()
		if self.ModelPanel.LastModel != currentModel then
			self.ModelPanel:SetModel(currentModel)
			self.ModelPanel.LastModel = currentModel
		end
		
		-- Rysuj tło dla panelu
		local x, y = self.ModelPanel:GetPos()
		local w, h = self.ModelPanel:GetSize()
		
		surface.SetDrawColor(20, 20, 20, 150)
		surface.DrawRect(x - 5, y - 5, w + 10, h + 10)
		
		surface.SetDrawColor(100, 100, 100, 200)
		surface.DrawOutlinedRect(x - 5, y - 5, w + 10, h + 10)
		
		-- Tytuł
		surface.SetFont("DermaDefault")
		surface.SetTextColor(200, 200, 200, 255)
		local text = "Current Form"
		local tw, th = surface.GetTextSize(text)
		surface.SetTextPos(x + w/2 - tw/2, y - 20)
		surface.DrawText(text)
		
		self.ModelPanel:SetVisible(true)
		self.ModelPanel:PaintManual()
	end
end

function SWEP:Holster()
	if CLIENT and IsValid(self.ModelPanel) then
		self.ModelPanel:Remove()
		self.ModelPanel = nil
	end
	return true
end

function SWEP:OnRemove()
	if CLIENT and IsValid(self.ModelPanel) then
		self.ModelPanel:Remove()
		self.ModelPanel = nil
	end
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_076.lua
================================================
AddCSLuaFile()

SWEP.Base 					= "weapon_scp_base"
SWEP.PrintName				= "SCP-076-2 Rework"

SWEP.ViewModel				= "models/weapons/scp076/v_katana.mdl"
SWEP.WorldModel				= "models/weapons/scp076/w_katana.mdl"

SWEP.HoldType 				= "melee"

SWEP.NextPrimary = 0
SWEP.NextIdle = 0

-- Berserk parametry
SWEP.BerserkChargeTime = 5 -- Czas ładowania berserka
SWEP.BerserkDuration = 10 -- Czas trwania berserka
SWEP.ExhaustionDuration = 15 -- Czas zmęczenia po berserku
SWEP.BerserkCooldown = 60 -- Całkowity cooldown berserka

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_076" )

	self:SetHoldType( self.HoldType )

	self.NextIdle = CurTime() + self:SequenceDuration( ACT_VM_DRAW)
	self:SendWeaponAnim( ACT_VM_DRAW )
	self.NextPrimary = CurTime() + 1
	self:EmitSound( "weapons/knife/knife_deploy1.wav" )
	
	-- Inicjalizacja zmiennych berserka
	self.IsBerserk = false
	self.IsCharging = false
	self.IsExhausted = false
	self.BerserkEnd = 0
	self.ChargeEnd = 0
	self.ExhaustEnd = 0
	self.NextBerserk = 0
	self.OriginalSpeed = 0
	self.OriginalWalkSpeed = 0
	
	-- Networking
	if SERVER then
		util.AddNetworkString("SCP076_BerserkUpdate")
	end
	
	if CLIENT then
		self.WepSelectIcon = surface.GetTextureID("breach/wep_076")
	end
end

-- Synchronizacja stanów przy spawnie broni
function SWEP:SetupDataTables()
	self:NetworkVar("Bool", 0, "BerserkActive")
	self:NetworkVar("Bool", 1, "ChargingActive")
	self:NetworkVar("Bool", 2, "ExhaustedActive")
end

function SWEP:Deploy()
end

function SWEP:Think()
	self:PlayerFreeze()

	if self.NextIdle > CurTime() then return end
	self.NextIdle = CurTime() + self:SequenceDuration( ACT_VM_IDLE )
	self:SendWeaponAnim( ACT_VM_IDLE )
	
	if SERVER then
		-- Sprawdź ładowanie berserka
		if self.IsCharging and CurTime() >= self.ChargeEnd then
			self:ActivateBerserk()
		end
		
		-- Sprawdź koniec berserka
		if self.IsBerserk and CurTime() >= self.BerserkEnd then
			self:EndBerserk()
		end
		
		-- Sprawdź koniec zmęczenia
		if self.IsExhausted and CurTime() >= self.ExhaustEnd then
			self:EndExhaustion()
		end
	end
end

function SWEP:PrimaryAttack()
	if postround then return end
	if self.NextPrimary > CurTime() then return end
	if self.IsCharging then return end -- Nie można atakować podczas ładowania
	
	self.NextPrimary = CurTime() + 1
	self.NextIdle = CurTime() + self:SequenceDuration( ACT_VM_MISSCENTER )
	self:EmitSound( "Weapon_Knife.Slash" )
	self.Owner:LagCompensation( true )
	
	local pos = self.Owner:GetShootPos()
	local aim = self.Owner:GetAimVector()
	local baseDmg = math.random( 25, 35 )
	
	-- Podwójne obrażenia w trybie berserk
	if self.IsBerserk then
		baseDmg = baseDmg * 2
	end
	
	local dist = 75

	local damage = DamageInfo()
	damage:SetDamage( baseDmg )
	damage:SetDamageType( DMG_SLASH )
	damage:SetAttacker( self.Owner )
	damage:SetInflictor( self )
	damage:SetDamageForce( aim * 300 )

	local tr = util.TraceHull( {
		start = pos,
		endpos = pos + aim * dist,
		filter = self.Owner,
		mask = MASK_SHOT_HULL,
		mins = Vector( -10, -5, -5 ),
		maxs = Vector( 10, 5, 5 )
	} )
	if tr.Hit then
		local ent = tr.Entity
		if ent:IsPlayer() then
			if ent:GTeam() != TEAM_SPEC and (ent:GTeam() != TEAM_SCP or ent:GetNClass() == ROLES.ROLE_SCP035) then
				self:EmitSound( "Weapon_Knife.Hit" )
				if SERVER and ent:GTeam() != TEAM_SCP then
					ent:TakeDamageInfo( damage )
				end
			end
		elseif !self:SCPDamageEvent( ent, self.IsBerserk and 20 or 10 ) then
			local look = self.Owner:GetEyeTrace()
			self:EmitSound( "weapons/rpg/shotdown.wav" )
			util.Decal("ManhackCut", look.HitPos + look.HitNormal, look.HitPos - look.HitNormal )
		end
	end
	
	self.Owner:LagCompensation( false )
	self:SendWeaponAnim( ACT_VM_MISSCENTER )
	self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

-- RMB - Aktywacja trybu Berserk
function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextBerserk > CurTime() then return end
	if self.IsBerserk or self.IsCharging or self.IsExhausted then return end
	
	if SERVER then
		-- Rozpocznij ładowanie
		self.IsCharging = true
		self.ChargeEnd = CurTime() + self.BerserkChargeTime
		
		-- Ustaw networked variable
		self:SetChargingActive(true)
		
		-- Zamroź gracza
		self.Owner:Freeze(true)
		
		-- Dźwięk ładowania
		self.Owner:EmitSound("ambient/energy/weld1.wav", 75, 50)
		
		-- Timer dla efektu ładowania
		timer.Create("SCP076_ChargeEffect_" .. self:EntIndex(), 0.1, 50, function()
			if not IsValid(self) or not IsValid(self.Owner) or not self.IsCharging then
				timer.Remove("SCP076_ChargeEffect_" .. self:EntIndex())
				return
			end
			
			-- Efekt czerwonego dymu zbierającego się
			local effectdata = EffectData()
			effectdata:SetOrigin(self.Owner:GetPos() + Vector(0, 0, 40))
			effectdata:SetScale(2)
			-- Zmieniony efekt zamiast GlassImpact
			util.Effect("BloodImpact", effectdata)
		end)
		
		-- Update klienta
		self:UpdateBerserkState()
	end
end

-- Aktywacja berserka
function SWEP:ActivateBerserk()
	if not SERVER then return end
	
	self.IsCharging = false
	self.IsBerserk = true
	self.BerserkEnd = CurTime() + self.BerserkDuration
	
	-- Ustaw networked variable
	self:SetBerserkActive(true)
	self:SetChargingActive(false)
	
	-- Odmroź gracza
	self.Owner:Freeze(false)
	
	-- Zatrzymaj timer efektu ładowania
	timer.Remove("SCP076_ChargeEffect_" .. self:EntIndex())
	
	-- Zapisz oryginalne prędkości
	self.OriginalSpeed = self.Owner:GetRunSpeed()
	self.OriginalWalkSpeed = self.Owner:GetWalkSpeed()
	
	-- Podwój prędkość
	self.Owner:SetRunSpeed(self.OriginalSpeed * 2)
	self.Owner:SetWalkSpeed(self.OriginalWalkSpeed * 2)
	
	-- Dźwięk aktywacji
	self.Owner:EmitSound("npc/antlion_guard/angry1.wav", 100, 80)
	
	-- Efekt czerwonej aury
	local effectdata = EffectData()
	effectdata:SetOrigin(self.Owner:GetPos())
	effectdata:SetEntity(self.Owner)
	util.Effect("BloodImpact", effectdata)
	
	-- Update klienta
	self:UpdateBerserkState()
end

-- Zakończenie berserka
function SWEP:EndBerserk()
	if not SERVER then return end
	
	self.IsBerserk = false
	self.IsExhausted = true
	self.ExhaustEnd = CurTime() + self.ExhaustionDuration
	self.NextBerserk = CurTime() + self.BerserkCooldown
	
	-- Ustaw networked variables
	self:SetBerserkActive(false)
	self:SetExhaustedActive(true)
	
	-- Ustaw spowolnienie (50% normalnej prędkości)
	self.Owner:SetRunSpeed(self.OriginalSpeed * 0.5)
	self.Owner:SetWalkSpeed(self.OriginalWalkSpeed * 0.5)
	
	-- Dźwięk zmęczenia
	self.Owner:EmitSound("player/pl_drown1.wav", 75, 100)
	
	-- Update klienta
	self:UpdateBerserkState()
end

-- Zakończenie zmęczenia
function SWEP:EndExhaustion()
	if not SERVER then return end
	
	self.IsExhausted = false
	
	-- Ustaw networked variable
	self:SetExhaustedActive(false)
	
	-- Przywróć normalną prędkość
	self.Owner:SetRunSpeed(self.OriginalSpeed)
	self.Owner:SetWalkSpeed(self.OriginalWalkSpeed)
	
	-- Update klienta
	self:UpdateBerserkState()
end

-- Aktualizacja stanu dla klienta
function SWEP:UpdateBerserkState()
	if not SERVER then return end
	
	net.Start("SCP076_BerserkUpdate")
		net.WriteEntity(self)
		net.WriteBool(self.IsBerserk)
		net.WriteBool(self.IsCharging)
		net.WriteBool(self.IsExhausted)
		net.WriteFloat(self.BerserkEnd)
		net.WriteFloat(self.ChargeEnd)
		net.WriteFloat(self.ExhaustEnd)
		net.WriteFloat(self.NextBerserk)
	net.Broadcast() -- Zmienione z net.Send(self.Owner) na net.Broadcast()
end

-- Odbieranie aktualizacji po stronie klienta
if CLIENT then
	net.Receive("SCP076_BerserkUpdate", function()
		local wep = net.ReadEntity()
		if IsValid(wep) and wep:GetClass() == "weapon_scp_076" then
			wep.IsBerserk = net.ReadBool()
			wep.IsCharging = net.ReadBool()
			wep.IsExhausted = net.ReadBool()
			wep.BerserkEnd = net.ReadFloat()
			wep.ChargeEnd = net.ReadFloat()
			wep.ExhaustEnd = net.ReadFloat()
			wep.NextBerserk = net.ReadFloat()
		end
	end)
	
	-- Hook do rysowania aury berserka na modelu
	hook.Add("PostDrawTranslucentRenderables", "SCP076_BerserkAura", function()
		-- Sprawdź wszystkich graczy
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply:Alive() then
				local wep = ply:GetActiveWeapon()
				-- Używaj networked variable zamiast lokalnej zmiennej
				if IsValid(wep) and wep:GetClass() == "weapon_scp_076" then
					-- Efekt ładowania
					if wep:GetChargingActive() or wep.IsCharging then
						local pos = ply:GetPos()
						local time = CurTime()
						local progress = 0
						if wep.ChargeEnd then
							progress = 1 - ((wep.ChargeEnd - time) / wep.BerserkChargeTime)
						end
						
						-- Czerwony okrąg zbierający się do środka
						render.SetColorMaterial()
						render.StartBeam(32)
						for i = 0, 31 do
							local angle = (i / 31) * math.pi * 2
							local radius = 100 * (1 - progress) + 20
							local x = pos.x + math.cos(angle) * radius
							local y = pos.y + math.sin(angle) * radius
							local z = pos.z + 40 + math.sin(time * 10 + i) * 5
							
							render.AddBeam(Vector(x, y, z), 10, i / 31, Color(255, 0, 0, 150 * progress))
						end
						render.EndBeam()
						
						-- Cząsteczki zbiegające się do gracza
						if math.random() > 0.5 then
							local emitter = ParticleEmitter(pos)
							if emitter then
								for p = 1, 2 do
									local angle = math.random() * math.pi * 2
									local dist = 80 + math.random() * 40
									local startPos = pos + Vector(math.cos(angle) * dist, math.sin(angle) * dist, math.random(20, 80))
									
									local part = emitter:Add("sprites/light_glow02_add", startPos)
									if part then
										part:SetDieTime(0.5)
										part:SetStartAlpha(100)
										part:SetEndAlpha(0)
										part:SetStartSize(8)
										part:SetEndSize(2)
										part:SetGravity(Vector(0, 0, 0))
										local vel = (pos + Vector(0, 0, 40) - startPos):GetNormalized() * 200
										part:SetVelocity(vel)
										part:SetColor(255, 0, 0)
										part:SetRoll(math.random(0, 360))
									end
								end
								emitter:Finish()
							end
						end
						
						-- Czerwona poświata podczas ładowania
						local pulse = math.sin(time * 8) * 0.3 + 0.7
						cam.Start3D()
						render.SetMaterial(Material("sprites/light_glow02_add"))
						render.DrawSprite(pos + Vector(0, 0, 40), 150 * progress * pulse, 150 * progress * pulse, Color(255, 0, 0, 100))
						cam.End3D()
					
					-- Efekt berserka
					elseif wep:GetBerserkActive() or wep.IsBerserk then
					-- Rysuj aurę na modelu gracza
					local pos = ply:GetPos()
					local time = CurTime()
					
					-- Czerwona poświata wokół modelu
					local mins, maxs = ply:GetModelBounds()
					local center = ply:GetPos() + Vector(0, 0, (maxs.z - mins.z) / 2)
					local pulse = math.sin(time * 4) * 0.2 + 0.8
					
					cam.Start3D()
					render.SetMaterial(Material("sprites/light_glow02_add"))
					render.DrawSprite(center, 120 * pulse, 120 * pulse, Color(255, 0, 0, 60))
					cam.End3D()
					
					-- Efekt czerwonych cząsteczek
					if math.random() > 0.7 then
						local emitter = ParticleEmitter(pos)
						if emitter then
							for p = 1, 3 do
								-- Losowa pozycja wokół gracza
								local offset = Vector(math.random(-40, 40), math.random(-40, 40), math.random(0, 70))
								local part = emitter:Add("particles/flamelet" .. math.random(1, 5), pos + offset)
								if part then
									part:SetDieTime(1.5)
									part:SetStartAlpha(200)
									part:SetEndAlpha(0)
									part:SetStartSize(15)
									part:SetEndSize(5)
									part:SetGravity(Vector(0, 0, 80))
									part:SetVelocity(Vector(math.random(-30, 30), math.random(-30, 30), math.random(40, 80)))
									part:SetColor(255, 50, 50)
									part:SetRoll(math.random(0, 360))
									part:SetRollDelta(math.random(-3, 3))
									part:SetAirResistance(50)
								end
							end
							emitter:Finish()
						end
					end
					end
				end
			end
		end
	end)
end

-- HUD w stylu innych SCP
function SWEP:DrawHUD()
	if disablehud == true then return end
	
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-076-2")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-076-2")
	
	-- Cooldowny (LMB i RMB)
	local cooldownY = hudY + 60
	local barWidth = 180
	local barHeight = 8
	local spacing = 60
	local totalWidth = barWidth * 2 + spacing
	local startX = centerX - totalWidth / 2
	
	-- LMB Cooldown (Atak)
	local lmbBarX = startX
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lmbBarX, cooldownY - 15)
	surface.DrawText("LMB - Sword Attack")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
	
	local attackCooldown = 0
	if self.NextPrimary and self.NextPrimary > CurTime() then
		attackCooldown = self.NextPrimary - CurTime()
	end
	
	if attackCooldown > 0 then
		local progress = 1 - attackCooldown
		surface.SetDrawColor(255, 100, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", attackCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- RMB Status (Berserk)
	local rmbBarX = startX + barWidth + spacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rmbBarX, cooldownY - 15)
	surface.DrawText("RMB - Berserk Mode")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
	
	-- Różne stany berserka
	if self.IsCharging then
		-- Ładowanie
		local progress = 0
		if self.ChargeEnd then
			progress = 1 - ((self.ChargeEnd - CurTime()) / self.BerserkChargeTime)
		end
		surface.SetDrawColor(255, 255, 0, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText("CHARGING...")
	elseif self.IsBerserk then
		-- Aktywny berserk
		local progress = 0
		if self.BerserkEnd then
			progress = (self.BerserkEnd - CurTime()) / self.BerserkDuration
		end
		surface.SetDrawColor(255, 0, 0, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText(string.format("BERSERK %.1fs", self.BerserkEnd - CurTime()))
	elseif self.IsExhausted then
		-- Zmęczenie
		local progress = 0
		if self.ExhaustEnd then
			progress = (self.ExhaustEnd - CurTime()) / self.ExhaustionDuration
		end
		surface.SetDrawColor(100, 100, 100, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 150, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText(string.format("EXHAUSTED %.1fs", self.ExhaustEnd - CurTime()))
	elseif self.NextBerserk and self.NextBerserk > CurTime() then
		-- Cooldown
		local cooldown = self.NextBerserk - CurTime()
		local progress = 1 - (cooldown / self.BerserkCooldown)
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.0fs", cooldown))
	else
		-- Gotowy
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- Status na dole
	local statusText = ""
	local statusColor = Color(200, 200, 200)
	
	if self.IsBerserk then
		statusText = "BERSERK MODE ACTIVE - 2x Damage & Speed"
		statusColor = Color(255, 100, 100)
	elseif self.IsExhausted then
		statusText = "EXHAUSTED - Movement Slowed"
		statusColor = Color(150, 150, 150)
	elseif self.IsCharging then
		statusText = "CHARGING BERSERK MODE..."
		statusColor = Color(255, 255, 100)
	else
		statusText = ""
		statusColor = Color(100, 255, 100)
	end
	
	surface.SetFont("DermaDefault")
	surface.SetTextColor(statusColor.r, statusColor.g, statusColor.b, 255)
	local tw, th = surface.GetTextSize(statusText)
	surface.SetTextPos(centerX - tw/2, hudY + hudHeight - 20)
	surface.DrawText(statusText)
	
	-- Celownik
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	
	local scale = 0.3
	local color = self.IsBerserk and Color(255, 0, 0) or Color(200, 200, 200)
	surface.SetDrawColor(color.r, color.g, color.b, 255)
	
	local gap = 5
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )
end

-- Czyszczenie przy usunięciu broni
function SWEP:OnRemove()
	if SERVER and IsValid(self.Owner) then
		-- Przywróć normalne prędkości jeśli broń jest usuwana
		if self.OriginalSpeed and self.OriginalSpeed > 0 then
			self.Owner:SetRunSpeed(self.OriginalSpeed)
			self.Owner:SetWalkSpeed(self.OriginalWalkSpeed)
		end
		
		-- Odmroź gracza jeśli był zamrożony
		if self.IsCharging then
			self.Owner:Freeze(false)
		end
		
		-- Usuń timer efektu ładowania
		timer.Remove("SCP076_ChargeEffect_" .. self:EntIndex())
	end
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_082.lua
================================================
AddCSLuaFile()

SWEP.Base 			= "weapon_scp_base"
SWEP.PrintName		= "SCP-082 Rework"

SWEP.ViewModel		= "models/weapons/scp082/v_machete.mdl"
SWEP.WorldModel		= "models/weapons/scp082/w_fc2_machete.mdl"

SWEP.Primary.Sound	= Sound( "scp/082/woosh.mp3" )
SWEP.KnifeShink 	= Sound( "scp/082/hitwall.mp3" )
SWEP.KnifeSlash 	= Sound( "scp/082/slash.mp3" )
SWEP.KnifeStab 		= Sound( "scp/082/nastystab.mp3" )

SWEP.HoldType 		= "melee"
SWEP.NextPrimary	= 0
SWEP.NextIdle 		= 0

-- Nowe zmienne
SWEP.NextPanic = 0
SWEP.PanicCooldown = 15 -- Cooldown paniki
SWEP.PanicDuration = 3 -- Czas trwania paniki
SWEP.PanicRange = 500 -- Zasięg paniki

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_082" )

	self:SetHoldType( self.HoldType )

	self:SendWeaponAnim( ACT_VM_DRAW )
	self.NextPrimary = CurTime() + 1.3
	self:EmitSound( "scp/082/knife_draw_x.mp3", 50, 100 )
	
	-- Networking
	if SERVER then
		util.AddNetworkString("SCP082_Panic")
		util.AddNetworkString("SCP082_Bleed")
		
		-- Hook do jedzenia ciał
		hook.Add("PlayerUse", "SCP082_EatCorpse_" .. self:EntIndex(), function(ply, ent)
			if ply == self.Owner and IsValid(ent) and ent:GetClass() == "prop_ragdoll" and ply:KeyDown(IN_USE) then
				local dist = ply:GetPos():Distance(ent:GetPos())
				if dist < 100 then
					self:EatCorpse(ent)
					return false
				end
			end
		end)
	end
	
	if CLIENT then
		self.WepSelectIcon = surface.GetTextureID("breach/wep_082")
	end
end

function SWEP:Deploy()
end

function SWEP:Think()
	self:PlayerFreeze()

	if self.NextIdle > CurTime() then return end
	self.NextIdle = CurTime() + self:SequenceDuration( ACT_VM_IDLE )
	self:SendWeaponAnim( ACT_VM_IDLE )
end

-- LMB - Atak z krwawieniem i spowolnieniem
function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if self.NextPrimary > CurTime() then return end
	self.NextPrimary = CurTime() + 1.75
	vm = self.Owner:GetViewModel()
	self.NextIdle = CurTime() + vm:SequenceDuration( vm:LookupSequence( "stab" ) )
	self.Owner:ViewPunch( Angle( -10,0,0 ) )
	self:EmitSound( self.Primary.Sound )
	if SERVER then
		vm:SetSequence( vm:LookupSequence( "stab" ) )
		timer.Create( "hack-n-slash", 0.3, 1, function()
			if IsValid( self ) and IsValid( self.Owner ) then
				if self.Owner:Alive() then 
					self:HackNSlash() 
				end
			end
		end )		
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
	end
end

function SWEP:HackNSlash()
	self.Owner:LagCompensation( true )
	local slash = {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 65,
		filter = self.Owner,
		mins = Vector( -8, -10, 5 ),
		maxs = Vector( 8, 10, 5 ),
	}
	local slashtrace = util.TraceHull( slash )
	
	if self.Owner:GetActiveWeapon():GetClass() == self:GetClass() then
		self.Owner:ViewPunch( Angle( 15, 0, 0 ) )
		local target = slashtrace.Entity
		if IsValid( target ) then
			if target:IsPlayer() then
				if target:GTeam() == TEAM_SPEC then return end
				if target:GTeam() == TEAM_SCP and target:GetNClass() != ROLES.ROLE_SCP035 then return end
				self:EmitSound( self.KnifeSlash )
				local dmg = math.random( 30, 60 )
				local paininfo = DamageInfo()
					paininfo:SetDamage( dmg )
					paininfo:SetDamageType( DMG_SLASH )
					paininfo:SetAttacker( self.Owner )
					paininfo:SetInflictor( self )
					paininfo:SetDamageForce( slashtrace.Normal * 3500 )
				target:TakeDamageInfo( paininfo )
				
				-- Heal 50 HP za trafienie
				local hp = self.Owner:Health() + 50
				if hp > self.Owner:GetMaxHealth() then hp = self.Owner:GetMaxHealth() end
				self.Owner:SetHealth( hp )
				
				-- Krwawienie
				net.Start("SCP082_Bleed")
				net.Send(target)
				
				-- Spowolnienie na sekundę
				local originalSpeed = target:GetRunSpeed()
				local originalWalk = target:GetWalkSpeed()
				target:SetRunSpeed(originalSpeed * 0.5)
				target:SetWalkSpeed(originalWalk * 0.5)
				
				timer.Create("SCP082_Slow_" .. target:SteamID(), 1, 1, function()
					if IsValid(target) then
						target:SetRunSpeed(originalSpeed)
						target:SetWalkSpeed(originalWalk)
					end
				end)
				
				-- Timer na krwawienie
				timer.Create("SCP082_Bleed_" .. target:SteamID(), 0.5, 10, function()
					if IsValid(target) and target:Alive() then
						target:TakeDamage(2, self.Owner, self)
					else
						timer.Remove("SCP082_Bleed_" .. target:SteamID())
					end
				end)
				
				-- Bonus heal za zabicie
				if target:Health() <= 0 then
					local bonushp = self.Owner:Health() + math.random( 100, 150 )
					if bonushp > self.Owner:GetMaxHealth() then bonushp = self.Owner:GetMaxHealth() end
					self.Owner:SetHealth( bonushp )
				end
			else
				self:SCPDamageEvent( target, 10 )
			end
		elseif slashtrace.Hit then
			self:EmitSound( self.KnifeShink )
			look = self.Owner:GetEyeTrace()
			util.Decal( "ManhackCut", look.HitPos + look.HitNormal * 5, look.HitPos - look.HitNormal * 5 )
		end
	end
	self.Owner:LagCompensation(false)
end

-- RMB - Panika
function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextPanic > CurTime() then return end
	
	self.NextPanic = CurTime() + self.PanicCooldown
	
	if SERVER then
		-- Znajdź gracza na którego patrzymy
		local tr = util.TraceLine({
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.PanicRange,
			filter = self.Owner
		})
		
		if IsValid(tr.Entity) and tr.Entity:IsPlayer() then
			if tr.Entity:GTeam() != TEAM_SCP and tr.Entity:GTeam() != TEAM_SPEC then
				-- Dźwięk krzyku
				self.Owner:EmitSound("npc/stalker/go_alert2a.wav", 100, 80)
				
				-- Wyślij efekt paniki
				net.Start("SCP082_Panic")
					net.WriteFloat(CurTime() + self.PanicDuration)
				net.Send(tr.Entity)
				
				-- Zablokuj strzelanie
				tr.Entity.PanicEnd = CurTime() + self.PanicDuration
				

			end
		end
	end
end

-- Jedzenie ciał
function SWEP:EatCorpse(ragdoll)
	if not SERVER then return end
	
	-- Animacja jedzenia
	self.Owner:EmitSound("npc/barnacle/barnacle_crunch" .. math.random(2,3) .. ".wav", 75, 100)
	
	-- Heal 200 HP
	local hp = self.Owner:Health() + 200
	if hp > self.Owner:GetMaxHealth() then hp = self.Owner:GetMaxHealth() end
	self.Owner:SetHealth(hp)
	
	-- Usuń ciało
	ragdoll:Remove()
	
	-- Efekt krwi
	local effectdata = EffectData()
	effectdata:SetOrigin(self.Owner:GetPos())
	effectdata:SetNormal(Vector(0,0,1))
	util.Effect("BloodImpact", effectdata)
end

-- Client: Efekty
if CLIENT then
	net.Receive("SCP082_Panic", function()
		local endTime = net.ReadFloat()
		LocalPlayer().PanicEnd = endTime
	end)
	
	net.Receive("SCP082_Bleed", function()
		LocalPlayer().BleedingEnd = CurTime() + 5
	end)
	
	-- Hook do blokowania strzelania podczas paniki
	hook.Add("StartCommand", "SCP082_PanicBlock", function(ply, cmd)
		if ply.PanicEnd and ply.PanicEnd > CurTime() then
			cmd:RemoveKey(IN_ATTACK)
			cmd:RemoveKey(IN_ATTACK2)
		end
	end)
	
	-- Efekty wizualne
	hook.Add("RenderScreenspaceEffects", "SCP082_Effects", function()
		local ply = LocalPlayer()
		
		-- Efekt paniki
		if ply.PanicEnd and ply.PanicEnd > CurTime() then
			-- Drżenie ekranu
			if math.random() > 0.7 then
				ply:ViewPunch(Angle(math.random(-3, 3), math.random(-3, 3), 0))
			end
			
			-- Rozmazanie
			DrawMotionBlur(0.4, 0.8, 0.01)
		else
			-- Czyść efekt gdy czas minął
			ply.PanicEnd = nil
		end
		
		-- Efekt krwawienia
		if ply.BleedingEnd and ply.BleedingEnd > CurTime() then
			-- Czerwone brzegi ekranu
			local alpha = math.sin(CurTime() * 4) * 50 + 50
			surface.SetDrawColor(255, 0, 0, alpha)
			surface.DrawRect(0, 0, ScrW(), 50)
			surface.DrawRect(0, ScrH() - 50, ScrW(), 50)
			surface.DrawRect(0, 0, 50, ScrH())
			surface.DrawRect(ScrW() - 50, 0, 50, ScrH())
		else
			-- Czyść efekt gdy czas minął
			ply.BleedingEnd = nil
		end
	end)
end

-- HUD
function SWEP:DrawHUD()
	if disablehud == true then return end
	
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-082")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-082")
	
	-- Cooldowny (LMB i RMB)
	local cooldownY = hudY + 60
	local barWidth = 180
	local barHeight = 8
	local spacing = 60
	local totalWidth = barWidth * 2 + spacing
	local startX = centerX - totalWidth / 2
	
	-- LMB Cooldown
	local lmbBarX = startX
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lmbBarX, cooldownY - 15)
	surface.DrawText("LMB - Slash Attack")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
	
	local attackCooldown = 0
	if self.NextPrimary and self.NextPrimary > CurTime() then
		attackCooldown = self.NextPrimary - CurTime()
	end
	
	if attackCooldown > 0 then
		local progress = 1 - (attackCooldown / 1.75)
		surface.SetDrawColor(255, 100, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", attackCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- RMB Cooldown (Panika)
	local rmbBarX = startX + barWidth + spacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rmbBarX, cooldownY - 15)
	surface.DrawText("RMB - Panic")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
	
	local panicCooldown = 0
	if self.NextPanic and self.NextPanic > CurTime() then
		panicCooldown = self.NextPanic - CurTime()
	end
	
	if panicCooldown > 0 then
		local progress = 1 - (panicCooldown / self.PanicCooldown)
		surface.SetDrawColor(255, 255, 0, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", panicCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- Info na dole
	surface.SetFont("DermaDefault")
	surface.SetTextColor(200, 200, 200, 255)
	local infoText = "Press E on corpses to eat (+200 HP)"
	local tw, th = surface.GetTextSize(infoText)
	surface.SetTextPos(centerX - tw/2, hudY + hudHeight - 20)
	surface.DrawText(infoText)
	
	-- Celownik
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	
	local scale = 0.3
	surface.SetDrawColor(200, 100, 100, 255)
	
	local gap = 5
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )
end

-- Czyszczenie
function SWEP:OnRemove()
	if SERVER then
		hook.Remove("PlayerUse", "SCP082_EatCorpse_" .. self:EntIndex())
	end
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_096.lua
================================================
AddCSLuaFile()

SWEP.Base 				= "weapon_scp_base"
SWEP.PrintName			= "SCP096"

SWEP.DrawCrosshair		= true
SWEP.ViewModel			= "models/weapons/v_arms_scp096.mdl"

SWEP.Primary.Sound 		= "weapons/scp96/attack1.wav"
SWEP.HoldType 			= "knife"

SWEP.NextAttackW		= 0
SWEP.IsWatched			= false

if CLIENT then
	SWEP.WepSelectIcon	= surface.GetTextureID( "vgui/entities/weapon_scp096" )
end

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_096" )

    self:SetHoldType( self.HoldType )
		
	sound.Add( { name = "096_1", channel = CHAN_STATIC, volume = 1.0, level = 80, pitch = { 95, 110 }, sound = "weapons/scp96/096_1.mp3" } )
	sound.Add( { name = "096_2", channel = CHAN_STATIC, volume = 1.0, level = 80, pitch = { 95, 110 }, sound = "weapons/scp96/096_2.mp3" } )
	sound.Add( { name = "096_3", channel = CHAN_STATIC, volume = 1.0, level = 80, pitch = { 95, 110 }, sound = "weapons/scp96/096_3.mp3" } )
	
	util.PrecacheSound("096_1")
	util.PrecacheSound("096_2")
	util.PrecacheSound("096_3")
	util.PrecacheSound("weapons/scp96/attack1.wav")
	util.PrecacheSound("weapons/scp96/attack2.wav")
	util.PrecacheSound("weapons/scp96/attack3.wav")
	util.PrecacheSound("weapons/scp96/attack4.wav")
	util.PrecacheSound("weapons/scp96/096_idle1.wav")
	util.PrecacheSound("weapons/scp96/096_idle2.wav")
	util.PrecacheSound("weapons/scp96/096_idle3.wav")
end

function SWEP:IsLookingAt( ply )
	local yes = ply:GetAimVector():Dot( ( self.Owner:GetPos() - ply:GetPos() + Vector( 70 ) ):GetNormalized() )
	return yes > 0.39
end

SWEP.NextIdle = 0
function SWEP:Think()
	if self.NextIdle < CurTime() then
		self:SendWeaponAnim( ACT_VM_IDLE )
		self.NextIdle = CurTime() + self:SequenceDuration( ACT_VM_IDLE )
	end
	if postround then return end
	local watching = 0
	for k,v in pairs(player.GetAll()) do
		if IsValid(v) and v:GTeam() != TEAM_SPEC and v:Alive() and v != self.Owner and v.canblink then
			local tr_eyes = util.TraceLine( {
				start = v:EyePos() + v:EyeAngles():Forward() * 15,
				//start = v:LocalToWorld( v:OBBCenter() ),
				//start = v:GetPos() + (self.Owner:EyeAngles():Forward() * 5000),
				endpos = self.Owner:EyePos(),
				//filter = v
			} )
			local tr_center = util.TraceLine( {
				start = v:LocalToWorld( v:OBBCenter() ),
				endpos = self.Owner:LocalToWorld( self.Owner:OBBCenter() ),
				filter = v
			} )
			if tr_eyes.Entity == self.Owner or tr_center.Entity == self.Owner then
				//self.Owner:PrintMessage(HUD_PRINTTALK, tostring(tr_eyes.Entity) .. " : " .. tostring(tr_center.Entity) .. " : " .. tostring(tr_center.Entity))
				if self:IsLookingAt( v ) and v.isblinking == false then
					watching = watching + 1
					//if self:GetPos():Distance(v:GetPos()) > 100 then
						//self.Owner:PrintMessage(HUD_PRINTTALK, v:Nick() .. " is looking at you")
					//end 
				end
			end
		end
	end
	
	self.IsWatched = watching > 0
	
	if self.basestats then
		if watching > 0 then
			self.Owner:SetRunSpeed( self.basestats.fast )
			self.Owner:SetWalkSpeed( self.basestats.fast )
		else
			self.Owner:SetRunSpeed( self.basestats.slow )
			self.Owner:SetWalkSpeed( self.basestats.slow )
		end
	end
end

function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if self.NextAttackW > CurTime() then return end
	
	-- Ustaw cooldown na początku dla wszystkich ataków
	self.NextAttackW = CurTime() + 1.25

	self.Owner:SetAnimation( PLAYER_ATTACK1 )
	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	self.NextIdle = CurTime() + 0.7
	
	if SERVER then
		local trace = self.Owner:GetEyeTrace()
		local tr = util.TraceHull( {
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 125,
			filter = { self, self.Owner },
			mins = Vector( -15, -15, -15 ),
			maxs = Vector( 15, 15, 15 ),
			mask = MASK_SHOT_HULL
		} )

		local ent = tr.Entity
		
		if IsValid( ent ) then
			if ent:IsPlayer() then
				if ent:GTeam() == TEAM_SCP and ent:GetNClass() != ROLES.ROLE_SCP035 then return end
				if ent:GTeam() == TEAM_SPEC then return end
				ent:TakeDamage(math.random(60, 100), self.Owner, self.Owner)
			else
				-- Możliwość niszczenia drzwi gdy ktoś się patrzy
				if self.IsWatched and (ent:GetClass() == "func_door" or ent:GetClass() == "func_door_rotating" or ent:GetClass() == "prop_dynamic") then
					-- Znajdź wszystkie powiązane entity drzwi w okolicy
					local doorPos = ent:GetPos()
					local doorsToRemove = {}
					
					-- Dodaj trafioną entity
					table.insert(doorsToRemove, ent)
					
					-- Szukaj innych części drzwi w promieniu 100 jednostek
					for _, nearEnt in pairs(ents.FindInSphere(doorPos, 100)) do
						if IsValid(nearEnt) and nearEnt != ent then
							local class = nearEnt:GetClass()
							if class == "func_door" or class == "func_door_rotating" or class == "prop_dynamic" then
								-- Sprawdź czy entity są blisko siebie (prawdopodobnie część tych samych drzwi)
								if nearEnt:GetPos():Distance(doorPos) < 50 then
									table.insert(doorsToRemove, nearEnt)
								end
							end
						end
					end
					
					-- Usuń wszystkie znalezione części drzwi
					for _, door in pairs(doorsToRemove) do
						if IsValid(door) then
							door:Remove()
						end
					end
					
					-- Efekt dźwiękowy
					self.Owner:EmitSound("physics/wood/wood_crate_break"..math.random(1,5)..".wav", 100, math.random(90, 110))
					-- Efekt wizualny
					local effectdata = EffectData()
					effectdata:SetOrigin(tr.HitPos)
					effectdata:SetNormal(tr.HitNormal)
					util.Effect("ManhackSparks", effectdata)
				else
					self:SCPDamageEvent( ent, 10 )
				end
			end
		end
	end
end

function SWEP:Deploy()
	if self.Owner:IsValid() then
		if SERVER and !self.basestats then
			self.basestats = {
				slow = self.Owner:GetWalkSpeed(),
				fast = self.Owner:GetRunSpeed()
			}
		end

		self.Owner:SetRunSpeed( self.Owner:GetWalkSpeed() )

		self.Owner:DrawWorldModel( false )
		self.Weapon:EmitSound( "weapons/scp96/096_idle"..math.random(1,3)..".wav" )
		
		self:SendWeaponAnim( ACT_VM_DRAW )

		self.NextIdle = CurTime() + self:SequenceDuration( ACT_VM_DRAW )
	end
end

SWEP.NextSpecial = 0
function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextSpecial > CurTime() then return end
	self.NextSpecial = CurTime() + 60 -- Cooldown 60 sekund

	if SERVER then
		-- Znajdź najbliższego gracza w zasięgu 200 jednostek
		local nearbyPlayers = {}
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply != self.Owner and ply:Alive() then
				if ply:GTeam() != TEAM_SCP and ply:GTeam() != TEAM_SPEC then
					local dist = ply:GetPos():Distance(self.Owner:GetPos())
					if dist <= 200 then
						table.insert(nearbyPlayers, ply)
					end
				end
			end
		end
		
		-- Jeśli są gracze w pobliżu
		if #nearbyPlayers > 0 then
			-- Krzyk
			self.Owner:EmitSound("096_"..math.random(1,3))
			
			-- Dla każdego gracza w pobliżu
			for _, ply in pairs(nearbyPlayers) do
				-- 50% szans na wyrzucenie broni
				if math.random() <= 0.5 then
					local wep = ply:GetActiveWeapon()
					if IsValid(wep) then
						local class = wep:GetClass()
						-- Nie wyrzucaj br_id i br_holster
						if class != "br_id" and class != "br_holster" then
							ply:DropWeapon(wep)
							

						end
					end
				end
			end
		else
			-- Jeśli nikogo nie ma w pobliżu, tylko krzyk
			self.Owner:EmitSound("096_"..math.random(1,3))
		end
	end
end

-- HUD
function SWEP:DrawHUD()
	if disablehud == true then return end
	
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-096")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-096")
	
	-- Cooldowny (LMB i RMB)
	local cooldownY = hudY + 60
	local barWidth = 180
	local barHeight = 8
	local spacing = 60
	local totalWidth = barWidth * 2 + spacing
	local startX = centerX - totalWidth / 2
	
	-- LMB Cooldown
	local lmbBarX = startX
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lmbBarX, cooldownY - 15)
	surface.DrawText("LMB - Attack")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
	
	local attackCooldown = 0
	if self.NextAttackW and self.NextAttackW > CurTime() then
		attackCooldown = self.NextAttackW - CurTime()
	end
	
	-- Pokaż cooldown
	if attackCooldown > 0 then
		local progress = 1 - (attackCooldown / 1.25)
		surface.SetDrawColor(255, 100, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", attackCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- RMB Cooldown (Disarm)
	local rmbBarX = startX + barWidth + spacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rmbBarX, cooldownY - 15)
	surface.DrawText("RMB - Scream")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
	
	local screamCooldown = 0
	if self.NextSpecial and self.NextSpecial > CurTime() then
		screamCooldown = self.NextSpecial - CurTime()
	end
	
	if screamCooldown > 0 then
		local progress = 1 - (screamCooldown / 60)
		surface.SetDrawColor(255, 255, 0, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", screamCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- Celownik
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	
	local scale = 0.3
	surface.SetDrawColor(200, 100, 100, 255)
	
	local gap = 5
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_1048a.lua
================================================
AddCSLuaFile()

SWEP.Base 			= "weapon_scp_base"
SWEP.PrintName		= "SCP-1048-A"

SWEP.DrawCrosshair	= true
SWEP.HoldType 		= "melee"


function SWEP:Initialize()
	self:InitializeLanguage( "SCP_1048A" )

	self:SetHoldType( self.HoldType )

	sound.Add( {
		name = "attack",
		channel = CHAN_STATIC,
		volume = 1.0,
		level = 150,
		pitch = 100,
		sound = "scp/1048A/attack.ogg"	
	} )
end

SWEP.NextPrimary = 0

function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextPrimary > CurTime() then return end
	self.NextPrimary = CurTime() + 8
	if SERVER then
		self.Owner:EmitSound( "attack" )
		timer.Create( "Attack1048A", 0.4, 15, function()
			if !IsValid( self ) or !IsValid( self.Owner ) then
				timer.Destroy( "Attack1048A" )
				return
			end
			fent = ents.FindInSphere( self.Owner:GetPos(), 200 )
			for k, v in pairs( fent ) do
				if IsValid( v ) then
					if v:IsPlayer() then
						if v:GTeam() != TEAM_SPEC and (v:GTeam() != TEAM_SCP or v:GetNClass() == ROLES.ROLE_SCP035) then
							local oldHP = v:Health()
							v:TakeDamage( 2, self.Owner, self.Owner )
							-- Sprawdź czy gracz został zabity
							if oldHP > 0 and v:Health() <= 0 then
								-- Daj 150 HP za zabicie
								self.Owner:SetHealth( math.min( self.Owner:Health() + 150, self.Owner:GetMaxHealth() ) )
							end
						end
					else
						self:SCPDamageEvent( v, 5 )
					end
				end
			end
		end )
	end
end

function SWEP:DrawHUD()
	if disablehud == true then return end
	
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD (tak jak w SCP-069 i SCP-049)
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-1048-A")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-1048-A")
	
	-- Cooldown ataku
	local cooldownY = hudY + 60
	local barWidth = 200
	local barHeight = 8
	local barX = centerX - barWidth / 2
	
	-- LMB (Attack) Cooldown
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(barX, cooldownY - 15)
	surface.DrawText("LMB - Attack")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(barX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(barX, cooldownY, barWidth, barHeight)
	
	local attackCooldown = 0
	if self.NextPrimary and self.NextPrimary > CurTime() then
		attackCooldown = self.NextPrimary - CurTime()
	end
	
	if attackCooldown > 0 then
		local progress = 1 - (attackCooldown / 8)
		surface.SetDrawColor(255, 100, 100, 255)
		surface.DrawRect(barX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(barX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", attackCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(barX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(barX, cooldownY + 10)
		surface.DrawText("READY")
	end
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_1048b.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_scp_base"
SWEP.PrintName = "SCP-1048-B"
SWEP.Category = "SCP"

-- Oryginalne modele z ffv_hhsaw
SWEP.ViewModel = "models/weapons/c_physcannon.mdl"
SWEP.WorldModel = "models/weapons/w_physics.mdl"
SWEP.ViewModelFOV = 62.51256281407
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true

SWEP.HoldType = "physgun"

SWEP.Primary.Ammo = ""
SWEP.Secondary.Ammo = ""
SWEP.Primary.Automatic = true
SWEP.Secondary.Automatic = true

-- KONFIGURACJA BRONI
SWEP.SawRange = 60 -- Zasięg piły w jednostkach
SWEP.DamageToPlayers = {3, 8} -- Min i max obrażenia dla graczy (nie-SCP)
SWEP.DamageToEntities = {10, 60} -- Min i max obrażenia dla innych entów
SWEP.ExpPerHit = 15 -- EXP za trafienie gracza
SWEP.ChaseSpeedBonus = 1.3 -- Mnożnik prędkości gdy goni wroga (1.3 = 30% szybciej)
SWEP.ChaseDetectionRange = 1000 -- Zasięg wykrywania wrogów do pościgu
SWEP.ChaseAngleTolerance = 45 -- Kąt patrzenia na wroga (w stopniach)
SWEP.LowHealthVisionThreshold = 30 -- Próg HP do widzenia przez ściany
SWEP.LowHealthVisionRange = 500 -- Zasięg widzenia przez ściany (jednostki)

-- Zmienne piły
SWEP.spinSound = nil
SWEP.timeShot = 0
SWEP.animPlace = 0

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("breach/wep_106") -- Tymczasowo
	
	-- Pozycje iron sight
	SWEP.ironsightPoses = {Vector(0, 0, -6.031), Vector(0, -2, -5.031)}
	SWEP.IronSightsPos = Vector(0, 0, -6.031)
	SWEP.IronSightsAng = Vector(7.738, 0, 0)
end

function to_goal(num, goal, change)
	return math.Clamp(goal, num - change, num + change)
end

function place_between(goal, num1, num2)
	return ((num2 - num1) / goal) + num1
end

function SWEP:Initialize()
	self:InitializeLanguage("SCP_1048B")
	
	self.spinSound = CreateSound(self, "vehicles/airboat/fan_blade_fullthrottle_loop1.wav")
	self:SetHoldType(self.HoldType)
	
	-- Predicted hooks
	self:SetNWBool("firing", false)
	self:SetNWFloat("spinSpeed", 0)

	if CLIENT then
		-- Viewmodel elements
		self.VElements = {
			["backcover"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "Base", rel = "base", pos = Vector(0.554, 3.418, -23.215), angle = Angle(0, 0, 0), size = Vector(0.5, 0.5, 0.057), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
			["base"] = { type = "Model", model = "models/props_c17/FurnitureBoiler001a.mdl", bone = "Base", rel = "", pos = Vector(1.1, 5.8, 9), angle = Angle(0, 180, 0), size = Vector(0.483, 0.483, 0.483), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
			["sawbase"] = { type = "Model", model = "models/props_c17/canister01a.mdl", bone = "Base", rel = "base", pos = Vector(0, 3, 20.26), angle = Angle(0, 180, 0), size = Vector(0.5, 0.5, 0.5), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
			["saw"] = { type = "Model", model = "models/props_junk/sawblade001a.mdl", bone = "Base", rel = "base", pos = Vector(0, 3, 34.631), angle = Angle(0, 90, 90), size = Vector(0.5, 0.5, 0.5), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
			["canister"] = { type = "Model", model = "models/props_junk/propane_tank001a.mdl", bone = "Base", rel = "base", pos = Vector(0, 17.885, -12.988), angle = Angle(158.498, 0, -90), size = Vector(0.5, 0.5, 0.5), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
		}
		
		-- Worldmodel elements
		self.WElements = {
			["backcover"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "base", pos = Vector(0.554, 3.418, -23.215), angle = Angle(0, 0, 0), size = Vector(0.5, 0.5, 0.057), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
			["base"] = { type = "Model", model = "models/props_c17/FurnitureBoiler001a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(27.708, -2.447, -4.874), angle = Angle(35, 100, 105), size = Vector(0.483, 0.483, 0.483), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
			["sawbase"] = { type = "Model", model = "models/props_c17/canister01a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "base", pos = Vector(0, 3, 20.26), angle = Angle(0, 180, 0), size = Vector(0.5, 0.5, 0.5), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
			["saw"] = { type = "Model", model = "models/props_junk/sawblade001a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "base", pos = Vector(0, 3, 34.631), angle = Angle(0, 90, 90), size = Vector(0.5, 0.5, 0.5), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
			["canister"] = { type = "Model", model = "models/props_junk/propane_tank001a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "base", pos = Vector(0, 17.885, -12.988), angle = Angle(30.993, 0, -90), size = Vector(0.5, 0.5, 0.5), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
		}
		
		self.ViewModelBoneMods = {}
		
		-- Create models
		self.VElements = table.FullCopy(self.VElements)
		self.WElements = table.FullCopy(self.WElements)
		self.ViewModelBoneMods = table.FullCopy(self.ViewModelBoneMods)

		self:CreateModels(self.VElements)
		self:CreateModels(self.WElements)
		
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					vm:SetColor(Color(255,255,255,1))
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
	end
end

function SWEP:PrimaryAttack()
	if preparing or postround then return end
	self.timeShot = CurTime()
	self:SetNWBool("firing", true)
end

function SWEP:SecondaryAttack()
	-- RMB wyłączone - brak rzucania piłą
end

function SWEP:Think()
	local ply = self:GetOwner()
	if not IsValid(ply) then return end
	
	-- Sprawdź czy gracz goni wroga (tylko SERVER)
	if SERVER then
		local chasingEnemy = false
		local nearestEnemy = nil
		local nearestDist = self.ChaseDetectionRange
		
		-- Znajdź najbliższego wroga
		for _, target in pairs(player.GetAll()) do
			if IsValid(target) and target:Alive() and target != ply then
				-- Sprawdź czy to nie SCP/SPEC
				if target:GTeam() != TEAM_SCP and target:GTeam() != TEAM_SPEC then
					local dist = ply:GetPos():Distance(target:GetPos())
					if dist < nearestDist then
						nearestDist = dist
						nearestEnemy = target
					end
				end
			end
		end
		
		-- Sprawdź czy patrzymy na wroga
		if IsValid(nearestEnemy) then
			local toEnemy = (nearestEnemy:GetPos() - ply:GetPos()):GetNormalized()
			local forward = ply:GetAimVector()
			local dot = forward:Dot(toEnemy)
			local angle = math.deg(math.acos(dot))
			
			-- Czy patrzymy w kierunku wroga?
			if angle < self.ChaseAngleTolerance then
				chasingEnemy = true
			end
		end
		
		-- Ustaw prędkość
		if chasingEnemy then
			if not ply.OriginalSpeed then
				ply.OriginalSpeed = ply:GetWalkSpeed()
				ply.OriginalRunSpeed = ply:GetRunSpeed()
			end
			ply:SetWalkSpeed(ply.OriginalSpeed * self.ChaseSpeedBonus)
			ply:SetRunSpeed(ply.OriginalRunSpeed * self.ChaseSpeedBonus)
		else
			-- Przywróć normalną prędkość
			if ply.OriginalSpeed and ply.OriginalRunSpeed then
				ply:SetWalkSpeed(ply.OriginalSpeed)
				ply:SetRunSpeed(ply.OriginalRunSpeed)
			end
		end
	end
	
	-- Client animation
	if CLIENT then
		-- Hold position
		local animGoal = 1
		if self:GetNWBool("firing") then animGoal = 4 end
		self.animPlace = to_goal(self.animPlace, animGoal, .1)

		local x1, y1, z1 = self.ironsightPoses[1]:Unpack()
		local x2, y2, z2 = self.ironsightPoses[2]:Unpack()
		self.IronSightsPos = Vector(
			place_between(self.animPlace, x1, x2),
			place_between(self.animPlace, y1, y2),
			place_between(self.animPlace, z1, z2)
		)

		-- Spinny blade
		local goal = 0
		if self:GetNWBool("firing") then goal = 8 end
		self.VElements.saw.angle = self.VElements.saw.angle + Angle(-self:GetNWFloat("spinSpeed"), 0, 0)
		self.VElements.saw.size = Vector(.5, .5, .5) -- Piła zawsze widoczna
		return
	end

	-- Spin sound volume
	self.spinSound:ChangeVolume(self:GetNWFloat("spinSpeed") / 8)

	if (CurTime() - self.timeShot) > 0.02 then
		-- Not firing
		self:SetNWBool("firing", false)
		self:SetNWFloat("spinSpeed", to_goal(self:GetNWFloat("spinSpeed"), 0, .02))
	else
		-- Is firing
		self:SetNWFloat("spinSpeed", to_goal(self:GetNWFloat("spinSpeed"), 8, .06))

		-- Damage timer
		if not timer.Exists("sawStuff"..ply:SteamID64()) then
			timer.Create("sawStuff"..ply:SteamID64(), .1, 0, function()
				if not IsValid(self) or not self:GetNWBool("firing") then
					timer.Remove("sawStuff"..ply:SteamID64())
					return
				end
				local trace = ply:GetEyeTrace()
				if not ((trace.HitPos - trace.StartPos):Length() < self.SawRange) then
					return
				end

				local ent = trace.Entity
				if IsValid(ent) then
					-- Obrażenia dla SCP
					if ent:IsPlayer() then
						if (ent:GTeam() == TEAM_SCP and ent:GetNClass() != ROLES.ROLE_SCP035) or ent:GTeam() == TEAM_SPEC then return end
						ent:TakeDamage(math.random(self.DamageToPlayers[1], self.DamageToPlayers[2]), ply, self)
						if IsValid(ply) then
							ply:AddExp(self.ExpPerHit, true)
						end
					else
						ent:TakeDamage(math.random(self.DamageToEntities[1], self.DamageToEntities[2]), ply, self)
					end
					
					local phys = ent:GetPhysicsObject()
					if IsValid(phys) then
						phys:ApplyForceOffset(ply:GetAimVector() * 240 * self:GetNWFloat("spinSpeed"), trace.HitPos)
					end

					local effect = EffectData()
					effect:SetOrigin(trace.HitPos)
					effect:SetNormal(trace.HitNormal)

					if ent:IsNPC() or ent:IsRagdoll() or ent:IsPlayer() then
						self:EmitSound("npc/manhack/grind_flesh"..math.random(3)..".wav")
						util.Effect("BloodImpact", effect)

						-- Blood decals
						util.Decal("Blood", trace.HitPos + trace.HitNormal, trace.HitPos - trace.HitNormal)
						if math.random(3) == 1 then
							local trace2 = {}
							trace2.start = trace.HitPos
							trace2.endpos = trace.HitPos + Vector(0, 0, -10000)
							trace2.filter = ent
							trace2 = util.TraceLine(trace2)
							util.Decal("Blood", trace2.HitPos + trace2.HitNormal, trace2.HitPos - trace2.HitNormal, ent)
						end
					else
						self:EmitSound("npc/manhack/grind"..math.random(5)..".wav")
						util.Effect("ManhackSparks", effect)
					end
				end
			end)
		end
	end
end

function SWEP:Deploy()
	self.spinSound:PlayEx(0, 100)
end

function SWEP:Holster()
	self:SetNWFloat("spinSpeed", 0)
	self.spinSound:Stop()
	
	-- Przywróć normalną prędkość
	if SERVER and IsValid(self.Owner) then
		if self.Owner.OriginalSpeed and self.Owner.OriginalRunSpeed then
			self.Owner:SetWalkSpeed(self.Owner.OriginalSpeed)
			self.Owner:SetRunSpeed(self.Owner.OriginalRunSpeed)
			self.Owner.OriginalSpeed = nil
			self.Owner.OriginalRunSpeed = nil
		end
	end
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	-- Usuń timer obrażeń
	if IsValid(self.Owner) then
		timer.Remove("sawStuff"..self.Owner:SteamID64())
		
		-- Przywróć normalną prędkość
		if SERVER and self.Owner.OriginalSpeed and self.Owner.OriginalRunSpeed then
			self.Owner:SetWalkSpeed(self.Owner.OriginalSpeed)
			self.Owner:SetRunSpeed(self.Owner.OriginalRunSpeed)
			self.Owner.OriginalSpeed = nil
			self.Owner.OriginalRunSpeed = nil
		end
	end
	
	self:Holster()
end

-- Rysowanie wrogów z niskim HP przez ściany
if CLIENT then
	hook.Add("PostDrawTranslucentRenderables", "SCP1048B_LowHealthVision", function()
		local ply = LocalPlayer()
		if not IsValid(ply) or not ply:Alive() then return end
		
		local wep = ply:GetActiveWeapon()
		if not IsValid(wep) or wep:GetClass() != "weapon_scp_1048b" then return end
		
		-- Znajdź wszystkich graczy z niskim HP
		for _, target in pairs(player.GetAll()) do
			if IsValid(target) and target != ply and target:Alive() then
				-- Sprawdź czy to nie SCP/SPEC i ma mało HP
				if target:GTeam() != TEAM_SCP and target:GTeam() != TEAM_SPEC then
					if target:Health() < wep.LowHealthVisionThreshold then
						-- Sprawdź zasięg
						local dist = ply:GetPos():Distance(target:GetPos())
						if dist <= wep.LowHealthVisionRange then
							-- Sprawdź czy gracz jest za ścianą
							local trace = util.TraceLine({
								start = ply:EyePos(),
								endpos = target:EyePos(),
								filter = {ply, target}
							})
							
							-- Renderuj tylko jeśli gracz jest za ścianą
							if trace.Hit then
						
						-- Ustaw kolor na podstawie HP
						local healthPercent = target:Health() / wep.LowHealthVisionThreshold
						local r = 255
						local g = 255 * healthPercent
						local b = 0
						
						-- Włącz ignorowanie Z-bufferu (renderowanie przez ściany)
						cam.IgnoreZ(true)
						
						-- Renderuj model przez ściany z efektem "glow"
						render.SuppressEngineLighting(true)
						render.SetColorModulation(r/255, g/255, b/255)
						render.SetBlend(0.8) -- Lekka przezroczystość
						render.MaterialOverride(Material("models/debug/debugwhite"))
						
						-- Rysuj model
						target:DrawModel()
						
						-- Przywróć ustawienia
						render.MaterialOverride()
						render.SetColorModulation(1, 1, 1)
						render.SetBlend(1)
						render.SuppressEngineLighting(false)
						
						-- Wyłącz ignorowanie Z-bufferu
						cam.IgnoreZ(false)
						
						-- Dodatkowo narysuj obrys
						render.SetStencilEnable(true)
						render.SetStencilWriteMask(1)
						render.SetStencilTestMask(1)
						render.SetStencilReferenceValue(1)
						
						-- Pierwszy pass - zapisz do stencil
						render.SetStencilCompareFunction(STENCIL_ALWAYS)
						render.SetStencilPassOperation(STENCIL_REPLACE)
						render.SetStencilFailOperation(STENCIL_KEEP)
						render.SetStencilZFailOperation(STENCIL_KEEP)
						
						render.OverrideDepthEnable(true, false)
						target:DrawModel()
						render.OverrideDepthEnable(false, false)
						
						-- Drugi pass - rysuj obrys
						render.SetStencilCompareFunction(STENCIL_NOTEQUAL)
						render.SetStencilPassOperation(STENCIL_KEEP)
						render.SetStencilFailOperation(STENCIL_KEEP)
						render.SetStencilZFailOperation(STENCIL_KEEP)
						
						-- Powiększ model dla obrysu
						local mat = Matrix()
						mat:Scale(Vector(1.05, 1.05, 1.05))
						target:EnableMatrix("RenderMultiply", mat)
						
						render.SetColorModulation(r/255, g/255, b/255)
						render.MaterialOverride(Material("models/wireframe"))
						target:DrawModel()
						
						target:DisableMatrix("RenderMultiply")
						render.MaterialOverride()
						render.SetColorModulation(1, 1, 1)
						
						render.SetStencilEnable(false)
							end -- end trace.Hit
						end -- end dist check
					end
				end
			end
		end
	end)
end

function SWEP:DrawHUD()
	if disablehud == true then return end
	
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-1048-B")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-1048-B")
	
	-- Info o pile
	local infoY = hudY + 60
	surface.SetFont("DermaDefaultBold")
	surface.SetTextColor(200, 200, 200, 255)
	
	-- Moc piły
	local power = self:GetNWFloat("spinSpeed") / 8
	local barWidth = 300
	local barHeight = 10
	local barX = centerX - barWidth / 2
	
	surface.SetTextPos(centerX - 50, infoY - 20)
	surface.DrawText("Saw Power")
	
	-- Tło paska
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(barX, infoY, barWidth, barHeight)
	
	-- Pasek mocy
	if power > 0 then
		surface.SetDrawColor(255, 100 + power * 155, 100, 255)
		surface.DrawRect(barX, infoY, barWidth * power, barHeight)
	end
	
	-- Obramowanie
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(barX, infoY, barWidth, barHeight)
	
	-- Instrukcje
	surface.SetFont("DermaDefault")
	surface.SetTextColor(150, 150, 150, 255)
	surface.SetTextPos(centerX - 50, infoY + 15)
	surface.DrawText("LMB - Spin Saw")
	
	-- Celownik
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	
	-- Animowany celownik gdy piła się kręci
	if self:GetNWFloat("spinSpeed") > 0 then
		local spin = CurTime() * self:GetNWFloat("spinSpeed") * 100
		local scale = 0.5 + self:GetNWFloat("spinSpeed") / 16
		
		surface.SetDrawColor(255, 150, 150, 255)
		
		-- Obracający się celownik
		for i = 0, 3 do
			local angle = math.rad(spin + i * 90)
			local cos = math.cos(angle)
			local sin = math.sin(angle)
			
			local x1 = x + cos * 10
			local y1 = y + sin * 10
			local x2 = x + cos * 30 * scale
			local y2 = y + sin * 30 * scale
			
			surface.DrawLine(x1, y1, x2, y2)
		end
	else
		-- Normalny celownik
		local scale = 0.3
		surface.SetDrawColor(200, 100, 100, 255)
		
		local gap = 5
		local length = gap + 20 * scale
		surface.DrawLine(x - length, y, x - gap, y)
		surface.DrawLine(x + length, y, x + gap, y)
		surface.DrawLine(x, y - length, x, y - gap)
		surface.DrawLine(x, y + length, x, y + gap)
	end
end

function SWEP:GetViewModelPosition(EyePos, EyeAng)
	local Mul = 1.0

	local Offset = self.IronSightsPos

	if self.IronSightsAng then
		EyeAng = EyeAng * 1
		
		EyeAng:RotateAroundAxis(EyeAng:Right(), self.IronSightsAng.x * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Up(), self.IronSightsAng.y * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Forward(), self.IronSightsAng.z * Mul)
	end

	local Right = EyeAng:Right()
	local Up = EyeAng:Up()
	local Forward = EyeAng:Forward()

	EyePos = EyePos + Offset.x * Right * Mul
	EyePos = EyePos + Offset.y * Forward * Mul
	EyePos = EyePos + Offset.z * Up * Mul
	
	return EyePos, EyeAng
end

-- CLIENT SIDE RENDERING
if CLIENT then
	
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()

		self.WElements.saw.angle = self.WElements.saw.angle + Angle(-self:GetNWFloat("spinSpeed"), 0, 0)
		self.WElements.saw.size = Vector(.5, .5, .5) -- Piła zawsze widoczna
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v)
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_106.lua
================================================
AddCSLuaFile()

SWEP.Base 			= "weapon_scp_base"
SWEP.PrintName		= "SCP-106"

SWEP.ViewModel		= "models/vinrax/props/keycard.mdl"
SWEP.WorldModel		= "models/vinrax/props/keycard.mdl"

SWEP.HoldType		= "normal"

SWEP.Chase 			= "scp/106/chase.ogg"
SWEP.Place 			= "scp/106/place.ogg"
SWEP.Teleport 		= "scp/106/tp.ogg"
SWEP.Disappear 		= "scp/106/disappear.ogg"

SWEP.NextAttackW	= 0
SWEP.AttackDelay	= 1.5
SWEP.AttackCount    = 0 -- Licznik ataków dla instakill

if CLIENT then
	SWEP.WepSelectIcon 	= surface.GetTextureID("breach/wep_106")
	SWEP.AttackCounter = 0 -- Kopia dla klienta
end

function SWEP:OnRemove()
	if IsValid( self.Owner ) then
		self.Owner:SetCustomCollisionCheck( false )
	end
end

function SWEP:Deploy()
	if IsValid( self.Owner ) then
		self.Owner:SetCustomCollisionCheck( true )
	end
	self:HideModels()
end

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_106" )

	self:SetHoldType(self.HoldType)

	self:PrecacheSnd( {
		{ name = "Place", snd = self.Place, level = 75 },
		{ name = "Disappear", snd = self.Disappear, level = 125 },
		{ name = "Teleport", snd = self.Teleport, level = 325 },
	} )
end

function SWEP:PrecacheSnd( tab )
	for k, v in pairs( tab ) do
		sound.Add( {
			name = v.name,
			channel = CHAN_STATIC,
			volume = 1.0,
			level = v.level or 75,
			pitch = 100,
			sound = v.snd
		} )
	end
end

SWEP.SoundPlayers = {}
SWEP.NThink = 0
function SWEP:Think()
	if self.NThink > CurTime() then return end
	self.NThink = CurTime() + 1
	if SERVER then
		for k, v in pairs( self.SoundPlayers ) do
			if v.ply:GTeam() == TEAM_SPEC or v.ply:GTeam() == TEAM_SCP or ( v.time and v.time < CurTime() ) or self.Owner:GetPos():DistToSqr( v.ply:GetPos() ) > 562500 then
				net.Start( "SendSound" )
					net.WriteInt( 0, 2 )
					net.WriteString( self.Chase )
				net.Send( v.ply )
				self.SoundPlayers[k] = nil
				--print( "Removing ", v.ply )
			end
		end
		-- OPTYMALIZACJA: Użyj zoptymalizowanej funkcji wyszukiwania graczy
		local nearbyPlayers = {}
		if _G.FindNearbyPlayers then
			nearbyPlayers = _G.FindNearbyPlayers(self.Owner:GetPos(), 750, self.Owner)
		else
			-- Fallback do oryginalnej metody
			local e = ents.FindInSphere( self.Owner:GetPos(), 750 )
			for k, v in pairs( e ) do
				if IsValid( v ) and v:IsPlayer() then
					table.insert(nearbyPlayers, v)
				end
			end
		end

		for k, v in pairs( nearbyPlayers ) do
			if IsValid( v ) and  v:IsPlayer() then
				if  v:GTeam() != TEAM_SPEC and v:GTeam() != TEAM_SCP then
					if !self:IsInTable( self.SoundPlayers, v ) then
						net.Start( "SendSound" )
							net.WriteInt( 1, 2 )
							net.WriteString( self.Chase )
						net.Send( v )
						table.insert( self.SoundPlayers, { ply = v, time = CurTime() + 31 } )
						--print( "inserting ", v )
					end
				end
			end
		end
	end
end

function SWEP:PrimaryAttack()
	//if ( !self:CanPrimaryAttack() ) then return end
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextAttackW > CurTime() then return end
	
	if SERVER then
		local ent = nil
		local tr = util.TraceHull( {
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + ( self.Owner:GetAimVector() * 100 ),
			filter = self.Owner,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			mask = MASK_SHOT_HULL
		} )
		ent = tr.Entity
		if IsValid(ent) then
			-- Ustaw cooldown tylko gdy trafiliśmy w coś
			self.NextAttackW = CurTime() + self.AttackDelay
			self:SetNWFloat("NextAttackW", self.NextAttackW) -- Synchronizuj z klientem
			
			if ent:IsPlayer() then
				if ent:GTeam() == TEAM_SCP and ent:GetNClass() != ROLES.ROLE_SCP035 then return end
				if ent:GTeam() == TEAM_SPEC then return end
				if ent.Using714 then return end
				
				-- Zwiększ licznik ataków
				self.AttackCount = self.AttackCount + 1
				self:SetNWInt("AttackCounter", self.AttackCount) -- Synchronizuj z klientem
				
				local pos = GetPocketPos()
				local ang = ent:GetAngles()
				ang.yaw = math.random( -180, 180 )
				if pos then
					roundstats.teleported = roundstats.teleported + 1
					
					-- Co trzeci atak = instakill
					if self.AttackCount >= 3 then
						self.AttackCount = 0 -- Reset licznika
						self:SetNWInt("AttackCounter", 0) -- Synchronizuj reset
						ent:Kill() -- Instakill
						self.Owner:AddExp(150, true) -- Więcej EXP za instakill
					else
						-- Normalny atak
						ent:TakeDamage( math.random( 25, 50 ), self.Owner, self.Owner )
						ent:SetPos(pos)
						ent:SetAngles( ang )
						self.Owner:AddExp(75, true)
					end
				end
			else
				self:SCPDamageEvent( ent, 10 )
			end
		end
		-- Jeśli nie trafiliśmy w nic, nie ustawiamy cooldownu
	end
end

SWEP.NextPlace = 0
SWEP.TPPoint = nil
function SWEP:SecondaryAttack()
	if SERVER then
		if self.NextPlace > CurTime() then
			self.Owner:PrintMessage( HUD_PRINTTALK, "You have to wait "..math.ceil( self.NextPlace - CurTime() ).." before next use!" )
			return
		end
		self.NextPlace = CurTime() + 15

		-- Synchronizuj z klientem
		self:SetNWFloat("NextPlace", self.NextPlace)

		self.Owner:EmitSound( "Place" )
		self.TPPoint = self.Owner:GetPos()
		
		local tr = util.TraceLine( {
			start = self.Owner:GetPos(),
			endpos = self.Owner:GetPos() - Vector( 0, 0, 100 ),
			filter = self.Owner
		} )
		if tr.Hit then
			util.Decal( "Decal106", tr.HitPos - tr.HitNormal, tr.HitPos + tr.HitNormal )
		end
	end
end

SWEP.NextTP = 0
function SWEP:Reload()
	if !IsFirstTimePredicted() then return end

	if self.NextTP > CurTime() then return end
	self.NextTP = CurTime() + 60 -- Zmiana z 90 na 60 sekund

	if SERVER then
		if self.TPPoint then
			self:TeleportSequence( self.TPPoint )
		end
	end
end

function SWEP:TeleportSequence( point )
	self.NextAttackW = CurTime() + 8
	self:SetNWFloat("NextAttackW", self.NextAttackW) -- Synchronizuj atak
	self.NextPlace = CurTime() + 15
	self:SetNWFloat("NextPlace", self.NextPlace) -- Synchronizuj z klientem

	local tr = util.TraceLine( {
		start = self.Owner:GetPos(),
		endpos = self.Owner:GetPos() - Vector( 0, 0, 100 ),
		filter = self.Owner
	} )
	if tr.Hit then
		util.Decal( "Decal106", tr.HitPos - tr.HitNormal, tr.HitPos + tr.HitNormal )
	end

	self.Owner:Freeze( true )

	if timer.Exists( "106TP_1"..self.Owner:SteamID64() ) then timer.Remove( "106TP_1"..self.Owner:SteamID64() ) end
	if timer.Exists( "106TP_2"..self.Owner:SteamID64() ) then timer.Remove( "106TP_2"..self.Owner:SteamID64() ) end

	local i = 40
	local ppos = self.Owner:GetPos()
	timer.Create( "106TP_1"..self.Owner:SteamID64(), 0.1, 40, function()
		if IsValid( self ) and IsValid( self.Owner ) then
			if i % 20 == 0 then
				self:SendSound( self.Disappear, 500 )
			end
			self.Owner:SetPos( ppos - Vector( 0, 0, 2 * ( 40 - i ) ) )
		end
		i = i - 1
	end )
	timer.Simple( 4.1, function()
		if IsValid( self ) and IsValid( self.Owner ) then
			self.Owner:SetPos( point - Vector( 0, 0, 80 ) )
		end
		local i = 40
		timer.Create( "106TP_2"..self.Owner:SteamID64(), 0.1, 41, function()
			if IsValid( self ) and IsValid( self.Owner ) then
				if i == 40 or i == 10 then
					self:SendSound( self.Teleport, 500 )
				end
				self.Owner:SetPos( point - Vector( 0, 0, 80 ) + Vector( 0, 0, 2 * ( 41 - i ) ) )
				i = i - 1
			end
		end )
		timer.Simple( 4.1, function()
			if IsValid( self ) and IsValid( self.Owner ) then
				self.Owner:SetPos( point )
				self.Owner:Freeze( false )
			end			
		end )
	end )
end

function SWEP:SendSound( sound, range )
	-- OPTYMALIZACJA: Użyj zoptymalizowanej funkcji wyszukiwania
	local nearbyPlayers = {}
	if _G.FindNearbyPlayers then
		nearbyPlayers = _G.FindNearbyPlayers(self.Owner:GetPos(), range, self.Owner)
	else
		-- Fallback do oryginalnej metody
		local e = ents.FindInSphere( self.Owner:GetPos(), range )
		for k, v in pairs( e ) do
			if IsValid( v ) and v:IsPlayer() then
				table.insert(nearbyPlayers, v)
			end
		end
	end

	for k, v in pairs( nearbyPlayers ) do
		if IsValid( v ) and  v:IsPlayer() then
			net.Start( "SendSound" )
				net.WriteInt( 1, 2 )
				net.WriteString( sound )
			net.Send( v )
		end
	end
end

function SWEP:DrawHUD()
	if disablehud == true then return end
	
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-106")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-106")
	
	-- Cooldowny
	local cooldownY = hudY + 60
	local barWidth = 140
	local barHeight = 8
	local spacing = 20 -- Zmniejszony odstęp z 40 na 20
	local totalWidth = barWidth * 3 + spacing * 2
	local startX = centerX - totalWidth / 2
	
	-- LMB Cooldown (Pocket Dimension)
	local lmbBarX = startX
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lmbBarX, cooldownY - 15)
	surface.DrawText("LMB - Pocket")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
	
	local attackCooldown = 0
	-- Pobierz z networked variable
	local nextAttack = self:GetNWFloat("NextAttackW", 0)
	if nextAttack > CurTime() then
		attackCooldown = nextAttack - CurTime()
	end
	
	if attackCooldown > 0 then
		local progress = 1 - (attackCooldown / self.AttackDelay)
		surface.SetDrawColor(255, 100, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", attackCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- RMB Cooldown (Place TP)
	local rmbBarX = startX + barWidth + spacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rmbBarX, cooldownY - 15)
	surface.DrawText("RMB - Place TP")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
	
	local placeCooldown = 0
	-- Pobierz z networked variable
	local nextPlace = self:GetNWFloat("NextPlace", 0)
	if nextPlace > CurTime() then
		placeCooldown = nextPlace - CurTime()
	end
	
	if placeCooldown > 0 then
		local progress = 1 - (placeCooldown / 15)
		surface.SetDrawColor(255, 255, 0, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", placeCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- R Cooldown (Teleport)
	local rBarX = startX + (barWidth + spacing) * 2
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rBarX, cooldownY - 15)
	surface.DrawText("R - Teleport")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rBarX, cooldownY, barWidth, barHeight)
	
	local tpCooldown = 0
	if self.NextTP and self.NextTP > CurTime() then
		tpCooldown = self.NextTP - CurTime()
	end
	
	if tpCooldown > 0 then
		local progress = 1 - (tpCooldown / 60)
		surface.SetDrawColor(148, 0, 211, 255) -- Fioletowy dla teleportu
		surface.DrawRect(rBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(200, 150, 255, 255)
		surface.SetTextPos(rBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", tpCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(rBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- Celownik
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	
	-- Pobierz licznik z networked variable
	local attackCounter = self:GetNWInt("AttackCounter", 0)
	
	-- Efekt gdy następny atak będzie instakill
	if attackCounter == 2 then
		local time = CurTime()
		
		-- Pulsujący efekt
		local pulse = math.sin(time * 5) * 0.3 + 0.7 -- Wartość od 0.4 do 1.0
		local pulseScale = 1 + math.sin(time * 3) * 0.2 -- Pulsująca wielkość
		
		-- Czerwone pulsujące zewnętrzne okręgi
		local radius = 40 * pulseScale
		surface.SetDrawColor(255, 0, 0, 100 * pulse)
		
		-- Rysuj okręgi
		for i = 1, 3 do
			local r = radius + i * 10
			-- Górny łuk
			surface.DrawLine(x - r, y, x - r + 10, y - 10)
			surface.DrawLine(x - r + 10, y - 10, x, y - r)
			surface.DrawLine(x, y - r, x + r - 10, y - 10)
			surface.DrawLine(x + r - 10, y - 10, x + r, y)
			-- Dolny łuk
			surface.DrawLine(x + r, y, x + r - 10, y + 10)
			surface.DrawLine(x + r - 10, y + 10, x, y + r)
			surface.DrawLine(x, y + r, x - r + 10, y + 10)
			surface.DrawLine(x - r + 10, y + 10, x - r, y)
		end
		
		-- Czerwony pulsujący celownik
		local scale = 0.3 + pulse * 0.1
		surface.SetDrawColor(255, 0, 0, 255) -- Jasny czerwony
		
		local gap = 5
		local length = gap + 20 * scale
		
		-- Grubsze linie
		for i = -1, 1 do
			surface.DrawLine( x - length, y + i, x - gap, y + i )
			surface.DrawLine( x + length, y + i, x + gap, y + i )
			surface.DrawLine( x + i, y - length, x + i, y - gap )
			surface.DrawLine( x + i, y + length, x + i, y + gap )
		end
		
		-- Tekst ostrzeżenia
		local warningAlpha = 255 * pulse
		draw.SimpleTextOutlined("INSTAKILL READY", "DermaLarge", x, y - 60,
			Color(255, 0, 0, warningAlpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER,
			2, Color(0, 0, 0, warningAlpha))
		
		-- Małe czerwone kropki wokół celownika
		local dotRadius = 25 + math.sin(time * 4) * 5
		for i = 0, 7 do
			local angle = (i / 8) * math.pi * 2 + time
			local dx = x + math.cos(angle) * dotRadius
			local dy = y + math.sin(angle) * dotRadius
			surface.SetDrawColor(255, 0, 0, warningAlpha)
			surface.DrawRect(dx - 2, dy - 2, 4, 4)
		end
	else
		-- Normalny celownik
		local scale = 0.3
		surface.SetDrawColor(100, 0, 100, 255) -- Ciemny fiolet dla 106
		
		local gap = 5
		local length = gap + 20 * scale
		surface.DrawLine( x - length, y, x - gap, y )
		surface.DrawLine( x + length, y, x + gap, y )
		surface.DrawLine( x, y - length, x, y - gap )
		surface.DrawLine( x, y + length, x, y + gap )
	end
end

function SWEP:IsInTable( tab, element )
	for k, v in pairs( tab ) do
		if v.ply == element then return true end
	end
	return false
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_1316.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_scp_base"
SWEP.PrintName = "SCP-1316"

SWEP.HoldType = "normal"

-- SCP-1316 Configuration
SWEP.AttackDelay = 1.0
SWEP.DefensiveAbilityCooldown = 60
SWEP.DefensiveAbilityDuration = 10
SWEP.HitDistance = 80

-- Ride System
SWEP.RidingTarget = nil
SWEP.IsRiding = false
SWEP.NextDefensiveUse = 0

-- No viewmodel needed for cat

if SERVER then
	util.AddNetworkString("scp1316_start_riding")
	util.AddNetworkString("scp1316_stop_riding")
	util.AddNetworkString("scp1316_defensive_ability")
	util.AddNetworkString("scp1316_sync_rider")
	
	-- Hook to handle when riding target dies or disconnects
	hook.Add("PlayerDeath", "SCP1316_StopRiding", function(victim, inflictor, attacker)
		if victim.SCP1316_Rider then
			local scp1316 = victim.SCP1316_Rider
			if IsValid(scp1316) then
				local weapon = scp1316:GetActiveWeapon()
				if IsValid(weapon) and weapon:GetClass() == "weapon_scp_1316" then
					weapon:StopRiding()
				end
			end
		end
	end)
	
	hook.Add("PlayerDisconnected", "SCP1316_StopRiding", function(ply)
		if ply.SCP1316_Rider then
			local scp1316 = ply.SCP1316_Rider
			if IsValid(scp1316) then
				local weapon = scp1316:GetActiveWeapon()
				if IsValid(weapon) and weapon:GetClass() == "weapon_scp_1316" then
					weapon:StopRiding()
				end
			end
		end
	end)
	
	-- Hook to reset riding when SCP-1316 dies
	hook.Add("PlayerDeath", "SCP1316_ResetRiding", function(victim, inflictor, attacker)
		if IsValid(victim) and victim:GTeam() == TEAM_SCP then
			local weapon = victim:GetActiveWeapon()
			if IsValid(weapon) and weapon:GetClass() == "weapon_scp_1316" then
				weapon:StopRiding()
			end
		end
	end)
	
	-- Hook to make SCP-1316 immortal and transparent when riding
	hook.Add("EntityTakeDamage", "SCP1316_RidingProtection", function(target, dmginfo)
		if IsValid(target) and target:IsPlayer() and target:GTeam() == TEAM_SCP then
			local weapon = target:GetActiveWeapon()
			if IsValid(weapon) and weapon:GetClass() == "weapon_scp_1316" and weapon.IsRiding then
				-- Immortal when riding
				return true
			end
		end
	end)
	
	-- Hook for defensive ability damage reduction
	hook.Add("EntityTakeDamage", "SCP1316_DefensiveAbility", function(target, dmginfo)
		if IsValid(target) and target:IsPlayer() and target.SCP1316_DefensiveActive then
			-- 99% damage reduction
			dmginfo:ScaleDamage(0.01)
		end
	end)
end

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("breach/wep_1316")
	
	-- Third person camera when riding
	local thirdPersonActive = false
	local originalCalcView = nil
	
	net.Receive("scp1316_start_riding", function()
		thirdPersonActive = true
		
		-- Store original CalcView if not already stored
		if not originalCalcView then
			originalCalcView = GAMEMODE.CalcView
		end
		
		-- Override CalcView for third person
		GAMEMODE.CalcView = function(self, ply, pos, angles, fov)
			if ply == LocalPlayer() and thirdPersonActive then
				local view = {}
				view.origin = pos - angles:Forward() * 100 + angles:Up() * 20
				view.angles = angles
				view.fov = fov
				view.drawviewer = true
				return view
			end
			
			-- Call original CalcView for other cases
			if originalCalcView then
				return originalCalcView(self, ply, pos, angles, fov)
			end
		end
	end)
	
	net.Receive("scp1316_stop_riding", function()
		thirdPersonActive = false
		
		-- Restore original CalcView
		if originalCalcView then
			GAMEMODE.CalcView = originalCalcView
		end
	end)
	
	-- Receive rider sync for cat icon
	net.Receive("scp1316_sync_rider", function()
		local target = net.ReadEntity()
		local hasRider = net.ReadBool()
		
		if IsValid(target) then
			target.SCP1316_HasRider = hasRider and true or nil
		end
	end)
	
	-- Draw custom cat icon above riding target's head
	hook.Add("PostPlayerDraw", "SCP1316_DrawCatIcon", function(ply)
		if ply.SCP1316_HasRider then
			local pos = ply:GetPos() + Vector(0, 0, 85)
			local ang = LocalPlayer():EyeAngles()
			ang:RotateAroundAxis(ang:Forward(), 90)
			ang:RotateAroundAxis(ang:Right(), 90)
			
			cam.Start3D2D(pos, ang, 0.15)
				-- Draw circle background
				surface.SetDrawColor(50, 50, 50, 200)
				draw.NoTexture()
				surface.DrawPoly({
					{x = 0, y = -30},
					{x = 21, y = -21},
					{x = 30, y = 0},
					{x = 21, y = 21},
					{x = 0, y = 30},
					{x = -21, y = 21},
					{x = -30, y = 0},
					{x = -21, y = -21}
				})
				
				-- Draw circle border
				surface.SetDrawColor(255, 200, 100, 255)
				for i = 0, 360, 10 do
					local x1 = math.cos(math.rad(i)) * 27
					local y1 = math.sin(math.rad(i)) * 27
					local x2 = math.cos(math.rad(i + 10)) * 27
					local y2 = math.sin(math.rad(i + 10)) * 27
					surface.DrawLine(x1, y1, x2, y2)
				end
				
				-- Draw cat whiskers
				surface.SetDrawColor(255, 255, 255, 255)
				-- Left whiskers
				surface.DrawLine(-22, -4, -12, -3)
				surface.DrawLine(-22, 0, -12, 0)
				surface.DrawLine(-22, 4, -12, 3)
				-- Right whiskers  
				surface.DrawLine(22, -4, 12, -3)
				surface.DrawLine(22, 0, 12, 0)
				surface.DrawLine(22, 4, 12, 3)
				
				-- Draw cat ears (triangles)
				surface.SetDrawColor(255, 200, 100, 255)
				draw.NoTexture()
				-- Left ear
				surface.DrawPoly({
					{x = -12, y = -18},
					{x = -4, y = -27},
					{x = 3, y = -18}
				})
				-- Right ear
				surface.DrawPoly({
					{x = -3, y = -18},
					{x = 4, y = -27},
					{x = 12, y = -18}
				})
				
				-- Draw cat eyes
				surface.SetDrawColor(100, 255, 100, 255)
				draw.NoTexture()
				-- Left eye
				surface.DrawPoly({
					{x = -9, y = -6},
					{x = -4, y = -9},
					{x = -4, y = -3}
				})
				-- Right eye
				surface.DrawPoly({
					{x = 4, y = -6},
					{x = 9, y = -9},
					{x = 9, y = -3}
				})
				
				-- Draw cat nose (small triangle)
				surface.SetDrawColor(255, 150, 150, 255)
				surface.DrawPoly({
					{x = -1, y = 3},
					{x = 1, y = 3},
					{x = 0, y = 6}
				})
				
			cam.End3D2D()
		end
	end)
end

function SWEP:Initialize()
	self:InitializeLanguage("SCP_1316")
	self:SetHoldType(self.HoldType)
	
	self.NextAttack = 0
	self.IsRiding = false
	self.RidingTarget = nil
	self.NextDefensiveUse = 0
end

function SWEP:StartRiding(target)
	if not SERVER then return end
	if not IsValid(target) or not target:IsPlayer() then return end
				if target:GTeam() == TEAM_SCP and target:GetNClass() != ROLES.ROLE_SCP035 then return end
	if self.IsRiding then return end
	
	self.IsRiding = true
	self.RidingTarget = target
	
	-- Set up riding relationship
	target.SCP1316_Rider = self.Owner
	target.SCP1316_HasRider = true
	target.SCP1316_OriginalSpeed = target:GetWalkSpeed()
	target.SCP1316_OriginalRunSpeed = target:GetRunSpeed()
	
	-- Apply speed boost to target (+20%)
	target:SetWalkSpeed(target:GetWalkSpeed() * 1.2)
	target:SetRunSpeed(target:GetRunSpeed() * 1.2)
	
	-- Make SCP-1316 invisible and non-solid
	self.Owner:SetNoDraw(true)
	self.Owner:SetSolid(SOLID_NONE)
	self.Owner:SetMoveType(MOVETYPE_NOCLIP)
	
	-- Start regeneration for target
	target.SCP1316_RegenTimer = timer.Create("SCP1316_Regen_" .. target:EntIndex(), 1, 0, function()
		if IsValid(target) and target:Alive() and target.SCP1316_HasRider then
			local newHealth = math.min(target:GetMaxHealth(), target:Health() + 1)
			target:SetHealth(newHealth)
		else
			timer.Remove("SCP1316_Regen_" .. target:EntIndex())
		end
	end)
	
	-- Network to client for third person camera
	net.Start("scp1316_start_riding")
	net.Send(self.Owner)
	
	-- Network to all clients to show cat icon
	net.Start("scp1316_sync_rider")
	net.WriteEntity(target)
	net.WriteBool(true)
	net.Broadcast()
	
	-- Sync riding target position
	self.Owner:SetPos(target:GetPos())
end

function SWEP:StopRiding()
	if not SERVER then return end
	if not self.IsRiding then return end
	
	local target = self.RidingTarget
	
	self.IsRiding = false
	self.RidingTarget = nil
	
	-- Restore SCP-1316 visibility and physics
	if IsValid(self.Owner) then
		self.Owner:SetNoDraw(false)
		self.Owner:SetSolid(SOLID_BBOX)
		self.Owner:SetMoveType(MOVETYPE_WALK)
	end
	
	-- Clean up target
	if IsValid(target) then
		target.SCP1316_Rider = nil
		target.SCP1316_HasRider = nil
		
		-- Restore original speed
		if target.SCP1316_OriginalSpeed then
			target:SetWalkSpeed(target.SCP1316_OriginalSpeed)
			target:SetRunSpeed(target.SCP1316_OriginalRunSpeed)
		end
		
		-- Stop regeneration
		timer.Remove("SCP1316_Regen_" .. target:EntIndex())
	end
	
	-- Network to client to stop third person camera
	if IsValid(self.Owner) then
		net.Start("scp1316_stop_riding")
		net.Send(self.Owner)
	end
	
	-- Network to all clients to hide cat icon
	if IsValid(target) then
		net.Start("scp1316_sync_rider")
		net.WriteEntity(target)
		net.WriteBool(false)
		net.Broadcast()
	end
end

function SWEP:DefensiveAbility()
	if not SERVER then return end
	if self.IsRiding then return end -- Can't use when riding
	if self.NextDefensiveUse > CurTime() then return end
	
	self.NextDefensiveUse = CurTime() + self.DefensiveAbilityCooldown
	
	-- Apply defensive buffs
	self.Owner.SCP1316_DefensiveActive = true
	
	-- 2x speed boost
	local originalWalk = self.Owner:GetWalkSpeed()
	local originalRun = self.Owner:GetRunSpeed()
	self.Owner:SetWalkSpeed(originalWalk * 2)
	self.Owner:SetRunSpeed(originalRun * 2)
	
	-- Remove buffs after duration
	timer.Simple(self.DefensiveAbilityDuration, function()
		if IsValid(self.Owner) then
			self.Owner.SCP1316_DefensiveActive = false
			self.Owner:SetWalkSpeed(originalWalk)
			self.Owner:SetRunSpeed(originalRun)
		end
	end)
	
	-- Network to client
	net.Start("scp1316_defensive_ability")
	net.Send(self.Owner)
end

function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextAttack > CurTime() then return end
	
	if self.IsRiding then
		-- Stop riding
		self:StopRiding()
	else
		-- Try to start riding
		local tr = util.TraceHull({
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.HitDistance,
			filter = self.Owner,
			mins = Vector(-16, -16, -16),
			maxs = Vector(16, 16, 16),
			mask = MASK_SHOT_HULL
		})
		
		if tr.Hit and IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity:GTeam() != TEAM_SCP then
			self:StartRiding(tr.Entity)
		end
	end
	
	self.NextAttack = CurTime() + self.AttackDelay
end

function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.IsRiding then return end -- Can't use when riding
	
	self:DefensiveAbility()
end

function SWEP:Reload()
	-- Manual stop riding
	if self.IsRiding then
		self:StopRiding()
	end
end

function SWEP:Think()
	-- Sync cooldown with client
	if SERVER then
		self:SetNWFloat("NextAttack", self.NextAttack)
		self:SetNWFloat("NextDefensiveUse", self.NextDefensiveUse)
		self:SetNWBool("IsRiding", self.IsRiding)
		
		-- Follow riding target
		if self.IsRiding and IsValid(self.RidingTarget) then
			self.Owner:SetPos(self.RidingTarget:GetPos())
		end
	end
end

function SWEP:Holster()
	if SERVER and self.IsRiding then
		self:StopRiding()
	end
	return true
end

function SWEP:OnRemove()
	if SERVER and self.IsRiding then
		self:StopRiding()
	end
end

if CLIENT then
	function SWEP:DrawHUD()
		if disablehud == true then return end
		
		local ply = LocalPlayer()
		if not IsValid(ply) then return end
		
		local centerX = ScrW() / 2
		local centerY = ScrH() / 2
		local hudY = ScrH() - 150
		
		local hudWidth = 500
		local hudHeight = 120
		local hudX = centerX - hudWidth / 2
		
		-- Tło HUD
		surface.SetDrawColor(20, 20, 20, 180)
		surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Obramowanie
		surface.SetDrawColor(100, 100, 100, 200)
		surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Linia dekoracyjna
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
		
		-- Tytuł SCP
		surface.SetFont("DermaLarge")
		surface.SetTextColor(200, 200, 200, 255)
		local titleW, titleH = surface.GetTextSize("SCP-1316")
		surface.SetTextPos(centerX - titleW / 2, hudY + 10)
		surface.DrawText("SCP-1316")
		
		local isRiding = self:GetNWBool("IsRiding", false)
		
		-- Cooldowny
		local cooldownY = hudY + 60
		local barWidth = 120
		local barHeight = 8
		local spacing = 20
		local totalWidth = barWidth * 2 + spacing
		local startX = centerX - totalWidth / 2
		
		-- LMB - Ride/Stop
		local lmbBarX = startX
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		if isRiding then
			surface.SetTextPos(lmbBarX, cooldownY - 15)
			surface.DrawText("LMB - Stop Riding")
		else
			surface.SetTextPos(lmbBarX, cooldownY - 15)
			surface.DrawText("LMB - Start Riding")
		end
		
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
		
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		local attackCooldown = math.max(0, self:GetNWFloat("NextAttack", 0) - CurTime())
		
		if attackCooldown > 0 then
			local progress = 1 - (attackCooldown / self.AttackDelay)
			surface.SetDrawColor(255, 200, 100, 255)
			surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(255, 220, 150, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText(string.format("%.1fs", attackCooldown))
		else
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 255, 150, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText("READY")
		end
		
		-- RMB - Defensive Ability (only when not riding)
		if not isRiding then
			local rmbBarX = startX + barWidth + spacing
			surface.SetTextColor(200, 200, 200, 255)
			surface.SetFont("DermaDefaultBold")
			surface.SetTextPos(rmbBarX, cooldownY - 15)
			surface.DrawText("RMB - Defensive")
			
			surface.SetDrawColor(150, 150, 150, 255)
			surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
			
			surface.SetDrawColor(40, 40, 40, 200)
			surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
			
			local defensiveCooldown = math.max(0, self:GetNWFloat("NextDefensiveUse", 0) - CurTime())
			
			if defensiveCooldown > 0 then
				local progress = 1 - (defensiveCooldown / self.DefensiveAbilityCooldown)
				surface.SetDrawColor(255, 100, 100, 255)
				surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
				
				surface.SetFont("DermaDefault")
				surface.SetTextColor(255, 150, 150, 255)
				surface.SetTextPos(rmbBarX, cooldownY + 10)
				surface.DrawText(string.format("%.0fs", defensiveCooldown))
			else
				surface.SetDrawColor(100, 255, 100, 255)
				surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
				
				surface.SetFont("DermaDefault")
				surface.SetTextColor(150, 255, 150, 255)
				surface.SetTextPos(rmbBarX, cooldownY + 10)
				surface.DrawText("READY")
			end
		end
		
		-- Celownik (tylko gdy nie jedzie)
		if not isRiding then
			local x = ScrW() / 2.0
			local y = ScrH() / 2.0
			local scale = 0.3
			local color = Color(255, 200, 100, 255)
			surface.SetDrawColor(color)
			
			local gap = 5
			local length = gap + 20 * scale
			surface.DrawLine(x - length, y, x - gap, y)
			surface.DrawLine(x + length, y, x + gap, y)
			surface.DrawLine(x, y - length, x, y - gap)
			surface.DrawLine(x, y + length, x, y + gap)
		end
	end
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_1471.lua
================================================
AddCSLuaFile()

SWEP.Base 				= "weapon_scp_base"
SWEP.PrintName			= "SCP-1471-A"

SWEP.Primary.Automatic  = true
SWEP.Primary.Delay 		= 0 -- Brak cooldownu na LMB

SWEP.Secondary.Delay 	= 7

SWEP.DrawCrosshair		= true
SWEP.HoldType 			= "normal"

--if (CLIENT) then
	--SWEP.WepSelectIcon	= surface.GetTextureID( "vgui/entities/weapon_scp096" )
	--SWEP.BounceWeaponIcon = false
	--killicon.Add( "kill_icon_scp096", "vgui/icons/kill_icon_scp096", Color( 255, 255, 255, 255 ) )
--end

SWEP.Lang = nil

-- Parametry niewidoczności
SWEP.InvisibilitySpeed = 50 -- Prędkość poniżej której SCP staje się niewidoczny
SWEP.InvisibilityDistance = 1000 -- Odległość od której niewidoczność zaczyna działać
SWEP.InvisibilityAlpha = 0 -- Wartość alpha gdy niewidoczny (55 = prawie niewidoczny)

function SWEP:SetupDataTables()
	self:NetworkVar("Float", 0, "InvisibilityLevel") -- 0 = w pełni widoczny, 1 = niewidoczny
	self:NetworkVar("Bool", 0, "IsMoving")
end

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_1471" )

	self:SetHoldType( self.HoldType )
	
	-- Inicjalizacja niewidoczności
	self:SetInvisibilityLevel(0)
	self:SetIsMoving(true)
	self.LastVelocityCheck = 0
	self.CurrentAlpha = 255
	
	if SERVER then
		-- Timer do sprawdzania ruchu
		timer.Create("SCP1471_Movement_" .. self:EntIndex(), 0.1, 0, function()
			if not IsValid(self) or not IsValid(self.Owner) then
				timer.Remove("SCP1471_Movement_" .. self:EntIndex())
				return
			end
			
			self:UpdateMovementState()
		end)
	end
end

function SWEP:OnRemove()
	if SERVER then
		timer.Remove("SCP1471_Movement_" .. self:EntIndex())
	end
	
	-- Przywróć pełną widoczność
	if IsValid(self.Owner) then
		self.Owner:SetRenderMode(RENDERMODE_NORMAL)
		self.Owner:SetColor(Color(255, 255, 255, 255))
	end
end

function SWEP:Deploy()
	self:HideModels()

	if SERVER and !self.walkspeed and !self.runspeed then
		self.walkspeed = self.Owner:GetWalkSpeed()
		self.runspeed = self.Owner:GetRunSpeed()

		self.Owner:SetRunSpeed( self.walkspeed )
	end
end

SWEP.NextPrimary = 0
function SWEP:PrimaryAttack()
	if preparing or postround then return end
	-- Brak sprawdzania cooldownu dla LMB
	if !SERVER then return end
	local fents = ents.FindInSphere( self.Owner:GetPos(), 50 ) -- Zmniejszony zasięg o połowę
	for k, ent in pairs( fents ) do
		if IsValid( ent ) then
			if ent:IsPlayer() then
				if ent:GTeam() != TEAM_SPEC and (ent:GTeam() != TEAM_SCP or ent:GetNClass() == ROLES.ROLE_SCP035) then
					//print( ent.scp1471stacks )
					ent:TakeDamage( ent.scp1471stacks or 1, self.Owner, self.Owner )
				end
			else
				self:SCPDamageEvent( ent, 5 )
			end	
		end
	end
end

SWEP.NextSecondary = 0
function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if self.NextSecondary > CurTime() then return end
	local trace = self.Owner:GetEyeTrace()
	if !trace.Hit then return end
	local ent = trace.Entity
	if IsValid( ent ) then
		if ent:IsPlayer() and (ent:GTeam() != TEAM_SCP or ent:GetNClass() == ROLES.ROLE_SCP035) and ent:GTeam() != TEAM_SPEC then
			if ent:GetAimVector():Dot( (ent:EyePos() - self.Owner:EyePos() ):GetNormalized() ) > -0.5 then
				self.NextSecondary = CurTime() + self.Secondary.Delay
				if !SERVER then return end

				self.Owner:SetWalkSpeed( self.runspeed )
				self.Owner:SetRunSpeed( self.runspeed )
				timer.Simple( 3, function()
					if IsValid( self ) and IsValid( self.Owner ) then
						self.Owner:SetWalkSpeed( self.walkspeed )
						self.Owner:SetRunSpeed( self.walkspeed )
					end
				end )

				local vec = self.Owner:GetPos() - ent:GetPos()
				local dir = vec:GetNormalized()

				ent:SendLua( "CamEnable = true" )
				ent:SendLua( "dir = Vector( "..dir.x..", "..dir.y..", "..dir.z.." )" )

				ent.scp1471stacks = ( ent.scp1471stacks or 1 ) + 1
				--self.Owner:SendLua( "CamEnable = true" )
				--self.Owner:SendLua( "dir = Vector( "..dir.x..", "..dir.y..", "..dir.z.." )" )
			end
		end
	end
end

function SWEP:DrawHUD()
	if disablehud == true then return end
	
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-1471-A")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-1471-A")
	
	-- Cooldowny
	local lpmCooldown = 0
	local ppmCooldown = 0
	
	if self.NextPrimary and self.NextPrimary > CurTime() then
		lpmCooldown = self.NextPrimary - CurTime()
	end
	
	if self.NextSecondary and self.NextSecondary > CurTime() then
		ppmCooldown = self.NextSecondary - CurTime()
	end
	
	local cooldownY = hudY + 60
	local barWidth = 120
	local barHeight = 8
	local barSpacing = 20
	
	-- LMB Cooldown (AOE Attack)
	local lpmBarX = centerX - barWidth - barSpacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lpmBarX, cooldownY - 15)
	surface.DrawText("LMB - AOE")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lpmBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lpmBarX, cooldownY, barWidth, barHeight)
	
	-- Zawsze pokazuj jako gotowe (brak cooldownu)
	surface.SetDrawColor(100, 255, 100, 255)
	surface.DrawRect(lpmBarX, cooldownY, barWidth, barHeight)
	
	surface.SetFont("DermaDefault")
	surface.SetTextColor(150, 255, 150, 255)
	surface.SetTextPos(lpmBarX, cooldownY + 10)
	surface.DrawText("READY")
	
	-- RMB Cooldown (Stalk)
	local ppmBarX = centerX + barSpacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(ppmBarX, cooldownY - 15)
	surface.DrawText("RMB - Stalk")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(ppmBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(ppmBarX, cooldownY, barWidth, barHeight)
	
	if ppmCooldown > 0 then
		local progress = 1 - (ppmCooldown / self.Secondary.Delay)
		surface.SetDrawColor(100, 150, 255, 255)
		surface.DrawRect(ppmBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 200, 255, 255)
		surface.SetTextPos(ppmBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", ppmCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(ppmBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(ppmBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- Wskaźnik niewidoczności
	local invisY = hudY + hudHeight - 20
	surface.SetFont("DermaDefault")
	
	local invisLevel = self:GetInvisibilityLevel()
	if invisLevel > 0 then
		surface.SetTextColor(150, 150, 255, 255)
		local invisText = "INVISIBLE"
		local invisW, invisH = surface.GetTextSize(invisText)
		surface.SetTextPos(centerX - invisW / 2, invisY)
		surface.DrawText(invisText)
	else
		surface.SetTextColor(255, 150, 150, 255)
		local invisText = "VISIBLE"
		local invisW, invisH = surface.GetTextSize(invisText)
		surface.SetTextPos(centerX - invisW / 2, invisY)
		surface.DrawText(invisText)
	end
	
	-- Celownik
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	
	local scale = 0.3
	surface.SetDrawColor(150, 150, 255, 255)
	
	local gap = 5
	local length = gap + 20 * scale
	surface.DrawLine(x - length, y, x - gap, y)
	surface.DrawLine(x + length, y, x + gap, y)
	surface.DrawLine(x, y - length, x, y - gap)
	surface.DrawLine(x, y + length, x, y + gap)
end

-- Aktualizacja stanu ruchu (SERVER)
function SWEP:UpdateMovementState()
	if not SERVER then return end
	
	local velocity = self.Owner:GetVelocity():Length()
	local isMoving = velocity > self.InvisibilitySpeed
	
	if isMoving != self:GetIsMoving() then
		self:SetIsMoving(isMoving)
		-- Natychmiastowe przełączanie niewidoczności
		if isMoving then
			self:SetInvisibilityLevel(0) -- W pełni widoczny
		else
			self:SetInvisibilityLevel(1) -- Niewidoczny
		end
	end
end

-- Globalny hook do renderowania SCP-1471 (CLIENT)
if CLIENT then
	hook.Add("PrePlayerDraw", "SCP1471_Invisibility", function(ply)
		if not IsValid(ply) or not ply:Alive() then return end
		
		local wep = ply:GetActiveWeapon()
		if not IsValid(wep) or wep:GetClass() != "weapon_scp_1471" then return end
		
		local localPly = LocalPlayer()
		if not IsValid(localPly) then return end
		
		-- Nie stosuj efektu dla samego siebie
		if ply == localPly then return end
		
		-- Prosty przełącznik - niewidoczny gdy się nie rusza
		local invisLevel = wep:GetInvisibilityLevel()
		
		if invisLevel > 0 then
			-- Jest niewidoczny - całkowicie ukryj model
			return true -- Return true blokuje rysowanie modelu
		end
		
		-- Normalnie widoczny
		ply:SetRenderMode(RENDERMODE_NORMAL)
		ply:SetColor(Color(255, 255, 255, 255))
	end)
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_1499.lua
================================================
AddCSLuaFile()

SWEP.Author = "AI Assistant"
SWEP.Category = "SCP"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.PrintName = "SCP-1499"
SWEP.Slot = 2
SWEP.SlotPos = 3
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "rpg"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.droppable = true
SWEP.teams = {2,3,5,6,7}

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

SWEP.ViewModel = ""
SWEP.WorldModel = "models/scp1499/scp1499mask.mdl"

SWEP.HoldType = "slam"

SWEP.NextTeleport = 0

function SWEP:Initialize()
    self:SetHoldType(self.HoldType)
    self.NextTeleport = 0
end

function SWEP:Deploy()
    return true
end

function SWEP:PrimaryAttack()
    if not IsFirstTimePredicted() then return end
    if preparing or postround then return end
    if not IsValid(self.Owner) then return end
    
    -- Check team restrictions (no SCPs)
    if self.Owner:GTeam() == TEAM_SCP then 
        return 
    end
    
    -- Check cooldown (90 seconds)
    if self.NextTeleport > CurTime() then
        if CLIENT then
            local timeLeft = math.ceil(self.NextTeleport - CurTime())
            LocalPlayer():PrintMessage(HUD_PRINTCENTER, "SCP-1499 on cooldown: " .. timeLeft .. "s")
        end
        return
    end
    
    if SERVER then
        self:TeleportToDimension()
    end
end

function SWEP:SecondaryAttack()
    -- No secondary attack
end

if SERVER then
    function SWEP:TeleportToDimension()
        if not IsValid(self.Owner) then return end
        
        -- Save original position
        local originalPos = self.Owner:GetPos()
        local originalAng = self.Owner:GetAngles()
        
        -- Set cooldown (90 seconds)
        self.NextTeleport = CurTime() + 90
        
        -- Teleport to dimension (outside map)
        local dimensionPos = originalPos + Vector(0, 0, -10000)
        self.Owner:SetPos(dimensionPos)
        
        -- Visual effect
        self.Owner:ScreenFade(SCREENFADE.IN, Color(0, 0, 0, 150), 1.5, 0)
        
        -- Save return data
        self.Owner.SCP1499_ReturnPos = originalPos
        self.Owner.SCP1499_ReturnAng = originalAng
        self.Owner.SCP1499_ReturnTime = CurTime() + 10
        
        -- Synchronizuj czas powrotu do klienta
        self.Owner:SetNWFloat("SCP1499_ReturnTime", CurTime() + 10)
        
        -- Set timer for return
        timer.Create("SCP1499_Return_" .. self.Owner:SteamID64(), 10, 1, function()
            if IsValid(self.Owner) then
                self:ReturnFromDimension()
            end
        end)
        
        -- Freeze player briefly
        self.Owner:Freeze(true)
        timer.Simple(1.5, function()
            if IsValid(self.Owner) then
                self.Owner:Freeze(false)
            end
        end)
    end
    
    function SWEP:ReturnFromDimension()
        if not IsValid(self.Owner) then return end
        if not self.Owner.SCP1499_ReturnPos then return end
        
        -- 10% chance to go to Pocket Dimension instead
        if math.random(1, 100) <= 10 then
            local pocketPos = GetPocketPos()
            if pocketPos then
                self.Owner:SetPos(pocketPos)
                self.Owner:SetAngles(Angle(0, math.random(-180, 180), 0))
                
                -- Visual effect for pocket dimension
                self.Owner:ScreenFade(SCREENFADE.IN, Color(100, 0, 0, 100), 2, 0)
                
                -- Clear return data
                self.Owner.SCP1499_ReturnPos = nil
                self.Owner.SCP1499_ReturnAng = nil
                self.Owner.SCP1499_ReturnTime = nil
                self.Owner:SetNWFloat("SCP1499_ReturnTime", 0)
                return
            end
        end
        
        -- Normal return to original position
        self.Owner:SetPos(self.Owner.SCP1499_ReturnPos)
        self.Owner:SetAngles(self.Owner.SCP1499_ReturnAng)
        
        -- Visual effect
        self.Owner:ScreenFade(SCREENFADE.IN, Color(255, 255, 255, 100), 1, 0)
        
        -- Clear return data
        self.Owner.SCP1499_ReturnPos = nil
        self.Owner.SCP1499_ReturnAng = nil
        self.Owner.SCP1499_ReturnTime = nil
        
        -- Wyczyść timer na kliencie
        self.Owner:SetNWFloat("SCP1499_ReturnTime", 0)
    end
    
    -- Clean up on disconnect
    hook.Add("PlayerDisconnected", "SCP1499_Cleanup", function(ply)
        timer.Remove("SCP1499_Return_" .. ply:SteamID64())
    end)
    
    -- Clean up on round end
    hook.Add("PrepareRound", "SCP1499_RoundCleanup", function()
        for _, ply in pairs(player.GetAll()) do
            timer.Remove("SCP1499_Return_" .. ply:SteamID64())
            ply.SCP1499_ReturnPos = nil
            ply.SCP1499_ReturnAng = nil
            ply.SCP1499_ReturnTime = nil
            ply:SetNWFloat("SCP1499_ReturnTime", 0)
        end
    end)
end

function SWEP:Think()
    -- Sync cooldown to client
    if SERVER then
        self:SetNWFloat("NextTeleport", self.NextTeleport)
    else
        self.NextTeleport = self:GetNWFloat("NextTeleport", 0)
    end
end

function SWEP:Holster()
    return true
end

function SWEP:OnRemove()
    if SERVER and IsValid(self.Owner) then
        timer.Remove("SCP1499_Return_" .. self.Owner:SteamID64())
        self.Owner:SetNWFloat("SCP1499_ReturnTime", 0)
    end
end

if CLIENT then
    surface.CreateFont("SCP1499_Small", {
        font = "Trebuchet24", 
        size = 18,
        weight = 500,
        antialias = true,
        shadow = true
    })

    function SWEP:DrawHUD()
        local ply = LocalPlayer()
        if not IsValid(ply) then return end
        
        -- Pozycja HUD prosto nad celownikiem
        local x = ScrW() / 2
        local y = ScrH() / 2 - 50 -- 50 pikseli nad środkiem ekranu
        
        -- Cooldown
        local cooldown = math.max(0, self.NextTeleport - CurTime())
        
        -- Czas do powrotu z wymiaru
        local returnTime = ply:GetNWFloat("SCP1499_ReturnTime", 0)
        local timeUntilReturn = math.max(0, returnTime - CurTime())
        
        -- Pasek postępu - ustawienia
        local barWidth = 100
        local barHeight = 4
        
        -- Jeśli jesteś w wymiarze (pokazuje tylko pasek i czas)
        if timeUntilReturn > 0 then
            -- Tekst
            local timeText = string.format("COMEBACK: %.1fs", timeUntilReturn)
            draw.SimpleText(timeText, "SCP1499_Small", x, y - 20, Color(255, 255, 100), TEXT_ALIGN_CENTER)
            
            -- Pasek postępu
            local progress = 1 - (timeUntilReturn / 10)
            
            -- Tło paska
            surface.SetDrawColor(0, 0, 0, 150)
            surface.DrawRect(x - barWidth/2, y, barWidth, barHeight)
            
            -- Wypełnienie paska
            surface.SetDrawColor(255, 255, 100, 255)
            surface.DrawRect(x - barWidth/2, y, barWidth * progress, barHeight)
            
        -- Jeśli nie jesteś w wymiarze (cooldown)
        elseif cooldown > 0 then
            -- Tekst
            draw.SimpleText("CD: " .. math.ceil(cooldown) .. "s", "SCP1499_Small", x, y - 20, Color(255, 100, 100), TEXT_ALIGN_CENTER)
            
            -- Pasek postępu
            local progress = 1 - (cooldown / 90)
            
            -- Tło paska
            surface.SetDrawColor(0, 0, 0, 150)
            surface.DrawRect(x - barWidth/2, y, barWidth, barHeight)
            
            -- Wypełnienie paska
            surface.SetDrawColor(255, 100, 100, 255)
            surface.DrawRect(x - barWidth/2, y, barWidth * progress, barHeight)
            
        else
            -- Gotowy do użycia
            draw.SimpleText("READY", "SCP1499_Small", x, y - 20, Color(100, 255, 100), TEXT_ALIGN_CENTER)
            
            -- Pasek pełny
            surface.SetDrawColor(0, 0, 0, 150)
            surface.DrawRect(x - barWidth/2, y, barWidth, barHeight)
            
            surface.SetDrawColor(100, 255, 100, 255)
            surface.DrawRect(x - barWidth/2, y, barWidth, barHeight)
        end
    end
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_173.lua
================================================
AddCSLuaFile()

SWEP.Base 			= "weapon_scp_base"
SWEP.PrintName		= "SCP-173"

SWEP.HoldType		= "normal"

SWEP.AttackDelay			= 0.25
SWEP.SpecialDelay			= 30
SWEP.NextAttackW			= 0
SWEP.NextKillAoE			= 0
SWEP.KillRadius				= 10 -- Bardzo blisko
SWEP.TeleportDelay			= 120 -- Cooldown na teleportację
SWEP.TeleportRange			= 300 -- Maksymalny zasięg teleportacji

if CLIENT then
	SWEP.WepSelectIcon 	= surface.GetTextureID("breach/wep_173")
end
 
--SWEP.SantasHatPositionOffset = Vector( -3, 47, 1 )
--SWEP.SantasHatAngleOffset = Angle( -90, -20, -20 )

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_173" )

	self:SetHoldType(self.HoldType)
	/*if CLIENT then
		if !self.SantasHat then
			self.SantasHat = ClientsideModel( "models/cloud/kn_santahat.mdl" )
			self.SantasHat:SetModelScale( 1.2 )
			self.SantasHat:SetNoDraw( true )
		end
	end*/
end

/*function SWEP:Remove()
	if CLIENT and IsValid( self.SantasHat ) then
		self.SantasHat:Remove()
	end
end*/

/*function SWEP:IsLookingAt( ply )
	local yes = ply:GetAimVector():Dot( ( self.Owner:GetPos() - ply:GetPos() + Vector( 70 ) ):GetNormalized() )
	return (yes > 0.39)
end*/
 
SWEP.Watching = 0
SWEP.NextTeleport = 0
function SWEP:Think()
	if CLIENT then
		self.Watching = CurTime() + 0.1
	end

	if postround then return end

	local watching = false

	local ply = self.Owner
	local obb_bot, obb_top = ply:GetModelBounds()
	local obb_mid = ( obb_bot + obb_top ) / 2

	obb_bot.x = obb_mid.x
	obb_bot.y = obb_mid.y
	obb_bot.z = obb_bot.z + 10

	obb_top.x = obb_mid.x
	obb_top.y = obb_mid.y
	obb_top.z = obb_top.z - 10

	local top, mid, bot = ply:LocalToWorld( obb_top ), ply:LocalToWorld( obb_mid ), ply:LocalToWorld( obb_bot )
	local mask = MASK_BLOCKLOS_AND_NPCS

	for k, v in pairs( player.GetAll() ) do
		if IsValid( v ) and v:GTeam() != TEAM_SPEC and v:GTeam() != TEAM_SCP and v:Alive() and v.canblink and !v.isblinking then
			if v.scp173allow and ply:GetPos():DistToSqr( v:GetPos() ) > 62500 then
				-- skip this player
			else

			local eyepos = v:EyePos()
			local eyevec = v:EyeAngles():Forward()

			local mid_z = mid:Copy()
			mid_z.z = mid_z.z + 17.5

			local line = ( mid_z - eyepos ):GetNormalized()
			local angle = math.acos( eyevec:Dot( line ) )

			if angle <= 0.8 then
				local trace_top = util.TraceLine( {
					start = eyepos,
					endpos = top,
					filter = { ply, v },
					mask = mask
				} )

				local trace_mid = util.TraceLine( {
					start = eyepos,
					endpos = mid,
					filter = { ply, v },
					mask = mask
				} )

				local trace_bot = util.TraceLine( {
					start = eyepos,
					endpos = bot,
					filter = { ply, v },
					mask = mask
				} )

				if !trace_top.Hit and !trace_mid.Hit and !trace_bot.Hit then
					watching = true
					break
				end
			end
			end -- End of else for continue replacement
		end
	end

	if watching then
		ply:Freeze( true )
		self:SetNWBool("IsWatched", true)
	else
		ply:Freeze( false )
		self:SetNWBool("IsWatched", false)
		
		-- Automatyczne AoE zabijanie gdy nikt nie patrzy
		if SERVER and self.NextKillAoE <= CurTime() then
			self.NextKillAoE = CurTime() + 0.5 -- Sprawdzaj co pół sekundy
			
			local nearbyPlayers = ents.FindInSphere(ply:GetPos(), self.KillRadius)
			for _, target in pairs(nearbyPlayers) do
				if IsValid(target) and target:IsPlayer() and target:Alive() then
					if (target:GTeam() != TEAM_SCP or target:GetNClass() == ROLES.ROLE_SCP035) and target:GTeam() != TEAM_SPEC then
						-- Zabij gracza
						local dmginfo = DamageInfo()
						dmginfo:SetDamage(target:Health() + 100)
						dmginfo:SetAttacker(ply)
						dmginfo:SetInflictor(self)
						dmginfo:SetDamageType(DMG_DIRECT)
						target:TakeDamageInfo(dmginfo)
						ply:AddExp(175, true)
						roundstats.snapped = roundstats.snapped + 1
						target:EmitSound("snap.wav", 500, 100)
					end
				end
			end
		end
	end
	/*local watching = 0
	for k,v in pairs(player.GetAll()) do
		if IsValid(v) and v:GTeam() != TEAM_SPEC and v:Alive() and v != self.Owner and v.canblink then
			local tr_eyes = util.TraceLine( {
				start = v:EyePos() - v:EyeAngles():Forward() * 5,
				//start = v:LocalToWorld( v:OBBCenter() ),
				//start = v:GetPos() + (self.Owner:EyeAngles():Forward() * 5000),
				endpos = self.Owner:EyePos() - self.Owner:EyeAngles():Forward() * 5,
				//filter = v
			} )

			/*local tr_center = util.TraceLine( {
				start = v:LocalToWorld( v:OBBCenter() ),
				endpos = self.Owner:LocalToWorld( self.Owner:OBBCenter() ),
				filter = v
			} )*/

			/*if tr_eyes.Entity == self.Owner then//tr_center.Entity == self.Owner then
				//self.Owner:PrintMessage(HUD_PRINTTALK, tostring(tr_eyes.Entity) .. " : " .. tostring(tr_center.Entity) .. " : " .. tostring(tr_center.Entity))
				if self:IsLookingAt( v ) and v.isblinking == false then
					if v.scp173allow and self.Owner:GetPos():DistToSqr( v:GetPos() ) > 62500 then
						continue
					end
					watching = watching + 1
					//if self:GetPos():Distance(v:GetPos()) > 100 then
						//self.Owner:PrintMessage(HUD_PRINTTALK, v:Nick() .. " is looking at you")
					//end 
				end
			end
		end
	end
	if watching > 0 then
		self.Owner:Freeze(true)
	else
		self.Owner:Freeze(false)
	end*/
end

function SWEP:PrimaryAttack()
	-- Usunięta funkcja - teraz zabijanie jest automatyczne w Think()
end

SWEP.NextSpecial = 0
function SWEP:SecondaryAttack()
	local time = 5
	if self.NextSpecial > CurTime() then return end
	self.NextSpecial = CurTime() + self.SpecialDelay
	self:SetNWFloat("NextSpecial", self.NextSpecial) -- Synchronizuj z klientem
	
	if CLIENT then
		surface.PlaySound("Horror2.ogg")
	end
	local findents = ents.FindInSphere( self.Owner:GetPos(), 600 )
	local foundplayers = {}
	for k,v in pairs(findents) do
		if v:IsPlayer() then
			if !((v:GTeam() == TEAM_SCP and v:GetNClass() != ROLES.ROLE_SCP035) or v:GTeam() == TEAM_SPEC or v.Using714 ) then
				if v.usedeyedrops == false then
					table.ForceInsert(foundplayers, v)
				end
			end
		end
	end
	if #foundplayers > 0 then
		local fixednicks = "Blinded: "
		if CLIENT then return end
		local numi = 0
		for k,v in pairs(foundplayers) do
			numi = numi + 1
			
			if numi == 1 then
				fixednicks = fixednicks .. v:Nick()
			elseif numi == #foundplayers then
				fixednicks = fixednicks .. " and " .. v:Nick()
			else
				fixednicks = fixednicks .. ", " .. v:Nick()
			end
			v:SendLua( 'surface.PlaySound("Horror2.ogg")' )
			net.Start("PlayerBlink")
				net.WriteFloat(time)
			net.Send(v)
			v.isblinking = true
			v.blinkedby173 = true
		end
		self.Owner:PrintMessage(HUD_PRINTTALK, fixednicks)
		timer.Create("UnBlinkTimer173", time + 0.2, 1, function()
			for k,v in pairs(player.GetAll()) do
				if v.blinkedby173 then
					v.isblinking = false
					v.blinkedby173 = false
				end
			end
		end)
	end
end

-- Nowa funkcja teleportacji na R
function SWEP:Reload()
	if !IsFirstTimePredicted() then return end
	if self.NextTeleport > CurTime() then return end
	
	self.NextTeleport = CurTime() + self.TeleportDelay
	
	if SERVER then
		self:SetNWFloat("NextTeleport", self.NextTeleport) -- Synchronizuj z klientem
		
		-- Znajdź najbliższego gracza w zasięgu
		local closestPlayer = nil
		local closestDist = math.huge
		local maxRangeSqr = self.TeleportRange * self.TeleportRange
		
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply:Alive() and ply != self.Owner then
				if (ply:GTeam() != TEAM_SCP or ply:GetNClass() == ROLES.ROLE_SCP035) and ply:GTeam() != TEAM_SPEC then
					local dist = self.Owner:GetPos():DistToSqr(ply:GetPos())
					-- Sprawdź czy w zasięgu
					if dist < closestDist and dist <= maxRangeSqr then
						closestDist = dist
						closestPlayer = ply
					end
				end
			end
		end
		
		if IsValid(closestPlayer) then
			-- Teleportuj na pozycję gracza
			self.Owner:SetPos(closestPlayer:GetPos())
			
			-- Obróć SCP-173 w stronę, w którą patrzy gracz
			local ang = closestPlayer:GetAngles()
			ang.p = 0
			ang.r = 0
			self.Owner:SetAngles(ang)
			

			
			-- Wiadomość
			self.Owner:PrintMessage(HUD_PRINTTALK, "Teleported to " .. closestPlayer:Nick())
		else
			self.Owner:PrintMessage(HUD_PRINTTALK, "No valid targets within range!")
			self.NextTeleport = CurTime() + 5 -- Krótszy cooldown jeśli nie ma celu
			self:SetNWFloat("NextTeleport", self.NextTeleport)
		end
	end
end

function SWEP:DrawHUD()
	if disablehud == true then return end
	
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-173")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-173")
	
	-- Status patrzenia
	local isWatched = self:GetNWBool("IsWatched", false)
	local statusText = isWatched and "BEING WATCHED" or "UNOBSERVED"
	local statusColor = isWatched and Color(255, 0, 0, 255) or Color(0, 255, 0, 255)
	
	surface.SetFont("DermaDefaultBold")
	surface.SetTextColor(statusColor)
	local statusW, statusH = surface.GetTextSize(statusText)
	surface.SetTextPos(centerX - statusW / 2, hudY + 95)  -- Przesunięte niżej z 35 na 45
	surface.DrawText(statusText)
	
	-- Cooldowny
	local cooldownY = hudY + 60
	local barWidth = 140
	local barHeight = 8
	local spacing = 20
	local totalWidth = barWidth * 3 + spacing * 2
	local startX = centerX - totalWidth / 2
	
	-- Auto Kill Status (LMB zastąpione przez status)
	local lmbBarX = startX
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lmbBarX, cooldownY - 15)
	surface.DrawText("AUTO-KILL")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
	
	-- Zawsze aktywne gdy nie jest obserwowany
	if not isWatched then
		surface.SetDrawColor(255, 0, 0, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText("ACTIVE")
	else
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 150, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText("DISABLED")
	end
	
	-- RMB Cooldown (Blind)
	local rmbBarX = startX + barWidth + spacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rmbBarX, cooldownY - 15)
	surface.DrawText("RMB - Blind")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
	
	local blindCooldown = 0
	local nextSpecial = self:GetNWFloat("NextSpecial", 0)
	if nextSpecial > CurTime() then
		blindCooldown = nextSpecial - CurTime()
	end
	
	if blindCooldown > 0 then
		local progress = 1 - (blindCooldown / self.SpecialDelay)
		surface.SetDrawColor(255, 255, 0, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", blindCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- R Cooldown (Teleport)
	local rBarX = startX + (barWidth + spacing) * 2
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rBarX, cooldownY - 15)
	surface.DrawText("R - Teleport")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rBarX, cooldownY, barWidth, barHeight)
	
	local tpCooldown = 0
	local nextTeleport = self:GetNWFloat("NextTeleport", 0)
	if nextTeleport > CurTime() then
		tpCooldown = nextTeleport - CurTime()
	end
	
	if tpCooldown > 0 then
		local progress = 1 - (tpCooldown / self.TeleportDelay)
		surface.SetDrawColor(0, 150, 255, 255) -- Niebieski dla teleportu
		surface.DrawRect(rBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 200, 255, 255)
		surface.SetTextPos(rBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", tpCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(rBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- Celownik
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	
	local scale = 0.3
	local color = isWatched and Color(255, 0, 0, 255) or Color(0, 255, 0, 255)
	surface.SetDrawColor(color)
	
	local gap = 5
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )
end

/*function SWEP:DrawWorldModel()
	if !IsValid( self.SantasHat ) then return end
	local boneid = self.Owner:LookupBone( "joint1" )
	if not boneid then
		return
	end

	local matrix = self.Owner:GetBoneMatrix( boneid )
	if not matrix then
		return
	end

	local newpos, newang = LocalToWorld( self.SantasHatPositionOffset, self.SantasHatAngleOffset, matrix:GetTranslation(), matrix:GetAngles() )

	self.SantasHat:SetPos( newpos )
	self.SantasHat:SetAngles( newang )
	self.SantasHat:SetupBones()
	self.SantasHat:DrawModel()
end*/


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_2137j.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_scp_base"
SWEP.PrintName = "SCP-2137-J"

SWEP.HoldType = "normal"

-- SCP-2137-J Configuration
SWEP.AttackDelay = 2.0
SWEP.SecondaryDelay = 60.0 -- RMB cooldown (longer for big kremowka)
SWEP.HitDistance = 500
SWEP.ThrowForce = 800

-- No viewmodel needed for Papaj

if SERVER then
	util.AddNetworkString("scp2137j_throw_kremowka")
	util.AddNetworkString("scp2137j_throw_big_kremowka")
	util.AddNetworkString("scp2137j_resurrection")
	
	-- Hook to prevent kremowka from dealing collision damage
	hook.Add("EntityTakeDamage", "SCP2137J_PreventKremowkaDamage", function(target, dmginfo)
		local inflictor = dmginfo:GetInflictor()
		if IsValid(inflictor) and inflictor.IsSCP2137JKremowka then
			-- Only allow explosion damage, block physics damage
			if dmginfo:GetDamageType() != DMG_BLAST then
				return true -- Block the damage
			end
		end
	end)
	
	-- Resurrection system for SCP-2137-J
	hook.Add("EntityTakeDamage", "SCP2137J_Resurrection", function(target, dmginfo)
		if not IsValid(target) then return end
		if not target:IsPlayer() then return end
		if target:GTeam() != TEAM_SCP then return end
		
		local weapon = target:GetActiveWeapon()
		if not IsValid(weapon) then return end
		if weapon:GetClass() != "weapon_scp_2137j" then return end
		
		-- Check if already resurrected
		if target:GetNWBool("SCP2137J_HasResurrected", false) then return end
		
		-- Check if damage would bring HP below 1
		local newHP = target:Health() - dmginfo:GetDamage()
		if newHP >= 1 then return end
		
		-- Block the damage
		dmginfo:SetDamage(0)
		
		-- Mark as resurrected (one time only)
		target:SetNWBool("SCP2137J_HasResurrected", true)
		
		-- Get spawn position
		local spawnPos = nil
		if game.GetMap() == "gm_site19" then
			spawnPos = Vector(4902.546875, -194.649277, 25.906204)
		elseif game.GetMap() == "br_site15" then
			spawnPos = Vector(1400.00, 2000.00, -7157.00)
		else
			-- Fallback to current position if unknown map
			spawnPos = target:GetPos()
		end
		
		-- Instant teleport and heal
		target:SetPos(spawnPos)
		target:SetHealth(1200) -- Full HP
	end)
end

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("breach/wep_2137j")
end

function SWEP:Initialize()
	self:InitializeLanguage("SCP_2137J")
	self:SetHoldType(self.HoldType)
	
	self.NextAttack = 0
	self.NextSecondaryAttack = 0
end

function SWEP:PrimaryAttack()
	if not IsFirstTimePredicted() then return end
	if CurTime() < self.NextAttack then return end
	
	self:ThrowKremowka()
	self.NextAttack = CurTime() + self.AttackDelay
end

function SWEP:ThrowKremowka()
	if not SERVER then return end
	if not IsValid(self.Owner) then return end
	
	local ply = self.Owner
	local eyePos = ply:EyePos()
	local eyeAng = ply:EyeAngles()
	local forward = eyeAng:Forward()
	
	-- Create kremowka entity
	local kremowka = ents.Create("prop_physics")
	if not IsValid(kremowka) then return end
	
	kremowka:SetModel("models/kremowka/kremowka.mdl")
	kremowka:SetPos(eyePos + forward * 50)
	kremowka:SetAngles(eyeAng)
	kremowka:Spawn()
	kremowka:Activate()
	
	-- Disable collision damage (kremowka shouldn't hurt on impact, only on explosion)
	kremowka:SetCollisionGroup(COLLISION_GROUP_WEAPON)
	
	-- Set physics properties
	local phys = kremowka:GetPhysicsObject()
	if IsValid(phys) then
		phys:SetVelocity(forward * self.ThrowForce + Vector(0, 0, 100))
		phys:AddAngleVelocity(VectorRand() * 10)
		-- Make kremowka lighter so it doesn't deal physics damage
		phys:SetMass(1)
	end
	
	-- Mark as SCP-2137-J kremowka
	kremowka.IsSCP2137JKremowka = true
	kremowka.SCP2137JOwner = ply
	
	-- Set explosion timer (3 seconds)
	timer.Simple(3, function()
		if IsValid(kremowka) then
			self:ExplodeKremowka(kremowka)
		end
	end)
	
	-- Network to client for effects
	net.Start("scp2137j_throw_kremowka")
	net.WriteVector(eyePos)
	net.WriteAngle(eyeAng)
	net.Broadcast()
end

function SWEP:ThrowBigKremowka()
	if not SERVER then return end
	if not IsValid(self.Owner) then return end
	
	local ply = self.Owner
	local eyePos = ply:EyePos()
	local eyeAng = ply:EyeAngles()
	local forward = eyeAng:Forward()
	
	-- Create big kremowka entity
	local kremowka = ents.Create("prop_physics")
	if not IsValid(kremowka) then return end
	
	kremowka:SetModel("models/kremowka/kremowka.mdl")
	kremowka:SetPos(eyePos + forward * 50)
	kremowka:SetAngles(eyeAng)
	kremowka:Spawn()
	kremowka:Activate()
	
	-- Make it bigger (1.5x scale)
	kremowka:SetModelScale(5, 0)
	
	-- Disable collision damage
	kremowka:SetCollisionGroup(COLLISION_GROUP_WEAPON)
	
	-- Set physics properties
	local phys = kremowka:GetPhysicsObject()
	if IsValid(phys) then
		phys:SetVelocity(forward * self.ThrowForce + Vector(0, 0, 100))
		phys:AddAngleVelocity(VectorRand() * 10)
		phys:SetMass(1)
	end
	
	-- Mark as SCP-2137-J big kremowka
	kremowka.IsSCP2137JKremowka = true
	kremowka.IsSCP2137JBigKremowka = true
	kremowka.SCP2137JOwner = ply
	
	-- Set explosion timer (3 seconds)
	timer.Simple(3, function()
		if IsValid(kremowka) then
			self:ExplodeBigKremowka(kremowka)
		end
	end)
	
	-- Network to client for effects
	net.Start("scp2137j_throw_big_kremowka")
	net.WriteVector(eyePos)
	net.WriteAngle(eyeAng)
	net.Broadcast()
end

function SWEP:ExplodeKremowka(kremowka)
	if not SERVER then return end
	if not IsValid(kremowka) then return end
	
	local pos = kremowka:GetPos()
	local owner = kremowka.SCP2137JOwner
	
	-- Create explosion effect
	local effectdata = EffectData()
	effectdata:SetOrigin(pos)
	effectdata:SetMagnitude(150)
	effectdata:SetScale(1)
	util.Effect("Explosion", effectdata)
	
	-- Damage nearby entities
	for _, ent in pairs(ents.FindInSphere(pos, 150)) do
		local shouldDamage = false
		local damage = 0
		
		-- Check line of sight
		local targetPos = ent:GetPos()
		if ent:IsPlayer() then
			targetPos = ent:GetPos() + Vector(0, 0, 36) -- Eye level for players
		else
			targetPos = ent:GetPos() + ent:OBBCenter() -- Center of entity
		end
		
		local trace = util.TraceLine({
			start = pos,
			endpos = targetPos,
			filter = {kremowka, ent}
		})
		
		-- Only damage if line of sight is clear
		if not trace.Hit then
			-- Damage players (non-SCP and SCP-035)
			if ent:IsPlayer() and ent:Alive() and (ent:GTeam() != TEAM_SCP or ent:GetNClass() == ROLES.ROLE_SCP035) then
				shouldDamage = true
				local distance = ent:GetPos():Distance(pos)
				damage = math.max(15, 100 - (distance / 3))
			end
			
			-- Damage breakable entities (func_breakable, prop_physics, etc.)
			if ent:GetClass() == "func_breakable" or 
			   ent:GetClass() == "func_breakable_surf" or
			   ent:GetClass() == "prop_physics" or
			   ent:GetClass() == "prop_dynamic" then
				shouldDamage = true
				damage = 100 -- Fixed damage for breakables
			end
		end
		
		if shouldDamage then
			local dmginfo = DamageInfo()
			dmginfo:SetDamage(damage)
			dmginfo:SetDamageType(DMG_BLAST)
			dmginfo:SetAttacker(IsValid(owner) and owner or kremowka)
			dmginfo:SetInflictor(kremowka)
			dmginfo:SetDamagePosition(pos)
			
			ent:TakeDamageInfo(dmginfo)
		end
	end
	
	-- Remove kremowka
	kremowka:Remove()
end

function SWEP:ExplodeBigKremowka(kremowka)
	if not SERVER then return end
	if not IsValid(kremowka) then return end
	
	local pos = kremowka:GetPos()
	local owner = kremowka.SCP2137JOwner
	
	-- Create bigger explosion effect
	local effectdata = EffectData()
	effectdata:SetOrigin(pos)
	effectdata:SetMagnitude(250) -- Bigger explosion
	effectdata:SetScale(1.5)
	util.Effect("Explosion", effectdata)
	
	-- Damage nearby entities (bigger radius and more damage)
	for _, ent in pairs(ents.FindInSphere(pos, 200)) do -- Increased radius from 150 to 200
		local shouldDamage = false
		local damage = 0
		
		-- Check line of sight
		local targetPos = ent:GetPos()
		if ent:IsPlayer() then
			targetPos = ent:GetPos() + Vector(0, 0, 36) -- Eye level for players
		else
			targetPos = ent:GetPos() + ent:OBBCenter() -- Center of entity
		end
		
		local trace = util.TraceLine({
			start = pos,
			endpos = targetPos,
			filter = {kremowka, ent}
		})
		
		-- Only damage if line of sight is clear
		if not trace.Hit then
			-- Damage players (non-SCP and SCP-035) - increased damage
			if ent:IsPlayer() and ent:Alive() and (ent:GTeam() != TEAM_SCP or ent:GetNClass() == ROLES.ROLE_SCP035) then
				shouldDamage = true
				local distance = ent:GetPos():Distance(pos)
				damage = math.max(30, 180 - (distance / 2.5)) -- Increased from 15/100 to 30/180
			end
			
			-- Damage breakable entities - increased damage
			if ent:GetClass() == "func_breakable" or 
			   ent:GetClass() == "func_breakable_surf" or
			   ent:GetClass() == "prop_physics" or
			   ent:GetClass() == "prop_dynamic" then
				shouldDamage = true
				damage = 200 -- Increased from 100 to 200
			end
		end
		
		if shouldDamage then
			local dmginfo = DamageInfo()
			dmginfo:SetDamage(damage)
			dmginfo:SetDamageType(DMG_BLAST)
			dmginfo:SetAttacker(IsValid(owner) and owner or kremowka)
			dmginfo:SetInflictor(kremowka)
			dmginfo:SetDamagePosition(pos)
			
			ent:TakeDamageInfo(dmginfo)
		end
	end
	
	-- Remove kremowka
	kremowka:Remove()
end

function SWEP:SecondaryAttack()
	if not IsFirstTimePredicted() then return end
	if CurTime() < self.NextSecondaryAttack then return end
	
	self:ThrowBigKremowka()
	self.NextSecondaryAttack = CurTime() + self.SecondaryDelay
end

function SWEP:Reload()
	-- No reload
end

function SWEP:Think()
	-- No special think behavior needed
end

if CLIENT then
	function SWEP:DrawHUD()
		if disablehud == true then return end
		
		local ply = LocalPlayer()
		if not IsValid(ply) then return end
		
		-- Draw standard SCP HUD
		self:DrawSCPHUD()
		
		-- Draw crosshair
		local centerX, centerY = ScrW() / 2, ScrH() / 2
		surface.SetDrawColor(255, 255, 255, 200)
		surface.DrawLine(centerX - 10, centerY, centerX + 10, centerY)
		surface.DrawLine(centerX, centerY - 10, centerX, centerY + 10)
	end
	
	function SWEP:DrawSCPHUD()
		local ply = LocalPlayer()
		if not IsValid(ply) then return end
		
		local centerX = ScrW() / 2
		local centerY = ScrH() / 2
		local hudY = ScrH() - 150
		
		local hudWidth = 500
		local hudHeight = 120
		local hudX = centerX - hudWidth / 2
		
		-- Tło HUD
		surface.SetDrawColor(20, 20, 20, 180)
		surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Obramowanie
		surface.SetDrawColor(100, 100, 100, 200)
		surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Linia dekoracyjna
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
		
		-- Tytuł SCP
		surface.SetFont("DermaLarge")
		surface.SetTextColor(200, 200, 200, 255)
		local titleW, titleH = surface.GetTextSize("SCP-2137-J")
		surface.SetTextPos(centerX - titleW / 2, hudY + 10)
		surface.DrawText("SCP-2137-J")
		
		-- Cooldowny kremówek
		local cooldownY = hudY + 60
		local barWidth = 120
		local barHeight = 8
		local spacing = 20
		local totalWidth = barWidth * 2 + spacing
		local startX = centerX - totalWidth / 2
		
		-- LMB Cooldown (Kremówka)
		local lmbBarX = startX
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		surface.SetTextPos(lmbBarX, cooldownY - 15)
		surface.DrawText("LMB - Kremówka")
		
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
		
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		local kremowkaCooldown = 0
		local timeSinceAttack = CurTime() - (self.NextAttack - self.AttackDelay)
		local cooldownProgress = math.Clamp(timeSinceAttack / self.AttackDelay, 0, 1)
		
		if cooldownProgress < 1 then
			kremowkaCooldown = self.NextAttack - CurTime()
		end
		
		if kremowkaCooldown > 0 then
			local progress = 1 - (kremowkaCooldown / self.AttackDelay)
			surface.SetDrawColor(255, 200, 0, 200)
			surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(255, 255, 150, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText(string.format("%.1fs", kremowkaCooldown))
		else
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 255, 150, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText("READY")
		end
		
		-- RMB Cooldown (Big Kremówka)
		local rmbBarX = startX + barWidth + spacing
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		surface.SetTextPos(rmbBarX, cooldownY - 15)
		surface.DrawText("RMB - Big Kremówka")
		
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
		
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		local bigKremowkaCooldown = 0
		local timeSinceSecondary = CurTime() - (self.NextSecondaryAttack - self.SecondaryDelay)
		local secondaryCooldownProgress = math.Clamp(timeSinceSecondary / self.SecondaryDelay, 0, 1)
		
		if secondaryCooldownProgress < 1 then
			bigKremowkaCooldown = self.NextSecondaryAttack - CurTime()
		end
		
		if bigKremowkaCooldown > 0 then
			local progress = 1 - (bigKremowkaCooldown / self.SecondaryDelay)
			surface.SetDrawColor(255, 200, 0, 200)
			surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(255, 255, 150, 255)
			surface.SetTextPos(rmbBarX, cooldownY + 10)
			surface.DrawText(string.format("%.1fs", bigKremowkaCooldown))
		else
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 255, 150, 255)
			surface.SetTextPos(rmbBarX, cooldownY + 10)
			surface.DrawText("READY")
		end
		

	end
	
	-- Receive throw effect
	net.Receive("scp2137j_throw_kremowka", function()
		local pos = net.ReadVector()
		local ang = net.ReadAngle()
		
		-- Play throw sound
		sound.Play("physics/body/body_medium_impact_soft_" .. math.random(1, 7) .. ".wav", pos, 75, math.random(90, 110))
	end)
	
	-- Receive big throw effect
	net.Receive("scp2137j_throw_big_kremowka", function()
		local pos = net.ReadVector()
		local ang = net.ReadAngle()
		
		-- Play deeper throw sound for big kremowka
		sound.Play("physics/body/body_medium_impact_soft_" .. math.random(1, 7) .. ".wav", pos, 75, math.random(70, 90))
	end)
	
	-- Receive resurrection effect
	net.Receive("scp2137j_resurrection", function()
		local pos = net.ReadVector()
		
		-- Play resurrection sound
		sound.Play("ambient/explosions/explode_4.wav", pos, 100, 80)
		
		-- Play holy/divine sound
		timer.Simple(0.5, function()
			sound.Play("ambient/atmosphere/cave_hit" .. math.random(1, 6) .. ".wav", pos, 90, 120)
		end)
	end)
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_239.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_scp_base"
SWEP.PrintName = "SCP-239"

SWEP.HoldType = "normal"
SWEP.DrawCrosshair = true

-- SCP-239 Configuration
SWEP.AbilityDelay = 25 -- 3 second cooldown between abilities
SWEP.VulnerabilityDuration = 30 -- 30 seconds of vulnerability
SWEP.VulnerabilityInterval = 120 -- 2 minutes between vulnerability windows
SWEP.InvisibilityDuration = 10 -- 10 seconds of invisibility
SWEP.LowGravityDuration = 10 -- 10 seconds of low gravity

SWEP.NextAttackW = 0
SWEP.NextSpecial = 0
SWEP.AbilityCooldown = 0
SWEP.NextAbilities = {} -- Lista następnych umiejętności

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("breach/wep_239")
	
	-- Client-side only code
	
	-- HUD Drawing
	function SWEP:DrawHUD()
		if disablehud == true then return end
		
		local ply = LocalPlayer()
		if not IsValid(ply) then return end
		
		local centerX = ScrW() / 2
		local centerY = ScrH() / 2
		local hudY = ScrH() - 150
		
		local hudWidth = 500
		local hudHeight = 120
		local hudX = centerX - hudWidth / 2
		
		-- Tło HUD (identyczne jak inne SCPy)
		surface.SetDrawColor(20, 20, 20, 180)
		surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Obramowanie
		surface.SetDrawColor(100, 100, 100, 200)
		surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Linia dekoracyjna
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
		
		-- Tytuł SCP
		surface.SetFont("DermaLarge")
		surface.SetTextColor(200, 200, 200, 255)
		local titleW, titleH = surface.GetTextSize("SCP-239")
		surface.SetTextPos(centerX - titleW / 2, hudY + 10)
		surface.DrawText("SCP-239")
		
		-- Cooldown LMB (lewa strona)
		local cooldownY = hudY + 60
		local barWidth = 180
		local barHeight = 8
		local lmbBarX = hudX + 20
		
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		surface.SetTextPos(lmbBarX, cooldownY - 15)
		surface.DrawText("LMB - Random Ability")
		
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
		
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		local cooldownRemaining = math.max(0, self.AbilityCooldown - CurTime())
		
		if cooldownRemaining > 0 then
			local progress = 1 - (cooldownRemaining / self.AbilityDelay)
			surface.SetDrawColor(255, 100, 255, 255)
			surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(255, 150, 255, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText(string.format("%.1fs", cooldownRemaining))
		else
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 255, 150, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText("READY")
		end
		
		-- Tabelka z umiejętnościami (prawa strona)
		local abilitiesX = hudX + hudWidth - 100
		local abilitiesY = hudY + 45
		
		-- Nazwy umiejętności
		local abilityNames = {
			[1] = "Instant Kill",
			[2] = "Swap Positions", 
			[3] = "Prop Transform",
			[4] = "Drain Health",
			[5] = "Low Gravity",
			[6] = "Explode Player",
			[7] = "Shrink Player",
			[8] = "Drop Items",
			[9] = "Invisibility"
		}
		
		-- Tytuł tabelki
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		surface.SetTextPos(abilitiesX, abilitiesY - 15)
		surface.DrawText("Next Abilities:")
		
		-- Pokaż 3 następne umiejętności z serwera
		for i = 1, 3 do
			local abilityIndex = self:GetNWInt("NextAbility" .. i, 0)
			if abilityIndex > 0 and abilityNames[abilityIndex] then
				surface.SetTextColor(180, 180, 180, 255)
				surface.SetFont("DermaDefault")
				surface.SetTextPos(abilitiesX, abilitiesY + (i * 15))
				surface.DrawText("• " .. abilityNames[abilityIndex])
			end
		end
		
		-- Celownik
		local x = ScrW() / 2.0
		local y = ScrH() / 2.0
		
		local scale = 0.3
		local color = Color(255, 100, 255, 255)
		surface.SetDrawColor(color)
		
		local gap = 5
		local length = gap + 20 * scale
		surface.DrawLine( x - length, y, x - gap, y )
		surface.DrawLine( x + length, y, x + gap, y )
		surface.DrawLine( x, y - length, x, y - gap )
		surface.DrawLine( x, y + length, x, y + gap )
		
		-- Info o rozbijaniu szyb
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 150, 150, 255)
		local glassText = "[E] - Break Glass"
		local glassW, glassH = surface.GetTextSize(glassText)
		surface.SetTextPos(centerX - glassW / 2, hudY + hudHeight - 25)
		surface.DrawText(glassText)
	end
end

function SWEP:Initialize()
	self:InitializeLanguage("SCP_239")
	self:SetHoldType(self.HoldType)
	
	-- Initialize glass break cooldown
	self.NextGlassBreak = 0
	
	if SERVER then
		-- Initialize vulnerability system
		self.VulnerabilityDuration = 30
		self.IsVulnerable = false
		
		-- Initialize abilities queue
		self.NextAbilities = {}
		self:GenerateNextAbilities()
		
		-- Wait for owner to be valid before setting NWBool
		timer.Simple(0.1, function()
			if IsValid(self) and IsValid(self.Owner) then
				-- Initialize as immortal
				self.Owner:SetNWBool("SCP239_Vulnerable", false)
				self:SetNWBool("SCP239_Vulnerable", false)
				self:SetNWFloat("SCP239_VulnerabilityTime", 0)
				
				-- Debug
				print("[SCP-239] Initialized as IMMORTAL for player:", self.Owner:Nick())
				print("[SCP-239] NWBool set to:", self.Owner:GetNWBool("SCP239_Vulnerable", true)) -- Should be false
				
				-- Start vulnerability timer
				local timerName = "SCP239_Vulnerability_" .. self.Owner:EntIndex()
				timer.Create(timerName, 120, 0, function()
					if IsValid(self) and IsValid(self.Owner) then
						self:StartVulnerability()
					else
						timer.Remove(timerName)
					end
				end)
			end
		end)
	end
end

-- SERVER FUNCTIONS
if SERVER then
	util.AddNetworkString("SCP239_VulnerabilityStart")
	util.AddNetworkString("SCP239_VulnerabilityEnd")
	
	-- Generate next 3 abilities
	function SWEP:GenerateNextAbilities()
		self.NextAbilities = {}
		
		-- Generate 3 random abilities
		for i = 1, 3 do
			local abilityIndex = math.random(1, 9)
			table.insert(self.NextAbilities, abilityIndex)
		end
		
		-- Sync to client
		self:SyncAbilitiesToClient()
	end
	
	-- Sync abilities to client via NWVars
	function SWEP:SyncAbilitiesToClient()
		for i = 1, 3 do
			local abilityIndex = self.NextAbilities[i] or 0
			self:SetNWInt("NextAbility" .. i, abilityIndex)
		end
	end
	
	-- Update abilities queue when one is used
	function SWEP:UseNextAbility()
		-- Remove first ability and add new one at the end
		table.remove(self.NextAbilities, 1)
		
		-- Add new random ability
		local newAbility = math.random(1, 9)
		table.insert(self.NextAbilities, newAbility)
		
		-- Sync to client
		self:SyncAbilitiesToClient()
	end
	
	function SWEP:StartVulnerability()
		if not IsValid(self.Owner) then return end
		
		self.IsVulnerable = true
		self.Owner:SetNWBool("SCP239_Vulnerable", true)
		self:SetNWBool("SCP239_Vulnerable", true)
		self:SetNWFloat("SCP239_VulnerabilityTime", CurTime() + self.VulnerabilityDuration)
		
		-- Debug
		print("[SCP-239] Started VULNERABILITY for player:", self.Owner:Nick())
		print("[SCP-239] Will end in", self.VulnerabilityDuration, "seconds")
		
		-- Notify all players
		net.Start("SCP239_VulnerabilityStart")
		net.Broadcast()
		
		-- Play alarm sound
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) then
				ply:EmitSound("buttons/button10.wav", 100, 80)
			end
		end
		
		-- End vulnerability after duration
		timer.Simple(self.VulnerabilityDuration, function()
			if IsValid(self) and IsValid(self.Owner) then
				self:EndVulnerability()
			end
		end)
	end
	
	function SWEP:EndVulnerability()
		if not IsValid(self.Owner) then return end
		
		self.IsVulnerable = false
		self.Owner:SetNWBool("SCP239_Vulnerable", false)
		self:SetNWBool("SCP239_Vulnerable", false)
		self:SetNWFloat("SCP239_VulnerabilityTime", 0)
		
		-- Debug
		print("[SCP-239] Ended VULNERABILITY for player:", self.Owner:Nick())
		print("[SCP-239] Player is now IMMORTAL again")
		
		-- Notify all players
		net.Start("SCP239_VulnerabilityEnd")
		net.Broadcast()
	end
	
	-- Invisibility system
	function SWEP:StartInvisibility()
		if IsValid(self.Owner) then
			self.Owner:SetNoDraw(true)
			self.Owner:SetNotSolid(true)
			
			timer.Simple(self.InvisibilityDuration, function()
				if IsValid(self.Owner) then
					self.Owner:SetNoDraw(false)
					self.Owner:SetNotSolid(false)
				end
			end)
		end
	end
	
	-- GLOBAL ABILITIES (no range restrictions)
	function SWEP:InstantKill()
		local enemies = {}
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply != self.Owner and ply:Alive() then
				if (ply:GTeam() != TEAM_SCP or ply:GetNClass() == ROLES.ROLE_SCP035) and ply:GTeam() != TEAM_SPEC then
					table.insert(enemies, ply)
				end
			end
		end
		
		if #enemies == 0 then return end
		
		local target = enemies[math.random(1, #enemies)]
		
		local dmginfo = DamageInfo()
		dmginfo:SetDamage(target:Health() + 100)
		dmginfo:SetAttacker(self.Owner)
		dmginfo:SetInflictor(self)
		dmginfo:SetDamageType(DMG_DIRECT)
		target:TakeDamageInfo(dmginfo)
		
		self.Owner:AddExp(200, true)
	end
	
	function SWEP:SwapPositions()
		local allPlayers = {}
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply != self.Owner and ply:Alive() and ply:GTeam() != TEAM_SPEC then
				table.insert(allPlayers, ply)
			end
		end
		
		if #allPlayers == 0 then return end
		
		local target = allPlayers[math.random(1, #allPlayers)]
		local ownerPos = self.Owner:GetPos()
		local targetPos = target:GetPos()
		
		self.Owner:SetPos(targetPos)
		target:SetPos(ownerPos)
	end
	
	function SWEP:PropTransform()
		local enemies = {}
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply != self.Owner and ply:Alive() then
				if (ply:GTeam() != TEAM_SCP or ply:GetNClass() == ROLES.ROLE_SCP035) and ply:GTeam() != TEAM_SPEC then
					table.insert(enemies, ply)
				end
			end
		end
		
		if #enemies == 0 then return end
		
		local target = enemies[math.random(1, #enemies)]
		local originalPos = target:GetPos() -- Zapisz pozycję PRZED teleportacją
		
		-- Teleportuj gracza poza mapę (bardzo daleko w dół)
		local farAwayPos = originalPos + Vector(0, 0, -10000)
		target:SetPos(farAwayPos)
		
		-- Natychmiast zabij gracza po teleportacji
		timer.Simple(0.05, function()
			if IsValid(target) then
				local dmginfo = DamageInfo()
				dmginfo:SetDamage(target:Health() + 1000)
				dmginfo:SetAttacker(self.Owner)
				dmginfo:SetInflictor(self)
				dmginfo:SetDamageType(DMG_DIRECT)
				target:TakeDamageInfo(dmginfo)
			end
		end)
		
		-- Stwórz prop w miejscu gdzie wcześniej stał gracz (originalPos)
		local propModels = {
			"models/props_c17/FurnitureChair001a.mdl",
			"models/props/cs_office/chair_office.mdl",
			"models/props_c17/FurnitureTable001a.mdl",
			"models/props_c17/FurnitureDrawer001a.mdl",
			"models/props_c17/FurnitureCouch001a.mdl",
			"models/props_interiors/refrigerator01a.mdl",
			"models/props_c17/FurnitureWashingmachine001a.mdl",
			"models/props_c17/FurnitureToilet001a.mdl",
			"models/props/cs_office/sofa.mdl",
			"models/props_c17/FurnitureBed001a.mdl"
		}
		
		local prop = ents.Create("prop_physics")
		prop:SetModel(propModels[math.random(1, #propModels)])
		prop:SetPos(originalPos + Vector(0, 0, 50)) -- Spawn 50 jednostek wyżej od oryginalnej pozycji
		prop:Spawn()
		
		-- Dodaj fizyczne siły żeby prop spadł naturalnie
		timer.Simple(0.1, function()
			if IsValid(prop) then
				local phys = prop:GetPhysicsObject()
				if IsValid(phys) then
					phys:Wake()
				end
			end
		end)
		
		-- Usuń prop po 30 sekundach
		timer.Simple(30, function()
			if IsValid(prop) then
				prop:Remove()
			end
		end)
		
		self.Owner:AddExp(150, true)
	end
	
	function SWEP:DrainHealth()
		local enemies = {}
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply != self.Owner and ply:Alive() then
				if (ply:GTeam() != TEAM_SCP or ply:GetNClass() == ROLES.ROLE_SCP035) and ply:GTeam() != TEAM_SPEC then
					table.insert(enemies, ply)
				end
			end
		end
		
		if #enemies == 0 then return end
		
		local target = enemies[math.random(1, #enemies)]
		target:SetHealth(1)
	end
	
	function SWEP:LowGravity()
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply:Alive() then
				ply:SetGravity(0.3)
			end
		end
		
		timer.Simple(self.LowGravityDuration, function()
			for _, ply in pairs(player.GetAll()) do
				if IsValid(ply) then
					ply:SetGravity(1)
				end
			end
		end)
	end
	
	function SWEP:ExplodePlayer()
		local enemies = {}
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply != self.Owner and ply:Alive() then
				if (ply:GTeam() != TEAM_SCP or ply:GetNClass() == ROLES.ROLE_SCP035) and ply:GTeam() != TEAM_SPEC then
					table.insert(enemies, ply)
				end
			end
		end
		
		if #enemies == 0 then return end
		
		local target = enemies[math.random(1, #enemies)]
		local targetPos = target:GetPos()
		
		-- Kill the player
		local dmginfo = DamageInfo()
		dmginfo:SetDamage(target:Health() + 100)
		dmginfo:SetAttacker(self.Owner)
		dmginfo:SetInflictor(self)
		dmginfo:SetDamageType(DMG_BLAST)
		target:TakeDamageInfo(dmginfo)
		
		-- Create explosion effect
		local explode = ents.Create("env_explosion")
		explode:SetPos(targetPos)
		explode:SetKeyValue("iMagnitude", "100")
		explode:Spawn()
		explode:Fire("Explode", 0, 0)
		
		self.Owner:AddExp(175, true)
	end
	
	function SWEP:ShrinkPlayer()
		local enemies = {}
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply != self.Owner and ply:Alive() then
				if (ply:GTeam() != TEAM_SCP or ply:GetNClass() == ROLES.ROLE_SCP035) and ply:GTeam() != TEAM_SPEC then
					table.insert(enemies, ply)
				end
			end
		end
		
		if #enemies == 0 then return end
		
		local target = enemies[math.random(1, #enemies)]
		target:SetModelScale(0.5)
		
		timer.Simple(60, function()
			if IsValid(target) then
				target:SetModelScale(1)
			end
		end)
	end
	
	function SWEP:DropItems()
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply:Alive() and ply:GTeam() != TEAM_SCP and ply:GTeam() != TEAM_SPEC then
				local weapon = ply:GetActiveWeapon()
				if IsValid(weapon) then
					local class = weapon:GetClass()
					-- Nie wyrzucaj br_holster i br_id
					if class != "br_holster" and class != "br_id" then
						ply:DropWeapon(weapon)
					end
				end
			end
		end
	end
	
	function SWEP:Invisibility()
		self:StartInvisibility()
	end
end

function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if self.AbilityCooldown > CurTime() then return end
	
	self.AbilityCooldown = CurTime() + self.AbilityDelay
	
	if SERVER then
		self:UseRandomAbility()
	end
end

if SERVER then
	function SWEP:UseRandomAbility()
		-- Use first ability from queue
		if not self.NextAbilities or #self.NextAbilities == 0 then
			self:GenerateNextAbilities()
		end
		
		local abilityIndex = self.NextAbilities[1] or 1
		
		local abilities = {
			function() self:InstantKill() end,
			function() self:SwapPositions() end,
			function() self:PropTransform() end,
			function() self:DrainHealth() end,
			function() self:LowGravity() end,
			function() self:ExplodePlayer() end,
			function() self:ShrinkPlayer() end,
			function() self:DropItems() end,
			function() self:Invisibility() end
		}
		
		-- Execute the ability
		if abilities[abilityIndex] then
			abilities[abilityIndex]()
		end
		
		-- Update abilities queue
		self:UseNextAbility()
	end
end

function SWEP:SecondaryAttack()
	-- No secondary attack for SCP-239
end

function SWEP:Deploy()
	if IsValid(self.Owner) then
		self.Owner:DrawWorldModel(false)
		self.Owner:DrawViewModel(false)
	end
end

-- Clean up on holster
function SWEP:Holster()
	if SERVER then
		-- Clean up timers when weapon is holstered
		local timerName = "SCP239_Vulnerability_" .. (IsValid(self.Owner) and self.Owner:EntIndex() or "unknown")
		timer.Remove(timerName)
		
		-- Reset vulnerability state
		if IsValid(self.Owner) then
			self.Owner:SetNWBool("SCP239_Vulnerable", false)
		end
	end
	
	return true
end

-- Rozbijanie szyb na klawisz E dla SCP-239
if SERVER then
	hook.Add("KeyPress", "SCP239_GlassBreak", function(ply, key)
		if !IsValid(ply) or !ply:Alive() then return end
		local wep = ply:GetActiveWeapon()
		if !IsValid(wep) or wep:GetClass() != "weapon_scp_239" then return end
		
		-- Sprawdź czy to E (32)
		if key != 32 then return end
		
		-- Cooldown
		if wep.NextGlassBreak and wep.NextGlassBreak > CurTime() then return end
		wep.NextGlassBreak = CurTime() + 0.5
		
		-- Znajdź szybę przed graczem
		local tr = util.TraceLine({
			start = ply:GetShootPos(),
			endpos = ply:GetShootPos() + ply:GetAimVector() * 100,
			filter = ply
		})
		
		local ent = tr.Entity
		if IsValid(ent) then
			if ent:GetClass() == "func_breakable" or ent:GetClass() == "func_breakable_surf" then
				ent:Fire("Break")
			elseif string.find(ent:GetClass(), "door") then
				-- Możliwość rozbicia drzwi ze szkłem
				wep:SCPDamageEvent(ent, 100)
			end
		end
	end)
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_2521.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_scp_base"
SWEP.PrintName = "SCP-2521"

SWEP.HoldType = "normal"

-- Attack delays and cooldowns
SWEP.MeleeDelay = 6 -- 6 second cooldown
SWEP.SilenceDelay = 60 -- 60 second cooldown 
SWEP.TeleportDelay = 60 -- 60 second cooldown
SWEP.NextMelee = 0
SWEP.NextSilence = 0
SWEP.NextTeleport = 0

-- Attack properties
SWEP.MeleeDamage = 99
SWEP.MeleeRange = 100
SWEP.SilenceRadius = 400
SWEP.SilenceDuration = 4
SWEP.TeleportRange = 1000
SWEP.PassiveDamageRadius = 300
SWEP.PassiveDamage = 5
SWEP.PassiveDamageDelay = 1

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("breach/wep_2521")
	
	-- Teleport preview
	SWEP.TeleportPreview = false
	SWEP.TeleportPos = Vector()
	SWEP.PreviewModel = nil
	SWEP.NextPreviewToggle = 0
	
	-- Black smoke effect (like SCP-054 but black)
	net.Receive("SCP2521_CreateSmoke", function()
		local pos = net.ReadVector()
		local emitter = ParticleEmitter(pos)
		for i = 1, 50 do
			local particle = emitter:Add("particle/smokesprites_0001", pos + Vector(math.random(-50, 50), math.random(-50, 50), math.random(0, 80)))
			if particle then
				particle:SetVelocity(Vector(math.random(-30, 30), math.random(-30, 30), math.random(20, 40)))
				particle:SetDieTime(2)
				particle:SetStartAlpha(150)
				particle:SetEndAlpha(0)
				particle:SetStartSize(30)
				particle:SetEndSize(60)
				particle:SetRoll(math.random(0, 360))
				particle:SetRollDelta(math.random(-0.5, 0.5))
				particle:SetColor(0, 0, 0) -- Black smoke instead of white
				particle:SetAirResistance(100)
				particle:SetGravity(Vector(0, 0, -10))
			end
		end
		emitter:Finish()
	end)
	
	-- Black smoke effect for hit player (3 seconds)
	net.Receive("SCP2521_CreateHitSmoke", function()
		local target = net.ReadEntity()
		if !IsValid(target) then return end
		
		-- Create timer for 3 second smoke effect
		local timerName = "SCP2521_HitSmoke_" .. target:EntIndex()
		timer.Remove(timerName) -- Remove existing timer if any
		
		timer.Create(timerName, 0.2, 15, function() -- 0.2s * 15 = 3 seconds
			if !IsValid(target) or !target:Alive() then
				timer.Remove(timerName)
				return
			end
			
			local pos = target:GetPos()
			local emitter = ParticleEmitter(pos)
			for i = 1, 8 do -- Less particles per interval but more frequent
				local particle = emitter:Add("particle/smokesprites_0001", pos + Vector(math.random(-30, 30), math.random(-30, 30), math.random(20, 70)))
				if particle then
					particle:SetVelocity(Vector(math.random(-20, 20), math.random(-20, 20), math.random(10, 30)))
					particle:SetDieTime(1.5)
					particle:SetStartAlpha(120)
					particle:SetEndAlpha(0)
					particle:SetStartSize(25)
					particle:SetEndSize(50)
					particle:SetRoll(math.random(0, 360))
					particle:SetRollDelta(math.random(-0.3, 0.3))
					particle:SetColor(0, 0, 0) -- Black smoke
					particle:SetAirResistance(80)
					particle:SetGravity(Vector(0, 0, -5))
				end
			end
			emitter:Finish()
		end)
	end)
	
	function SWEP:UpdateTeleportPreview()
		if !self.TeleportPreview then return end
		
		local owner = self.Owner
		if !IsValid(owner) then return end
		
		-- Calculate teleport position
		local tr = util.TraceLine({
			start = owner:EyePos(),
			endpos = owner:EyePos() + owner:EyeAngles():Forward() * self.TeleportRange,
			filter = owner,
			mask = MASK_PLAYERSOLID
		})
		
		self.TeleportPos = tr.HitPos
		
		-- Create or update preview model
		if !IsValid(self.PreviewModel) then
			self.PreviewModel = ClientsideModel(owner:GetModel(), RENDERGROUP_TRANSLUCENT)
			self.PreviewModel:SetNoDraw(true)
		end
		
		if IsValid(self.PreviewModel) then
			self.PreviewModel:SetPos(self.TeleportPos)
			self.PreviewModel:SetAngles(owner:EyeAngles())
			
			-- Make it transparent and colored
			self.PreviewModel:SetColor(Color(255, 255, 255, 100))
			self.PreviewModel:SetRenderMode(RENDERMODE_TRANSALPHA)
		end
	end
	

	
	hook.Add("PostDrawOpaqueRenderables", "SCP2521_DrawPreview", function()
		for _, ply in pairs(player.GetAll()) do
			local wep = ply:GetActiveWeapon()
			if IsValid(wep) and wep:GetClass() == "weapon_scp_2521" and wep.TeleportPreview and IsValid(wep.PreviewModel) then
				wep.PreviewModel:DrawModel()
			end
		end
	end)
	
	function SWEP:OnRemove()
		if IsValid(self.PreviewModel) then
			self.PreviewModel:Remove()
			self.PreviewModel = nil
		end
		self.TeleportPreview = false
		self.NextPreviewToggle = 0
	end
	
	-- Also clean up when holstering
	function SWEP:Holster()
		if IsValid(self.PreviewModel) then
			self.PreviewModel:Remove()
			self.PreviewModel = nil
		end
		self.TeleportPreview = false
		self.NextPreviewToggle = 0
		return true
	end
	
	-- Clean up hooks when gamemode changes
	hook.Add("OnGamemodeLoaded", "SCP2521_CleanupHooks", function()
		hook.Remove("PostDrawOpaqueRenderables", "SCP2521_DrawPreview")
		hook.Remove("PlayerSay", "SCP2521_ChatDetection")
		hook.Remove("PlayerSwitchWeapon", "SCP2521_ForceHolster")
		hook.Remove("PlayerDeath", "SCP2521_CleanupHitSmoke")
	end)
	
	-- Clean up hit smoke timers when player dies
	hook.Add("PlayerDeath", "SCP2521_CleanupHitSmoke", function(victim, inflictor, attacker)
		if IsValid(victim) then
			timer.Remove("SCP2521_HitSmoke_" .. victim:EntIndex())
		end
	end)
end

function SWEP:Initialize()
	self:InitializeLanguage("SCP_2521")
	self:SetHoldType(self.HoldType)
	
	if SERVER then
		-- Initialize network variables
		self:SetNWFloat("NextMelee", 0)
		self:SetNWFloat("NextSilence", 0) 
		self:SetNWFloat("NextTeleport", 0)
		
		-- Table to track silenced players
		self.SilencedPlayers = {}
		
		-- Passive damage tracking
		self.NextPassiveDamage = 0
		
		-- Ensure owner has correct team
		timer.Simple(0.1, function()
			if IsValid(self) and IsValid(self.Owner) then
				if self.Owner:GTeam() != TEAM_SCP then
					self.Owner:StripWeapon("weapon_scp_2521")
				end
			end
		end)
	end
end

function SWEP:Think()
	self:PlayerFreeze()
	
	if SERVER then
		self:PassiveDamageThink()
		self:UpdateSilencedPlayers()
	elseif CLIENT then
		if self.TeleportPreview then
			self:UpdateTeleportPreview()
		end
	end
end

-- SERVER FUNCTIONS
if SERVER then
	-- Passive damage for nearby players using chat/voice
	function SWEP:PassiveDamageThink()
		if self.NextPassiveDamage > CurTime() then return end
		self.NextPassiveDamage = CurTime() + self.PassiveDamageDelay
		
		local owner = self.Owner
		if !IsValid(owner) then return end
		
		local nearbyPlayers = ents.FindInSphere(owner:GetPos(), self.PassiveDamageRadius)
		
		for _, ply in pairs(nearbyPlayers) do
			if IsValid(ply) and ply:IsPlayer() and ply:Alive() and ply != owner then
				if ply:GTeam() != TEAM_SCP and ply:GTeam() != TEAM_SPEC then
					-- Check if player is using voice chat or has recent chat activity
					local damage = 0
					
					-- Chat activity with character-based damage
					if ply.LastChatTime and CurTime() - ply.LastChatTime < 3 and ply.LastChatLength then
						damage = ply.LastChatLength -- Damage = character count
					end
					
					if damage > 0 then
						local dmginfo = DamageInfo()
						dmginfo:SetDamage(damage)
						dmginfo:SetAttacker(owner)
						dmginfo:SetInflictor(self)
						dmginfo:SetDamageType(DMG_DIRECT)
						ply:TakeDamageInfo(dmginfo)
					end
				end
			end
		end
	end
	
	-- Update force holstered players
	function SWEP:UpdateSilencedPlayers()
		for ply, endTime in pairs(self.SilencedPlayers) do
			if CurTime() > endTime then
				self.SilencedPlayers[ply] = nil
				if IsValid(ply) then
					ply:SetNWBool("IsForceHolstered", false)
				end
			end
		end
	end
	
	-- Hook for chat detection with character counting
	hook.Add("PlayerSay", "SCP2521_ChatDetection", function(ply, text, public)
		ply.LastChatTime = CurTime()
		ply.LastChatLength = string.len(text) -- Count all characters including spaces
	end)
	

	
	-- Hook for preventing weapon switching during force holster
	hook.Add("PlayerSwitchWeapon", "SCP2521_ForceHolster", function(ply, oldwep, newwep)
		if IsValid(ply) and ply:GetNWBool("IsForceHolstered", false) then
			if IsValid(newwep) and newwep:GetClass() != "br_holster" and newwep:GetClass() != "br_id" then
				ply:PrintMessage(HUD_PRINTCENTER, "You are forced to holster your weapons!")
				return true -- Prevent switching from holster
			end
		end
	end)
end

-- Helper function to check if weapon can be used
function SWEP:CanUseWeapon()
	local owner = self.Owner
	if !IsValid(owner) or !owner:Alive() then return false end
	if owner:GTeam() != TEAM_SCP and owner:GetNClass() != ROLES.ROLE_SCP035 then return false end
	return true
end

-- PRIMARY ATTACK - Melee Attack (99 damage, 6s cooldown, black smoke)
function SWEP:PrimaryAttack()
	if !self:CanUseWeapon() then return end
	if self.NextMelee > CurTime() then return end
	
	local owner = self.Owner
	
	-- Attack animation
	owner:SetAnimation(PLAYER_ATTACK1)
	
	if SERVER then
		-- Trace for target
		local tr = util.TraceLine({
			start = owner:EyePos(),
			endpos = owner:EyePos() + owner:EyeAngles():Forward() * self.MeleeRange,
			filter = owner,
			mask = MASK_SHOT_HULL
		})
		
		if IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity:Alive() then
			local target = tr.Entity
			
			if target:GTeam() != TEAM_SCP and target:GTeam() != TEAM_SPEC then
				-- Set cooldown only when we hit a valid target
				self.NextMelee = CurTime() + self.MeleeDelay
				self:SetNWFloat("NextMelee", self.NextMelee)
				
				-- Deal damage
				local dmginfo = DamageInfo()
				dmginfo:SetDamage(self.MeleeDamage)
				dmginfo:SetAttacker(owner)
				dmginfo:SetInflictor(self)
				dmginfo:SetDamageType(DMG_SLASH)
				dmginfo:SetDamagePosition(tr.HitPos)
				target:TakeDamageInfo(dmginfo)
				
				-- Create smoke effect on hit target (3 seconds)
				net.Start("SCP2521_CreateHitSmoke")
					net.WriteEntity(target)
				net.Broadcast()
				
				-- Experience gain
				if owner.AddExp then
					owner:AddExp(50, true)
				end
			end
		end
	end
end

-- SECONDARY ATTACK - Force Holster (4s duration, 60s cooldown)  
function SWEP:SecondaryAttack()
	if !self:CanUseWeapon() then return end
	if self.NextSilence > CurTime() then return end
	
	local owner = self.Owner
	
	self.NextSilence = CurTime() + self.SilenceDelay
	self:SetNWFloat("NextSilence", self.NextSilence)
	
	if SERVER then
		-- Find nearby enemies
		local nearbyPlayers = ents.FindInSphere(owner:GetPos(), self.SilenceRadius)
		local forcedCount = 0
		
		for _, ply in pairs(nearbyPlayers) do
			if IsValid(ply) and ply:IsPlayer() and ply:Alive() and ply != owner then
				if (ply:GTeam() != TEAM_SCP or ply:GetNClass() == ROLES.ROLE_SCP035) and ply:GTeam() != TEAM_SPEC then
					-- Force holster for 4 seconds
					self.SilencedPlayers[ply] = CurTime() + self.SilenceDuration
					ply:SetNWBool("IsForceHolstered", true)
					
					-- Force holster weapon
					ply:SelectWeapon("br_holster")
					
					forcedCount = forcedCount + 1
				end
			end
		end
		
		if forcedCount > 0 then
			-- Experience gain
			if owner.AddExp then
				owner:AddExp(25 * forcedCount, true)
			end
		end
	end
end

-- RELOAD - Teleport (60s cooldown with preview)
function SWEP:Reload()
	if !self:CanUseWeapon() then return end
	local teleportCooldown = math.max(0, self:GetNWFloat("NextTeleport", 0) - CurTime())
	if teleportCooldown > 0 then return end
	
	local owner = self.Owner
	
	if CLIENT then
		-- Check if we can toggle preview (1 second cooldown)
		if CurTime() < self.NextPreviewToggle then return end
		
		if !self.TeleportPreview then
			-- Start preview mode
			self.TeleportPreview = true
			self.NextPreviewToggle = CurTime() + 1 -- 1 second cooldown
			self:UpdateTeleportPreview()
		else
			-- Execute teleport
			self.TeleportPreview = false
			self.NextPreviewToggle = CurTime() + 1 -- 1 second cooldown
			
			-- Clean up preview model
			if IsValid(self.PreviewModel) then
				self.PreviewModel:Remove()
				self.PreviewModel = nil
			end
			
			-- Send teleport request to server
			net.Start("SCP2521_Teleport")
				net.WriteVector(self.TeleportPos)
			net.SendToServer()
		end
		return
	end
end

if SERVER then
	util.AddNetworkString("SCP2521_Teleport")
	util.AddNetworkString("SCP2521_CreateSmoke")
	util.AddNetworkString("SCP2521_CreateHitSmoke")
	
	net.Receive("SCP2521_Teleport", function(len, ply)
		local wep = ply:GetActiveWeapon()
		if !IsValid(wep) or wep:GetClass() != "weapon_scp_2521" then return end
		
		local teleportCooldown = math.max(0, wep:GetNWFloat("NextTeleport", 0) - CurTime())
		if teleportCooldown > 0 then return end
		
		local teleportPos = net.ReadVector()
		
		-- Validate position
		local tr = util.TraceLine({
			start = ply:EyePos(),
			endpos = ply:EyePos() + ply:EyeAngles():Forward() * wep.TeleportRange,
			filter = ply,
			mask = MASK_PLAYERSOLID
		})
		
		-- Check if position is close to calculated position (anti-cheat)
		if teleportPos:Distance(tr.HitPos) > 100 then
			ply:PrintMessage(HUD_PRINTCENTER, "Invalid teleport position!")
			return
		end
		
		-- Check if position is valid (not inside wall)
		local hullTrace = util.TraceHull({
			start = teleportPos,
			endpos = teleportPos,
			mins = Vector(-16, -16, 0),
			maxs = Vector(16, 16, 72),
			filter = ply,
			mask = MASK_PLAYERSOLID
		})
		
		if hullTrace.Hit then
			ply:PrintMessage(HUD_PRINTCENTER, "Cannot teleport into solid objects!")
			return
		end
		
		wep.NextTeleport = CurTime() + wep.TeleportDelay
		wep:SetNWFloat("NextTeleport", wep.NextTeleport)
		
		-- Create black smoke effect at old position (like SCP-054)
		local oldPos = ply:GetPos()
		net.Start("SCP2521_CreateSmoke")
			net.WriteVector(oldPos)
		net.Broadcast()
		

		
		-- Teleport
		ply:SetPos(teleportPos)
		
		-- Create black smoke effect at new position (like SCP-054)
		net.Start("SCP2521_CreateSmoke")
			net.WriteVector(teleportPos)
		net.Broadcast()
		
		-- Creepy teleport sound at new position (~1 second)
		sound.Play("ambient/atmosphere/cave_hit1.wav", teleportPos, 70, 70)
		sound.Play("ambient/wind/wind_hit1.wav", teleportPos, 60, 50)
		sound.Play("ambient/atmosphere/underground_explosion_distant1.wav", teleportPos, 50, 40)
		
		-- Experience gain
		if ply.AddExp then
			ply:AddExp(10, true)
		end
	end)
end

-- CLIENT FUNCTIONS
if CLIENT then

	
	-- HUD elements
	function SWEP:DrawHUD()
		if disablehud == true then return end
		
		local ply = LocalPlayer()
		if !IsValid(ply) then return end
		
		local centerX = ScrW() / 2
		local centerY = ScrH() / 2
		local hudY = ScrH() - 150
		
		local hudWidth = 500
		local hudHeight = 120
		local hudX = centerX - hudWidth / 2
		
		-- Tło HUD
		surface.SetDrawColor(20, 20, 20, 180)
		surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Obramowanie
		surface.SetDrawColor(100, 100, 100, 200)
		surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Linia dekoracyjna
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
		
		-- Tytuł SCP
		surface.SetFont("DermaLarge")
		surface.SetTextColor(200, 200, 200, 255)
		local titleW, titleH = surface.GetTextSize("SCP-2521")
		surface.SetTextPos(centerX - titleW / 2, hudY + 10)
		surface.DrawText("SCP-2521")
		

		
		-- Cooldowny
		local cooldownY = hudY + 60
		local barWidth = 140
		local barHeight = 8
		local spacing = 20
		local totalWidth = barWidth * 3 + spacing * 2
		local startX = centerX - totalWidth / 2
		
		-- LMB - Dark Strike
		local lmbBarX = startX
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		surface.SetTextPos(lmbBarX, cooldownY - 15)
		surface.DrawText("LMB - Dark Strike")
		
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
		
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		local meleeCooldown = math.max(0, self:GetNWFloat("NextMelee", 0) - CurTime())
		
		if meleeCooldown > 0 then
			local progress = 1 - (meleeCooldown / self.MeleeDelay)
			surface.SetDrawColor(150, 50, 150, 255)
			surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(200, 150, 200, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText(string.format("%.1fs", meleeCooldown))
		else
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 255, 150, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText("READY")
		end
		
		-- RMB - Silence Field
		local rmbBarX = startX + barWidth + spacing
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		surface.SetTextPos(rmbBarX, cooldownY - 15)
		surface.DrawText("RMB - Force Holster")
		
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
		
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		local silenceCooldown = math.max(0, self:GetNWFloat("NextSilence", 0) - CurTime())
		
		if silenceCooldown > 0 then
			local progress = 1 - (silenceCooldown / self.SilenceDelay)
			surface.SetDrawColor(255, 200, 0, 255)
			surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(255, 255, 150, 255)
			surface.SetTextPos(rmbBarX, cooldownY + 10)
			surface.DrawText(string.format("%.0fs", silenceCooldown))
		else
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 255, 150, 255)
			surface.SetTextPos(rmbBarX, cooldownY + 10)
			surface.DrawText("READY")
		end
		
		-- R - Teleport
		local rBarX = startX + (barWidth + spacing) * 2
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		surface.SetTextPos(rBarX, cooldownY - 15)
		surface.DrawText("R - Teleport")
		
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(rBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
		
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(rBarX, cooldownY, barWidth, barHeight)
		
		local teleportCooldown = math.max(0, self:GetNWFloat("NextTeleport", 0) - CurTime())
		
		if self.TeleportPreview then
			-- Preview mode - show different color and text
			surface.SetDrawColor(255, 255, 0, 255)
			surface.DrawRect(rBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(255, 255, 100, 255)
			surface.SetTextPos(rBarX, cooldownY + 10)
			surface.DrawText("PREVIEW")
		elseif teleportCooldown > 0 then
			local progress = 1 - (teleportCooldown / self.TeleportDelay)
			surface.SetDrawColor(100, 150, 255, 255)
			surface.DrawRect(rBarX, cooldownY, barWidth * progress, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 200, 255, 255)
			surface.SetTextPos(rBarX, cooldownY + 10)
			surface.DrawText(string.format("%.0fs", teleportCooldown))
		else
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(rBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 255, 150, 255)
			surface.SetTextPos(rBarX, cooldownY + 10)
			surface.DrawText("READY")
		end
		
		-- Celownik
		local x = ScrW() / 2.0
		local y = ScrH() / 2.0
		
		local scale = 0.3
		surface.SetDrawColor(150, 50, 150, 255)
		
		local gap = 5
		local length = gap + 20 * scale
		surface.DrawLine( x - length, y, x - gap, y )
		surface.DrawLine( x + length, y, x + gap, y )
		surface.DrawLine( x, y - length, x, y - gap )
		surface.DrawLine( x, y + length, x, y + gap )
		

		

	end
end



================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_3166.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_scp_base"
SWEP.PrintName = "SCP-3166"

SWEP.HoldType = "knife"

-- SCP-3166 Configuration
SWEP.AttackDelay = 2.0
SWEP.HitDistance = 80
SWEP.LasagnaTarget = nil
SWEP.SpeedBoost = false
SWEP.NextTargetSelect = 0

-- Models
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ShowWorldModel = false
SWEP.ViewModelFOV = 54
SWEP.UseHands = true

if SERVER then
	util.AddNetworkString("scp3166_target_selected")
	util.AddNetworkString("scp3166_target_killed")
	
	-- Hook to reset model when lasagna target dies or disconnects
	hook.Add("PlayerDeath", "SCP3166_ResetLasagnaModel", function(victim, inflictor, attacker)
		if victim.IsLasagnaTarget then
			victim.IsLasagnaTarget = false
			if victim.OriginalModel then
				victim:SetModel(victim.OriginalModel)
			end
			
			-- If lasagna target died but not by SCP-3166, select new target
			local killedBySCP3166 = false
			if IsValid(attacker) and attacker:IsPlayer() and attacker:GTeam() == TEAM_SCP then
				local weapon = attacker:GetActiveWeapon()
				if IsValid(weapon) and weapon:GetClass() == "weapon_scp_3166" then
					killedBySCP3166 = true
				end
			end
			
			-- If not killed by SCP-3166, find SCP-3166 and select new target
			if not killedBySCP3166 then
				for _, ply in pairs(player.GetAll()) do
					if IsValid(ply) and ply:GTeam() == TEAM_SCP then
						local weapon = ply:GetActiveWeapon()
						if IsValid(weapon) and weapon:GetClass() == "weapon_scp_3166" then
							timer.Simple(1, function()
								if IsValid(weapon) then
									weapon:SelectLasagnaTarget()
								end
							end)
							break
						end
					end
				end
			end
		end
	end)
	
	hook.Add("PlayerDisconnected", "SCP3166_ResetLasagnaModel", function(ply)
		if ply.IsLasagnaTarget then
			ply.IsLasagnaTarget = false
		end
	end)
	
	-- Hook to reset all lasagna targets when SCP-3166 dies
	hook.Add("PlayerDeath", "SCP3166_ResetAllLasagna", function(victim, inflictor, attacker)
		if IsValid(victim) and victim:GTeam() == TEAM_SCP then
			local weapon = victim:GetActiveWeapon()
			if IsValid(weapon) and weapon:GetClass() == "weapon_scp_3166" then
				-- SCP-3166 died, reset all lasagna targets
				for _, ply in pairs(player.GetAll()) do
					if IsValid(ply) and ply.IsLasagnaTarget then
						ply.IsLasagnaTarget = false
						if ply.OriginalModel then
							ply:SetModel(ply.OriginalModel)
						end
					end
				end
			end
		end
	end)
	
	-- Hook to reset lasagna targets when SCP-3166 changes team
	hook.Add("PlayerChangeTeam", "SCP3166_ResetOnTeamChange", function(ply, oldteam, newteam)
		if IsValid(ply) and oldteam == TEAM_SCP and newteam != TEAM_SCP then
			local weapon = ply:GetActiveWeapon()
			if IsValid(weapon) and weapon:GetClass() == "weapon_scp_3166" then
				-- SCP-3166 left SCP team, reset all lasagna targets
				for _, target in pairs(player.GetAll()) do
					if IsValid(target) and target.IsLasagnaTarget then
						target.IsLasagnaTarget = false
						if target.OriginalModel then
							target:SetModel(target.OriginalModel)
						end
					end
				end
			end
		end
	end)
end

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("breach/wep_3166")
	
	-- Receive target notifications
	net.Receive("scp3166_target_selected", function()
		local target = net.ReadEntity()
		-- Notification removed
	end)
	
	net.Receive("scp3166_target_killed", function()
		local killer = net.ReadEntity()
		if IsValid(killer) then
			chat.AddText(Color(255, 100, 0), "[SCP-3166] ", Color(255, 255, 255), "Lasagna target eliminated! SCP-3166 grows stronger!")
		end
	end)
end

-- Custom model elements for Garfield
-- No custom view model elements needed for claw attacks

function SWEP:Initialize()
	self:InitializeLanguage("SCP_3166")
	self:SetHoldType(self.HoldType)
	
	self.NextAttack = 0
	
	-- Select initial lasagna target
	if SERVER then
		timer.Simple(1, function()
			if IsValid(self) and IsValid(self.Owner) then
				self:SelectLasagnaTarget()
			end
		end)
	end
end

function SWEP:SelectLasagnaTarget()
	if not SERVER then return end
	
	-- Reset previous target's model
	if IsValid(self.LasagnaTarget) and self.LasagnaTarget.IsLasagnaTarget then
		self.LasagnaTarget.IsLasagnaTarget = false
		self.LasagnaTarget.OriginalModel = self.LasagnaTarget.OriginalModel or "models/player/Group01/male_02.mdl"
		self.LasagnaTarget:SetModel(self.LasagnaTarget.OriginalModel)
	end
	
	local possibleTargets = {}
	for _, ply in pairs(player.GetAll()) do
					if IsValid(ply) and ply:Alive() and (ply:GTeam() != TEAM_SCP or ply:GetNClass() == ROLES.ROLE_SCP035) and ply:GTeam() != TEAM_SPEC then
			table.insert(possibleTargets, ply)
		end
	end
	
	if #possibleTargets > 0 then
		local target = possibleTargets[math.random(#possibleTargets)]
		
		-- Store original model before changing
		target.OriginalModel = target:GetModel()
		
		self.LasagnaTarget = target
		
		-- Change target's model
		target:SetModel("models/cktheamazingfrog/player/lasagna/lasagna.mdl")
		target.IsLasagnaTarget = true
	end
end

function SWEP:ClawAttack()
	if not SERVER then return end
	
	-- Simple trace for claw attack
	local tr = util.TraceHull({
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.HitDistance,
		filter = self.Owner,
		mins = Vector(-16, -16, -16),
		maxs = Vector(16, 16, 16),
		mask = MASK_SHOT_HULL
	})
	

	
	-- Deal damage if we hit something
	if tr.Hit and IsValid(tr.Entity) and (tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:Health() > 0) then
		-- Don't attack other SCPs
		if tr.Entity:IsPlayer() and tr.Entity:GTeam() == TEAM_SCP then
			return
		end
		local damage = 50
		local isLasagnaTarget = tr.Entity:IsPlayer() and tr.Entity == self.LasagnaTarget and tr.Entity.IsLasagnaTarget
		
		-- Double damage to lasagna target
		if isLasagnaTarget then
			damage = 100
		end
		
		-- Check if this will kill the lasagna target
		if isLasagnaTarget and tr.Entity:Health() <= damage then
			-- Grant bonuses to SCP-3166: +500 HP and +25% speed
			self.Owner:SetHealth(math.min(self.Owner:GetMaxHealth(), self.Owner:Health() + 500))
			
			-- Speed boost +25%
			local currentWalk = self.Owner:GetWalkSpeed()
			local currentRun = self.Owner:GetRunSpeed()
			self.Owner:SetWalkSpeed(currentWalk * 1.25)
			self.Owner:SetRunSpeed(currentRun * 1.25)
			
			-- Reset target model and flag
			tr.Entity.IsLasagnaTarget = false
			if tr.Entity.OriginalModel then
				tr.Entity:SetModel(tr.Entity.OriginalModel)
			end
			self.LasagnaTarget = nil
			

			
			-- Give bonus EXP
			self.Owner:AddExp(500, true)
			
			-- Select new lasagna target after killing current one
			timer.Simple(1, function()
				if IsValid(self) and IsValid(self.Owner) then
					self:SelectLasagnaTarget()
				end
			end)
		end
		
		-- Create damage
		local dmginfo = DamageInfo()
		dmginfo:SetDamage(damage)
		dmginfo:SetAttacker(self.Owner)
		dmginfo:SetInflictor(self)
		dmginfo:SetDamageType(DMG_SLASH)
		dmginfo:SetDamageForce(self.Owner:GetAimVector() * 1000)
		tr.Entity:TakeDamageInfo(dmginfo)
		
		-- Give normal EXP
		if tr.Entity:IsPlayer() then
			self.Owner:AddExp(100, true)
		end
	end
end

function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextAttack > CurTime() then return end
	
	self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
	self:SetNextPrimaryFire(CurTime() + self.AttackDelay)
	self:SetNextSecondaryFire(CurTime() + self.AttackDelay)
	
	self:ClawAttack()
	self.Owner:SetAnimation(PLAYER_ATTACK1)
	
	self.NextAttack = CurTime() + self.AttackDelay
end

function SWEP:SecondaryAttack()
	-- Manual target selection (only if no current target)
	if SERVER and not IsValid(self.LasagnaTarget) then
		self:SelectLasagnaTarget()
	end
end

function SWEP:Reload()
	-- Garfield taunt
	if CurTime() < (self.TauntCooldown or 0) then return end
	

	
	self.TauntCooldown = CurTime() + 10
end

function SWEP:Think()
	-- Sync cooldown with client
	if SERVER then
		self:SetNWFloat("NextAttack", self.NextAttack)
		
		-- Force lasagna model on target (check every 0.5 seconds)
		self.NextModelCheck = self.NextModelCheck or 0
		if self.NextModelCheck <= CurTime() then
			self.NextModelCheck = CurTime() + 0.5
			
			if IsValid(self.LasagnaTarget) and self.LasagnaTarget:Alive() and self.LasagnaTarget.IsLasagnaTarget then
				local correctModel = "models/cktheamazingfrog/player/lasagna/lasagna.mdl"
				if self.LasagnaTarget:GetModel() != correctModel then
					self.LasagnaTarget:SetModel(correctModel)
				end
			end
		end
	end
end

function SWEP:Holster()
	return true
end

function SWEP:OnRemove()
	return true
end

if CLIENT then
	function SWEP:DrawHUD()
		if disablehud == true then return end
		
		local ply = LocalPlayer()
		if not IsValid(ply) then return end
		
		local centerX = ScrW() / 2
		local centerY = ScrH() / 2
		local hudY = ScrH() - 150
		
		local hudWidth = 500
		local hudHeight = 120
		local hudX = centerX - hudWidth / 2
		
		-- Tło HUD
		surface.SetDrawColor(20, 20, 20, 180)
		surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Obramowanie
		surface.SetDrawColor(100, 100, 100, 200)
		surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Linia dekoracyjna
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
		
		-- Tytuł SCP
		surface.SetFont("DermaLarge")
		surface.SetTextColor(200, 200, 200, 255)
		local titleW, titleH = surface.GetTextSize("SCP-3166")
		surface.SetTextPos(centerX - titleW / 2, hudY + 10)
		surface.DrawText("SCP-3166")
		

		
		-- Cooldowny
		local cooldownY = hudY + 60
		local barWidth = 140
		local barHeight = 8
		local spacing = 20
		local totalWidth = barWidth -- Tylko 1 pasek
		local startX = centerX - totalWidth / 2
		
		-- LMB - Claw Attack
		local lmbBarX = startX
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		surface.SetTextPos(lmbBarX, cooldownY - 15)
		surface.DrawText("LMB - Claw Attack")
		
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
		
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		local attackCooldown = math.max(0, self:GetNWFloat("NextAttack", 0) - CurTime())
		
		if attackCooldown > 0 then
			local progress = 1 - (attackCooldown / self.AttackDelay)
			surface.SetDrawColor(255, 165, 0, 255) -- Orange dla Garfielda
			surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(255, 200, 150, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText(string.format("%.1fs", attackCooldown))
		else
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 255, 150, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText("READY")
		end
		

		
		-- Celownik
		local x = ScrW() / 2.0
		local y = ScrH() / 2.0
		
		local scale = 0.3
		local color = Color(255, 165, 0, 255) -- Orange dla Garfielda
		surface.SetDrawColor(color)
		
		local gap = 5
		local length = gap + 20 * scale
		surface.DrawLine(x - length, y, x - gap, y)
		surface.DrawLine(x + length, y, x + gap, y)
		surface.DrawLine(x, y - length, x, y - gap)
		surface.DrawLine(x, y + length, x, y + gap)
	end

end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_3199.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_scp_base"
SWEP.PrintName = "SCP-3199"

local BiteSounds = {
    "SCP3199Bite1",
    "SCP3199Bite2",
    "SCP3199Bite3",
    "SCP3199Bite4"
}

local VomitSound = Sound("SCP3199Vomit")
local RoarSound = Sound("SCP3199scream")
local XplodeSound = Sound("SCP3199Corrosion")

SWEP.Category = "SCP Sweps"
SWEP.Instructions = "Primary: Bite\nSecondary: Corrosive Spit \nReload: Roar"
SWEP.Author = "PapuMaster and Bombón Asesino"
SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Slot = 3
SWEP.SlotPos = 1

SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true

SWEP.ViewModel = "" 
SWEP.WorldModel = ""
SWEP.HoldType = "knife"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Range = 72

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

function SWEP:Initialize()
    self:InitializeLanguage("SCP_3199")
    self:SetHoldType(self.HoldType)
end

function SWEP:PrimaryAttack()
    if CurTime() < self:GetNextPrimaryFire() then return end
    self:SetNextPrimaryFire(CurTime() + 0.8)
    
    local ply = self.Owner
    if not IsValid(ply) then return end
    
    ply:DoAnimationEvent(ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE)
    ply:EmitSound(BiteSounds[math.random(#BiteSounds)])

    local tr = util.TraceHull({
        start = ply:GetShootPos(),
        endpos = ply:GetShootPos() + ply:GetAimVector() * self.Primary.Range,
        filter = ply,
        mins = Vector(-15, -15, -15),
        maxs = Vector(15, 15, 15)
    })

    local HitSounds = {
        "npc/fast_zombie/claw_strike1.wav",
        "npc/fast_zombie/claw_strike2.wav",
        "npc/fast_zombie/claw_strike3.wav",
    }
    
    if tr.Hit and IsValid(tr.Entity) then
        if SERVER then
            -- Don't damage other SCPs
            if tr.Entity:IsPlayer() then
                		if tr.Entity:GTeam() ~= TEAM_SCP or tr.Entity:GetNClass() == ROLES.ROLE_SCP035 then
                    local dmg = DamageInfo()
                    dmg:SetDamage(math.random(54, 62))
                    dmg:SetAttacker(ply)
                    dmg:SetInflictor(self)
                    dmg:SetDamageType(DMG_SLASH)
                    tr.Entity:TakeDamageInfo(dmg)
                    ply:ViewPunch(Angle(math.random(-3, 1), math.random(-3, 2), 0))
                end
            else
                -- Use standard SCP damage system for non-players
                self:SCPDamageEvent(tr.Entity, math.random(54, 62))
                ply:ViewPunch(Angle(math.random(-3, 1), math.random(-3, 2), 0))
            end
            
            if tr.Entity:IsPlayer() or tr.Entity:IsNPC() then
                self.Owner:EmitSound(HitSounds[math.random(#HitSounds)], 75, math.random(115, 120), 0.5)
            end
        end
    end
end

function SWEP:DealAoeDamage(dmgtype, dmgamt, src, range)
    local dmg = DamageInfo()
    dmg:SetDamageType(dmgtype)
    dmg:SetAttacker(self.Owner)
    dmg:SetInflictor(self)
    dmg:SetDamage(dmgamt)

    if SERVER then
        for _, ent in pairs(ents.FindInSphere(src, range)) do
            if ent ~= self.Owner then
                -- Don't damage other SCPs
                if ent:IsPlayer() then
                    		if ent:GTeam() ~= TEAM_SCP or ent:GetNClass() == ROLES.ROLE_SCP035 then
                        ent:TakeDamageInfo(dmg)
                        ent:ScreenFade( SCREENFADE.IN, Color( 125, 145, 50, 128 ), 1, 0 )
                    end
                else
                    -- Use standard SCP damage system for non-players
                    self:SCPDamageEvent(ent, dmgamt)
                end
            end
        end
    end
end

function SWEP:CorroSpit(dmg, decay, acc)
    if SERVER then
        local ent = ents.Create("prop_physics")
        if not IsValid(ent) then return end
        ent:SetModel("models/grub_nugget_large.mdl")
        ent:SetMaterial("models/spitball/spitball")
        ent:SetModelScale(1.2)
        ent:SetPos(self.Owner:EyePos() + self.Owner:GetAimVector() * 20)
        ent:SetAngles(self.Owner:EyeAngles())
        ent:Spawn()

        local phys = ent:GetPhysicsObject()
        if not IsValid(phys) then ent:Remove() return end
        phys:ApplyForceCenter(self.Owner:GetAimVector() * 3000 + VectorRand() * acc)
       
        ParticleEffectAttach("corro_blob", 1, ent, 1)

        ent:AddCallback("PhysicsCollide", function()
            if not IsValid(self) or not IsValid(self.Owner) then return end
            local pos = ent:GetPos()
            self:DealAoeDamage(DMG_NERVEGAS, math.random(22, 24), pos, 60)
            ParticleEffect("eml_generic_crsv", pos, Angle(0, 0, 0), self.Owner)
            ent:EmitSound(XplodeSound)
            ent:Fire("break", "", 0.01)
        end)

        timer.Simple(3, function()
            if IsValid(ent) then
                if not IsValid(self) or not IsValid(self.Owner) then return end
                local pos = ent:GetPos()
                self:DealAoeDamage(DMG_NERVEGAS, math.random(22, 24), pos, 60)
                ParticleEffect("eml_generic_crsv", pos, Angle(0, 0, 0), self.Owner)
                ent:EmitSound(XplodeSound)
                ent:Fire("break", "", 0.01)
            end
        end)
        ent:SetPhysicsAttacker(self.Owner, decay)
        SafeRemoveEntityDelayed(ent, decay)
    end
end

function SWEP:SecondaryAttack()
    if CurTime() < self:GetNextSecondaryFire() then return end
    self:SetNextSecondaryFire(CurTime() + 30)
    self:SetNextPrimaryFire(CurTime() + 1)

    local ply = self.Owner
    if not IsValid(ply) then return end

    ply:EmitSound(VomitSound)
    ply:DoAnimationEvent(ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE)
    ply:ViewPunch(Angle(math.random(-2, 2), 0, 0))

    if SERVER then
        self:CorroSpit(25, 10, 1)
    end
end

function SWEP:Reload()
    if CurTime() < (self.NextRoar or 0) then return end
    self.NextRoar = CurTime() + 60 

    local ply = self.Owner

    if not IsValid(ply) then return end

    ply:DoAnimationEvent(ACT_GMOD_TAUNT_LAUGH)

    if SERVER then
        ply:ViewPunch(Angle(math.random(-1.5, -2), 0, 0))

        ply:Freeze(true)
        ply:EmitSound(RoarSound)
        self.IsSCREAMING  = true 

        -- Find closest non-SCP player and damage them
        local closestPlayer = nil
        local closestDistance = math.huge
        
        for _, target in pairs(player.GetAll()) do
            		if IsValid(target) and target:Alive() and target ~= ply and (target:GTeam() ~= TEAM_SCP or target:GetNClass() == ROLES.ROLE_SCP035) and target:GTeam() ~= TEAM_SPEC then
                local distance = ply:GetPos():DistToSqr(target:GetPos())
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = target
                end
            end
        end
        
        if IsValid(closestPlayer) then
            local dmg = DamageInfo()
            dmg:SetDamage(1)
            dmg:SetAttacker(ply)
            dmg:SetInflictor(self)
            dmg:SetDamageType(DMG_SONIC)
            closestPlayer:TakeDamageInfo(dmg)
        end

        timer.Simple(2.2, function()
                ply:Freeze(false)
                ply:ViewPunch(Angle(math.random(1, 1.5), 0, 0))
                self.IsSCREAMING = false
        end)
    end
end

-- HUD w stylu SCP-069
function SWEP:DrawHUD()
    if disablehud == true then return end
    
    local ply = LocalPlayer()
    if not IsValid(ply) then return end
    
    local centerX = ScrW() / 2
    local centerY = ScrH() / 2
    local hudY = ScrH() - 150
    
    local hudWidth = 500
    local hudHeight = 120
    local hudX = centerX - hudWidth / 2
    
    -- Tło HUD
    surface.SetDrawColor(20, 20, 20, 180)
    surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
    
    -- Obramowanie
    surface.SetDrawColor(100, 100, 100, 200)
    surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
    
    -- Linia dekoracyjna
    surface.SetDrawColor(150, 150, 150, 255)
    surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
    
    -- Tytuł SCP
    surface.SetFont("DermaLarge")
    surface.SetTextColor(200, 200, 200, 255)
    local titleW, titleH = surface.GetTextSize("SCP-3199")
    surface.SetTextPos(centerX - titleW / 2, hudY + 10)
    surface.DrawText("SCP-3199")
    
    -- Cooldowny
    local cooldownY = hudY + 60
    local barWidth = 140
    local barHeight = 8
    local spacing = 20
    local totalWidth = barWidth * 3 + spacing * 2
    local startX = centerX - totalWidth / 2
    
    -- LMB (Bite) Cooldown
    local lmbBarX = startX
    surface.SetTextColor(200, 200, 200, 255)
    surface.SetFont("DermaDefaultBold")
    surface.SetTextPos(lmbBarX, cooldownY - 15)
    surface.DrawText("LMB - Bite")
    
    surface.SetDrawColor(150, 150, 150, 255)
    surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
    
    surface.SetDrawColor(40, 40, 40, 200)
    surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
    
    local biteCooldown = 0
    if self:GetNextPrimaryFire() > CurTime() then
        biteCooldown = self:GetNextPrimaryFire() - CurTime()
    end
    
    if biteCooldown > 0 then
        local progress = 1 - (biteCooldown / 0.8)
        surface.SetDrawColor(255, 100, 100, 255)
        surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
        
        surface.SetFont("DermaDefault")
        surface.SetTextColor(255, 150, 150, 255)
        surface.SetTextPos(lmbBarX, cooldownY + 10)
        surface.DrawText(string.format("%.1fs", biteCooldown))
    else
        surface.SetDrawColor(100, 255, 100, 255)
        surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
        
        surface.SetFont("DermaDefault")
        surface.SetTextColor(150, 255, 150, 255)
        surface.SetTextPos(lmbBarX, cooldownY + 10)
        surface.DrawText("READY")
    end
    
    -- RMB (Corrosive Spit) Cooldown
    local rmbBarX = startX + barWidth + spacing
    surface.SetTextColor(200, 200, 200, 255)
    surface.SetFont("DermaDefaultBold")
    surface.SetTextPos(rmbBarX, cooldownY - 15)
    surface.DrawText("RMB - Spit")
    
    surface.SetDrawColor(150, 150, 150, 255)
    surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
    
    surface.SetDrawColor(40, 40, 40, 200)
    surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
    
    local spitCooldown = 0
    if self:GetNextSecondaryFire() > CurTime() then
        spitCooldown = self:GetNextSecondaryFire() - CurTime()
    end
    
    if spitCooldown > 0 then
        local progress = 1 - (spitCooldown / 30)
        surface.SetDrawColor(125, 145, 50, 255)
        surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
        
        surface.SetFont("DermaDefault")
        surface.SetTextColor(150, 200, 100, 255)
        surface.SetTextPos(rmbBarX, cooldownY + 10)
        surface.DrawText(string.format("%.0fs", spitCooldown))
    else
        surface.SetDrawColor(100, 255, 100, 255)
        surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
        
        surface.SetFont("DermaDefault")
        surface.SetTextColor(150, 255, 150, 255)
        surface.SetTextPos(rmbBarX, cooldownY + 10)
        surface.DrawText("READY")
    end
    
    -- R (Roar) Cooldown
    local roarBarX = startX + (barWidth + spacing) * 2
    surface.SetTextColor(200, 200, 200, 255)
    surface.SetFont("DermaDefaultBold")
    surface.SetTextPos(roarBarX, cooldownY - 15)
    surface.DrawText("R - Roar")
    
    surface.SetDrawColor(150, 150, 150, 255)
    surface.DrawOutlinedRect(roarBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
    
    surface.SetDrawColor(40, 40, 40, 200)
    surface.DrawRect(roarBarX, cooldownY, barWidth, barHeight)
    
    local roarCooldown = 0
    if self.NextRoar and self.NextRoar > CurTime() then
        roarCooldown = self.NextRoar - CurTime()
    end
    
    if roarCooldown > 0 then
        local progress = 1 - (roarCooldown / 6)
        surface.SetDrawColor(255, 165, 0, 255)
        surface.DrawRect(roarBarX, cooldownY, barWidth * progress, barHeight)
        
        surface.SetFont("DermaDefault")
        surface.SetTextColor(255, 200, 100, 255)
        surface.SetTextPos(roarBarX, cooldownY + 10)
        surface.DrawText(string.format("%.0fs", roarCooldown))
    else
        surface.SetDrawColor(100, 255, 100, 255)
        surface.DrawRect(roarBarX, cooldownY, barWidth, barHeight)
        
        surface.SetFont("DermaDefault")
        surface.SetTextColor(150, 255, 150, 255)
        surface.SetTextPos(roarBarX, cooldownY + 10)
        surface.DrawText("READY")
    end
end

function SWEP:Holster()
    if SERVER and IsValid(self.Owner) then
        if self.IsSCREAMING then return end
    end
    return true
end

function SWEP:OnRemove()
    -- Cleanup jeśli potrzebny
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_457.lua
================================================
AddCSLuaFile()

SWEP.Base 		= "weapon_scp_base"
SWEP.PrintName	= "SCP-457"

SWEP.HoldType	= "normal"

if CLIENT then
	SWEP.WepSelectIcon 	= surface.GetTextureID("breach/wep_457")
end

-- Właściwości
SWEP.droppable = false

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_457" )
	self:SetHoldType(self.HoldType)
end

-- Zmienne
SWEP.NextAttackW = 0
SWEP.AttackDelay = 0.5
SWEP.NextSpecial = 0
SWEP.SpecialDelay = 20
SWEP.NextUltimate = 0
SWEP.UltimateDelay = 45
SWEP.FireWallDuration = 8

SWEP.LastDMG = 0
SWEP.NextBurn = 0
function SWEP:Think()
	if SERVER then
		-- Obrażenia w wodzie
		if self.Owner:WaterLevel() > 0 then
			if self.LastDMG < CurTime() and self.Owner:Health() > 1 then
				self.LastDMG = CurTime() + 0.1
				self.Owner:SetHealth( math.max( 1, self.Owner:Health() - 20 ) )
			end
		else
			-- Pasywne palenie w małym zasięgu
			if self.NextBurn < CurTime() then
				self.NextBurn = CurTime() + 0.5
				
				for k,v in pairs(ents.FindInSphere( self.Owner:GetPos(), 125 )) do
					if v:IsPlayer() and v:Alive() then
						if v:GTeam() != TEAM_SCP and v:GTeam() != TEAM_SPEC then
							v:Ignite(2, 0)
							
							-- Regeneracja
							if self.Owner.nextexp == nil then self.Owner.nextexp = 0 end
							if self.Owner.nextexp < CurTime() then
								self.Owner:SetHealth( math.Clamp( self.Owner:Health() + 20, 0, self.Owner:GetMaxHealth() ) )
								self.Owner:AddExp(5)
								self.Owner.nextexp = CurTime() + 1
							end
						end
					end
				end
			end
		end
	end
end

-- LMB - Podstawowy atak ogniem
function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextAttackW > CurTime() then return end
	
	self.NextAttackW = CurTime() + self.AttackDelay
	self:SetNWFloat("NextAttackW", self.NextAttackW)
	
	if SERVER then
		local ent = nil
		local tr = util.TraceHull( {
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + ( self.Owner:GetAimVector() * 100 ),
			filter = self.Owner,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			mask = MASK_SHOT_HULL
		} )
		ent = tr.Entity
		if IsValid(ent) then
			if ent:IsPlayer() then
				if ent:GTeam() == TEAM_SCP and ent:GetNClass() != ROLES.ROLE_SCP035 then return end
				if ent:GTeam() == TEAM_SPEC then return end
				ent:Ignite(5, 0)
				ent:TakeDamage(35, self.Owner, self)
				self.Owner:AddExp(15, true)
			else
				self:SCPDamageEvent( ent, 10 )
			end
		end
	end
end

-- RMB - Rzut kulą ognia
function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextSpecial > CurTime() then return end
	
	self.NextSpecial = CurTime() + self.SpecialDelay
	self:SetNWFloat("NextSpecial", self.NextSpecial)
	
	if SERVER then
		-- Stwórz kulę ognia
		local fireball = ents.Create("prop_physics")
		if IsValid(fireball) then
			fireball:SetModel("models/props_junk/flare.mdl")
			fireball:SetPos(self.Owner:GetShootPos() + self.Owner:GetAimVector() * 40)
			fireball:SetAngles(self.Owner:EyeAngles())
			fireball:SetOwner(self.Owner)
			fireball:Spawn()
			fireball:SetColor(Color(255, 100, 0))
			fireball:SetMaterial("models/debug/debugwhite")
			fireball:SetModelScale(2)
			fireball:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
			
			-- Nadaj prędkość
			local phys = fireball:GetPhysicsObject()
			if IsValid(phys) then
				phys:SetVelocity(self.Owner:GetAimVector() * 1500)
				phys:SetMass(1)
				phys:EnableGravity(false)
			end
			
			-- Efekt ognia
			local fire = ents.Create("env_fire")
			fire:SetPos(fireball:GetPos())
			fire:SetParent(fireball)
			fire:SetKeyValue("health", "5")
			fire:SetKeyValue("firesize", "64")
			fire:Spawn()
			fire:Fire("StartFire")
			
			-- Funkcja eksplozji
			local function ExplodeFireball()
				if not IsValid(fireball) then return end
				
				-- Eksplozja
				local effectdata = EffectData()
				effectdata:SetOrigin(fireball:GetPos())
				effectdata:SetScale(2)
				util.Effect("Explosion", effectdata)
				
				-- Zadaj obrażenia i podpal
				for _, ent in pairs(ents.FindInSphere(fireball:GetPos(), 200)) do
					if ent:IsPlayer() and ent:GTeam() != TEAM_SCP and ent:GTeam() != TEAM_SPEC then
						ent:TakeDamage(50, self.Owner, self)
						ent:Ignite(4, 0)
					end
				end
				
				-- Dźwięk
				fireball:EmitSound("ambient/explosions/explode_4.wav", 100, 120)
				
				-- Usuń
				if IsValid(fire) then fire:Remove() end
				fireball:Remove()
			end
			
			-- Eksploduj przy kontakcie
			fireball:AddCallback("PhysicsCollide", function(ent, data)
				if data.HitEntity != self.Owner then
					ExplodeFireball()
				end
			end)
			
			-- Eksploduj po czasie
			timer.Simple(3, ExplodeFireball)
		end
		
		-- Dźwięk wystrzału
		self.Owner:EmitSound("weapons/flaregun/fire.wav", 90, 80)
	end
end

-- R - Ściana ognia
function SWEP:Reload()
	if not IsFirstTimePredicted() then return end
	if self.NextUltimate > CurTime() then return end
	
	self.NextUltimate = CurTime() + self.UltimateDelay
	
	if SERVER then
		self:SetNWFloat("NextUltimate", self.NextUltimate)
		
		-- Stwórz ścianę ognia przed sobą
		local startPos = self.Owner:GetPos() + self.Owner:GetAimVector() * 100
		local angles = self.Owner:EyeAngles()
		angles.p = 0
		local right = angles:Right()
		
		-- Stwórz linię ognia
		for i = -5, 5 do
			local firePos = startPos + right * (i * 40)
			
			-- Sprawdź czy jest podłoże
			local tr = util.TraceLine({
				start = firePos + Vector(0, 0, 50),
				endpos = firePos - Vector(0, 0, 100),
				filter = self.Owner
			})
			
			if tr.Hit then
				-- Stwórz ogień
				local fire = ents.Create("env_fire")
				if IsValid(fire) then
					fire:SetPos(tr.HitPos)
					fire:SetKeyValue("health", tostring(self.FireWallDuration))
					fire:SetKeyValue("firesize", "128")
					fire:SetKeyValue("fireattack", "3")
					fire:SetKeyValue("damagescale", "2")
					fire:Spawn()
					fire:Fire("StartFire")
					
					-- Zadawaj obrażenia co sekundę
					local burnTime = CurTime() + self.FireWallDuration
					timer.Create("FireWall_" .. fire:EntIndex(), 0.5, self.FireWallDuration * 2, function()
						if not IsValid(fire) then return end
						
						for _, ent in pairs(ents.FindInSphere(fire:GetPos(), 80)) do
							if ent:IsPlayer() and ent:GTeam() != TEAM_SCP and ent:GTeam() != TEAM_SPEC then
								ent:TakeDamage(15, IsValid(self.Owner) and self.Owner or fire, fire)
								ent:Ignite(2, 0)
							end
						end
						
						if CurTime() >= burnTime then
							fire:Remove()
						end
					end)
				end
			end
		end
		
		-- Dźwięk
		self.Owner:EmitSound("ambient/fire/ignite.wav", 110, 70)
		
		-- Efekt wizualny
		local effectdata = EffectData()
		effectdata:SetOrigin(startPos)
		effectdata:SetNormal(self.Owner:GetAimVector())
		effectdata:SetScale(3)
		util.Effect("ManhackSparks", effectdata)
	end
end

function SWEP:DrawHUD()
	if disablehud == true then return end
	if self.Owner:Team() == TEAM_SPEC then return end
	
	self:DrawSCPHUD()
end

function SWEP:DrawSCPHUD()
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-457")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-457")
	
	-- Cooldowny
	local cooldownY = hudY + 60
	local barWidth = 140
	local barHeight = 8
	local spacing = 20
	local totalWidth = barWidth * 3 + spacing * 2
	local startX = centerX - totalWidth / 2
	
	-- LMB Cooldown
	local lmbBarX = startX
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lmbBarX, cooldownY - 15)
	surface.DrawText("LMB - Burn")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
	
	local attackCooldown = 0
	local nextAttack = self:GetNWFloat("NextAttackW", 0)
	if nextAttack > CurTime() then
		attackCooldown = nextAttack - CurTime()
	end
	
	if attackCooldown > 0 then
		local progress = 1 - (attackCooldown / self.AttackDelay)
		surface.SetDrawColor(255, 100, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", attackCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- RMB Cooldown
	local rmbBarX = startX + barWidth + spacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rmbBarX, cooldownY - 15)
	surface.DrawText("RMB - Fireball")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
	
	local specialCooldown = 0
	local nextSpecial = self:GetNWFloat("NextSpecial", 0)
	if nextSpecial > CurTime() then
		specialCooldown = nextSpecial - CurTime()
	end
	
	if specialCooldown > 0 then
		local progress = 1 - (specialCooldown / self.SpecialDelay)
		surface.SetDrawColor(255, 255, 0, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", specialCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- R Cooldown
	local rBarX = startX + (barWidth + spacing) * 2
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rBarX, cooldownY - 15)
	surface.DrawText("R - Fire Wall")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rBarX, cooldownY, barWidth, barHeight)
	
	local ultimateCooldown = 0
	local nextUltimate = self:GetNWFloat("NextUltimate", 0)
	if nextUltimate > CurTime() then
		ultimateCooldown = nextUltimate - CurTime()
	end
	
	if ultimateCooldown > 0 then
		local progress = 1 - (ultimateCooldown / self.UltimateDelay)
		surface.SetDrawColor(148, 0, 211, 255)
		surface.DrawRect(rBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(200, 150, 255, 255)
		surface.SetTextPos(rBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", ultimateCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(rBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- Celownik
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	
	local scale = 0.3
	surface.SetDrawColor(255, 0, 0, 255)
	
	local gap = 5
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_617.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_scp_base"
SWEP.PrintName = "SCP-617"

SWEP.HoldType = "normal"

-- SCP-617 Configuration
SWEP.TouchRange = 20
SWEP.StoneDuration = 4 -- Seconds before crumbling
SWEP.CheckDelay = 0.1 -- How often to check for nearby players

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("breach/wep_617")
end

-- Clean up stone effects when player dies
if SERVER then
	hook.Add("PlayerDeath", "SCP617_CleanupStone", function(victim, inflictor, attacker)
		if IsValid(victim) and victim.IsBeingStoned then
			victim:Freeze(false)
			if victim.OriginalMaterial then
				victim:SetMaterial(victim.OriginalMaterial)
			else
				victim:SetMaterial("")
			end
			victim.IsBeingStoned = false
			victim.StoneEndTime = nil
			victim.OriginalMaterial = nil
			timer.Remove("SCP617_Stone_" .. victim:SteamID64())
		end
	end)
end

function SWEP:Initialize()
	self:InitializeLanguage("SCP_617")
	self:SetHoldType(self.HoldType)
	
	self.NextCheck = 0
end

function SWEP:PrimaryAttack()
	-- No primary attack
end

function SWEP:SecondaryAttack()
	-- No secondary attack
end

function SWEP:Reload()
	-- No reload
end

function SWEP:Think()
	if SERVER then
		-- Check for players touching SCP-617
		if self.NextCheck <= CurTime() then
			self.NextCheck = CurTime() + self.CheckDelay
			self:CheckForTouch()
		end
		
		-- Clean up any expired stone effects
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply.IsBeingStoned and ply.StoneEndTime then
				if ply.StoneEndTime <= CurTime() then
					self:CrumblePlayer(ply)
				end
			end
		end
	end
end

function SWEP:CheckForTouch()
	if not SERVER then return end
	if not IsValid(self.Owner) then return end
	
	-- Find all players near SCP-617
	for _, ply in pairs(player.GetAll()) do
		if IsValid(ply) and ply != self.Owner and ply:Alive() then
			if (ply:GTeam() != TEAM_SCP or ply:GetNClass() == ROLES.ROLE_SCP035) and ply:GTeam() != TEAM_SPEC then
				local dist = ply:GetPos():Distance(self.Owner:GetPos())
				if dist <= self.TouchRange then
					-- Don't affect already stoned players
					if not ply.IsBeingStoned then
						self:StonePlayer(ply)
					end
				end
			end
		end
	end
end

function SWEP:StonePlayer(target)
	if not SERVER then return end
	if not IsValid(target) then return end
	
	-- Mark as being stoned
	target.IsBeingStoned = true
	target.StoneEndTime = CurTime() + self.StoneDuration
	
	-- Store original material
	target.OriginalMaterial = target:GetMaterial()
	
	-- Apply stone material
	target:SetMaterial("models/props_wasteland/rockcliff02b")
	
	-- Freeze the player
	target:Freeze(true)
	
	-- Create timer for crumbling
	timer.Create("SCP617_Stone_" .. target:SteamID64(), self.StoneDuration, 1, function()
		if IsValid(target) and target.IsBeingStoned then
			self:CrumblePlayer(target)
		end
	end)
	
	-- Sound effect
	target:EmitSound("physics/concrete/concrete_break" .. math.random(2,3) .. ".wav", 75, 100)
	
	-- Message to player
	target:PrintMessage(HUD_PRINTCENTER, "You are turning to stone!")
	
	-- Give EXP to SCP
	if IsValid(self.Owner) then
		self.Owner:AddExp(150, true)
	end
end

function SWEP:CrumblePlayer(target)
	if not SERVER then return end
	if not IsValid(target) then return end
	
	local pos = target:GetPos()
	local ang = target:GetAngles()
	
	-- No visual effects - just stone crumbling sounds
	
	-- Crumbling sound
	target:EmitSound("physics/concrete/concrete_break" .. math.random(2,3) .. ".wav", 85, 80)
	target:EmitSound("ambient/materials/rock" .. math.random(1,5) .. ".wav", 80, 90)
	
	-- Clean up BEFORE killing player
	target.IsBeingStoned = false
	target.StoneEndTime = nil
	target:Freeze(false)
	if target.OriginalMaterial then
		target:SetMaterial(target.OriginalMaterial)
	else
		target:SetMaterial("")
	end
	target.OriginalMaterial = nil
	
	-- Kill the player
	local dmginfo = DamageInfo()
	dmginfo:SetDamage(target:Health() + 100)
	dmginfo:SetAttacker(self.Owner)
	dmginfo:SetInflictor(self)
	dmginfo:SetDamageType(DMG_CRUSH)
	target:TakeDamageInfo(dmginfo)
	
	-- Give bonus EXP for successful kill
	if IsValid(self.Owner) then
		self.Owner:AddExp(200, true)
	end
end

function SWEP:Holster()
	return true
end

function SWEP:OnRemove()
	-- Clean up any ongoing stone effects
	if SERVER then
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply.IsBeingStoned then
				ply:Freeze(false)
				if ply.OriginalMaterial then
					ply:SetMaterial(ply.OriginalMaterial)
				else
					ply:SetMaterial("")
				end
				ply.IsBeingStoned = false
				ply.StoneEndTime = nil
				ply.OriginalMaterial = nil
				timer.Remove("SCP617_Stone_" .. ply:SteamID64())
			end
		end
	end
	return true
end

if CLIENT then
	function SWEP:DrawHUD()
		-- No HUD needed - SCP-617 is fully passive
		return
	end
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_682.lua
================================================
AddCSLuaFile()

SWEP.Base 			= "weapon_scp_base"
SWEP.PrintName		= "SCP-682"

SWEP.HoldType			= "normal"

SWEP.Roar 				= "scp/682/roar.ogg"

SWEP.DrawCrosshair 			= true

--SWEP.SantasHatPositionOffset = Vector( 16, -5, 3.5 )
--SWEP.SantasHatAngleOffset = Angle( -10, 180, -20 )

function SWEP:Deploy()
	self:HideModels()

	if SERVER and !self.basespeed then
		self.basespeed = self.Owner:GetWalkSpeed()
		self.furyspeed = self.Owner:GetRunSpeed()
		self.Owner:SetRunSpeed( self.basespeed )
	end

	//self.Owner:SetModelScale( 0.75 )
end

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_682" )

	self:SetHoldType(self.HoldType)
	/*if CLIENT then
		if !self.SantasHat then
			self.SantasHat = ClientsideModel( "models/cloud/kn_santahat.mdl" )
			self.SantasHat:SetModelScale( 1.8 )
			self.SantasHat:SetNoDraw( true )
		end
	end*/
end

function SWEP:OnRemove()
	//if IsValid( self.Owner ) then
		//self.Owner:SetModelScale( 1 )
	//end
	/*if CLIENT and IsValid( self.SantasHat ) then
		self.SantasHat:Remove()
	end*/
end

SWEP.NextAttackW	= 0
SWEP.AttackDelay	= 4
SWEP.OnFuryCD = 0.7
function SWEP:PrimaryAttack()
	if preparing then return end
	if not IsFirstTimePredicted() then return end
	if self.NextAttackW > CurTime() then return end
	if CLIENT then return end
	local ent = nil
	local tr = util.TraceHull({
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + (self.Owner:GetAimVector() * 75),
		mins = Vector(-10, -10, -10),
		maxs = Vector(10, 10, 10),
		filter = self.Owner,
		mask = MASK_SHOT,
	})
	ent = tr.Entity
	if IsValid(ent) then
		if ent:IsPlayer() then
			if ent:GTeam() == TEAM_SPEC or (ent:GTeam() == TEAM_SCP and ent:GetNClass() != ROLES.ROLE_SCP035) then return end
				local rdmdmg = math.random(50, 100)
				ent:TakeDamage(rdmdmg, self.Owner, self.Owner)
			--ent:Kill()
			--self.Owner:AddExp(15, true)
			if self.fury == true then
				self.NextAttackW = CurTime() + self.OnFuryCD
			else
				self.NextAttackW = CurTime() + self.AttackDelay
				self:EmitSound( self.Roar )
			end
			self:SetNWFloat("NextAttackW", self.NextAttackW) -- Synchronizuj z klientem
		else
			self:SCPDamageEvent( ent, 10 )
		end
	end
end

SWEP.NextSpeial = 0
SWEP.SpecialDelay = 45
SWEP.fury = false
function SWEP:SecondaryAttack()
	if self.NextSpeial > CurTime() then
		if SERVER then
			self.Owner:PrintMessage(HUD_PRINTTALK, "Special ability is on cooldown!")
		end
		return
	end
	self.NextSpeial = CurTime() + self.SpecialDelay
	self:SetNWFloat("NextSpecial", self.NextSpeial) -- Synchronizuj z klientem
	
	if SERVER then
		local hp = self:ApplyEffect()
		timer.Create( "682BuffEnd"..self.Owner:SteamID64(), 7, 1, function()
			self:RemoveEffect( hp, 0 )
		end )
	end
end

function SWEP:ApplyEffect()
	self.fury = true
	self:SetNWBool("IsFury", true) -- Synchronizuj status fury
	self.NextAttackW = CurTime() + 0.5
	self:SetNWFloat("NextAttackW", self.NextAttackW)
	self:EmitSound( self.Roar )
	self.Owner:SetWalkSpeed(self.furyspeed)
	self.Owner:SetRunSpeed(self.furyspeed)
	local hp = self.Owner:Health()
	self.Owner:SetHealth( 9999 )
	return hp
end

function SWEP:RemoveEffect( hp, regen )
	self.fury = false
	self:SetNWBool("IsFury", false) -- Synchronizuj status fury
	self.Owner:SetWalkSpeed(self.basespeed)
	self.Owner:SetRunSpeed(self.basespeed)
	hp = hp + regen
	if hp > self.Owner:GetMaxHealth() then hp = self.Owner:GetMaxHealth() end
	self.Owner:SetHealth( hp )
end

hook.Add("EntityTakeDamage", "AcidDamage", function(target, dmg)
	if !target or !target:IsPlayer() or !target:Alive() then return end
	if !IsValid( target:GetActiveWeapon() ) or target:GetActiveWeapon():GetClass() != "weapon_scp_682" then return end
	if dmg:GetDamageType() == DMG_ACID then
		if preparing then return true end
		dmg:ScaleDamage( 3 )
	end
end)

function SWEP:DrawHUD()
	if disablehud == true then return end
	if self.Owner:Team() == TEAM_SPEC then return end
	
	self:DrawSCPHUD()
end

function SWEP:DrawSCPHUD()
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-682")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-682")
	
	-- Status Fury
	local isFury = self:GetNWBool("IsFury", false)
	if isFury then
		surface.SetFont("DermaDefaultBold")
		surface.SetTextColor(255, 0, 0, 255)
		local furyText = "FURY MODE ACTIVE"
		local furyW, furyH = surface.GetTextSize(furyText)
		surface.SetTextPos(centerX - furyW / 2, hudY + 95)
		surface.DrawText(furyText)
	end
	
	-- Cooldowny
	local cooldownY = hudY + 60
	local barWidth = 210  -- Szersze paski bo tylko 2
	local barHeight = 8
	local spacing = 20
	local totalWidth = barWidth * 2 + spacing
	local startX = centerX - totalWidth / 2
	
	-- LMB Cooldown (Bite)
	local lmbBarX = startX
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lmbBarX, cooldownY - 15)
	surface.DrawText("LMB - Bite")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
	
	local attackCooldown = 0
	local nextAttack = self:GetNWFloat("NextAttackW", 0)
	if nextAttack > CurTime() then
		attackCooldown = nextAttack - CurTime()
	end
	
	if attackCooldown > 0 then
		local maxCooldown = isFury and self.OnFuryCD or self.AttackDelay
		local progress = 1 - (attackCooldown / maxCooldown)
		surface.SetDrawColor(255, 100, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", attackCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- RMB Cooldown (Fury)
	local rmbBarX = startX + barWidth + spacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rmbBarX, cooldownY - 15)
	surface.DrawText("RMB - Fury")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
	
	local specialCooldown = 0
	local nextSpecial = self:GetNWFloat("NextSpecial", 0)
	if nextSpecial > CurTime() then
		specialCooldown = nextSpecial - CurTime()
	end
	
	if specialCooldown > 0 then
		local progress = 1 - (specialCooldown / self.SpecialDelay)
		surface.SetDrawColor(255, 0, 0, 255) -- Czerwony dla fury
		surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", specialCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- Celownik
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	
	local scale = 0.3
	-- Czerwony celownik gdy fury aktywne
	if isFury then
		surface.SetDrawColor(255, 0, 0, 255)
	else
		surface.SetDrawColor(0, 255, 0, 255)
	end
	
	local gap = 5
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )
end

function SWEP:DrawWorldModel()
	/*if !IsValid( self.SantasHat ) then return end
	local boneid = self.Owner:LookupBone( "Bip01_Head" )
	if not boneid then
		for i=0, self.Owner:GetBoneCount()-1 do
			print( i, self.Owner:GetBoneName( i ) )
		end
		return
	end

	local matrix = self.Owner:GetBoneMatrix( boneid )
	if not matrix then
		return
	end

	local newpos, newang = LocalToWorld( self.SantasHatPositionOffset, self.SantasHatAngleOffset, matrix:GetTranslation(), matrix:GetAngles() )

	self.SantasHat:SetPos( newpos )
	self.SantasHat:SetAngles( newang )
	self.SantasHat:SetupBones()
	self.SantasHat:DrawModel()*/
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_689.lua
================================================
AddCSLuaFile()

SWEP.Base 			= "weapon_scp_base"
SWEP.PrintName		= "SCP-689"

SWEP.Primary.Delay 	=  15
SWEP.Sound			= "scp/689/689Attack.ogg"

SWEP.DrawCrosshair	= true
SWEP.HoldType 		= "normal"

SWEP.Targets = {}
SWEP.TargetTimers = {} -- Przechowuje czasy dodania celów

function SWEP:SetupDataTables()
	self:NetworkVar( "Entity", 0, "NCurTarget" )
	self:NetworkVar( "Float", 0, "NextRewind" )
	self:SetNCurTarget( nil )
	self:SetNextRewind( 0 )
end

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_689" )

	self:SetHoldType( self.HoldType )
	
	-- Inicjalizacja dla umiejętności rewind (jak ult Ekko)
	self.RewindPositions = {}
	self.RewindDelay = 60 -- Cooldown na rewind
	self.RewindTime = 4 -- Cofanie do pozycji sprzed 4 sekund
	self.LastPositionSave = 0
	
	-- Ghost model dla rewind (jak Ekko)
	if CLIENT then
		timer.Simple(0.1, function()
			if IsValid(self) and IsValid(self.Owner) then
				self.GhostModel = ClientsideModel(self.Owner:GetModel())
				self.GhostModel:SetNoDraw(true)
				self.GhostModel:SetMaterial("models/wireframe")
				self.GhostModel:SetRenderMode(RENDERMODE_TRANSALPHA)
				self.GhostModel:SetColor(Color(128, 0, 255, 100)) -- Fioletowy przezroczysty
			end
		end)
	end
end

function SWEP:OnRemove()
	if CLIENT and IsValid(self.GhostModel) then
		self.GhostModel:Remove()
	end
end

SWEP.ntabupdate = 0
SWEP.NextGlassBreak = 0
function SWEP:Think()
	if postround or preparing then return end
	
	-- Wybijanie szyb - używamy KeyPressed hook zamiast KeyDown
	
	if self.ntabupdate < CurTime() then
		self.ntabupdate = CurTime() + 3 --delay for performance

		if SERVER then
			net.Start( "689" )
				net.WriteTable( self.Targets )
			net.Send( self.Owner )
		end
	end

	if CLIENT then
		-- Zapisywanie pozycji dla ghost modelu także po stronie klienta
		if self.LastPositionSave < CurTime() then
			self.LastPositionSave = CurTime() + 0.5
			table.insert(self.RewindPositions, {
				pos = self.Owner:GetPos(),
				ang = self.Owner:EyeAngles(),
				time = CurTime(),
				health = self.Owner:Health()
			})
			
			-- Usuń stare pozycje
			for i = #self.RewindPositions, 1, -1 do
				if self.RewindPositions[i].time < CurTime() - self.RewindTime then
					table.remove(self.RewindPositions, i)
				end
			end
		end
		
		-- Aktualizuj pozycję ghost modelu
		if IsValid(self.GhostModel) and #self.RewindPositions > 0 then
			local oldestPos = self.RewindPositions[1]
			self.GhostModel:SetPos(oldestPos.pos)
			self.GhostModel:SetAngles(oldestPos.ang)
			
			-- Ustaw sekwencję animacji aby uniknąć T-pose
			local seq = self.Owner:GetSequence()
			if seq and seq >= 0 then
				self.GhostModel:SetSequence(seq)
				self.GhostModel:SetCycle(self.Owner:GetCycle())
				self.GhostModel:SetPlaybackRate(0) -- Zatrzymaj animację
			end
			
			self.GhostModel:SetupBones()
			
			-- Pokaż ghost tylko gdy rewind jest gotowy
			local nextRewind = self:GetNextRewind()
			if nextRewind <= CurTime() and self.Owner == LocalPlayer() then
				self.GhostModel:SetNoDraw(false)
			else
				self.GhostModel:SetNoDraw(true)
			end
		end
		return
	end
	
	-- Zapisywanie pozycji dla rewind co 0.5 sekundy
	if self.LastPositionSave < CurTime() then
		self.LastPositionSave = CurTime() + 0.5
		table.insert(self.RewindPositions, {
			pos = self.Owner:GetPos(),
			ang = self.Owner:EyeAngles(),
			time = CurTime(),
			health = self.Owner:Health()
		})
		
		-- Usuń stare pozycje (starsze niż RewindTime)
		for i = #self.RewindPositions, 1, -1 do
			if self.RewindPositions[i].time < CurTime() - self.RewindTime then
				table.remove(self.RewindPositions, i)
			end
		end
	end

	local ownerpos = self.Owner:GetPos()
	local currentTime = CurTime()
	
	-- Usuń cele które są za długo na liście (15 sekund)
	for k = #self.Targets, 1, -1 do
		local v = self.Targets[k]
		if !IsValid( v ) or !v:Alive() or v:GTeam() == TEAM_SPEC or (v:GTeam() == TEAM_SCP and v:GetNClass() != ROLES.ROLE_SCP035) or v.Using714 or v:GetPos():DistToSqr(ownerpos) > 9000000 then
			table.remove(self.Targets, k)
			self.TargetTimers[v] = nil
		elseif self.TargetTimers[v] and currentTime - self.TargetTimers[v] > 15 then
			-- Usuń cel po 15 sekundach
			table.remove(self.Targets, k)
			self.TargetTimers[v] = nil
		end
	end

	for k, v in pairs( player.GetAll() ) do
		if v != self.Owner and !table.HasValue( self.Targets, v ) and !v.Using714 then
			if v:IsPlayer() and v:GTeam() != TEAM_SPEC and (v:GTeam() != TEAM_SCP or v:GetNClass() == ROLES.ROLE_SCP035) then
				local treyes = util.TraceLine( {
					start = v:EyePos(),
					endpos = self.Owner:EyePos(),
					mask = MASK_SHOT_HULL,
					filter = { v, self.Owner }
				} )

				local trpos = util.TraceLine( {
					start = v:EyePos(),
					endpos = self.Owner:GetPos(),
					mask = MASK_SHOT_HULL,
					filter = { v, self.Owner }
				} )

				if !treyes.Hit or !trpos.Hit then
					local trnormal = !treyes.Hit and treyes.Normal or !trpos.Hit and trpos.Normal
					local eyenormal = v:EyeAngles():Forward()

					if eyenormal:Dot( trnormal ) > 0.70 then
						table.insert( self.Targets, v )
						self.TargetTimers[v] = currentTime -- Zapisz czas dodania celu
					end
				end
			end
		end
	end
end

SWEP.NextPrimary = 0

function SWEP:PrimaryAttack()
	if preparing or postround then return end
	//if not IsFirstTimePredicted() then return end
	if #self.Targets < 1 then return end
	if self.NextPrimary > CurTime() then return end
	self.NextPrimary = CurTime() + self.Primary.Delay
	self:SetNWFloat("NextPrimary", self.NextPrimary) -- Synchronizuj z klientem

	if SERVER then
		local at = self:GetNCurTarget()
		if !table.HasValue( self.Targets, at ) then at = nil print( "689 tried to attack invalid entity!" ) end

		if !IsValid( at ) then
			at = table.Random(self.Targets)
			self:SetNCurTarget( at )
		end

		-- Odtwórz dźwięk tylko na ofierze
		at:EmitSound(self.Sound)
		
		-- Zablokuj skakanie i zmień broń na holster
		if IsValid(at) and at:IsPlayer() then
			at:SetJumpPower(0) -- Zablokuj skakanie
			at:StripWeapons() -- Usuń wszystkie bronie
			at:Give("br_holster") -- Daj holster
			at:SelectWeapon("br_holster") -- Wybierz holster
		end

		timer.Create("CheckTimer"..self.Owner:SteamID64(), 0.5, math.floor(self.Primary.Delay), function()
			if !( IsValid( self ) and IsValid( self.Owner ) and self.Owner:Alive() and IsValid( at ) and at:Alive() and at:GTeam() != TEAM_SPEC ) or at.Using714 then
				timer.Destroy("CheckTimer")
				timer.Destroy( "KillTimer"..self.Owner:SteamID64() )
				-- Przywróć skakanie jeśli atak został przerwany
				if IsValid(at) and at:IsPlayer() and at:Alive() then
					at:SetJumpPower(200) -- Domyślna wartość
				end
			end
		end )

		timer.Create("KillTimer"..self.Owner:SteamID64(), math.floor(self.Primary.Delay / 2), 1, function()
			if IsValid( self ) and IsValid( self.Owner ) and self.Owner:Alive() and IsValid( at ) and at:Alive() and at:GTeam() != TEAM_SPEC then
				local pos = at:GetPos()
				
				-- Użyj TakeDamageInfo zamiast Kill() aby system punktów działał prawidłowo
				local dmginfo = DamageInfo()
				dmginfo:SetDamage(at:Health() + 100) -- Zapewnij zabicie
				dmginfo:SetAttacker(self.Owner)
				dmginfo:SetInflictor(self)
				dmginfo:SetDamageType(DMG_DIRECT)
				at:TakeDamageInfo(dmginfo)
				
				self.Owner:SetPos(pos)
				self.Owner:AddExp(125, true)
				table.RemoveByValue(self.Targets, at)
				self:SetNCurTarget( nil )

				local toremove = math.ceil( #self.Targets / 2 )

				for i = 1, toremove do
					print( "rem!", table.remove( self.Targets, math.random( 0, #self.Targets ) ) )
					
				end
			end
		end )
	end
end

SWEP.NextSecondary = 0
function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextSecondary > CurTime() then return end
	
	if SERVER then
		-- Umiejętność Rewind (jak ult Ekko)
		if #self.RewindPositions > 0 then
			local oldestPos = self.RewindPositions[1]
			

			
			-- Efekt wizualny przed teleportacją usunięty
			
			-- Teleportuj do starej pozycji
			self.Owner:SetPos(oldestPos.pos)
			self.Owner:SetEyeAngles(oldestPos.ang)
			
			-- Przywróć HP jeśli było wyższe
			if oldestPos.health > self.Owner:Health() then
				self.Owner:SetHealth(oldestPos.health)
			end
			

			
			-- Efekt po teleportacji usunięty
			
			-- Wyczyść historię pozycji
			self.RewindPositions = {}
			
			-- Ustaw cooldown
			self.NextSecondary = CurTime() + self.RewindDelay
			self:SetNextRewind(self.NextSecondary)
		end
	end
end

SWEP.LastReload = 0

function SWEP:Reload()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end

	if !SERVER then return end
	if self.NextPrimary > CurTime() then return end
	if self.LastReload > CurTime() then return end

	self.LastReload = CurTime() + 0.25

	local CurTarget = self:GetNCurTarget()
	if !IsValid( CurTarget ) then
		self:SetNCurTarget( self.Targets[1] )
		return
	end

	for i, v in ipairs( self.Targets ) do
		if v == CurTarget then
			if i == #self.Targets then self:SetNCurTarget( self.Targets[1] ) return end
			self:SetNCurTarget( self.Targets[i + 1] )
			return
		end
	end
end


function SWEP:DrawHUD()
	if disablehud == true then return end
	if self.Owner:Team() == TEAM_SPEC then return end
	
	self:DrawSCPHUD()
	
	-- Lista celów po prawej stronie
	if #self.Targets > 0 then
		draw.Text( {
			text = self.Lang.HUD.targets..":",
			pos = { ScrW() * 0.97, ScrH() / 3 - 35 },
			font = "173font",
			color = Color(200, 200, 200, 255),
			xalign = TEXT_ALIGN_RIGHT,
			yalign = TEXT_ALIGN_CENTER,
		})
	end
	for i, v in ipairs( self.Targets ) do
		local add = v == self:GetNCurTarget() and "> " or ""
		local col = v == self:GetNCurTarget() and Color(255, 100, 100, 255) or Color(150, 150, 150, 255)
		draw.Text( {
			text = add..v:GetName(),
			pos = { ScrW() * 0.99, ScrH() / 3 + i * 25 },
			font = "173font",
			color = col,
			xalign = TEXT_ALIGN_RIGHT,
			yalign = TEXT_ALIGN_CENTER,
		})
	end
end

function SWEP:DrawSCPHUD()
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-689")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-689")
	
	-- Status ataku
	local nextPrimary = self:GetNWFloat("NextPrimary", 0)
	local isAttacking = nextPrimary > CurTime()
	local currentTarget = self:GetNCurTarget()
	
	if isAttacking and IsValid(currentTarget) then
		-- Usunięto czerwony napis "ATTACKING" na życzenie użytkownika
		-- surface.SetFont("DermaDefaultBold")
		-- surface.SetTextColor(255, 0, 0, 255)
		-- local attackText = "ATTACKING: " .. currentTarget:GetName()
		-- local attackW, attackH = surface.GetTextSize(attackText)
		-- surface.SetTextPos(centerX - attackW / 2, hudY + 35)
		-- surface.DrawText(attackText)
	elseif #self.Targets > 0 then
		-- Usunięto zielony napis "TARGETS" na życzenie użytkownika
		-- surface.SetFont("DermaDefaultBold")
		-- surface.SetTextColor(100, 255, 100, 255)
		-- local targetsText = "TARGETS: " .. #self.Targets
		-- local targetsW, targetsH = surface.GetTextSize(targetsText)
		-- surface.SetTextPos(centerX - targetsW / 2, hudY + 35)
		-- surface.DrawText(targetsText)
	else
		-- Usunięto żółty napis "NO TARGETS" na życzenie użytkownika
		-- surface.SetFont("DermaDefaultBold")
		-- surface.SetTextColor(255, 255, 100, 255)
		-- local noTargetsText = "NO TARGETS"
		-- local noTargetsW, noTargetsH = surface.GetTextSize(noTargetsText)
		-- surface.SetTextPos(centerX - noTargetsW / 2, hudY + 35)
		-- surface.DrawText(noTargetsText)
	end
	
	-- Cooldowny
	local cooldownY = hudY + 60
	local barWidth = 150
	local barHeight = 8
	local spacing = 20
	local totalWidth = barWidth * 3 + spacing * 2
	local startX = centerX - totalWidth / 2
	
	-- LMB Cooldown (Attack)
	local lmbBarX = startX
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lmbBarX, cooldownY - 15)
	surface.DrawText("LMB - Attack")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
	
	local attackCooldown = 0
	if nextPrimary > CurTime() then
		attackCooldown = nextPrimary - CurTime()
	end
	
	if attackCooldown > 0 then
		local progress = 1 - (attackCooldown / self.Primary.Delay)
		surface.SetDrawColor(255, 100, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", attackCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- R Cooldown (Switch Target)
	local rBarX = startX + barWidth + spacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rBarX, cooldownY - 15)
	surface.DrawText("R - Switch")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rBarX, cooldownY, barWidth, barHeight)
	
	if #self.Targets > 0 then
		surface.SetDrawColor(100, 100, 255, 255) -- Niebieski dla switch target
		surface.DrawRect(rBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 150, 255, 255)
		surface.SetTextPos(rBarX, cooldownY + 10)
		surface.DrawText("AVAILABLE")
	else
		surface.SetFont("DermaDefault")
		surface.SetTextColor(100, 100, 100, 255)
		surface.SetTextPos(rBarX, cooldownY + 10)
		surface.DrawText("NO TARGETS")
	end
	
	-- RMB (Rewind)
	local rmbBarX = startX + (barWidth + spacing) * 2
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rmbBarX, cooldownY - 15)
	surface.DrawText("RMB - Rewind")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
	
	local rewindCooldown = 0
	local nextRewind = self:GetNextRewind()
	if nextRewind > CurTime() then
		rewindCooldown = nextRewind - CurTime()
	end
	
	if rewindCooldown > 0 then
		local progress = 1 - (rewindCooldown / self.RewindDelay)
		surface.SetDrawColor(128, 0, 255, 255) -- Fioletowy dla rewind
		surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(200, 150, 255, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", rewindCooldown))
	else
		surface.SetDrawColor(200, 100, 255, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(220, 180, 255, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- Celownik
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	
	local scale = 0.3
	-- Czerwony celownik gdy atakuje
	if isAttacking then
		surface.SetDrawColor(255, 0, 0, 255)
	else
		surface.SetDrawColor(0, 255, 0, 255)
	end
	
	local gap = 5
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )
	
	-- Info o rozbijaniu szyb
	surface.SetFont("DermaDefault")
	surface.SetTextColor(150, 150, 150, 255)
	local glassText = "[E] - Break Glass"
	local glassW, glassH = surface.GetTextSize(glassText)
	surface.SetTextPos(centerX - glassW / 2, hudY + hudHeight - 25)
	surface.DrawText(glassText)
end

-- Renderowanie ghost modelu - tylko dla właściciela broni
hook.Add("PostDrawTranslucentRenderables", "SCP689_GhostModel", function(bDepth, bSkybox, b3DSkybox)
	if bSkybox or b3DSkybox then return end
	
	local ply = LocalPlayer()
	if !IsValid(ply) or !ply:Alive() then return end
	
	local wep = ply:GetActiveWeapon()
	if !IsValid(wep) or wep:GetClass() != "weapon_scp_689" then return end
	
	-- WAŻNE: Renderuj ghost tylko dla właściciela broni
	if wep.Owner != ply then return end
	
	if !IsValid(wep.GhostModel) or wep.GhostModel:GetNoDraw() then return end
	
	-- Ustaw model gracza
	local mdl = ply:GetModel()
	if wep.GhostModel:GetModel() != mdl then
		wep.GhostModel:SetModel(mdl)
	end
	
	-- Renderuj ghost z efektem
	render.SetBlend(0.5)
	render.SetColorModulation(0.5, 0, 1) -- Fioletowy
	wep.GhostModel:DrawModel()
	render.SetColorModulation(1, 1, 1)
	render.SetBlend(1)
	
	-- Dodaj efekt świecenia
	local pos = wep.GhostModel:GetPos()
	render.SetMaterial(Material("sprites/light_glow02_add"))
	render.DrawSprite(pos + Vector(0, 0, 40), 128, 128, Color(128, 0, 255, 100))
end)

-- Rozbijanie szyb na środkowy przycisk myszy lub E
if SERVER then
	hook.Add("KeyPress", "SCP689_GlassBreak", function(ply, key)
		if !IsValid(ply) or !ply:Alive() then return end
		local wep = ply:GetActiveWeapon()
		if !IsValid(wep) or wep:GetClass() != "weapon_scp_689" then return end
		
		-- Sprawdź czy to środkowy przycisk myszy (107) lub E (32)
		if key != 107 and key != 32 then return end
		
		if wep.NextGlassBreak and wep.NextGlassBreak > CurTime() then return end
		wep.NextGlassBreak = CurTime() + 0.5
		
		-- Znajdź szybę przed graczem
		local tr = util.TraceLine({
			start = ply:GetShootPos(),
			endpos = ply:GetShootPos() + ply:GetAimVector() * 100,
			filter = ply
		})
		
		local ent = tr.Entity
		if IsValid(ent) then
			if ent:GetClass() == "func_breakable" or ent:GetClass() == "func_breakable_surf" then
				ent:Fire("Break")
				-- Usunięto dźwięk rozbijania szyby
				
				-- Efekt wizualny usunięty na życzenie użytkownika
				-- local effectdata = EffectData()
				-- effectdata:SetOrigin(tr.HitPos)
				-- effectdata:SetNormal(tr.HitNormal)
				-- util.Effect("GlassImpact", effectdata)
			elseif string.find(ent:GetClass(), "door") then
				-- Możliwość rozbicia drzwi ze szkłem
				wep:SCPDamageEvent(ent, 100)
			end
		end
	end)
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_8602.lua
================================================
AddCSLuaFile()

SWEP.Base 				= "weapon_scp_base"
SWEP.PrintName			= "SCP-860-2"

SWEP.Primary.Delay      = 1.5
SWEP.GrabCooldown      = 60 -- Cooldown na grab
SWEP.GrabDuration      = 3 -- Maksymalny czas trzymania
SWEP.ShieldCooldown    = 60 -- Cooldown na tarczę
SWEP.ShieldDuration    = 3 -- Czas trwania tarczy (przed teleportacją)

SWEP.DrawCrosshair		= true
SWEP.HoldType 			= "normal"

function SWEP:SetupDataTables()
	self:NetworkVar("Float", 0, "NextPrimary")
	self:NetworkVar("Float", 1, "NextGrab")
	self:NetworkVar("Float", 2, "NextShield")
	self:NetworkVar("Bool", 0, "IsGrabbing")
	self:NetworkVar("Bool", 1, "IsShielded")
	self:NetworkVar("Entity", 0, "GrabbedTarget")
end

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_8602" )

	self:SetHoldType(self.HoldType)
	
	-- Inicjalizacja cooldownów
	self:SetNextPrimary(0)
	self:SetNextGrab(0)
	self:SetNextShield(0)
	self:SetIsGrabbing(false)
	self:SetIsShielded(false)
	
	if SERVER then
		util.AddNetworkString("SCP8602_Shield")
	end
end

-- LPM - Zwykły bite
function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self:GetNextPrimary() > CurTime() then return end
	if self:GetIsGrabbing() then return end -- Nie może atakować podczas trzymania
	
	self:SetNextPrimary(CurTime() + self.Primary.Delay)
	
	if SERVER then
		local trace = util.TraceHull({
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 75,
			filter = self.Owner,
			mask = MASK_SHOT,
			maxs = Vector(15, 15, 15),
			mins = Vector(-15, -15, -15)
		})
		
		if trace.Hit and IsValid(trace.Entity) then
			local ent = trace.Entity
			if ent:IsPlayer() then
				if ent:GTeam() == TEAM_SPEC or (ent:GTeam() == TEAM_SCP and ent:GetNClass() != ROLES.ROLE_SCP035) then return end
				ent:TakeDamage(math.random(30, 45), self.Owner, self)
				self.Owner:EmitSound("npc/zombie/zombie_hit.wav", 90, math.random(80, 120))
				ent:ViewPunch(Angle(math.random(-15, 15), math.random(-15, 15), 0))
			else
				self:SCPDamageEvent(ent, 20)
			end
		end
	end
end

-- PPM - Grab
function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self:GetNextGrab() > CurTime() then return end
	
	if self:GetIsGrabbing() then
		-- Puść cel
		self:ReleaseGrab()
	else
		-- Spróbuj złapać
		if SERVER then
			local trace = util.TraceHull({
				start = self.Owner:GetShootPos(),
				endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 100,
				filter = self.Owner,
				mask = MASK_SHOT,
				maxs = Vector(20, 20, 20),
				mins = Vector(-20, -20, -20)
			})
			
			if trace.Hit and IsValid(trace.Entity) and trace.Entity:IsPlayer() then
				local ent = trace.Entity
				if ent:GTeam() != TEAM_SPEC and ent:GTeam() != TEAM_SCP then
					self:GrabTarget(ent)
				end
			end
		end
	end
end

function SWEP:GrabTarget(target)
	if !IsValid(target) then return end
	
	self:SetIsGrabbing(true)
	self:SetGrabbedTarget(target)
	self:SetNextGrab(CurTime() + self.GrabCooldown)
	self.GrabStartTime = CurTime()
	
	-- Nakładanie krwawienia
	target.NextBleeding = CurTime() + 1
	target.Bleeding = true
	
	-- Dźwięk złapania
	self.Owner:EmitSound("npc/barnacle/barnacle_bark2.wav", 100, 80)
	
	-- Zmiana prędkości
	self.OldWalkSpeed = self.Owner:GetWalkSpeed()
	self.OldRunSpeed = self.Owner:GetRunSpeed()
	self.Owner:SetWalkSpeed(150)
	self.Owner:SetRunSpeed(150)
end

function SWEP:ReleaseGrab()
	local target = self:GetGrabbedTarget()
	
	self:SetIsGrabbing(false)
	self:SetGrabbedTarget(nil)
	
	-- Przywróć prędkość
	if self.OldWalkSpeed then
		self.Owner:SetWalkSpeed(self.OldWalkSpeed)
		self.Owner:SetRunSpeed(self.OldRunSpeed)
	end
	
	-- Wyrzuć cel
	if IsValid(target) then
		local dir = self.Owner:GetAimVector()
		target:SetVelocity(dir * 800 + Vector(0, 0, 300))
		target:EmitSound("npc/zombie/zombie_pound_door.wav", 100, 100)
		
		-- Dodaj tymczasową ochronę przed fall damage
		target.SCP8602_FallProtection = CurTime() + 1.75
	end
end

-- R - Tarcza
function SWEP:Reload()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self:GetNextShield() > CurTime() then return end
	if self:GetIsShielded() then return end
	
	self:SetNextShield(CurTime() + self.ShieldCooldown)
	self:SetIsShielded(true)
	
	if SERVER then
		-- Najpierw aktywuj tarczę
		self.Owner:EmitSound("ambient/energy/force_field_loop1.wav", 100, 100)
		
		-- Wyślij info o tarczy
		net.Start("SCP8602_Shield")
			net.WriteBool(true)
			net.WriteEntity(self.Owner)
		net.Broadcast()
		
		-- Po 3 sekundach teleportuj i wyłącz tarczę
		timer.Simple(self.ShieldDuration, function()
			if IsValid(self) and IsValid(self.Owner) then
				-- Teleport do lokacji
				self.Owner:SetPos(Vector(6477.314941, 4795.328613, -1088.002808))
				self.Owner:SetEyeAngles(Angle(-1.278438, -0.006986, 0.000000))
				self.Owner:SetLocalVelocity(Vector(0, 0, 0))
				
				-- Wyłącz tarczę
				self:SetIsShielded(false)
				self.Owner:StopSound("ambient/energy/force_field_loop1.wav")
				self.Owner:EmitSound("ambient/energy/zap" .. math.random(1, 3) .. ".wav", 100, 100)
				
				net.Start("SCP8602_Shield")
					net.WriteBool(false)
					net.WriteEntity(self.Owner)
				net.Broadcast()
			end
		end)
	end
end

-- Think dla grab
function SWEP:Think()
	if SERVER and self:GetIsGrabbing() then
		local target = self:GetGrabbedTarget()
		
		-- Sprawdź czy minął maksymalny czas trzymania
		if self.GrabStartTime and CurTime() > self.GrabStartTime + self.GrabDuration then
			self:ReleaseGrab()
			return
		end
		
		if !IsValid(target) or !target:Alive() or target:GetPos():Distance(self.Owner:GetPos()) > 150 then
			self:ReleaseGrab()
			return
		end
		
		-- Trzymaj cel bliżej pyska
		local pos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 35
		target:SetPos(pos - Vector(0, 0, 20))
		target:SetVelocity(Vector(0, 0, 0))
		
		-- Krwawienie
		if target.NextBleeding and target.NextBleeding < CurTime() then
			target.NextBleeding = CurTime() + 2
			target:TakeDamage(5, self.Owner, self)
			
			-- Efekt krwi
			local effectdata = EffectData()
			effectdata:SetOrigin(target:GetPos() + Vector(0, 0, 40))
			effectdata:SetNormal(Vector(0, 0, -1))
			util.Effect("BloodImpact", effectdata)
		end
	end
end

-- Czyszczenie przy usunięciu broni
function SWEP:OnRemove()
	if self:GetIsGrabbing() then
		self:ReleaseGrab()
	end
	if SERVER and IsValid(self.Owner) then
		self.Owner:StopSound("ambient/energy/force_field_loop1.wav")
	end
end

-- Hook na obrażenia gdy tarcza aktywna
if SERVER then
	hook.Add("EntityTakeDamage", "SCP8602_Shield", function(target, dmg)
		if !IsValid(target) or !target:IsPlayer() then return end
		local wep = target:GetActiveWeapon()
		if !IsValid(wep) or wep:GetClass() != "weapon_scp_8602" then return end
		
		if wep:GetIsShielded() then
			dmg:ScaleDamage(0) -- 100% redukcji obrażeń podczas tarczy
			target:EmitSound("physics/plastic/plastic_box_impact_soft" .. math.random(1, 4) .. ".wav", 80, 150)
			return true
		end
	end)
	
	-- Blokuj fall damage dla złapanego gracza i przez 1.75s po wypuszczeniu
	hook.Add("EntityTakeDamage", "SCP8602_NoFallDamage", function(target, dmg)
		if !IsValid(target) or !target:IsPlayer() then return end
		
		-- Sprawdź czy gracz jest złapany przez jakiegoś SCP-860-2
		for _, ply in pairs(player.GetAll()) do
			local wep = ply:GetActiveWeapon()
			if IsValid(wep) and wep:GetClass() == "weapon_scp_8602" then
				if wep:GetIsGrabbing() and wep:GetGrabbedTarget() == target then
					-- Blokuj fall damage podczas trzymania
					if dmg:IsFallDamage() then
						return true
					end
				end
			end
		end
		
		-- Sprawdź czy gracz ma tymczasową ochronę po wypuszczeniu
		if target.SCP8602_FallProtection and target.SCP8602_FallProtection > CurTime() then
			if dmg:IsFallDamage() then
				return true
			end
		end
	end)
end

-- Efekty klienckie
if CLIENT then
	net.Receive("SCP8602_Shield", function()
		local active = net.ReadBool()
		local ent = net.ReadEntity()
		
		if !IsValid(ent) then return end
		
		if active then
			ent.ShieldEffect = true
		else
			ent.ShieldEffect = false
		end
	end)
	
	-- Renderowanie tarczy
	hook.Add("PostDrawTranslucentRenderables", "SCP8602_Shield", function()
		for _, ply in pairs(player.GetAll()) do
			if ply.ShieldEffect then
				render.SetColorMaterial()
				render.SetBlend(0.3)
				render.DrawSphere(ply:GetPos() + Vector(0, 0, 40), 80, 20, 20, Color(0, 255, 0, 100))
				render.SetBlend(1)
			end
		end
	end)
end

function SWEP:DrawHUD()
	if disablehud == true then return end
	if self.Owner:Team() == TEAM_SPEC then return end
	
	self:DrawSCPHUD()
end

function SWEP:DrawSCPHUD()
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-860-2")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-860-2")
	
	-- Status
	local statusText = ""
	local statusColor = Color(200, 200, 200, 255)
	
	if self:GetIsShielded() then
		statusText = "SHIELDED"
		statusColor = Color(0, 255, 0, 255)
	elseif self:GetIsGrabbing() then
		local target = self:GetGrabbedTarget()
		if IsValid(target) then
			statusText = "GRABBING: " .. target:GetName()
			statusColor = Color(255, 100, 100, 255)
		end
	end
	
	if statusText != "" then
		surface.SetFont("DermaDefaultBold")
		surface.SetTextColor(statusColor.r, statusColor.g, statusColor.b, 255)
		local statusW, statusH = surface.GetTextSize(statusText)
		surface.SetTextPos(centerX - statusW / 2, hudY + 35)
		surface.DrawText(statusText)
	end
	
	-- Cooldowny
	local cooldownY = hudY + 60
	local barWidth = 150
	local barHeight = 8
	local spacing = 20
	local totalWidth = barWidth * 3 + spacing * 2
	local startX = centerX - totalWidth / 2
	
	-- LMB Cooldown (Bite)
	local lmbBarX = startX
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lmbBarX, cooldownY - 15)
	surface.DrawText("LMB - Bite")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
	
	local attackCooldown = 0
	local nextAttack = self:GetNextPrimary()
	if nextAttack > CurTime() then
		attackCooldown = nextAttack - CurTime()
	end
	
	if attackCooldown > 0 then
		local progress = 1 - (attackCooldown / self.Primary.Delay)
		surface.SetDrawColor(255, 100, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", attackCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- RMB Cooldown (Grab)
	local rmbBarX = startX + barWidth + spacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rmbBarX, cooldownY - 15)
	surface.DrawText("RMB - Grab")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
	
	local grabCooldown = 0
	local nextGrab = self:GetNextGrab()
	if nextGrab > CurTime() and !self:GetIsGrabbing() then
		grabCooldown = nextGrab - CurTime()
	end
	
	if self:GetIsGrabbing() then
		surface.SetDrawColor(255, 0, 0, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 200, 200, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText("RELEASE")
	elseif grabCooldown > 0 then
		local progress = 1 - (grabCooldown / 60)
		surface.SetDrawColor(255, 150, 0, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 200, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", grabCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- R Cooldown (Shield)
	local rBarX = startX + (barWidth + spacing) * 2
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rBarX, cooldownY - 15)
	surface.DrawText("R - Shield")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rBarX, cooldownY, barWidth, barHeight)
	
	local shieldCooldown = 0
	local nextShield = self:GetNextShield()
	if nextShield > CurTime() and !self:GetIsShielded() then
		shieldCooldown = nextShield - CurTime()
	end
	
	if self:GetIsShielded() then
		surface.SetDrawColor(0, 255, 0, 255)
		surface.DrawRect(rBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rBarX, cooldownY + 10)
		surface.DrawText("ACTIVE")
	elseif shieldCooldown > 0 then
		local progress = 1 - (shieldCooldown / 60)
		surface.SetDrawColor(0, 255, 0, 255)
		surface.DrawRect(rBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", shieldCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(rBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- Celownik
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	
	local scale = 0.3
	if self:GetIsShielded() then
		surface.SetDrawColor(0, 255, 0, 255)
	elseif self:GetIsGrabbing() then
		surface.SetDrawColor(255, 0, 0, 255)
	else
		surface.SetDrawColor(200, 200, 200, 255)
	end
	
	local gap = 5
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_939.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_scp_base"
SWEP.PrintName = "SCP-939"

-- Primary attack settings
SWEP.Primary.Delay = 1.0
SWEP.BiteDamage = 30
SWEP.BiteRange = 100

-- Secondary attack settings  
SWEP.TrackingCooldown = 30
SWEP.TrackingDuration = 1.0
SWEP.TrackingRange = 4000
SWEP.DamageBonus = 0.2
SWEP.BonusDuration = 5

-- Bleed settings
SWEP.BleedDamage = 5
SWEP.BleedDuration = 3
SWEP.BleedTickRate = 1

-- Motion vision settings
SWEP.MotionThreshold = 8
SWEP.FadeSpeed = 0.08

SWEP.DrawCrosshair = true
SWEP.HoldType = ""

function SWEP:SetupDataTables()
	self:NetworkVar("Float", 0, "NextPrimary")
	self:NetworkVar("Float", 1, "NextTracking")
	self:NetworkVar("Float", 2, "DamageBonusEndTime")
	self:NetworkVar("Float", 3, "NextVoiceToggle") -- Cooldown dla R
	self:NetworkVar("Bool", 0, "IsTracking")
	self:NetworkVar("Bool", 1, "VoiceChatAll") -- false = SCP only, true = all
end

function SWEP:Initialize()
	self:InitializeLanguage("SCP_939")
	self:SetHoldType(self.HoldType)
	
	-- Initialize cooldowns
	self:SetNextPrimary(0)
	self:SetNextTracking(0)
	self:SetDamageBonusEndTime(0)
	self:SetNextVoiceToggle(0)
	self:SetIsTracking(false)
	self:SetVoiceChatAll(false) -- Start with SCP only
	
	if SERVER then
		self.BiteCounter = {}
		self.BleedingPlayers = {}
		self.PlayerOutlines = {}
		self.LastPlayerPositions = {}
		self.PlayerVisibility = {}
		
		-- Set up network strings
		util.AddNetworkString("SCP939_UpdateVision")
		util.AddNetworkString("SCP939_ClearVision")
		util.AddNetworkString("SCP939_ShowOutline")
		util.AddNetworkString("SCP939_ClearOutlines")
		util.AddNetworkString("SCP939_BloodSpot")
		util.AddNetworkString("SCP939_ActionSpot")
	end
	
	if CLIENT then
		self.PlayerVisibilityData = {}
		self.LastBleedApplication = 0
	end
end

function SWEP:DrawWorldModel()
	-- Nie rysuj modelu broni
end

function SWEP:DrawWorldModelTranslucent()
	-- Nie rysuj modelu broni
end

function SWEP:DrawViewModel()
	-- Nie rysuj viewmodelu
end

function SWEP:PreDrawViewModel()
	return true -- Zapobiega rysowaniu
end

function SWEP:ViewModelDrawn()
	-- Nic nie rób
end

function SWEP:GetViewModelPosition(pos, ang)
	return pos, ang
end

SWEP.ShowViewModel = false
SWEP.ShowWorldModel = false

function SWEP:Deploy()
	if SERVER then
		self:StartMotionVision()
		self:StartHealthRegeneration()
		-- self:StartVoiceLines() -- Wyłączone dźwięki ludzkie
		self:StartMaxHPCheck()
		
		local owner = self:GetOwner()
		if IsValid(owner) then
			local currentMaxHP = owner:GetNWInt("SCP939_MaxHP", 0)
			if currentMaxHP == 0 or currentMaxHP < owner:Health() then
				owner:SetNWInt("SCP939_MaxHP", owner:Health())
			end
		end
	end
	return true
end

function SWEP:Holster()
	if SERVER then
		self:StopMotionVision()
		self:ClearPlayerOutlines()
		self:StopHealthRegeneration()
		-- self:StopVoiceLines() -- Wyłączone dźwięki ludzkie
		self:StopMaxHPCheck()
	end
	return true
end

function SWEP:OnRemove()
	if SERVER then
		self:StopMotionVision()
		self:ClearPlayerOutlines()
		self:StopHealthRegeneration()
		-- self:StopVoiceLines() -- Wyłączone dźwięki ludzkie
		self:StopMaxHPCheck()
		
		-- Clean up bleed timers
		if self.BleedingPlayers then
			for steamid, _ in pairs(self.BleedingPlayers) do
				timer.Remove("SCP939_Bleed_" .. steamid)
			end
		end
		
		-- Remove hooks
		local entIndex = self:EntIndex()
		hook.Remove("EntityFireBullets", "SCP939_DetectShooting_" .. entIndex)
		hook.Remove("PlayerStartVoice", "SCP939_DetectVoice_" .. entIndex)
	end
end

-- LMB - Bite attack
function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self:GetNextPrimary() > CurTime() then return end
	
	self:SetNextPrimary(CurTime() + self.Primary.Delay)
	
	local owner = self:GetOwner()
	if not IsValid(owner) then return end
	
	self:EmitSound("939lmb.wav", 75, 100)
	owner:SetAnimation(PLAYER_ATTACK1)
	
	if SERVER then
		local trace = util.TraceLine({
			start = owner:GetShootPos(),
			endpos = owner:GetShootPos() + owner:GetAimVector() * self.BiteRange,
			filter = owner
		})
		
		if trace.Hit and IsValid(trace.Entity) then
			if trace.Entity:IsPlayer() then
				local target = trace.Entity
				if target:GTeam() == TEAM_SPEC or (target:GTeam() == TEAM_SCP and target:GetNClass() != ROLES.ROLE_SCP035) then return end
				
				local damage = self.BiteDamage
				
				-- Apply damage bonus if active
				if CurTime() < self:GetDamageBonusEndTime() then
					damage = damage * (1 + self.DamageBonus)
					
					local effectdata = EffectData()
					effectdata:SetOrigin(trace.HitPos)
					effectdata:SetNormal(trace.HitNormal)
					effectdata:SetScale(1.5)
					util.Effect("cball_explode", effectdata)
				end
				
				target:TakeDamage(damage, owner, self)
				
				-- Blood effect
				local effectdata = EffectData()
				effectdata:SetOrigin(trace.HitPos)
				effectdata:SetNormal(trace.HitNormal)
				effectdata:SetEntity(target)
				util.Effect("BloodImpact", effectdata)
				
				-- Track bite counter for bleeding
				local steamid = target:SteamID()
				self.BiteCounter[steamid] = (self.BiteCounter[steamid] or 0) + 1
				
				if self.BiteCounter[steamid] >= 3 then
					self:ApplyBleeding(target)
					self.BiteCounter[steamid] = 0
					-- Set flag for crosshair highlight
					self.LastBleedApplication = CurTime()
				end
			elseif trace.Entity:GetClass():find("func_breakable") then
				-- Możliwość wybijania szyb
				trace.Entity:TakeDamage(100, owner, self)
				-- Usunięto dźwięk rozbijania szyby
			end
		end
	end
end

-- RMB - Tracking ability
function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self:GetNextTracking() > CurTime() then return end
	
	self:SetNextTracking(CurTime() + self.TrackingCooldown)
	self:SetIsTracking(true)
	
	local owner = self:GetOwner()
	if not IsValid(owner) then return end
	
	self:EmitSound("939rmb.wav", 75, 100)
	
	if SERVER then
		owner:Freeze(true)
		
		local foundPlayers = self:ShowPlayerOutlines(owner)
		
		-- Visual effect
		local effectdata = EffectData()
		effectdata:SetOrigin(owner:GetPos() + Vector(0, 0, 50))
		effectdata:SetRadius(300)
		effectdata:SetMagnitude(2)
		util.Effect("ThumperDust", effectdata)
		
		timer.Simple(self.TrackingDuration, function()
			if IsValid(self) and IsValid(owner) then
				owner:Freeze(false)
				self:SetIsTracking(false)
				
				if foundPlayers > 0 then
					self:SetDamageBonusEndTime(CurTime() + self.BonusDuration)
				end
			end
		end)
	end
end

-- R - Toggle voice chat mode
function SWEP:Reload()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	
	local owner = self:GetOwner()
	if not IsValid(owner) then return end
	
	-- Sprawdź cooldown
	if self:GetNextVoiceToggle() > CurTime() then return end
	
	-- Ustaw cooldown 1 sekunda
	self:SetNextVoiceToggle(CurTime() + 1)
	
	-- Toggle voice chat mode
	self:SetVoiceChatAll(not self:GetVoiceChatAll())
	
	-- Sound feedback - usunieto dzwiek
	-- owner:EmitSound("buttons/button14.wav", 65, 100)
end

function SWEP:ApplyBleeding(target)
	if not SERVER or not IsValid(target) then return end
	
	local steamid = target:SteamID()
	
	if self.BleedingPlayers[steamid] then return end
	
	self.BleedingPlayers[steamid] = true
	
	local bleedCount = 0
	timer.Create("SCP939_Bleed_" .. steamid, self.BleedTickRate, self.BleedDuration, function()
		if IsValid(target) and IsValid(self) and target:Alive() then
			target:TakeDamage(self.BleedDamage, self:GetOwner(), self)
			
			-- Blood effect
			local effectdata = EffectData()
			effectdata:SetOrigin(target:GetPos() + Vector(math.random(-20, 20), math.random(-20, 20), 40))
			effectdata:SetNormal(Vector(0, 0, -1))
			util.Effect("bloodspray", effectdata)
			
			target:EmitSound("player/pl_pain" .. math.random(5, 7) .. ".wav", 60, math.random(90, 110))
			
			bleedCount = bleedCount + 1
			if bleedCount >= self.BleedDuration then
				self.BleedingPlayers[steamid] = nil
			end
		else
			timer.Remove("SCP939_Bleed_" .. steamid)
			if self.BleedingPlayers then
				self.BleedingPlayers[steamid] = nil
			end
		end
	end)
end

function SWEP:ShowPlayerOutlines(owner)
	if not SERVER or not IsValid(owner) then return 0 end
	
	self:ClearPlayerOutlines()
	
	local foundPlayers = 0
	
	for _, ply in pairs(player.GetAll()) do
		if IsValid(ply) and ply != owner and ply:Alive() then
			if ply:GTeam() != TEAM_SPEC and ply:GTeam() != TEAM_SCP then
				local distance = owner:GetPos():Distance(ply:GetPos())
				if distance <= self.TrackingRange then
					foundPlayers = foundPlayers + 1
					
					self.PlayerOutlines[ply:EntIndex()] = {
						pos = ply:GetPos(),
						endTime = CurTime() + 6
					}
					
					net.Start("SCP939_ShowOutline")
					net.WriteEntity(ply)
					net.WriteVector(ply:GetPos())
					net.WriteFloat(6)
					net.Send(owner)
				end
			end
		end
	end
	
	return foundPlayers
end

function SWEP:ClearPlayerOutlines()
	if not SERVER then return end
	
	local owner = self:GetOwner()
	if IsValid(owner) then
		net.Start("SCP939_ClearOutlines")
		net.Send(owner)
	end
	
	self.PlayerOutlines = {}
end

function SWEP:StartMotionVision()
	if not SERVER then return end
	
	local owner = self:GetOwner()
	if not IsValid(owner) then return end
	
	-- Initialize player positions
	for _, ply in pairs(player.GetAll()) do
		if IsValid(ply) and ply != owner then
			self.LastPlayerPositions[ply] = ply:GetPos()
			self.PlayerVisibility[ply] = 1
		end
	end
	
	-- Set up detection hooks
	local entIndex = self:EntIndex()
	
	hook.Add("EntityFireBullets", "SCP939_DetectShooting_" .. entIndex, function(entity, data)
		if IsValid(entity) and entity:IsPlayer() and IsValid(self) and IsValid(self:GetOwner()) then
			-- Nie pokazuj wykrzykników dla SCP i SPEC
			if entity:GTeam() != TEAM_SCP and entity:GTeam() != TEAM_SPEC then
				self:CreateActionSpot(entity, "shooting")
			end
		end
	end)
	
	hook.Add("PlayerStartVoice", "SCP939_DetectVoice_" .. entIndex, function(ply)
		if IsValid(ply) and IsValid(self) and IsValid(self:GetOwner()) then
			-- Nie pokazuj wykrzykników dla SCP i SPEC
			if ply:GTeam() != TEAM_SCP and ply:GTeam() != TEAM_SPEC then
				self:CreateActionSpot(ply, "voice")
			end
		end
	end)
	
	-- Start vision update timer
	local steamID = owner:SteamID()
	timer.Create("SCP939_MotionVision_" .. steamID, 0.1, 0, function()
		if IsValid(self) and IsValid(owner) then
			self:UpdateMotionVision()
		else
			timer.Remove("SCP939_MotionVision_" .. steamID)
		end
	end)
end

function SWEP:StopMotionVision()
	if not SERVER then return end
	
	local owner = self:GetOwner()
	if IsValid(owner) then
		timer.Remove("SCP939_MotionVision_" .. owner:SteamID())
		
		net.Start("SCP939_ClearVision")
		net.Send(owner)
	end
	
	self.LastPlayerPositions = {}
	self.PlayerVisibility = {}
end

function SWEP:UpdateMotionVision()
	if not SERVER then return end
	
	local owner = self:GetOwner()
	if not IsValid(owner) then return end
	
	local visibilityData = {}
	
	for _, ply in pairs(player.GetAll()) do
		if IsValid(ply) and ply != owner and ply:Alive() then
			if ply:GTeam() != TEAM_SPEC and ply:GTeam() != TEAM_SCP then
				local currentPos = ply:GetPos()
				local lastPos = self.LastPlayerPositions[ply] or currentPos
				local movement = currentPos:Distance(lastPos)
				
				if movement > self.MotionThreshold then
					-- Player is moving - fully visible
					self.PlayerVisibility[ply] = 1
					visibilityData[ply:EntIndex()] = {visible = true, alpha = 255, glow = true}
				else
					-- Player is still - fade out
					self.PlayerVisibility[ply] = math.max(0, (self.PlayerVisibility[ply] or 1) - self.FadeSpeed)
					
					if self.PlayerVisibility[ply] <= 0 then
						visibilityData[ply:EntIndex()] = {visible = false, alpha = 0, glow = false}
					else
						local alpha = math.floor(255 * self.PlayerVisibility[ply])
						visibilityData[ply:EntIndex()] = {visible = true, alpha = alpha, glow = false}
					end
				end
				
				self.LastPlayerPositions[ply] = currentPos
			end
		end
	end
	
	net.Start("SCP939_UpdateVision")
	net.WriteTable(visibilityData)
	net.Send(owner)
end

function SWEP:CreateActionSpot(ply, actionType)
	if not SERVER or not IsValid(ply) or not ply:IsPlayer() then return end
	
	-- Find all SCP-939 players
	for _, scp939Player in pairs(player.GetAll()) do
		if IsValid(scp939Player) and scp939Player:Alive() and scp939Player != ply then
			local wep = scp939Player:GetActiveWeapon()
			if IsValid(wep) and wep:GetClass() == "weapon_scp_939" then
				local distance = scp939Player:GetPos():Distance(ply:GetPos())
				
				if distance <= 8000 then
					net.Start("SCP939_ActionSpot")
					net.WriteVector(ply:GetPos() + Vector(0, 0, 40))
					net.WriteString(actionType)
					net.WriteString(ply:SteamID())
					net.WriteFloat(0.5)
					net.Send(scp939Player)
				end
			end
		end
	end
end

function SWEP:StartHealthRegeneration()
	if not SERVER then return end
	
	local owner = self:GetOwner()
	if not IsValid(owner) then return end
	
	timer.Create("SCP939_HealthRegen_" .. owner:SteamID(), 2, 0, function()
		if IsValid(self) and IsValid(owner) and owner:Alive() then
			local currentHealth = owner:Health()
			local maxHealth = owner:GetNWInt("SCP939_MaxHP", currentHealth)
			
			if currentHealth < (maxHealth * 0.5) and currentHealth > 0 then
				local newHealth = math.min(maxHealth, currentHealth + 2)
				owner:SetHealth(newHealth)
			end
		else
			timer.Remove("SCP939_HealthRegen_" .. (IsValid(owner) and owner:SteamID() or "unknown"))
		end
	end)
end

function SWEP:StopHealthRegeneration()
	if not SERVER then return end
	
	local owner = self:GetOwner()
	if IsValid(owner) then
		timer.Remove("SCP939_HealthRegen_" .. owner:SteamID())
	end
end

-- Funkcje voice lines wyłączone - SCP-939 nie emituje ludzkich dźwięków
--[[
function SWEP:StartVoiceLines()
	if not SERVER then return end
	
	local owner = self:GetOwner()
	if not IsValid(owner) then return end
	
	timer.Create("SCP939_VoiceLines_" .. owner:SteamID(), 30, 0, function()
		if IsValid(self) and IsValid(owner) and owner:Alive() then
			local voiceLines = {
				"vo/npc/male01/help01.wav",
				"vo/npc/male01/question06.wav",
				"vo/npc/male01/question11.wav",
				"vo/npc/male01/question17.wav",
				"vo/npc/male01/question22.wav",
				"vo/npc/male01/question27.wav",
				"vo/npc/female01/help01.wav",
				"vo/npc/female01/question06.wav",
				"vo/npc/female01/question11.wav",
				"vo/npc/female01/question17.wav",
				"vo/npc/female01/question22.wav",
				"vo/npc/female01/question27.wav"
			}
			
			local randomVoice = voiceLines[math.random(1, #voiceLines)]
			owner:EmitSound(randomVoice, 75, math.random(90, 110))
		else
			timer.Remove("SCP939_VoiceLines_" .. (IsValid(owner) and owner:SteamID() or "unknown"))
		end
	end)
end

function SWEP:StopVoiceLines()
	if not SERVER then return end
	
	local owner = self:GetOwner()
	if IsValid(owner) then
		timer.Remove("SCP939_VoiceLines_" .. owner:SteamID())
	end
end
--]]

function SWEP:StartMaxHPCheck()
	if not SERVER then return end
	
	local owner = self:GetOwner()
	if not IsValid(owner) then return end
	
	timer.Create("SCP939_MaxHPCheck_" .. owner:SteamID(), 1, 0, function()
		if IsValid(self) and IsValid(owner) and owner:Alive() then
			local currentHP = owner:Health()
			local savedMaxHP = owner:GetNWInt("SCP939_MaxHP", 0)
			
			if currentHP > savedMaxHP then
				owner:SetNWInt("SCP939_MaxHP", currentHP)
			end
		else
			timer.Remove("SCP939_MaxHPCheck_" .. (IsValid(owner) and owner:SteamID() or "unknown"))
		end
	end)
end

function SWEP:StopMaxHPCheck()
	if not SERVER then return end
	
	local owner = self:GetOwner()
	if IsValid(owner) then
		timer.Remove("SCP939_MaxHPCheck_" .. owner:SteamID())
	end
end

function SWEP:DrawHUD()
	if disablehud == true then return end
	if self.Owner:Team() == TEAM_SPEC then return end
	
	self:DrawSCPHUD()
end

function SWEP:DrawSCPHUD()
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Background
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Border
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Decorative line
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Title
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-939")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-939")
	
	-- Status
	local statusText = ""
	local statusColor = Color(200, 200, 200, 255)
	
	if self:GetIsTracking() then
		statusText = "TRACKING..."
		statusColor = Color(255, 150, 0, 255)
	else
		-- Show voice chat mode
		local vcMode = self:GetVoiceChatAll() and "Voice: ALL" or "Voice: SCP"
		statusText = vcMode .. " [R]"
		statusColor = self:GetVoiceChatAll() and Color(100, 255, 100, 255) or Color(255, 255, 100, 255)
	end
	
	if statusText != "" then
		surface.SetFont("DermaDefaultBold")
		surface.SetTextColor(statusColor.r, statusColor.g, statusColor.b, 255)
		local statusW, statusH = surface.GetTextSize(statusText)
		surface.SetTextPos(centerX - statusW / 2, hudY + 95)
		surface.DrawText(statusText)
	end
	
	-- Cooldowns
	local cooldownY = hudY + 60
	local barWidth = 230
	local barHeight = 8
	local spacing = 20
	local totalWidth = barWidth * 2 + spacing
	local startX = centerX - totalWidth / 2
	
	-- LMB Cooldown (Bite)
	local lmbBarX = startX
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lmbBarX, cooldownY - 15)
	surface.DrawText("LMB - Bite")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
	
	local attackCooldown = 0
	local nextAttack = self:GetNextPrimary()
	if nextAttack > CurTime() then
		attackCooldown = nextAttack - CurTime()
	end
	
	if attackCooldown > 0 then
		local progress = 1 - (attackCooldown / self.Primary.Delay)
		surface.SetDrawColor(255, 100, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", attackCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- RMB Cooldown (Tracking)
	local rmbBarX = startX + barWidth + spacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rmbBarX, cooldownY - 15)
	surface.DrawText("RMB - Detect")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
	
	local trackingCooldown = 0
	local nextTracking = self:GetNextTracking()
	if nextTracking > CurTime() and !self:GetIsTracking() then
		trackingCooldown = nextTracking - CurTime()
	end
	
	if self:GetIsTracking() then
		surface.SetDrawColor(255, 150, 0, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 200, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText("ACTIVE")
	elseif trackingCooldown > 0 then
		local progress = 1 - (trackingCooldown / self.TrackingCooldown)
		surface.SetDrawColor(255, 150, 0, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 200, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", trackingCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- Celownik
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	
	local scale = 0.3
	-- Efekt na celowniku podczas damage boost
	if CurTime() < self:GetDamageBonusEndTime() then
		-- Pulsujący żółty celownik podczas damage boost
		local pulse = math.sin(CurTime() * 8) * 0.5 + 0.5
		surface.SetDrawColor(255, 200 + pulse * 55, 0, 255)
		scale = 0.3 + pulse * 0.1
	elseif CLIENT and self.LastBleedApplication and CurTime() - self.LastBleedApplication < 1 then
		-- Czerwony gdy aplikuje krwawienie
		surface.SetDrawColor(255, 0, 0, 255)
	else
		surface.SetDrawColor(200, 200, 200, 255)
	end
	
	local gap = 5
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )
	
	-- Dodatkowy efekt podczas damage boost
	if CurTime() < self:GetDamageBonusEndTime() then
		local timeLeft = self:GetDamageBonusEndTime() - CurTime()
		local alpha = math.min(255, timeLeft * 100)
		surface.SetDrawColor(255, 200, 0, alpha)
		local extraGap = gap + 10
		local extraLength = extraGap + 25 * scale
		surface.DrawLine( x - extraLength, y, x - extraGap, y )
		surface.DrawLine( x + extraLength, y, x + extraGap, y )
		surface.DrawLine( x, y - extraLength, x, y - extraGap )
		surface.DrawLine( x, y + extraLength, x, y + extraGap )
	end
end

-- Client-side hooks and rendering
if CLIENT then
	local playerOutlines = {}
	local bloodSpots = {}
	local actionSpots = {}
	
	-- Motion vision rendering
	hook.Add("PrePlayerDraw", "SCP939_PlayerVisibility", function(ply)
		local localPly = LocalPlayer()
		if not IsValid(localPly) then return end
		
		local wep = localPly:GetActiveWeapon()
		if not IsValid(wep) or wep:GetClass() != "weapon_scp_939" then return end
		
		if wep.PlayerVisibilityData and wep.PlayerVisibilityData[ply:EntIndex()] then
			local data = wep.PlayerVisibilityData[ply:EntIndex()]
			if not data.visible or data.alpha <= 0 then
				return true
			elseif data.glow then
				ply:SetRenderMode(RENDERMODE_NORMAL)
				ply:SetColor(Color(255, 255, 255, 255))
			elseif data.alpha < 255 then
				ply:SetRenderMode(RENDERMODE_TRANSALPHA)
				ply:SetColor(Color(255, 255, 255, data.alpha))
			else
				ply:SetRenderMode(RENDERMODE_NORMAL)
				ply:SetColor(Color(255, 255, 255, 255))
			end
		else
			ply:SetRenderMode(RENDERMODE_NORMAL)
			ply:SetColor(Color(255, 255, 255, 255))
		end
	end)
	
	-- Renderuj efekt świecenia dla ruszających się graczy (tylko gdy widoczni)
	hook.Add("PostDrawTranslucentRenderables", "SCP939_MotionGlow", function()
		local localPly = LocalPlayer()
		if not IsValid(localPly) then return end
		
		local wep = localPly:GetActiveWeapon()
		if not IsValid(wep) or wep:GetClass() != "weapon_scp_939" then return end
		
		if not wep.PlayerVisibilityData then return end
		
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply != localPly and ply:Alive() then
				local data = wep.PlayerVisibilityData[ply:EntIndex()]
				if data and data.visible and data.glow then
					-- Sprawdź czy gracz jest widoczny (nie za ścianą)
					local trace = util.TraceLine({
						start = localPly:EyePos(),
						endpos = ply:EyePos(),
						filter = {localPly, ply}
					})
					
					if not trace.Hit then
						-- Gracz jest widoczny - renderuj z efektem świecenia
						render.SuppressEngineLighting(true)
						render.SetColorModulation(1, 0.8, 0.8)
						render.SetBlend(0.9)
						render.MaterialOverride(Material("models/debug/debugwhite"))
						
						ply:DrawModel()
						
						-- Dodatkowy obrys
						local mat = Matrix()
						mat:Scale(Vector(1.02, 1.02, 1.02))
						ply:EnableMatrix("RenderMultiply", mat)
						
						render.SetColorModulation(1, 0.5, 0.5)
						render.SetBlend(0.6)
						ply:DrawModel()
						
						ply:DisableMatrix("RenderMultiply")
						
						-- Przywróć ustawienia
						render.MaterialOverride()
						render.SetColorModulation(1, 1, 1)
						render.SetBlend(1)
						render.SuppressEngineLighting(false)
					end
				end
			end
		end
	end)
	
	-- Hook do ukrywania nicków niewidocznych graczy
	hook.Add("HUDDrawTargetID", "SCP939_HideInvisibleNames", function()
		local localPly = LocalPlayer()
		if not IsValid(localPly) then return end
		
		local wep = localPly:GetActiveWeapon()
		if not IsValid(wep) or wep:GetClass() != "weapon_scp_939" then return end
		
		local trace = localPly:GetEyeTrace()
		if not IsValid(trace.Entity) or not trace.Entity:IsPlayer() then return end
		
		-- Sprawdź czy gracz jest widoczny w motion vision
		if wep.PlayerVisibilityData and wep.PlayerVisibilityData[trace.Entity:EntIndex()] then
			local data = wep.PlayerVisibilityData[trace.Entity:EntIndex()]
			if not data.visible or data.alpha <= 0 then
				return false -- Ukryj nick
			end
		end
	end)
	
	-- Network receivers
	net.Receive("SCP939_UpdateVision", function()
		local localPly = LocalPlayer()
		if not IsValid(localPly) then return end
		
		local wep = localPly:GetActiveWeapon()
		if not IsValid(wep) or wep:GetClass() != "weapon_scp_939" then return end
		
		wep.PlayerVisibilityData = net.ReadTable()
	end)
	
	net.Receive("SCP939_ClearVision", function()
		local localPly = LocalPlayer()
		if not IsValid(localPly) then return end
		
		local wep = localPly:GetActiveWeapon()
		if not IsValid(wep) or wep:GetClass() != "weapon_scp_939" then return end
		
		wep.PlayerVisibilityData = {}
		
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply != localPly then
				ply:SetRenderMode(RENDERMODE_NORMAL)
				ply:SetColor(Color(255, 255, 255, 255))
			end
		end
	end)
	
	net.Receive("SCP939_ShowOutline", function()
		local ply = net.ReadEntity()
		local pos = net.ReadVector()
		local duration = net.ReadFloat()
		
		if IsValid(ply) then
			playerOutlines[ply:EntIndex()] = {
				player = ply,
				pos = pos,
				endTime = CurTime() + duration,
				followPlayer = true
			}
		end
	end)
	
	net.Receive("SCP939_ClearOutlines", function()
		playerOutlines = {}
	end)
	
	net.Receive("SCP939_BloodSpot", function()
		local pos = net.ReadVector()
		local duration = net.ReadFloat()
		
		table.insert(bloodSpots, {
			pos = pos,
			endTime = CurTime() + duration,
			intensity = 1
		})
	end)
	
	net.Receive("SCP939_ActionSpot", function()
		local pos = net.ReadVector()
		local actionType = net.ReadString()
		local playerSteamID = net.ReadString()
		local extensionTime = net.ReadFloat()
		
		local localPly = LocalPlayer()
		if not IsValid(localPly) then return end
		
		local wep = localPly:GetActiveWeapon()
		if not IsValid(wep) or wep:GetClass() != "weapon_scp_939" then return end
		
		local foundExisting = false
		for i, spot in ipairs(actionSpots) do
			if spot.playerSteamID == playerSteamID and spot.type == actionType and spot.pos:Distance(pos) < 50 then
				spot.endTime = CurTime() + extensionTime
				spot.pos = pos
				foundExisting = true
				break
			end
		end
		
		if not foundExisting then
			table.insert(actionSpots, {
				pos = pos,
				type = actionType,
				playerSteamID = playerSteamID,
				endTime = CurTime() + extensionTime,
				startTime = CurTime()
			})
		end
	end)
	
	-- Draw outlines
	hook.Add("PostDrawTranslucentRenderables", "SCP939_DrawOutlines", function()
		local localPly = LocalPlayer()
		if not IsValid(localPly) then return end
		
		local wep = localPly:GetActiveWeapon()
		if not IsValid(wep) or wep:GetClass() != "weapon_scp_939" then return end
		
		render.SetStencilEnable(false)
		render.OverrideDepthEnable(true, false)
		cam.IgnoreZ(true)
		
		for entIndex, data in pairs(playerOutlines) do
			if CurTime() < data.endTime then
				local drawPos = data.pos
				if data.followPlayer and IsValid(data.player) then
					drawPos = data.player:GetPos()
				end
				
				local mins = Vector(-16, -16, 0)
				local maxs = Vector(16, 16, 72)
				
				render.SetColorMaterial()
				render.DrawWireframeBox(drawPos, Angle(0, 0, 0), mins, maxs, Color(255, 100, 100, 255), true)
				
				local pulse = math.sin(CurTime() * 3) * 0.3 + 0.7
				render.DrawWireframeBox(drawPos, Angle(0, 0, 0), mins * pulse, maxs * pulse, Color(255, 150, 150, 200), true)
			else
				playerOutlines[entIndex] = nil
			end
		end
		
		cam.IgnoreZ(false)
		render.OverrideDepthEnable(false)
	end)
	
	-- Draw blood spots
	hook.Add("PostDrawTranslucentRenderables", "SCP939_DrawBloodSpots", function()
		local localPly = LocalPlayer()
		if not IsValid(localPly) then return end
		
		local wep = localPly:GetActiveWeapon()
		if not IsValid(wep) or wep:GetClass() != "weapon_scp_939" then return end
		
		render.SetStencilEnable(false)
		render.OverrideDepthEnable(true, false)
		cam.IgnoreZ(true)
		
		for i = #bloodSpots, 1, -1 do
			local spot = bloodSpots[i]
			if CurTime() < spot.endTime then
				local timeLeft = spot.endTime - CurTime()
				local alpha = math.min(255, (timeLeft / 5) * 255)
				local pulse = math.sin(CurTime() * 3) * 0.3 + 0.8
				
				render.SetColorMaterial()
				render.DrawSphere(spot.pos, 15 * pulse, 16, 16, Color(255, 50, 50, alpha))
				render.DrawSphere(spot.pos, 8, 12, 12, Color(255, 0, 0, alpha))
			else
				table.remove(bloodSpots, i)
			end
		end
		
		cam.IgnoreZ(false)
		render.OverrideDepthEnable(false)
	end)
	
	-- Draw action spots
	hook.Add("PostDrawTranslucentRenderables", "SCP939_DrawActionSpots", function()
		local localPly = LocalPlayer()
		if not IsValid(localPly) then return end
		
		local wep = localPly:GetActiveWeapon()
		if not IsValid(wep) or wep:GetClass() != "weapon_scp_939" then return end
		
		render.SetStencilEnable(false)
		render.OverrideDepthEnable(true, false)
		render.SuppressEngineLighting(true)
		cam.IgnoreZ(true)
		
		render.SetColorMaterial()
		
		for i = #actionSpots, 1, -1 do
			local spot = actionSpots[i]
			
			if CurTime() > spot.endTime then
				table.remove(actionSpots, i)
			else
				local color = Color(255, 255, 0, 255) -- yellow
				if spot.type == "shooting" then
					color = Color(255, 150, 0, 255) -- orange
				elseif spot.type == "attack" then
					color = Color(255, 50, 50, 255) -- red
				elseif spot.type == "voice" then
					color = Color(50, 255, 255, 255) -- cyan
				end
				
				local pulse = math.sin(CurTime() * 4) * 0.3 + 0.7
				
				local alpha = 255
				local finalColor = Color(color.r, color.g, color.b, alpha)
				
				local distance = localPly:GetPos():Distance(spot.pos)
				
				local baseSize = 25
				local distanceScale = math.max(1, distance / 1000)
				local size = (baseSize + distanceScale * 10) * pulse
				
				local pos = spot.pos
				
				render.SetColorMaterial()
				render.DrawSphere(pos, size * 0.7, 16, 16, Color(0, 0, 0, alpha * 0.8))
				render.DrawSphere(pos, size * 0.6, 16, 16, finalColor)
				
				-- Exclamation mark
				local lineHeight = size * 0.5
				local lineWidth = size * 0.12
				render.DrawBox(pos + Vector(0, 0, lineHeight * 0.15), Angle(0, 0, 0),
					Vector(-lineWidth/2, -lineWidth/2, -lineHeight/2),
					Vector(lineWidth/2, lineWidth/2, lineHeight/2),
					Color(255, 255, 255, alpha))
				
				local dotSize = size * 0.15
				render.DrawSphere(pos + Vector(0, 0, -size * 0.35), dotSize, 12, 12, Color(255, 255, 255, alpha))
			end
		end
		
		cam.IgnoreZ(false)
		render.OverrideDepthEnable(false)
		render.SuppressEngineLighting(false)
	end)
end

-- Server-side hooks
if SERVER then
	-- Blood detection
	hook.Add("PlayerHurt", "SCP939_BloodDetection", function(victim, attacker, healthRemaining, damageTaken)
		if not IsValid(victim) or not victim:IsPlayer() then return end
		
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply:Alive() and ply != victim then
				local wep = ply:GetActiveWeapon()
				if IsValid(wep) and wep:GetClass() == "weapon_scp_939" then
					local distance = ply:GetPos():Distance(victim:GetPos())
					if distance <= 2500 then
						net.Start("SCP939_BloodSpot")
						net.WriteVector(victim:GetPos() + Vector(0, 0, 20))
						net.WriteFloat(5)
						net.Send(ply)
					end
				end
			end
		end
	end)
	
	-- Attack detection
	if not timer.Exists("SCP939_GlobalAttackCheck") then
		timer.Create("SCP939_GlobalAttackCheck", 0.1, 0, function()
			for _, ply in pairs(player.GetAll()) do
				if IsValid(ply) and ply:Alive() and ply:KeyDown(IN_ATTACK) then
					-- Nie pokazuj wykrzykników dla SCP i SPEC
					if ply:GTeam() != TEAM_SCP and ply:GTeam() != TEAM_SPEC then
						for _, scp939Player in pairs(player.GetAll()) do
							if IsValid(scp939Player) and scp939Player:Alive() and scp939Player != ply then
								local wep = scp939Player:GetActiveWeapon()
								if IsValid(wep) and wep:GetClass() == "weapon_scp_939" then
									local distance = scp939Player:GetPos():Distance(ply:GetPos())
									if distance <= 7000 then
										net.Start("SCP939_ActionSpot")
										net.WriteVector(ply:GetPos() + Vector(0, 0, 40))
										net.WriteString("attack")
										net.WriteString(ply:SteamID())
										net.WriteFloat(0.5)
										net.Send(scp939Player)
									end
								end
							end
						end
					end
				end
			end
		end)
	end
	
	-- Clean up bleeding on death/spawn
	hook.Add("PlayerDeath", "SCP939_ClearBleedOnDeath", function(victim, inflictor, attacker)
		local steamid = victim:SteamID()
		timer.Remove("SCP939_Bleed_" .. steamid)
		
		-- Clean up from all SCP-939 weapons
		for _, ply in pairs(player.GetAll()) do
			local wep = ply:GetActiveWeapon()
			if IsValid(wep) and wep:GetClass() == "weapon_scp_939" then
				if wep.BleedingPlayers then
					wep.BleedingPlayers[steamid] = nil
					wep.BiteCounter[steamid] = nil
				end
			end
		end
	end)
	
	hook.Add("PlayerSpawn", "SCP939_ClearBleedOnSpawn", function(ply)
		local steamid = ply:SteamID()
		timer.Remove("SCP939_Bleed_" .. steamid)
		
		-- Clean up from all SCP-939 weapons
		for _, scp in pairs(player.GetAll()) do
			local wep = scp:GetActiveWeapon()
			if IsValid(wep) and wep:GetClass() == "weapon_scp_939" then
				if wep.BleedingPlayers then
					wep.BleedingPlayers[steamid] = nil
					wep.BiteCounter[steamid] = nil
				end
			end
		end
	end)
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_957.lua
================================================
AddCSLuaFile()

SWEP.Base 			= "weapon_scp_base"
SWEP.PrintName		= "SCP-957"

SWEP.Primary.Delay 	= 8

SWEP.DrawCrosshair	= true
SWEP.HoldType 		= "normal"

-- Nowe zmienne dla slowa
SWEP.Secondary.Delay = 90 -- Cooldown dla slowa
SWEP.SlowRange = 500 -- Zasięg slowa
SWEP.SlowDuration = 2 -- Czas trwania slowa w sekundach
SWEP.SlowAmount = 0.1 -- 90% slow = 10% prędkości

function SWEP:SetupDataTables()
	self:NetworkVar( "Entity", 0, "SCPInstance" )
	-- Nowe zmienne sieciowe dla slowa
	self:NetworkVar("Float", 1, "NextSecondaryFire")
	-- Zmienna dla wyboru podczas preparing
	self:NetworkVar("Bool", 1, "CanSelect")
	-- Zmienna dla wybranego gracza (przed przemianą)
	self:NetworkVar("Entity", 1, "PendingServant")
	-- Zmienna dla drugiego wybranego gracza (backup)
	self:NetworkVar("Entity", 2, "BackupServant")
	-- Flaga dla timera przemiany
	self:NetworkVar("Bool", 2, "TransformationScheduled")
end

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_957" )

	self:SetHoldType(self.HoldType)
	
	-- Inicjalizacja zmiennych slowa
	self:SetNextSecondaryFire(0)
	-- Ustaw możliwość wyboru podczas preparing
	self:SetCanSelect(preparing or false)
	-- Wyczyść wybranych graczy
	self:SetPendingServant(NULL)
	self:SetBackupServant(NULL)
	-- Inicjalizacja flagi dla automatycznego wyboru
	self.CanSelectPrevious = false
end

function SWEP:Think()
	self:PlayerFreeze()
	
	-- Aktualizuj status wyboru podczas preparing
	if SERVER then
		self:SetCanSelect(preparing == true)
		
		-- Automatyczny wybór jeśli preparing się kończy i nie wybrano sług
		if self.CanSelectPrevious and !preparing then
			-- Sprawdź czy nie mamy już wybranych sług
			local pendingServant = self:GetPendingServant()
			local backupServant = self:GetBackupServant()
			
			if (!IsValid(pendingServant) or pendingServant == NULL) and (!IsValid(backupServant) or backupServant == NULL) then
				-- Wybierz losowo dwóch graczy
				local availablePlayers = {}
				for _, ply in pairs(player.GetAll()) do
					-- Sprawdź czy gracz jest ważny, żywy, nie jest właścicielem i nie jest spektatorem
					if IsValid(ply) and ply != self.Owner and ply:Alive() and ply:GTeam() != TEAM_SPEC then
						if ply:GTeam() != TEAM_SCP and !ply.Using714 then
							-- Dodatkowe sprawdzenie - czy gracz rzeczywiście żyje (nie jest obserwatorem)
							if ply:GetObserverMode() == OBS_MODE_NONE then
								table.insert(availablePlayers, ply)
							end
						end
					end
				end
				
				if #availablePlayers >= 2 then
					-- Wybierz dwóch losowych graczy
					local first = table.remove(availablePlayers, math.random(#availablePlayers))
					local second = availablePlayers[math.random(#availablePlayers)]
					
					self:SetPendingServant(first)
					self:SetBackupServant(second)
					
					self.Owner:PrintMessage(HUD_PRINTTALK, "[AUTO] Selected servants: " .. first:Nick() .. " (first) and " .. second:Nick() .. " (backup)")
				elseif #availablePlayers == 1 then
					-- Tylko jeden gracz dostępny
					local first = availablePlayers[1]
					self:SetPendingServant(first)
					
					self.Owner:PrintMessage(HUD_PRINTTALK, "[AUTO] Selected servant: " .. first:Nick() .. " (only one available)")
				else
					-- Brak dostępnych graczy
					self.Owner:PrintMessage(HUD_PRINTTALK, "[AUTO] No available players to select as servants!")
				end
			end
		end
		
		self.CanSelectPrevious = (preparing == true)
	end
	
	if preparing or postround then return end
	if SERVER and IsValid( self.Owner ) then
		-- Usuń automatyczny wybór - teraz tylko manualny podczas preparing

		if self.Instance and !IsValid( self.Instance ) then
			-- Pierwszy SCP-957-1 zginął, sprawdź czy mamy backup
			local backup = self:GetBackupServant()
			if IsValid(backup) and backup:Alive() and backup:GTeam() != TEAM_SCP and backup:GTeam() != TEAM_SPEC and backup:GetObserverMode() == OBS_MODE_NONE then
				-- Przemień backup w SCP-957-1
				local scp = GetSCP( "SCP9571" )
				if scp then
					scp:SetupPlayer( backup )
				end
				
				self.Instance = backup
				self:SetSCPInstance( backup )
				self:SetBackupServant(NULL) -- Wyczyść backup
				
				-- Informacje
				self.Owner:PrintMessage(HUD_PRINTTALK, "Your first servant died! " .. backup:Nick() .. " has been transformed into SCP-957-1!")
				backup:PrintMessage(HUD_PRINTTALK, "The first servant died! You have been transformed into SCP-957-1!")
				
				WinCheck()
			else
				-- Brak backup lub backup martwy/niedostępny - KONIEC, nie ma więcej SCP-957-1
				self.Instance = nil
				self:SetSCPInstance( nil )
				self:SetBackupServant(NULL)
				
				-- Informacja
				self.Owner:PrintMessage(HUD_PRINTTALK, "Both of your servants have died! You have no more SCP-957-1.")
			end
		end

		if IsValid( self.Instance ) then
			if self.Instance:GTeam() != TEAM_SCP then
				-- Sprawdź backup przed czyszczeniem
				local backup = self:GetBackupServant()
				if IsValid(backup) and backup:Alive() and backup:GTeam() != TEAM_SCP and backup:GTeam() != TEAM_SPEC and backup:GetObserverMode() == OBS_MODE_NONE then
					-- Przemień backup w SCP-957-1
					local scp = GetSCP( "SCP9571" )
					if scp then
						scp:SetupPlayer( backup )
					end
					
					self.Instance = backup
					self:SetSCPInstance( backup )
					self:SetBackupServant(NULL) -- Wyczyść backup
					
					-- Informacje o przemianie backup
					self.Owner:PrintMessage(HUD_PRINTTALK, "Your first servant died! " .. backup:Nick() .. " has been transformed into SCP-957-1!")
					backup:PrintMessage(HUD_PRINTTALK, "The first servant died! You have been transformed into SCP-957-1!")
					
					WinCheck()
				else
					-- KONIEC - nie ma więcej SCP-957-1
					self.Instance = nil
					self:SetSCPInstance( nil )
					self:SetBackupServant(NULL)
					
					-- Informacja
					self.Owner:PrintMessage(HUD_PRINTTALK, "Both of your servants have died! You have no more SCP-957-1.")
				end
			end
		end
		
		-- Sprawdź czy preparing się skończył i mamy wybranego gracza
		if self:GetPendingServant() and IsValid(self:GetPendingServant()) and !preparing and !self:GetTransformationScheduled() then
			-- Zaplanuj przemianę za 10 sekund
			self:SetTransformationScheduled(true)
			
			timer.Simple(10, function()
				if IsValid(self) and IsValid(self.Owner) and IsValid(self:GetPendingServant()) then
					local servant = self:GetPendingServant()
					
					-- Sprawdź czy gracz nadal żyje i nie jest spektatorem
					if servant:Alive() and servant:GTeam() != TEAM_SPEC and servant:GetObserverMode() == OBS_MODE_NONE then
												-- Wykonaj przemianę
						local scp = GetSCP( "SCP9571" )
						if scp then
							scp:SetupPlayer( servant )
						end
						
						self.Instance = servant
						self:SetSCPInstance( servant )
						
						-- Informacje o przemianie
						self.Owner:PrintMessage(HUD_PRINTTALK, servant:Nick() .. " has been transformed into SCP-957-1!")
						servant:PrintMessage(HUD_PRINTTALK, "You have been transformed into SCP-957-1!")
						
						-- Wyczyść wybranego gracza
						self:SetPendingServant(NULL)
						self:SetTransformationScheduled(false)
						
						WinCheck()
					else
						-- Gracz już nie żyje lub jest spektatorem
						self.Owner:PrintMessage(HUD_PRINTTALK, "Cannot transform " .. servant:Nick() .. " - player is dead or spectating!")
						self:SetPendingServant(NULL)
						self:SetTransformationScheduled(false)
					end
				else
					-- Coś poszło nie tak, resetuj flagę
					if IsValid(self) then
						self:SetTransformationScheduled(false)
					end
				end
			end)
			
			-- Informacja o opóźnieniu
			self.Owner:PrintMessage(HUD_PRINTTALK, "Transformation will occur in 10 seconds...")
		end
	end

	if CLIENT then
		self.Instance = self:GetSCPInstance()
	end
end

SWEP.NextPrimary = 0
function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if CurTime() < self.NextPrimary then return end
	self.NextPrimary = CurTime() + self.Primary.Delay

	-- Podczas preparing, LPM służy do wyboru SCP-957-1
	if self:GetCanSelect() and SERVER and IsValid( self.Owner ) then
		local tr = util.TraceLine({
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 200,
			filter = self.Owner,
			mask = MASK_SHOT
		})
		
		local ent = tr.Entity
		if IsValid(ent) and ent:IsPlayer() then
			-- Sprawdź czy gracz nie jest spektatorem, SCP, nie używa 714 i rzeczywiście żyje
			if ent:GTeam() != TEAM_SPEC and ent:GTeam() != TEAM_SCP and !ent.Using714 and ent:Alive() and ent:GetObserverMode() == OBS_MODE_NONE then
				-- Zaznacz tego gracza jako przyszłego SCP-957-1 (przemiana po preparing)
				self:SetPendingServant(ent)
				
				-- Informacja tylko dla SCP-957
				self.Owner:PrintMessage(HUD_PRINTTALK, "You have chosen " .. ent:Nick() .. " as SCP-957-1! Transformation will occur after preparing phase.")
			else
				-- Informacja o tym, dlaczego nie można wybrać tego gracza
				if ent:GTeam() == TEAM_SPEC then
					self.Owner:PrintMessage(HUD_PRINTTALK, "Cannot select " .. ent:Nick() .. " - player is a spectator!")
				elseif ent:GTeam() == TEAM_SCP then
					self.Owner:PrintMessage(HUD_PRINTTALK, "Cannot select " .. ent:Nick() .. " - player is already an SCP!")
				elseif ent.Using714 then
					self.Owner:PrintMessage(HUD_PRINTTALK, "Cannot select " .. ent:Nick() .. " - player is using SCP-714!")
				elseif !ent:Alive() or ent:GetObserverMode() != OBS_MODE_NONE then
					self.Owner:PrintMessage(HUD_PRINTTALK, "Cannot select " .. ent:Nick() .. " - player is dead or observing!")
				end
			end
		end
	elseif !self:GetCanSelect() and SERVER and IsValid( self.Owner ) then
		-- Normalny atak AOE po rundzie
		local fent = ents.FindInSphere( self.Owner:GetPos(), 1000 )
		local plys = {}
		for k, v in pairs( fent ) do
			if IsValid( v ) and v:IsPlayer() then
				if v:GTeam() != TEAM_SPEC and v:GTeam() != TEAM_SCP and !v.Using714 and v:Alive() and v:GetObserverMode() == OBS_MODE_NONE then
					table.insert( plys, v )
					v.scp173allow = true
					Timer( "957Timer_"..v:SteamID64(), 1, 5, function( s, n )
						if !IsValid( self ) or !IsValid( self.Owner ) or !IsValid( v ) or v:GTeam() == TEAM_SPEC or v:GTeam() == TEAM_SCP or v.Using714 then
							s:Destroy()
							net.Start( "957Effect" )
								net.WriteBool( false )
							net.Send( plys )
							v.scp173allow = false
							return
						end


						if self:BuffEnabled() then
							local shp = math.Clamp( self.Owner:Health() + 2, 0, self.Owner:GetMaxHealth() )
							self.Owner:SetHealth( shp )
							if IsValid( self.Instance ) then
								local hp = math.Clamp( self.Instance:Health() + 2, 0, self.Instance:GetMaxHealth() )
								self.Instance:SetHealth( hp )
							end
						end

						v:TakeDamage( 3, self.Owner, self )
					end, function()
						v.scp173allow = false
					end )
				end
			end
		end
		if #plys > 0 then
			net.Start( "957Effect" )
				net.WriteBool( true )
			net.Send( plys )
		end
	end
end

-- Nowa funkcja SecondaryAttack - slow
function SWEP:SecondaryAttack()
	if preparing or postround then return end
	
	local nextFire = self:GetNextSecondaryFire()
	if nextFire > CurTime() then return end
	
	if !SERVER then return end
	
	-- Znajdź cel w zasięgu
	local target = nil
	local nearestDist = self.SlowRange
	
	for _, ply in pairs(player.GetAll()) do
		if IsValid(ply) and ply:Alive() and ply != self.Owner then
			if ply:GTeam() != TEAM_SPEC and ply:GTeam() != TEAM_SCP and !ply.Using714 then
				local dist = self.Owner:GetPos():Distance(ply:GetPos())
				if dist < nearestDist then
					-- Sprawdź czy gracz jest widoczny
					local tr = util.TraceLine({
						start = self.Owner:GetShootPos(),
						endpos = ply:GetShootPos(),
						filter = {self.Owner, self},
						mask = MASK_SHOT
					})
					
					if tr.Entity == ply then
						nearestDist = dist
						target = ply
					end
				end
			end
		end
	end
	
	if IsValid(target) then
		-- Zastosuj slow
		self:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
		

		
		-- Spowolnienie celu (90% slow)
		if not target.SCP957_OriginalWalkSpeed then
			target.SCP957_OriginalWalkSpeed = target:GetWalkSpeed()
			target.SCP957_OriginalRunSpeed = target:GetRunSpeed()
		end
		target:SetWalkSpeed(target.SCP957_OriginalWalkSpeed * self.SlowAmount)
		target:SetRunSpeed(target.SCP957_OriginalRunSpeed * self.SlowAmount)
		
		-- Timer do zakończenia slowa
		timer.Create("SCP957_Slow_" .. target:SteamID64(), self.SlowDuration, 1, function()
			if IsValid(target) and target.SCP957_OriginalWalkSpeed then
				target:SetWalkSpeed(target.SCP957_OriginalWalkSpeed)
				target:SetRunSpeed(target.SCP957_OriginalRunSpeed)
				target.SCP957_OriginalWalkSpeed = nil
				target.SCP957_OriginalRunSpeed = nil
			end
		end)
		
		-- Komunikat dla celu
		target:PrintMessage(HUD_PRINTCENTER, "You have been slowed by SCP-957!")
	else
		-- Brak celu - krótszy cooldown
		self:SetNextSecondaryFire(CurTime() + 5)
		self.Owner:EmitSound("buttons/button10.wav")
	end
end


function SWEP:BuffEnabled()
	if IsValid( self.Owner ) and IsValid( self.Instance ) then
		if self.Owner:GetPos():DistToSqr( self.Instance:GetPos() ) < 62500 then
			return true
		end
	end
end

-- Klawisz R - otwiera menu wyboru SCP-957-1 podczas preparing
function SWEP:Reload()
	if CLIENT and self:GetCanSelect() and !IsValid(self.Instance) then
		-- Sprawdź czy mamy już wybranych obu
		local pending = self:GetPendingServant()
		local backup = self:GetBackupServant()
		if IsValid(pending) and IsValid(backup) then
			-- Już wybrano obu
			return
		end
		self:OpenSelectionMenu()
	end
end

-- CLIENT SIDE - Menu wyboru
if CLIENT then
	function SWEP:OpenSelectionMenu()
		if IsValid(self.SelectionMenu) then
			self.SelectionMenu:Remove()
		end
		
		-- Sprawdź co wybieramy
		local pending = self:GetPendingServant()
		local backup = self:GetBackupServant()
		local selectingFirst = !IsValid(pending)
		local titleText = selectingFirst and "SCP-957 - Select Your FIRST Servant" or "SCP-957 - Select Your BACKUP Servant"
		
		self.SelectionMenu = vgui.Create("DFrame")
		self.SelectionMenu:SetSize(650, 550)
		self.SelectionMenu:Center()
		self.SelectionMenu:SetTitle(titleText)
		self.SelectionMenu:SetDraggable(true)
		self.SelectionMenu:ShowCloseButton(true)
		self.SelectionMenu:MakePopup()
		
		-- Panel główny
		local mainPanel = vgui.Create("DPanel", self.SelectionMenu)
		mainPanel:Dock(FILL)
		mainPanel.Paint = function(self, w, h)
			draw.RoundedBox(0, 0, 0, w, h, Color(40, 40, 40, 255))
		end
		
		-- Nagłówek
		local header = vgui.Create("DLabel", mainPanel)
		local headerText = selectingFirst and "Choose your FIRST servant (will transform after preparing)" or "Choose your BACKUP servant (will transform if first dies)"
		header:SetText(headerText)
		header:SetFont("DermaLarge")
		header:SetTextColor(selectingFirst and Color(200, 200, 200, 255) or Color(255, 255, 100, 255))
		header:Dock(TOP)
		header:DockMargin(10, 10, 10, 10)
		header:SetContentAlignment(5)
		
		-- Lista graczy
		local playerScroll = vgui.Create("DScrollPanel", mainPanel)
		playerScroll:Dock(FILL)
		playerScroll:DockMargin(5, 5, 5, 5)
		
		-- Zbierz graczy którzy mogą być wybrani
		local availablePlayers = {}
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) and ply != self.Owner then
				if ply:GTeam() != TEAM_SPEC and ply:GTeam() != TEAM_SCP and !ply.Using714 then
					-- Nie pokazuj gracza który już został wybrany
					if ply != pending and ply != backup then
						table.insert(availablePlayers, ply)
					end
				end
			end
		end
		
		-- Sortuj po nazwie
		table.sort(availablePlayers, function(a, b)
			return a:Nick() < b:Nick()
		end)
		
		-- Utwórz panele dla każdego gracza
		for i, ply in ipairs(availablePlayers) do
			local playerPanel = vgui.Create("DPanel", playerScroll)
			playerPanel:SetSize(620, 100)
			playerPanel:Dock(TOP)
			playerPanel:DockMargin(5, 5, 5, 5)
			playerPanel.Paint = function(self, w, h)
				draw.RoundedBox(4, 0, 0, w, h, Color(60, 60, 60, 255))
				if self:IsHovered() then
					draw.RoundedBox(4, 0, 0, w, h, Color(80, 80, 80, 255))
				end
			end
			
			-- Model gracza
			local modelPanel = vgui.Create("DModelPanel", playerPanel)
			modelPanel:SetSize(100, 100)
			modelPanel:Dock(LEFT)
			modelPanel:SetModel(ply:GetModel())
			modelPanel:SetFOV(45)
			modelPanel:SetCamPos(Vector(50, 50, 50))
			modelPanel:SetLookAt(Vector(0, 0, 40))
			
			function modelPanel:LayoutEntity(Entity) return end
			
			-- Informacje o graczu
			local infoPanel = vgui.Create("DPanel", playerPanel)
			infoPanel:Dock(FILL)
			infoPanel:DockMargin(10, 10, 10, 10)
			infoPanel.Paint = function() end
			
			-- Nazwa gracza
			local nameLabel = vgui.Create("DLabel", infoPanel)
			nameLabel:SetText(ply:Nick())
			nameLabel:SetFont("DermaLarge")
			nameLabel:SetTextColor(Color(255, 255, 255, 255))
			nameLabel:Dock(TOP)
			
			-- Rola gracza
			local roleLabel = vgui.Create("DLabel", infoPanel)
			roleLabel:SetText("Current Role: " .. GetLangRole(ply:GetNClass()))
			roleLabel:SetFont("DermaDefault")
			roleLabel:SetTextColor(Color(180, 180, 180, 255))
			roleLabel:Dock(TOP)
			roleLabel:DockMargin(0, 5, 0, 0)
			
			-- Przycisk wyboru
			local selectBtn = vgui.Create("DButton", playerPanel)
			selectBtn:SetText("SELECT")
			selectBtn:SetSize(100, 80)
			selectBtn:Dock(RIGHT)
			selectBtn:DockMargin(10, 10, 10, 10)
			selectBtn:SetFont("DermaDefaultBold")
			selectBtn.DoClick = function()
				net.Start("SCP957_SelectServant")
					net.WriteEntity(ply)
					net.WriteBool(selectingFirst) -- Czy wybieramy pierwszego
				net.SendToServer()
				self.SelectionMenu:Close()
				-- Dźwięk wyboru
				surface.PlaySound("buttons/button14.wav")
				
				-- Jeśli wybraliśmy pierwszego, otwórz menu dla drugiego
				if selectingFirst then
					timer.Simple(0.1, function()
						if IsValid(self) then
							self:OpenSelectionMenu()
						end
					end)
				end
			end
			selectBtn.Paint = function(self, w, h)
				local col = Color(100, 200, 100, 255)
				if self:IsHovered() then
					col = Color(150, 255, 150, 255)
				end
				draw.RoundedBox(4, 0, 0, w, h, col)
			end
		end
		
		-- Jeśli brak graczy
		if #availablePlayers == 0 then
			local noPlayersLabel = vgui.Create("DLabel", playerScroll)
			noPlayersLabel:SetText("No available players to select")
			noPlayersLabel:SetFont("DermaLarge")
			noPlayersLabel:SetTextColor(Color(255, 100, 100, 255))
			noPlayersLabel:SetContentAlignment(5)
			noPlayersLabel:Dock(TOP)
			noPlayersLabel:SetTall(100)
		end
	end
end

-- SERVER SIDE - Net messages
if SERVER then
	util.AddNetworkString("SCP957_SelectServant")
	
	net.Receive("SCP957_SelectServant", function(len, ply)
		if !IsValid(ply) then return end
		
		local wep = ply:GetActiveWeapon()
		if !IsValid(wep) or wep:GetClass() != "weapon_scp_957" then return end
		if !wep:GetCanSelect() then return end
		if IsValid(wep.Instance) then return end
		
		local target = net.ReadEntity()
		local isFirst = net.ReadBool()
		
		if !IsValid(target) or !target:IsPlayer() then return end
					if target:GTeam() == TEAM_SPEC or (target:GTeam() == TEAM_SCP and target:GetNClass() != ROLES.ROLE_SCP035) or target.Using714 then return end
		
		if isFirst then
			-- Zaznacz gracza jako pierwszego sługę
			wep:SetPendingServant(target)
			
			-- Informacja tylko dla SCP-957
			ply:PrintMessage(HUD_PRINTTALK, "You have chosen " .. target:Nick() .. " as your FIRST servant! They will transform after preparing phase.")
		else
			-- Zaznacz gracza jako backup
			wep:SetBackupServant(target)
			
			-- Informacja tylko dla SCP-957
			ply:PrintMessage(HUD_PRINTTALK, "You have chosen " .. target:Nick() .. " as your BACKUP servant! They will transform if the first one dies.")
		end
	end)
end

function SWEP:Holster()
	if CLIENT and IsValid(self.ModelPanel) then
		self.ModelPanel:Remove()
		self.ModelPanel = nil
	end
	
	return true
end

function SWEP:OnRemove()
	-- Hook do resetowania prędkości graczy
	if SERVER then
		hook.Add("PlayerSpawn", "SCP957_ResetSpeed", function(ply)
			if ply.SCP957_OriginalWalkSpeed then
				ply:SetWalkSpeed(ply.SCP957_OriginalWalkSpeed)
				ply:SetRunSpeed(ply.SCP957_OriginalRunSpeed)
				ply.SCP957_OriginalWalkSpeed = nil
				ply.SCP957_OriginalRunSpeed = nil
			end
		end)
	end
	
	if CLIENT and IsValid(self.ModelPanel) then
		self.ModelPanel:Remove()
		self.ModelPanel = nil
	end
end

-- HUD dokładnie w stylu SCP-069
function SWEP:DrawHUD()
	if disablehud == true then return end
	
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Tło HUD
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Obramowanie
	surface.SetDrawColor(100, 100, 100, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Linia dekoracyjna
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP
	surface.SetFont("DermaLarge")
	surface.SetTextColor(200, 200, 200, 255)
	local titleW, titleH = surface.GetTextSize("SCP-957")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-957")
	
	-- Jeśli preparing - pokaż info o wyborze
	if self:GetCanSelect() then
		local pendingServant = self:GetPendingServant()
		local backupServant = self:GetBackupServant()
		
		if !IsValid(pendingServant) then
			-- Nie wybrano jeszcze pierwszego
			surface.SetFont("DermaLarge")
			surface.SetTextColor(255, 255, 100, 255)
			local selectText = "Press R to select your FIRST servant"
			local tw, th = surface.GetTextSize(selectText)
			surface.SetTextPos(centerX - tw/2, hudY + 45)
			surface.DrawText(selectText)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(200, 200, 200, 255)
			local instructText = "Choose two players - first will transform, second is backup"
			tw, th = surface.GetTextSize(instructText)
			surface.SetTextPos(centerX - tw/2, hudY + 75)
			surface.DrawText(instructText)
		elseif !IsValid(backupServant) then
			-- Wybrano pierwszego, czeka na drugiego
			surface.SetFont("DermaDefault")
			surface.SetTextColor(100, 255, 100, 255)
			local selectText = "First: " .. pendingServant:Nick()
			local tw, th = surface.GetTextSize(selectText)
			surface.SetTextPos(centerX - tw/2, hudY + 40)
			surface.DrawText(selectText)
			
			surface.SetFont("DermaLarge")
			surface.SetTextColor(255, 255, 100, 255)
			selectText = "Press R to select BACKUP servant"
			tw, th = surface.GetTextSize(selectText)
			surface.SetTextPos(centerX - tw/2, hudY + 60)
			surface.DrawText(selectText)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(200, 200, 200, 255)
			local instructText = "Backup will transform if first servant dies"
			tw, th = surface.GetTextSize(instructText)
			surface.SetTextPos(centerX - tw/2, hudY + 90)
			surface.DrawText(instructText)
		else
			-- Wybrano obu
			surface.SetFont("DermaDefault")
			surface.SetTextColor(100, 255, 100, 255)
			local selectText = "First: " .. pendingServant:Nick()
			local tw, th = surface.GetTextSize(selectText)
			surface.SetTextPos(centerX - tw/2, hudY + 40)
			surface.DrawText(selectText)
			
			surface.SetTextColor(255, 255, 100, 255)
			selectText = "Backup: " .. backupServant:Nick()
			tw, th = surface.GetTextSize(selectText)
			surface.SetTextPos(centerX - tw/2, hudY + 60)
			surface.DrawText(selectText)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(200, 200, 200, 255)
			local instructText = "Transformation will occur after preparing phase"
			tw, th = surface.GetTextSize(instructText)
			surface.SetTextPos(centerX - tw/2, hudY + 85)
			surface.DrawText(instructText)
		end
		return
	end
	
	-- Cooldowny
	local lpmCooldown = 0
	local ppmCooldown = 0
	
	if self.NextPrimary and self.NextPrimary > CurTime() then
		lpmCooldown = self.NextPrimary - CurTime()
	end
	
	local nextSecondary = self:GetNextSecondaryFire()
	if nextSecondary > CurTime() then
		ppmCooldown = nextSecondary - CurTime()
	end
	
	local cooldownY = hudY + 60
	local barWidth = 120
	local barHeight = 8
	local barSpacing = 20
	
	-- LMB Cooldown
	local lpmBarX = centerX - barWidth - barSpacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lpmBarX, cooldownY - 15)
	surface.DrawText("LMB - AOE")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lpmBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lpmBarX, cooldownY, barWidth, barHeight)
	
	if lpmCooldown > 0 then
		local progress = 1 - (lpmCooldown / self.Primary.Delay)
		surface.SetDrawColor(255, 100, 100, 255)
		surface.DrawRect(lpmBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 150, 150, 255)
		surface.SetTextPos(lpmBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", lpmCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(lpmBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(lpmBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- RMB Cooldown
	local ppmBarX = centerX + barSpacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(ppmBarX, cooldownY - 15)
	surface.DrawText("RMB - Slow")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(ppmBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(ppmBarX, cooldownY, barWidth, barHeight)
	
	if ppmCooldown > 0 then
		local progress = 1 - (ppmCooldown / self.Secondary.Delay)
		surface.SetDrawColor(100, 150, 255, 255)
		surface.DrawRect(ppmBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 200, 255, 255)
		surface.SetTextPos(ppmBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", ppmCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(ppmBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(ppmBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- Box SCP-957-1 po prawej stronie
	if IsValid(self.Instance) then
		local boxX = ScrW() - 240
		local boxY = ScrH() / 2 - 150
		local boxW = 220
		local boxH = 300
		
		-- Tło
		surface.SetDrawColor(20, 20, 20, 180)
		surface.DrawRect(boxX - 5, boxY - 5, boxW + 10, boxH + 10)
		
		surface.SetDrawColor(100, 100, 100, 200)
		surface.DrawOutlinedRect(boxX - 5, boxY - 5, boxW + 10, boxH + 10)
		
		-- 1. DISTANCE (na górze)
		local playerPos = ply:GetPos()
		local servantPos = self.Instance:GetPos()
		local distance = math.Round(playerPos:Distance(servantPos))
		surface.SetFont("DermaDefaultBold")
		surface.SetTextColor(255, 255, 255, 255)
		local distText = distance .. "m"
		local tw, th = surface.GetTextSize(distText)
		surface.SetTextPos(boxX + boxW/2 - tw/2, boxY + 10)
		surface.DrawText(distText)
		
		-- 2. MODEL RENDER
		if !IsValid(self.ModelPanel) then
			self.ModelPanel = vgui.Create("DModelPanel")
			self.ModelPanel:SetSize(150, 150)
			self.ModelPanel:SetPos(boxX + boxW/2 - 75, boxY + 35)
			self.ModelPanel:SetModel(self.Instance:GetModel())
			self.ModelPanel:SetFOV(35)
			self.ModelPanel:SetCamPos(Vector(80, 0, 60))
			self.ModelPanel:SetLookAt(Vector(0, 0, 40))
			self.ModelPanel:SetAmbientLight(Color(50, 50, 50))
			self.ModelPanel:SetDirectionalLight(BOX_TOP, Color(255, 255, 255))
			self.ModelPanel.LayoutEntity = function(panel, ent)
				ent:SetAngles(Angle(0, RealTime() * 30, 0))
			end
		else
			-- Aktualizuj model jeśli się zmienił
			if self.ModelPanel:GetModel() != self.Instance:GetModel() then
				self.ModelPanel:SetModel(self.Instance:GetModel())
			end
		end
		
		-- 3. HEALTHBAR (bezpośrednio pod modelem)
		local healthY = boxY + 190
		local healthPercent = self.Instance:Health() / self.Instance:GetMaxHealth()
		local healthBarWidth = 180
		local healthBarHeight = 6
		local healthBarX = boxX + 20
		
		-- Tło paska
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(healthBarX, healthY, healthBarWidth, healthBarHeight)
		
		-- Pasek życia
		local healthColor = Color(255 * (1 - healthPercent), 255 * healthPercent, 0, 255)
		surface.SetDrawColor(healthColor)
		surface.DrawRect(healthBarX, healthY, healthBarWidth * healthPercent, healthBarHeight)
		
		-- Obramowanie
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(healthBarX, healthY, healthBarWidth, healthBarHeight)
		
		-- 4. NICK - ROLA
		surface.SetFont("DermaDefaultBold")
		surface.SetTextColor(255, 255, 255, 255)
		local nick = self.Instance:Nick()
		if string.len(nick) > 18 then
			nick = string.sub(nick, 1, 15) .. "..."
		end
		local nameText = nick .. " - " .. GetLangRole(self.Instance:GetLastRole())
		tw, th = surface.GetTextSize(nameText)
		surface.SetTextPos(boxX + boxW/2 - tw/2, healthY + 15)
		surface.DrawText(nameText)
		
		-- 5. BUFF STATUS
		surface.SetFont("DermaDefault")
		if self:BuffEnabled() then
			surface.SetTextColor(0, 255, 0, 255)
			text = "BUFF ACTIVE"
		else
			surface.SetTextColor(255, 100, 100, 255)
			text = "BUFF INACTIVE"
		end
		tw, th = surface.GetTextSize(text)
		surface.SetTextPos(boxX + boxW/2 - tw/2, healthY + 35)
		surface.DrawText(text)
		
		-- 6. BACKUP ALIVE OR NOT
		local backupServant = self:GetBackupServant()
		if IsValid(backupServant) and backupServant != NULL then
			surface.SetFont("DermaDefaultBold")
			surface.SetTextColor(255, 255, 100, 255)
			
			-- Sprawdzamy status backup
			local backupText = "Backup: "
			if backupServant:Alive() and backupServant:GTeam() != TEAM_SPEC then
				surface.SetTextColor(100, 255, 100, 255)
				backupText = backupText .. "ALIVE"
			else
				surface.SetTextColor(255, 100, 100, 255)
				backupText = backupText .. "DEAD"
			end
			
			tw, th = surface.GetTextSize(backupText)
			surface.SetTextPos(boxX + boxW/2 - tw/2, healthY + 95)
			surface.DrawText(backupText)
		end
		
	else
		-- Usuń panel modelu jeśli istnieje
		if IsValid(self.ModelPanel) then
			self.ModelPanel:Remove()
			self.ModelPanel = nil
		end
		
		-- Nie ma SCP-957-1 i nie ma już backup
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 100, 100, 255)
		local noServantText = "No SCP-957-1 available"
		local tw, th = surface.GetTextSize(noServantText)
		surface.SetTextPos(centerX - tw/2, hudY + 95)
		surface.DrawText(noServantText)
	end
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_966.lua
================================================
AddCSLuaFile()

SWEP.Base 			= "weapon_scp_base"
SWEP.PrintName		= "SCP-966"

SWEP.DrawCrosshair	= true
SWEP.HoldType		= "normal"

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("breach/wep_966")
end

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_966" )

	self:SetHoldType(self.HoldType)
end

SWEP.NextSpec 	= 0
SWEP.SpecDelay = 1
function SWEP:Think()
	if postround then return end
	if self.NextSpec > CurTime() then return end
	self.NextSpec = CurTime() + self.SpecDelay
	if SERVER then
		local ent = ents.FindInSphere( self.Owner:GetPos(), 200 )
		local gplayers = {}
	
		for k, v in pairs( player.GetAll() ) do
			if v:IsPlayer() then 
				if v.mblur == true then
					if !self:isAny(v, ent) then
						v.mblur = false
					end
				end
			end
		end
	
		for k, v in pairs( ent ) do
			if v:IsPlayer() then 
				if v.mblur == nil then v.mblur = false end	
				if !( v:GTeam() == TEAM_SCP or v:GTeam() == TEAM_SPEC or v.Using714 ) then
					table.ForceInsert(gplayers, v)
				end
			end
		end
		if ( #gplayers > 0 ) then
			for k, v in pairs( gplayers ) do
				if v:Alive() then
					v:TakeDamage(4, self.Owner, self.Owner)
					v.mblur = true
				end
			end
		end
	end
end

function SWEP:isAny(ittf, allit)
	for k, v in pairs( allit ) do
		if (v == ittf) then return true end
	end
	return false
end

SWEP.AttackDelay			= 0.8
SWEP.NextAttackW			= 0
function SWEP:PrimaryAttack()
	if not IsFirstTimePredicted() then return end
	if self.NextAttackW > CurTime() then return end
	self.NextAttackW = CurTime() + self.AttackDelay
	if SERVER then
		local ent = nil
		local hullsize = 20
		local tr = util.TraceHull( {
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + ( self.Owner:GetAimVector() * 160 ),
			filter = self.Owner,
			mins = Vector( -hullsize, -hullsize, -hullsize ),
			maxs = Vector( hullsize, hullsize, hullsize ),
			mask = MASK_SHOT_HULL
		} )
		ent = tr.Entity
		if IsValid(ent) then
			--if ent:IsPlayer() then
				--if ent:GTeam() == TEAM_SPEC then return end
				--if ent:GTeam() == TEAM_SCP then return end
				--if ent:Alive() then
				--	ent:TakeDamage( 48, self.Owner, self.Owner )
				--	self.Owner:EmitSound("Damage4.ogg")
			--end
			--else
				self:SCPDamageEvent( ent, 10 )
			--end
		end
	end
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_999.lua
================================================
AddCSLuaFile()

SWEP.Base 				= "weapon_scp_base"
SWEP.PrintName			= "SCP999"			

SWEP.Primary.Delay 		= 2
SWEP.Secondary.Delay 	= 5

SWEP.DrawCrosshair		= true
SWEP.HoldType 			= ""

function SWEP:SetupDataTables()
	self:NetworkVar("Float", 0, "NextPrimary")
	self:NetworkVar("Float", 1, "NextSecondary")
end

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_999" )

	self:SetHoldType(self.HoldType)
	
	-- Initialize cooldowns
	self:SetNextPrimary(0)
	self:SetNextSecondary(0)
end

function SWEP:DrawWorldModel()
	-- Nie rysuj modelu broni
end

function SWEP:DrawWorldModelTranslucent()
	-- Nie rysuj modelu broni
end

function SWEP:DrawViewModel()
	-- Nie rysuj viewmodelu
end

function SWEP:PreDrawViewModel()
	return true -- Zapobiega rysowaniu
end

function SWEP:ViewModelDrawn()
	-- Nic nie rób
end

function SWEP:GetViewModelPosition(pos, ang)
	return pos, ang
end

SWEP.ShowViewModel = false
SWEP.ShowWorldModel = false

function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if CurTime() < self:GetNextPrimary() then return end
	self:SetNextPrimary(CurTime() + self.Primary.Delay)
	if SERVER then
		local tr = util.TraceHull({
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 150,
			maxs = Vector(10, 10, 10),
			mins = Vector(-10, -10, -10),
			filter = self.Owner,
			mask = MASK_SHOT
		})
		local ent = tr.Entity
		if !IsValid(ent) then return end
		if ent:IsPlayer() then
			if ent:GTeam() != TEAM_SPEC then
				if ent:Health() == ent:GetMaxHealth() then return end
				local hp = ent:Health() + math.random(5, 10)
				if hp > ent:GetMaxHealth() then hp = ent:GetMaxHealth() end
				self.Owner:AddExp(20, false)
				ent:SetHealth(hp)
			end
		else
			self:SCPDamageEvent( ent, 10 )
		end
	end
end

function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if CurTime() < self:GetNextSecondary() then return end
	self:SetNextSecondary(CurTime() + self.Secondary.Delay)
	if SERVER then
		local fent = ents.FindInSphere(self.Owner:GetPos(), 300)
		local hp = 0
		local totalheal = 0
		for k, v in pairs(fent) do
			if v:IsPlayer() then
				if v:GTeam() != TEAM_SPEC and v != self.Owner then
					hp = v:Health() + math.random(5, 15)
					if hp > v:GetMaxHealth() then hp = v:GetMaxHealth() end
					totalheal = totalheal + (hp - v:Health())
					v:SetHealth(hp)
					hp = 0
				end
			end
		end
		if totalheal > 0 then self.Owner:AddExp(totalheal, false) end
	end
end

function SWEP:Deploy()
	if IsValid( self.Owner ) then
		self.Owner:SetCustomCollisionCheck( true )
		self.Owner:DrawViewModel( false )
		-- Dodaj flagę identyfikującą SCP-999
		self.Owner.SCP999Active = true
	end
	return true
end

function SWEP:OnRemove()
	if IsValid( self.Owner ) then
		self.Owner:SetCustomCollisionCheck( false )
		-- Usuń flagę
		self.Owner.SCP999Active = false
	end
end

function SWEP:Holster()
	if IsValid( self.Owner ) then
		self.Owner:SetCustomCollisionCheck( false )
		-- Usuń flagę
		self.Owner.SCP999Active = false
	end
	return true
end

function SWEP:DrawHUD()
	if disablehud == true then return end
	if self.Owner:Team() == TEAM_SPEC then return end
	
	self:DrawSCPHUD()
end

function SWEP:DrawSCPHUD()
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local centerX = ScrW() / 2
	local centerY = ScrH() / 2
	local hudY = ScrH() - 150
	
	local hudWidth = 500
	local hudHeight = 120
	local hudX = centerX - hudWidth / 2
	
	-- Funkcja pomocnicza do generowania koloru tęczy
	local function getRainbowColor(speed)
		speed = speed or 1
		local time = CurTime() * speed
		local r = math.sin(time) * 127 + 128
		local g = math.sin(time + 2) * 127 + 128
		local b = math.sin(time + 4) * 127 + 128
		return Color(r, g, b, 255)
	end
	
	-- Tło HUD
	surface.SetDrawColor(20, 20, 20, 180)
	surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Tęczowe obramowanie
	local rainbowColor = getRainbowColor(2)
	surface.SetDrawColor(rainbowColor.r, rainbowColor.g, rainbowColor.b, 200)
	surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
	
	-- Tęczowa linia dekoracyjna
	surface.SetDrawColor(rainbowColor.r, rainbowColor.g, rainbowColor.b, 255)
	surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
	
	-- Tytuł SCP z efektem tęczy
	surface.SetFont("DermaLarge")
	surface.SetTextColor(rainbowColor.r, rainbowColor.g, rainbowColor.b, 255)
	local titleW, titleH = surface.GetTextSize("SCP-999")
	surface.SetTextPos(centerX - titleW / 2, hudY + 10)
	surface.DrawText("SCP-999")
	
	-- Cooldowny
	local cooldownY = hudY + 60
	local barWidth = 230
	local barHeight = 8
	local spacing = 20
	local totalWidth = barWidth * 2 + spacing
	local startX = centerX - totalWidth / 2
	
	-- LMB Cooldown (Heal)
	local lmbBarX = startX
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(lmbBarX, cooldownY - 15)
	surface.DrawText("LMB - Heal")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
	
	local healCooldown = 0
	local nextHeal = self:GetNextPrimary()
	if nextHeal > CurTime() then
		healCooldown = nextHeal - CurTime()
	end
	
	if healCooldown > 0 then
		local progress = 1 - (healCooldown / self.Primary.Delay)
		local barRainbow = getRainbowColor(3)
		surface.SetDrawColor(barRainbow.r, barRainbow.g, barRainbow.b, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 200, 220, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", healCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(lmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- RMB Cooldown (Group Heal)
	local rmbBarX = startX + barWidth + spacing
	surface.SetTextColor(200, 200, 200, 255)
	surface.SetFont("DermaDefaultBold")
	surface.SetTextPos(rmbBarX, cooldownY - 15)
	surface.DrawText("RMB - Group Heal")
	
	surface.SetDrawColor(150, 150, 150, 255)
	surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
	
	surface.SetDrawColor(40, 40, 40, 200)
	surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
	
	local groupHealCooldown = 0
	local nextGroupHeal = self:GetNextSecondary()
	if nextGroupHeal > CurTime() then
		groupHealCooldown = nextGroupHeal - CurTime()
	end
	
	if groupHealCooldown > 0 then
		local progress = 1 - (groupHealCooldown / self.Secondary.Delay)
		local barRainbow2 = getRainbowColor(3.5)
		surface.SetDrawColor(barRainbow2.r, barRainbow2.g, barRainbow2.b, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(255, 200, 220, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText(string.format("%.1fs", groupHealCooldown))
	else
		surface.SetDrawColor(100, 255, 100, 255)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		surface.SetFont("DermaDefault")
		surface.SetTextColor(150, 255, 150, 255)
		surface.SetTextPos(rmbBarX, cooldownY + 10)
		surface.DrawText("READY")
	end
	
	-- Tęczowy celownik
	local x = ScrW() / 2.0
	local y = ScrH() / 2.0
	
	local crosshairRainbow = getRainbowColor(4)
	surface.SetDrawColor(crosshairRainbow.r, crosshairRainbow.g, crosshairRainbow.b, 255)
	
	local gap = 5
	local length = gap + 15
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )
end



================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_base.lua
================================================
AddCSLuaFile()

SWEP.PrintName				= "BASE SCP"

SWEP.DrawAmmo				= false
SWEP.BounceWeaponIcon		= false
SWEP.DrawCrosshair			= false

SWEP.AutoSwitchTo			= false
SWEP.AutoSwitchFrom			= false

SWEP.ViewModelFOV			= 60
SWEP.ViewModelFlip			= false

SWEP.Spawnable				= false
SWEP.AdminSpawnable			= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= ""

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= ""

SWEP.ISSCP 					= true
SWEP.droppable				= false
SWEP.teams					= { 1 }

SWEP.Lang = nil
SWEP.FreezePlayer = false
SWEP.ShouldFreezePlayer = false

function SWEP:InitializeLanguage( name )
	if CLIENT then
		self.Lang = GetWeaponLang()[name]
		if self.Lang then
			self.Author			= self.Lang.author
			self.Contact		= self.Lang.contact
			self.Purpose		= self.Lang.purpose
			self.Instructions	= self.Lang.instructions
		end
	end
end

function SWEP:Deploy()
	self:HideModels()
end

function SWEP:HideModels()
	if IsValid( self.Owner ) then
		self.Owner:DrawWorldModel( false )
		self.Owner:DrawViewModel( false )
	end
end

function SWEP:PlayerFreeze()
	if !SERVER then return end

	if preparing and self.ShouldFreezePlayer and !self.FreezePlayer then
		self.FreezePlayer = true
		self.OldStats = {
			jump = self.Owner:GetJumpPower(),
			walk = self.Owner:GetWalkSpeed(),
			run = self.Owner:GetRunSpeed(),
			crouch = self.Owner:GetCrouchedWalkSpeed()
		}
		self.Owner:SetJumpPower( 0 )
		self.Owner:SetCrouchedWalkSpeed( 0 )
		self.Owner:SetWalkSpeed( 0 )
		self.Owner:SetRunSpeed( 0 )
	end

	if preparing or postround then return end

	if self.FreezePlayer then
		self.FreezePlayer = false

		self.Owner:SetCrouchedWalkSpeed( self.OldStats.crouch )
		self.Owner:SetJumpPower( self.OldStats.jump )
		self.Owner:SetWalkSpeed( self.OldStats.walk )
		self.Owner:SetRunSpeed( self.OldStats.run )
	end
end

function SWEP:Think()
	self:PlayerFreeze()
end

function SWEP:SCPDamageEvent( ent, dmg )
	if SERVER then
		hook.Run( "BreachSCPDamage", self.Owner, ent, dmg )
	end
end

function SWEP:PrimaryAttack()
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_doomguyj.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_scp_base"
SWEP.PrintName = "SCP-DOOMGUY-J"

SWEP.ViewModelFOV = 90
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapons/c_crucible.mdl"
SWEP.WorldModel = "models/weapons/w_crucible.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true
SWEP.HoldType = "melee2"

SWEP.DrawCrosshair = true

SWEP.Primary.Delay = 1.5
SWEP.Primary.DelayHit = 0.35
SWEP.Primary.Damage = 85
SWEP.Primary.Force = 1000
SWEP.Primary.Range = 100

SWEP.Secondary.Delay = 5
SWEP.Secondary.Damage = 125
SWEP.Secondary.Force = 1500
SWEP.Secondary.Range = 120

SWEP.NextPrimary = 0
SWEP.NextSecondary = 0
SWEP.Idle = 0
SWEP.IdleTimer = 0

function SWEP:Initialize()
	self:InitializeLanguage( "SCP_DOOMGUYJ" )
	self:SetHoldType(self.HoldType)
	self:SetWeaponHoldType(self.HoldType)
	
	self.Idle = 0
	self.IdleTimer = CurTime() + 1
	
	-- Inicjalizacja dźwięków dla broni
	if SERVER then
		util.AddNetworkString("DOOMGUYJ_PlaySound")
	end
end

function SWEP:Deploy()
	self.Idle = 0
	self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
	self:SendWeaponAnim( ACT_VM_DRAW )
	
	-- Dźwięk wyciągania broni
	if SERVER then
		self.Owner:EmitSound( "weapons/tfa_kf2/crucible/WPN_LS_Equip_01.wav", 50 )
	end
	
	-- Pętla dźwięku
	if CLIENT then
		self.NoiseLoop = CreateSound( self.Owner, Sound( "weapons/tfa_kf2/crucible/wpn_ls_idle_01_lpm.wav" ) )
		if ( self.NoiseLoop ) then 
			self.NoiseLoop:Play() 
			self.NoiseLoop:ChangeVolume( 0.6, 0.1 ) 
		end
	end
	
	return true
end

function SWEP:Holster()
	self.Idle = 0
	self.IdleTimer = CurTime()
	
	if !IsValid(self.Owner) then return false end
	
	-- Zatrzymaj pętlę dźwięku
	if CLIENT and self.NoiseLoop then 
		self.NoiseLoop:Stop() 
		self.NoiseLoop = nil 
	end
	
	-- Dźwięk chowania
	if SERVER then
		self.Owner:EmitSound( "weapons/tfa_kf2/crucible/WPN_LS_UnEquip_01.wav", 50 )
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

function SWEP:GetViewModelPosition (pos, ang, inv)
	local DefPos = Vector(0,0,0)
	local DefAng = Vector(9,10,-15)
	
	if DefAng then
		ang = ang * 1
		ang:RotateAroundAxis (ang:Right(), DefAng.x)
		ang:RotateAroundAxis (ang:Up(), DefAng.y)
		ang:RotateAroundAxis (ang:Forward(), DefAng.z)
	end

	if DefPos then
		local Right = ang:Right()
		local Up = ang:Up()
		local Forward = ang:Forward()
	
		pos = pos + DefPos.x * Right
		pos = pos + DefPos.y * Forward
		pos = pos + DefPos.z * Up
	end
	
	return pos, ang
end

function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if self.NextPrimary > CurTime() then return end
	
	local swinganims = {ACT_VM_HITLEFT, ACT_VM_HITRIGHT, ACT_VM_PRIMARYATTACK}
	self:SendWeaponAnim(swinganims[math.random(#swinganims)])
	self.Owner:SetAnimation( PLAYER_ATTACK1 )
	
	-- Dźwięk zamachu
	self:EmitSound( "TFA_crucible.Swing" )
	
	-- Zwiększ głośność pętli podczas ataku
	if CLIENT and self.NoiseLoop then 
		self.NoiseLoop:ChangeVolume( 0.7, 0.1 ) 
	end
	
	self.Idle = 0
	self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
	
	-- Opóźnione trafienie
	timer.Simple(0.2, function()
		if !IsValid(self) then return end
		if !IsValid(self.Owner) then return end
		if !IsValid(self.Owner:GetActiveWeapon()) then return end
		if self.Owner:GetActiveWeapon() ~= self then return end
		
		self:PerformMeleeAttack(self.Primary.Damage, self.Primary.Range, self.Primary.Force)
	end)
	
	-- Ustaw następny możliwy atak
	self.NextPrimary = CurTime() + self.Primary.Delay
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
end

function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if self.NextSecondary > CurTime() then return end
	
	-- Silniejszy atak
	self:SendWeaponAnim(ACT_VM_SECONDARYATTACK)
	self.Owner:SetAnimation( PLAYER_ATTACK1 )
	
	-- Dźwięk zamachu
	self:EmitSound( "TFA_crucible.Swing" )
	
	-- Zwiększ głośność pętli podczas ataku
	if CLIENT and self.NoiseLoop then 
		self.NoiseLoop:ChangeVolume( 0.7, 0.1 ) 
	end
	
	self.Idle = 0
	self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
	
	-- Opóźnione trafienie
	timer.Simple(0.4, function()
		if !IsValid(self) then return end
		if !IsValid(self.Owner) then return end
		if !IsValid(self.Owner:GetActiveWeapon()) then return end
		if self.Owner:GetActiveWeapon() ~= self then return end
		
		self:PerformMeleeAttack(self.Secondary.Damage, self.Secondary.Range, self.Secondary.Force)
	end)
	
	-- Ustaw następny możliwy atak
	self.NextSecondary = CurTime() + self.Secondary.Delay
	self:SetNextPrimaryFire( CurTime() + self.Secondary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Secondary.Delay )
end

function SWEP:PerformMeleeAttack(damage, range, force)
	if !SERVER then return end
	
	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * range,
		filter = self.Owner,
		mask = MASK_SHOT
	} )
	
	if !tr.Hit then
		tr = util.TraceHull( {
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * range,
			filter = self.Owner,
			mins = Vector( -16, -16, 0 ),
			maxs = Vector( 16, 16, 0 ),
			mask = MASK_SHOT
		} )
	end
	
	if tr.Hit then
		-- Efekt trafienia
		local effectdata = EffectData()
		effectdata:SetOrigin(tr.HitPos)
		effectdata:SetNormal(tr.HitNormal)
		util.Effect("cball_explode", effectdata)
		
		-- Dźwięk uderzenia
		sound.Play("weapons/tfa_kf2/crucible/shock_impact.wav", tr.HitPos + tr.HitNormal*5, 75)
		
		if IsValid(tr.Entity) then
			-- Sprawdź czy cel to SCP - ale SCP-035 może być atakowany!
			if tr.Entity:IsPlayer() and tr.Entity:GTeam() == TEAM_SCP and tr.Entity:GetNClass() != ROLES.ROLE_SCP035 then
				-- Efekt wizualny bez obrażeń dla normalnych SCP (ale nie SCP-035)
				local spark = EffectData()
				spark:SetOrigin(tr.HitPos)
				spark:SetNormal(tr.HitNormal)
				util.Effect("StunstickImpact", spark)
				
				self.Owner:EmitSound( "TFA_crucible.HitWorld" )
				print("[DOOMGUY DEBUG] Blocked damage to SCP (not SCP-035): " .. tr.Entity:Nick() .. " (" .. tostring(tr.Entity:GetNClass()) .. ")")
			else
				-- Normalnie zadaj obrażenia nie-SCP
				local dmginfo = DamageInfo()
				dmginfo:SetDamage(damage)
				dmginfo:SetDamageType(DMG_SLASH)
				dmginfo:SetAttacker(self.Owner)
				dmginfo:SetInflictor(self)
				dmginfo:SetDamagePosition(tr.HitPos)
				dmginfo:SetDamageForce( self.Owner:GetAimVector() * force )
				
				-- Modyfikuj obrażenia w zależności od trafionej części ciała
				if tr.Entity:IsPlayer() or tr.Entity:IsNPC() then
					local finalDamage = damage
					
					if tr.HitGroup == HITGROUP_HEAD then
						finalDamage = damage * 1.5
					elseif tr.HitGroup == HITGROUP_CHEST or tr.HitGroup == HITGROUP_STOMACH then
						finalDamage = damage
					else
						finalDamage = damage * 0.75
					end
					
					dmginfo:SetDamage(finalDamage)
					
					-- Dźwięk trafienia w cel organiczny
					self.Owner:EmitSound( "TFA_crucible.HitFlesh" )
					
					-- Ukryte leczenie przy trafieniu
					self:HealOnHit()
				else
					-- Dźwięk trafienia w świat
					self.Owner:EmitSound( "TFA_crucible.HitWorld" )
				end
				
				tr.Entity:TakeDamageInfo( dmginfo )
				
				-- Wywołaj event obrażeń SCP
				self:SCPDamageEvent( tr.Entity, dmginfo:GetDamage() )
			end
		else
			-- Obrażenia obszarowe jeśli nie trafiliśmy bezpośrednio
			util.BlastDamage(self, self.Owner, tr.HitPos, 32, damage * 0.5)
		end
		
		-- Szybsze ataki po trafieniu
		self.NextPrimary = CurTime() + self.Primary.DelayHit
		self.NextSecondary = CurTime() + self.Primary.DelayHit
	else
		-- Wolniejsze ataki po chybieniu
		self.NextPrimary = CurTime() + self.Primary.Delay
		self.NextSecondary = CurTime() + self.Secondary.Delay
	end
end

-- Ukryta funkcja leczenia przy trafieniu
function SWEP:HealOnHit()
	if not SERVER then return end
	if not IsValid(self.Owner) then return end
	
	local currentHP = self.Owner:Health()
	local maxHP = self.Owner:GetMaxHealth()
	local hpPercent = currentHP / maxHP
	
	-- Oblicz leczenie - im mniej HP, tym więcej leczy
	local healAmount
	if hpPercent <= 0.25 then
		-- Poniżej 25% HP - leczy 30-40 HP
		healAmount = math.random(30, 40)
	elseif hpPercent <= 0.5 then
		-- Poniżej 50% HP - leczy 20-30 HP
		healAmount = math.random(20, 30)
	elseif hpPercent <= 0.75 then
		-- Poniżej 75% HP - leczy 10-20 HP
		healAmount = math.random(10, 20)
	else
		-- Powyżej 75% HP - leczy 5-10 HP
		healAmount = math.random(5, 10)
	end
	
	-- Zastosuj leczenie
	if currentHP < maxHP then
		local newHP = math.min(currentHP + healAmount, maxHP)
		self.Owner:SetHealth(newHP)
		
		-- DEBUG (opcjonalnie)
		-- print("[DOOMGUY] Healed: " .. currentHP .. " -> " .. newHP .. " (+" .. healAmount .. " HP)")
	end
end

function SWEP:Think()
	-- Wywołaj Think z klasy bazowej
	if self.BaseClass and self.BaseClass.Think then
		self.BaseClass.Think(self)
	end
	
	-- Animacja idle
	if self.Idle == 0 and self.IdleTimer <= CurTime() then
		if SERVER then
			self:SendWeaponAnim( ACT_VM_IDLE )
		end
		self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
	end
	
	-- Przywróć normalną głośność pętli
	if CLIENT and self.NoiseLoop then 
		self.NoiseLoop:ChangeVolume( 0.6, 0.1 ) 
	end
end

function SWEP:DoImpactEffect( tr )
	if tr.HitSky then return end
	
	local effect = EffectData()
	effect:SetOrigin(tr.HitPos)
	effect:SetNormal( tr.HitNormal )
	util.Effect("cball_explode", effect)
	return true
end

if CLIENT then
	function SWEP:DrawHUD()
		if disablehud == true then return end
		
		local ply = LocalPlayer()
		if not IsValid(ply) then return end
		
		local centerX = ScrW() / 2
		local centerY = ScrH() / 2
		local hudY = ScrH() - 150
		
		local hudWidth = 500
		local hudHeight = 120
		local hudX = centerX - hudWidth / 2
		
		-- Tło HUD
		surface.SetDrawColor(20, 20, 20, 180)
		surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Obramowanie
		surface.SetDrawColor(100, 100, 100, 200)
		surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Linia dekoracyjna
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
		
		-- Tytuł SCP
		surface.SetFont("DermaLarge")
		surface.SetTextColor(200, 200, 200, 255)
		local titleW, titleH = surface.GetTextSize("SCP-DOOMGUY-J")
		surface.SetTextPos(centerX - titleW / 2, hudY + 10)
		surface.DrawText("SCP-DOOMGUY-J")
		
		-- Cooldowny
		local lpmCooldown = 0
		local ppmCooldown = 0
		
		if self.NextPrimary and self.NextPrimary > CurTime() then
			lpmCooldown = self.NextPrimary - CurTime()
		end
		
		if self.NextSecondary and self.NextSecondary > CurTime() then
			ppmCooldown = self.NextSecondary - CurTime()
		end
		
		local cooldownY = hudY + 60
		local barWidth = 120
		local barHeight = 8
		local barSpacing = 20
		
		-- LMB (Light Attack) Cooldown
		local lpmBarX = centerX - barWidth - barSpacing
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		surface.SetTextPos(lpmBarX, cooldownY - 15)
		surface.DrawText("LMB - Light")
		
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(lpmBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
		
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(lpmBarX, cooldownY, barWidth, barHeight)
		
		if lpmCooldown > 0 then
			local progress = 1 - (lpmCooldown / self.Primary.Delay)
			surface.SetDrawColor(255, 100, 100, 255)
			surface.DrawRect(lpmBarX, cooldownY, barWidth * progress, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(255, 150, 150, 255)
			surface.SetTextPos(lpmBarX, cooldownY + 10)
			surface.DrawText(string.format("%.1fs", lpmCooldown))
		else
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(lpmBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 255, 150, 255)
			surface.SetTextPos(lpmBarX, cooldownY + 10)
			surface.DrawText("READY")
		end
		
		-- RMB (Heavy Attack) Cooldown
		local ppmBarX = centerX + barSpacing
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		surface.SetTextPos(ppmBarX, cooldownY - 15)
		surface.DrawText("RMB - Heavy")
		
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(ppmBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
		
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(ppmBarX, cooldownY, barWidth, barHeight)
		
		if ppmCooldown > 0 then
			local progress = 1 - (ppmCooldown / self.Secondary.Delay)
			surface.SetDrawColor(255, 215, 0, 255)
			surface.DrawRect(ppmBarX, cooldownY, barWidth * progress, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(255, 255, 150, 255)
			surface.SetTextPos(ppmBarX, cooldownY + 10)
			surface.DrawText(string.format("%.1fs", ppmCooldown))
		else
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(ppmBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 255, 150, 255)
			surface.SetTextPos(ppmBarX, cooldownY + 10)
			surface.DrawText("READY")
		end
		
	end
	
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_impostor_j.lua
================================================
AddCSLuaFile()

SWEP.Base				= "weapon_scp_base"
SWEP.PrintName			= "SCP-Impostor-J"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true
SWEP.HoldType       = "knife"
SWEP.ViewModel		= "models/weapons/v_knife_t.mdl"	 
SWEP.WorldModel		= "models/weapons/w_knife_t.mdl"
SWEP.ShowWorldModel = false	
SWEP.DrawCrosshair              = false
SWEP.ViewModelBoneMods = {
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.Irons = {
    Normal = {
        Pos = Vector(-7.52, -2.126, -4.801),
        Ang = Vector(0, 0, -70),
        BlendTime = 0,
    }
}

SWEP.ViewModelFOV = 80

SWEP.ViewModelFlip = false


SWEP.Weight				= 1			 
SWEP.AutoSwitchTo		= true		 
SWEP.AutoSwitchFrom		= false	
SWEP.CSMuzzleFlashes		= false	  	 		 
		 
SWEP.Primary.Damage			= 75						 			  
SWEP.Primary.ClipSize		= -1		
SWEP.Primary.Delay			= 1		  
SWEP.Primary.DefaultClip	= 1		 
SWEP.Primary.Automatic		= true		 
SWEP.Primary.Ammo			= "none"	
SWEP.Primary.Force = 1000000000;

SWEP.VElements = {
	["bowie_knife"] = { type = "Model", model = "models/bowie_knife.mdl", bone = "v_weapon.knife_Parent", rel = "", pos = Vector(0.326, -0.102, 1.825), angle = Angle(60.569, 0, 0), size = Vector(0.5, 0.5, 0.5), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["bowie_knife"] = { type = "Model", model = "models/bowie_knife.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.91, 1.753, 0), angle = Angle(0, -32.132, -90), size = Vector(0.68, 0.68, 0.68), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.Secondary.ClipSize		= -1			
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Damage			= 0		 
SWEP.Secondary.Automatic		= false		 
SWEP.Secondary.Ammo			= "none"


SWEP.MissSound 				= Sound("weapons/knife/knife_slash1.wav")
SWEP.WallSound 				= Sound("weapons/knife/knife_hitwall1.wav")

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("breach/wep_impostor_j")
end

function SWEP:GetViewModelPosition( pos, ang )
    local b, r, u, f, n, x, y, z
    
    self.BobScale = 0.4
    self.SwayScale = 0.8
    
    r, u, f = ang:Right( ), ang:Up( ), ang:Forward( )
    
    x = self.Irons.Normal.Ang.x
    y = self.Irons.Normal.Ang.y
    z = self.Irons.Normal.Ang.z
    
    ang:RotateAroundAxis( r, x )
    ang:RotateAroundAxis( u, y )
    ang:RotateAroundAxis( f, z )
        
    r, u, f = ang:Right( ), ang:Up( ), ang:Forward( )
    
    x = self.Irons.Normal.Pos.x
    y = self.Irons.Normal.Pos.y
    z = self.Irons.Normal.Pos.z
        
    pos = pos + x * r
    pos = pos + y * f
    pos = pos + z * u
    
    return pos, ang
end

/*---------------------------------------------------------
PrimaryAttack
---------------------------------------------------------*/
function SWEP:PrimaryAttack()

	local tr = {}
	tr.start = self.Owner:GetShootPos()
	tr.endpos = self.Owner:GetShootPos() + ( self.Owner:GetAimVector() * 100 )
	tr.filter = self.Owner
	tr.mask = MASK_SHOT
	local trace = util.TraceLine( tr )

	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	if ( trace.Hit ) then

		if trace.Entity:IsPlayer() or string.find(trace.Entity:GetClass(),"npc") or string.find(trace.Entity:GetClass(),"prop_ragdoll") then
			self.Weapon:SendWeaponAnim(ACT_VM_MISSCENTER)
			
			-- Don't damage other SCPs (except SCP-035)
			local shouldDamage = true
			if trace.Entity:IsPlayer() and trace.Entity:GTeam() == TEAM_SCP and trace.Entity:GetNClass() != ROLES.ROLE_SCP035 then
				shouldDamage = false
			end
			
			if shouldDamage then
				local damage = 75 -- Default damage
				
				-- Check for backstab (instakill from behind)
				if trace.Entity:IsPlayer() then
					local victimForward = trace.Entity:GetAimVector()
					local attackerToVictim = (trace.Entity:GetPos() - self.Owner:GetPos()):GetNormalized()
					local dot = victimForward:Dot(attackerToVictim)
					
					-- If attacking from behind (dot > 0.5 means roughly 60+ degree angle)
					if dot > 0.5 then
						damage = trace.Entity:GetMaxHealth() + 100 -- Instakill
					end
				end
				
				bullet = {}
				bullet.Num    = 1
				bullet.Src    = self.Owner:GetShootPos()
				bullet.Dir    = self.Owner:GetAimVector()
				bullet.Spread = Vector(0, 0, 0)
				bullet.Tracer = 0
				bullet.Force  = 1
				bullet.Damage = damage
				self.Owner:FireBullets(bullet)
			end 
		else
			self.Weapon:SendWeaponAnim(ACT_VM_HITCENTER)
			bullet = {}
			bullet.Num    = 1
			bullet.Src    = self.Owner:GetShootPos()
			bullet.Dir    = self.Owner:GetAimVector()
			bullet.Spread = Vector(0, 0, 0)
			bullet.Tracer = 0
			bullet.Force  = 1
			bullet.Damage = self.Primary.Damage
			self.Owner:FireBullets(bullet) 
			self.Weapon:EmitSound( self.WallSound )		
			util.Decal("ManhackCut", trace.HitPos + trace.HitNormal, trace.HitPos - trace.HitNormal)
		end
	else
		self.Weapon:EmitSound(self.MissSound,100,math.random(90,120))
		self.Weapon:SendWeaponAnim(ACT_VM_HITCENTER)
	end
	

end


function SWEP:SecondaryAttack()
	return false
end

function SWEP:Reload()

	return false
end

/*---------------------------------------------------------
OnRemove
---------------------------------------------------------*/
function SWEP:OnRemove()

return true
end

if CLIENT then
	function SWEP:DrawHUD()
		if disablehud == true then return end
		
		local ply = LocalPlayer()
		if not IsValid(ply) then return end
		
		local centerX = ScrW() / 2
		local centerY = ScrH() / 2
		local hudY = ScrH() - 150
		
		local hudWidth = 500
		local hudHeight = 120
		local hudX = centerX - hudWidth / 2
		
		-- Tło HUD
		surface.SetDrawColor(20, 20, 20, 180)
		surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Obramowanie
		surface.SetDrawColor(100, 100, 100, 200)
		surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Linia dekoracyjna
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
		
		-- Tytuł SCP
		surface.SetFont("DermaLarge")
		surface.SetTextColor(200, 200, 200, 255)
		local titleW, titleH = surface.GetTextSize("SCP-Impostor-J")
		surface.SetTextPos(centerX - titleW / 2, hudY + 10)
		surface.DrawText("SCP-Impostor-J")
		
		-- Cooldowny
		local cooldownY = hudY + 60
		local barWidth = 140
		local barHeight = 8
		local spacing = 20
		local totalWidth = barWidth
		local startX = centerX - totalWidth / 2
		
		-- LMB - Knife Attack
		local lmbBarX = startX
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		surface.SetTextPos(lmbBarX, cooldownY - 15)
		surface.DrawText("LMB - Knife Attack")
		
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
		
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		local attackCooldown = 0
		if self:GetNextPrimaryFire() > CurTime() then
			attackCooldown = self:GetNextPrimaryFire() - CurTime()
		end
		
		if attackCooldown > 0 then
			local progress = 1 - (attackCooldown / self.Primary.Delay)
			surface.SetDrawColor(255, 100, 100, 255)
			surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(255, 150, 150, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText(string.format("%.1fs", attackCooldown))
		else
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 255, 150, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText("READY")
		end
	end
end

function SWEP:Deploy()
   self.Weapon:SendWeaponAnim(ACT_VM_DRAW);
   return true
end

/*---------------------------------------------------------
Holster
---------------------------------------------------------*/
function SWEP:Holster()

	return true
end

/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()
	self:InitializeLanguage("SCP_IMPOSTOR_J")
	self:SetWeaponHoldType( self.HoldType )
	
	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

function SWEP:OwnerChanged()
	self:Holster()
end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end



================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_radar.lua
================================================
SWEP.Base = "weapon_base"
SWEP.Category = "Breach SWEPs"
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.PrintName = "SCP Radar"
SWEP.Author = "Breach Team"
SWEP.Instructions = "Passive radar that shows SCP locations. No interaction required."
SWEP.ViewModel = ""
SWEP.WorldModel = "models/weapons/w_slam.mdl"
SWEP.HoldType = "slam"

SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.Ammo = "none"

SWEP.Slot = 2
SWEP.SlotPos = 1

-- Breach gamemode integration
SWEP.droppable = true
SWEP.teams = {TEAM_SCI}

-- Radar settings
SWEP.RadarRange = 2000
SWEP.RadarSize = 150

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
end

function SWEP:Deploy()
	self.Owner:DrawViewModel(false)
	return true
end

function SWEP:DrawWorldModel()
	if not IsValid(self.Owner) then
		self:DrawModel()
	end
end

function SWEP:PrimaryAttack()
	-- No primary attack
end

function SWEP:SecondaryAttack()
	-- No secondary attack
end



function SWEP:Holster()
	return true
end

-- Client-side radar display
if CLIENT then
	hook.Add("HUDPaint", "SCPRadar_Display", function()
		local ply = LocalPlayer()
		if not IsValid(ply) or not ply:Alive() then return end
		
		-- Check if player has SCP radar in inventory
		local hasRadar = false
		for _, weapon in pairs(ply:GetWeapons()) do
			if IsValid(weapon) and weapon:GetClass() == "weapon_scp_radar" then
				hasRadar = true
				break
			end
		end
		
		if not hasRadar then return end
		
		-- Radar display settings
		local radarSize = 200
		local radarX = ScrW() - radarSize - 50
		local radarY = 50
		local radarRange = 2000
		
		-- Draw black background
		surface.SetDrawColor(0, 0, 0, 200)
		surface.DrawRect(radarX, radarY, radarSize, radarSize)
		
		-- Draw border
		surface.SetDrawColor(100, 100, 100, 255)
		surface.DrawOutlinedRect(radarX, radarY, radarSize, radarSize)
		
		-- Player position (center of radar)
		local playerPos = ply:GetPos()
		local centerX = radarX + radarSize / 2
		local centerY = radarY + radarSize / 2
		
		-- Draw player (green triangle pointing up in center)
		surface.SetDrawColor(0, 255, 0, 255)
		local triangleSize = 5
		surface.DrawPoly({
			{x = centerX, y = centerY - triangleSize},           -- Top point
			{x = centerX - triangleSize, y = centerY + triangleSize}, -- Bottom left
			{x = centerX + triangleSize, y = centerY + triangleSize}  -- Bottom right
		})
		
		-- Get player's view angle for dynamic rotation
		local playerAngle = ply:EyeAngles().y
		
		-- Draw SCPs (red squares)
		for _, target in pairs(player.GetAll()) do
			if IsValid(target) and target != ply and target:Alive() and target:GTeam() == TEAM_SCP then
				local targetPos = target:GetPos()
				local distance = playerPos:Distance(targetPos)
				
				-- Only show SCPs within range
				if distance <= radarRange then
					-- Calculate relative position
					local relativePos = targetPos - playerPos
					
					-- Get forward and right vectors from player's view angle
					local playerForward = ply:GetForward()
					local playerRight = ply:GetRight()
					
					-- Project relative position onto player's forward and right vectors
					local forwardDist = relativePos:Dot(playerForward)
					local rightDist = relativePos:Dot(playerRight)
					
					-- Convert to radar coordinates (player view always up)
					local scale = (radarSize / 2) / radarRange
					local dotX = centerX + (rightDist * scale)    -- Right = positive X on screen
					local dotY = centerY - (forwardDist * scale)  -- Forward = negative Y on screen
					
					-- Keep dots within radar bounds
					dotX = math.Clamp(dotX, radarX + 2, radarX + radarSize - 2)
					dotY = math.Clamp(dotY, radarY + 2, radarY + radarSize - 2)
					
					-- Draw SCP as red inverted triangle
					surface.SetDrawColor(255, 0, 0, 255)
					local scpTriangleSize = 4
					surface.DrawPoly({
						{x = dotX, y = dotY + scpTriangleSize},              -- Bottom point
						{x = dotX - scpTriangleSize, y = dotY - scpTriangleSize}, -- Top left
						{x = dotX + scpTriangleSize, y = dotY - scpTriangleSize}  -- Top right
					})
				end
			end
		end
	end)
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_santaj.lua
================================================
AddCSLuaFile()

SWEP.PrintName			= "SCP-SANTA-J"			

SWEP.ViewModelFOV 		= 56
SWEP.Spawnable 			= false
SWEP.AdminOnly 			= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Delay        = 6
SWEP.Primary.Automatic	= true
SWEP.Primary.Ammo		= "None"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Delay			= 0.25
SWEP.Secondary.Ammo		= "None"

SWEP.ISSCP 				= true
SWEP.droppable				= false
SWEP.CColor					= Color(0,255,0)
SWEP.teams					= { 1 }

SWEP.Weight				= 3
SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false
SWEP.Slot					= 0
SWEP.SlotPos				= 4
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true
SWEP.WorldModel			= ""
SWEP.IconLetter			= "w"
SWEP.HoldType 			= "normal"

SWEP.NextPrimary = 0
SWEP.NextSecondary = 0
SWEP.ActGift = false

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().SCP_SantaJ
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end
	self:SetHoldType(self.HoldType)
end

function SWEP:Deploy()
	if self.Owner:IsValid() then
		self.Owner:DrawWorldModel( false )
		self.Owner:DrawViewModel( false )
	end
end

function SWEP:Remove()
end

function SWEP:Holster()
	return true
end

SWEP.Freeze = false

function SWEP:Think()
	if SERVER then
		if preparing and (self.Freeze == false) then
			self.Freeze = true
			self.Owner:SetJumpPower(0)
			self.Owner:SetCrouchedWalkSpeed(0)
			self.Owner:SetWalkSpeed(0)
			self.Owner:SetRunSpeed(0)
		end
		if preparing or postround then return end
		if self.Freeze == true then
			self.Freeze = false
			self.Owner:SetCrouchedWalkSpeed(0.6)
			self.Owner:SetJumpPower(200)
			self.Owner:SetWalkSpeed(160)
			self.Owner:SetRunSpeed(160)
		end
	end

	if self.EndTime and self.CTime and self.EndTime != 0 and self.CTime != 0 then
		if self.CTime < CurTime() - 0.1 then
			if SERVER then
				self:ThrowGift( 1.2 - ( self.EndTime - CurTime() ) / 2 )
			end
			self.EndTime = 0
			self.CTime = 0
			self.NextPrimary = CurTime() + self.Primary.Delay
		elseif self.EndTime - CurTime() < 0 then
			self.EndTime = 0
			self.CTime = 0
			self.NextPrimary = CurTime() + 1
		end
	end
	--self.NextPrimary = CurTime() + self.Primary.Delay
end

function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextPrimary > CurTime() then return end
	if !self.EndTime or self.EndTime == 0 then self.EndTime = CurTime() + 2 end
	if self.EndTime != 0 then
		self.CTime = CurTime()
	end
	--
end

function SWEP:SecondaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextSecondary > CurTime() then return end
	self.NextSecondary = CurTime() + self.Secondary.Delay
	self.ActGift = !self.ActGift
	--
end

function SWEP:Reload()
end

function SWEP:DrawHUD()
	if disablehud == true then return end

	local x = ScrW() / 2.0
	local y = ScrH() / 2.0

	if self.EndTime and self.EndTime != 0 then
		surface.SetDrawColor( Color( 200, 200, 200, 200 ) )
		surface.DrawRing( x, y, 50, 10, 360, 50, 1 - ( self.EndTime - CurTime() ) / 2 + 0.05, 0 )
	end

	local showtext = self.Lang.HUD.attackReady
	local showcolor = Color( 0, 255, 0 )
	
	if self.NextPrimary > CurTime() then
		showtext = self.Lang.HUD.attackCD.." ".. math.Round( self.NextPrimary - CurTime() )
		showcolor = Color( 255, 0, 0 )
	end
	
	draw.Text( {
		text = showtext,
		pos = { ScrW() / 2, ScrH() - 30 },
		font = "173font",
		color = showcolor,
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_CENTER,
	})
	
	draw.Text( {
		text = self.Lang.HUD.gtype.." "..( self.ActGift and self.Lang.HUD.healing or self.Lang.HUD.explosive ),
		pos = { ScrW() / 2, ScrH() - 50 },
		font = "173font",
		color = Color( 0, 255, 0 ),
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_CENTER,
	})

	local scale = 0.3
	surface.SetDrawColor( 0, 255, 0, 255 )
	
	local gap = 5
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )
end

function SWEP:DrawWorldModel()
end

function SWEP:ThrowGift( power )
	local gift = ents.Create( "br_gift" )
	if IsValid( gift ) then
		gift:SetOwner( self.Owner )
		gift:SetGiftType( self.ActGift )
		gift:Spawn()
		gift:SetPos( self.Owner:GetShootPos() )
		gift:SetPhysVelocity( self.Owner:GetAimVector() * 750 * power )
	end
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_steve_j.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_scp_base"
SWEP.PrintName = "SCP-Steve-J"

SWEP.HoldType = "crowbar"

-- SCP-Steve-J Configuration
SWEP.SwordDelay = 0.8
SWEP.PearlDelay = 30.0
SWEP.SwordDamage = 80
SWEP.SwordRange = 80

-- Weapon properties from original sweps
SWEP.ViewModelFOV = 70
SWEP.ViewModel = "models/weapons/v_diamond_mc_sword.mdl"
SWEP.WorldModel = "models/weapons/w_diamond_mc_sword.mdl"
SWEP.UseHands = true
SWEP.ViewModelFlip = false
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true

-- VElements and WElements - using sword viewmodel so no need for sword VElement
SWEP.VElements = {
	["pearl"] = { 
		type = "Model", 
		model = "models/lolixtin/ender_pearl.mdl", 
		bone = "ValveBiped.Bip01_L_Hand", 
		rel = "", 
		pos = Vector(2.596, 1.557, -2.597), 
		angle = Angle(115.713, 0, -3.507), 
		size = Vector(0.5, 0.5, 0.5), 
		color = Color(255, 255, 255, 255), 
		surpresslightning = false, 
		material = "", 
		skin = 0, 
		bodygroup = {} 
	}
}

SWEP.WElements = {
	["pearl"] = { 
		type = "Model", 
		model = "models/lolixtin/ender_pearl.mdl", 
		bone = "ValveBiped.Bip01_L_Hand", 
		rel = "", 
		pos = Vector(4.196, 6.752, -2.597), 
		angle = Angle(125.065, 0, 0), 
		size = Vector(0.5, 0.5, 0.5), 
		color = Color(255, 255, 255, 255), 
		surpresslightning = false, 
		material = "", 
		skin = 0, 
		bodygroup = {} 
	}
}

SWEP.ViewModelBoneMods = {}

if SERVER then
	util.AddNetworkString("scp_steve_j_sword_hit")
	util.AddNetworkString("scp_steve_j_pearl_throw")
end

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("breach/wep_steve_j")
end

function SWEP:Initialize()
	self:InitializeLanguage("SCP_STEVE_J")
	self:SetHoldType(self.HoldType)
	
	self.NextSwordAttack = 0
	self.NextPearlThrow = 0

	if CLIENT then
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
	end
end

function SWEP:OwnerChanged()
	self:Holster()
end

function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

function SWEP:Deploy()
	if CLIENT then
		self:SendWeaponAnim(ACT_VM_DRAW)
	end
	return true
end

function SWEP:PrimaryAttack()
	if not IsFirstTimePredicted() then return end
	if CurTime() < self.NextSwordAttack then return end
	
	self:SwordAttack()
	self.NextSwordAttack = CurTime() + self.SwordDelay
end

function SWEP:SwordAttack()
	if not IsValid(self.Owner) then return end
	
	local ply = self.Owner
	
	-- Send weapon animation
	if CLIENT then
		self:SendWeaponAnim(ACT_VM_HITCENTER)
	end
	
	if SERVER then
		local spos = ply:GetShootPos()
		local sdest = spos + (ply:GetAimVector() * self.SwordRange)
		
		local kmins = Vector(1,1,1) * -15
		local kmaxs = Vector(1,1,1) * 15
		
		local tr = util.TraceHull({
			start = spos, 
			endpos = sdest, 
			filter = ply, 
			mask = MASK_SHOT_HULL, 
			mins = kmins, 
			maxs = kmaxs
		})
		
		-- Hull might hit environment stuff that line does not hit
		if not IsValid(tr.Entity) then
			tr = util.TraceLine({
				start = spos, 
				endpos = sdest, 
				filter = ply, 
				mask = MASK_SHOT_HULL
			})
		end
		
		local hitEnt = tr.Entity
		local hit = false
		
		if IsValid(hitEnt) then
			-- Damage only non-SCP players and SCP-035
			if hitEnt:IsPlayer() and (hitEnt:GTeam() != TEAM_SCP or hitEnt:GetNClass() == ROLES.ROLE_SCP035) then
				local dmginfo = DamageInfo()
				dmginfo:SetDamage(self.SwordDamage)
				dmginfo:SetDamageType(DMG_SLASH)
				dmginfo:SetAttacker(ply)
				dmginfo:SetInflictor(self)
				dmginfo:SetDamagePosition(tr.HitPos)
				
				hitEnt:TakeDamageInfo(dmginfo)
				hit = true
			end
			
			-- Damage breakable entities
			if hitEnt:GetClass() == "func_breakable" or 
			   hitEnt:GetClass() == "func_breakable_surf" or
			   hitEnt:GetClass() == "prop_physics" or
			   hitEnt:GetClass() == "prop_dynamic" then
				local dmginfo = DamageInfo()
				dmginfo:SetDamage(self.SwordDamage)
				dmginfo:SetDamageType(DMG_SLASH)
				dmginfo:SetAttacker(ply)
				dmginfo:SetInflictor(self)
				dmginfo:SetDamagePosition(tr.HitPos)
				
				hitEnt:TakeDamageInfo(dmginfo)
				hit = true
			end
		end
		
		-- Network hit effect
		net.Start("scp_steve_j_sword_hit")
		net.WriteBool(hit)
		net.WriteVector(tr.HitPos)
		net.WriteVector(tr.Normal)
		net.Broadcast()
		
		-- Play attack animation
		ply:SetAnimation(PLAYER_ATTACK1)
		
		-- Play sound
		if hit then
			self:EmitSound("Weapon_Crowbar.Melee_Hit")
		else
			self:EmitSound("Zombie.AttackMiss")
		end
	end
end

function SWEP:SecondaryAttack()
	if not IsFirstTimePredicted() then return end
	if CurTime() < self.NextPearlThrow then return end
	
	self:ThrowEnderPearl()
	self.NextPearlThrow = CurTime() + self.PearlDelay
end

function SWEP:ThrowEnderPearl()
	if not IsValid(self.Owner) then return end
	
	local ply = self.Owner
	
	-- Send weapon animation
	if CLIENT then
		self:SendWeaponAnim(ACT_VM_THROW)
		timer.Create("steve_j_draw_" .. self:EntIndex(), 0.35, 1, function() 
			if IsValid(self) then 
				self:SendWeaponAnim(ACT_VM_DRAW) 
			end 
		end)
	end
	
	if SERVER then
		local eyePos = ply:EyePos()
		local eyeAng = ply:EyeAngles()
		local forward = eyeAng:Forward()
		
		-- Create ender pearl entity using original entity
		local pearl = ents.Create("ender_pearl")
		if not IsValid(pearl) then return end
		
		pearl:SetModel("models/lolixtin/ender_pearl.mdl")
		pearl:SetPos(ply:GetShootPos())
		pearl:SetAngles(ply:EyeAngles() + Angle(0, 0, 90))
		pearl:SetOwner(ply)
		pearl:Spawn()
		
		-- Set physics velocity like in original
		local phys = pearl:GetPhysicsObject()
		if IsValid(phys) then
			phys:AddVelocity(pearl:GetForward() * 3000)
		end
		
		-- Play throw sound
		ply:EmitSound("throw.wav", 75, math.random(90, 110))
	end
end

function SWEP:Reload()
	-- No reload
end

function SWEP:Think()
	-- No special think behavior needed
end



if CLIENT then
	function SWEP:DrawHUD()
		if disablehud == true then return end
		
		local ply = LocalPlayer()
		if not IsValid(ply) then return end
		
		-- Draw standard SCP HUD
		self:DrawSCPHUD()
		
		-- Draw crosshair
		local centerX, centerY = ScrW() / 2, ScrH() / 2
		surface.SetDrawColor(0, 255, 0, 200)
		surface.DrawLine(centerX - 10, centerY, centerX + 10, centerY)
		surface.DrawLine(centerX, centerY - 10, centerX, centerY + 10)
	end
	
	function SWEP:DrawSCPHUD()
		local ply = LocalPlayer()
		if not IsValid(ply) then return end
		
		local centerX = ScrW() / 2
		local centerY = ScrH() / 2
		local hudY = ScrH() - 150
		
		local hudWidth = 500
		local hudHeight = 120
		local hudX = centerX - hudWidth / 2
		
		-- Tło HUD
		surface.SetDrawColor(20, 20, 20, 180)
		surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Obramowanie
		surface.SetDrawColor(100, 100, 100, 200)
		surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Linia dekoracyjna
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
		
		-- Tytuł SCP
		surface.SetFont("DermaLarge")
		surface.SetTextColor(200, 200, 200, 255)
		local titleW, titleH = surface.GetTextSize("SCP-Steve-J")
		surface.SetTextPos(centerX - titleW / 2, hudY + 10)
		surface.DrawText("SCP-Steve-J")
		
		-- Cooldowny
		local cooldownY = hudY + 60
		local barWidth = 120
		local barHeight = 8
		local spacing = 20
		local totalWidth = barWidth * 2 + spacing
		local startX = centerX - totalWidth / 2
		
		-- LMB Cooldown (Sword)
		local lmbBarX = startX
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		surface.SetTextPos(lmbBarX, cooldownY - 15)
		surface.DrawText("LMB - Diamond Sword")
		
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
		
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		local swordCooldown = math.max(0, self.NextSwordAttack - CurTime())
		
		if swordCooldown > 0 then
			local progress = 1 - (swordCooldown / self.SwordDelay)
			surface.SetDrawColor(255, 200, 0, 200)
			surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(255, 255, 150, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText(string.format("%.1fs", swordCooldown))
		else
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 255, 150, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText("READY")
		end
		
		-- RMB Cooldown (Ender Pearl)
		local rmbBarX = startX + barWidth + spacing
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		surface.SetTextPos(rmbBarX, cooldownY - 15)
		surface.DrawText("RMB - Ender Pearl")
		
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(rmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
		
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
		
		local pearlCooldown = math.max(0, self.NextPearlThrow - CurTime())
		
		if pearlCooldown > 0 then
			local progress = 1 - (pearlCooldown / self.PearlDelay)
			surface.SetDrawColor(255, 100, 255, 200)
			surface.DrawRect(rmbBarX, cooldownY, barWidth * progress, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(255, 150, 255, 255)
			surface.SetTextPos(rmbBarX, cooldownY + 10)
			surface.DrawText(string.format("%.1fs", pearlCooldown))
		else
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(rmbBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 255, 150, 255)
			surface.SetTextPos(rmbBarX, cooldownY + 10)
			surface.DrawText("READY")
		end
	end

	-- SWEP Construction Kit functions
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end
	
	-- Receive sword hit effect
	net.Receive("scp_steve_j_sword_hit", function()
		local hit = net.ReadBool()
		local hitPos = net.ReadVector()
		local normal = net.ReadVector()
		
		if hit then
			-- Blood effect for hits
			local effectdata = EffectData()
			effectdata:SetOrigin(hitPos)
			effectdata:SetNormal(normal)
			util.Effect("BloodImpact", effectdata)
		end
	end)
	
	-- Receive pearl teleport effect
	net.Receive("scp_steve_j_pearl_throw", function()
		local pos = net.ReadVector()
		-- Additional client effects can be added here
	end)
end

/**************************
	Global utility code
**************************/

// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
// Does not copy entities of course, only copies their reference.
// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
function table.FullCopy( tab )

	if (!tab) then return nil end
	
	local res = {}
	for k, v in pairs( tab ) do
		if (type(v) == "table") then
			res[k] = table.FullCopy(v) // recursion ho!
		elseif (type(v) == "Vector") then
			res[k] = Vector(v.x, v.y, v.z)
		elseif (type(v) == "Angle") then
			res[k] = Angle(v.p, v.y, v.r)
		else
			res[k] = v
		end
	end
	
	return res
	
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_ttt_sahur.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_scp_base"
SWEP.PrintName = "SCP-TTT-SAHUR"

SWEP.HoldType = "melee2"
SWEP.ViewModelFOV = 61
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ShowViewModel = true
SWEP.UseHands = true
SWEP.ShowWorldModel = false

-- SCP-TTT-SAHUR Configuration
SWEP.AttackDelay = 0.8
SWEP.HitDistance = 100
SWEP.Damage = 60

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Finger1"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -26.994, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 3.403), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(6.178, 5.046, 8.994), angle = Angle(-46.744, -28.446, 76.347) },
	["ValveBiped.Bip01_L_Finger0"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-1.047, 12.956, 4.587) },
	["ValveBiped.Bip01_L_Finger2"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -23.066, 0) },
	["ValveBiped.Bip01_L_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(-5.153, -3.849, -5.435), angle = Angle(33.363, 1.567, 1.123) },
	["ValveBiped.Bip01_L_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(16.929, 23.065, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -14.051, 0) }
}

SWEP.VElements = {
	["bat"] = { type = "Model", model = "models/weapons/melee/w_bat.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -1.351), angle = Angle(0, 0, 0), size = Vector(0.819, 0.819, 0.819), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["bat"] = { type = "Model", model = "models/weapons/melee/w_bat.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(1.281, 1.312, 8.831), angle = Angle(-167.043, 2.161, -3.87), size = Vector(0.899, 0.899, 0.899), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("breach/wep_ttt_sahur")
end

function SWEP:Initialize()
	self:InitializeLanguage("SCP_TTT_SAHUR")
	self:SetHoldType(self.HoldType)
	
	self.NextAttack = 0
	
	if CLIENT then
		self:SetWeaponHoldType( self.HoldType )	
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) -- create viewmodels
		self:CreateModels(self.WElements) -- create worldmodels
		
		-- init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
			end
		end
	end
end

function SWEP:BatAttack()
	if not SERVER then return end
	
	local trace = self.Owner:GetEyeTrace()
	
	if trace.HitPos:Distance(self.Owner:GetShootPos()) <= self.HitDistance then
		-- Hit something
		local bullet = {}
		bullet.Num = 1
		bullet.Src = self.Owner:GetShootPos()
		bullet.Dir = self.Owner:GetAimVector()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force = 2
		bullet.Damage = self.Damage
		
		-- Don't attack other SCPs
		if trace.Entity:IsPlayer() and trace.Entity:GTeam() == TEAM_SCP and trace.Entity:GetNClass() != ROLES.ROLE_SCP035 then
			return
		end
		
		self.Owner:FireBullets(bullet)
		self:EmitSound("sillynightstick_flesh1.wav")
		
		-- Give EXP for hits
		if trace.Entity:IsPlayer() then
			self.Owner:AddExp(100, true)
		end
	else
		-- Miss
		self:EmitSound("macheteswing1.wav")
		self:EmitSound("macheteswing2.wav")
	end
end

function SWEP:PrimaryAttack()
	if preparing or postround then return end
	if not IsFirstTimePredicted() then return end
	if self.NextAttack > CurTime() then return end
	
	self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
	self:SetNextPrimaryFire(CurTime() + self.AttackDelay)
	self:SetNextSecondaryFire(CurTime() + self.AttackDelay)
	
	self:BatAttack()
	self.Owner:SetAnimation(PLAYER_ATTACK1)
	
	self.NextAttack = CurTime() + self.AttackDelay
end

function SWEP:SecondaryAttack()
	-- Secondary attack could be added here
end

function SWEP:Reload()
	-- Reload could be used for special ability
end

function SWEP:Think()
	-- Sync cooldown with client
	if SERVER then
		self:SetNWFloat("NextAttack", self.NextAttack)
	end
end

function SWEP:Deploy()
	self:SendWeaponAnim( ACT_VM_DRAW )
	self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() )
	return true
end

function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then
	SWEP.vRenderOrder = nil
	
	function SWEP:ViewModelDrawn()
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
		end

		for k, name in ipairs( self.vRenderOrder ) do
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
			elseif (v.type == "Sprite" and sprite) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
			elseif (v.type == "Quad" and v.draw_func) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()
			end
		end
	end

	SWEP.wRenderOrder = nil
	
	function SWEP:DrawWorldModel()
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then
			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end
		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			-- when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
			elseif (v.type == "Sprite" and sprite) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
			elseif (v.type == "Quad" and v.draw_func) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()
			end
		end
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
		else
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r -- Fixes mirrored models
			end
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )
		if (!tab) then return end

		-- Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				-- make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
			end
		end
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		if self.ViewModelBoneMods then
			if (!vm:GetBoneCount()) then return end
			
			-- !! WORKAROUND !! --
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			-- !! ----------- !! --
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				-- !! WORKAROUND !! --
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				-- !! ----------- !! --
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
	end
	 
	function SWEP:ResetBonePositions(vm)
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
	end

	-- Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	-- Does not copy entities of course, only copies their reference.
	-- WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )
		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) -- recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
	end

	function SWEP:DrawHUD()
		if disablehud == true then return end
		
		local ply = LocalPlayer()
		if not IsValid(ply) then return end
		
		local centerX = ScrW() / 2
		local centerY = ScrH() / 2
		local hudY = ScrH() - 150
		
		local hudWidth = 500
		local hudHeight = 120
		local hudX = centerX - hudWidth / 2
		
		-- Tło HUD
		surface.SetDrawColor(20, 20, 20, 180)
		surface.DrawRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Obramowanie
		surface.SetDrawColor(100, 100, 100, 200)
		surface.DrawOutlinedRect(hudX, hudY, hudWidth, hudHeight)
		
		-- Linia dekoracyjna
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawRect(hudX + 10, hudY + 5, hudWidth - 20, 2)
		
		-- Tytuł SCP
		surface.SetFont("DermaLarge")
		surface.SetTextColor(200, 200, 200, 255)
		local titleW, titleH = surface.GetTextSize("SCP-TTT-SAHUR")
		surface.SetTextPos(centerX - titleW / 2, hudY + 10)
		surface.DrawText("SCP-TTT-SAHUR")
		
		-- Cooldowny
		local cooldownY = hudY + 60
		local barWidth = 140
		local barHeight = 8
		local spacing = 20
		local totalWidth = barWidth -- Tylko 1 pasek
		local startX = centerX - totalWidth / 2
		
		-- LMB - Bat Attack
		local lmbBarX = startX
		surface.SetTextColor(200, 200, 200, 255)
		surface.SetFont("DermaDefaultBold")
		surface.SetTextPos(lmbBarX, cooldownY - 15)
		surface.DrawText("LMB - Bat Attack")
		
		surface.SetDrawColor(150, 150, 150, 255)
		surface.DrawOutlinedRect(lmbBarX - 2, cooldownY - 2, barWidth + 4, barHeight + 4)
		
		surface.SetDrawColor(40, 40, 40, 200)
		surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
		
		local attackCooldown = math.max(0, self:GetNWFloat("NextAttack", 0) - CurTime())
		
		if attackCooldown > 0 then
			local progress = 1 - (attackCooldown / self.AttackDelay)
			surface.SetDrawColor(255, 100, 100, 255)
			surface.DrawRect(lmbBarX, cooldownY, barWidth * progress, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(255, 200, 200, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText(string.format("%.1fs", attackCooldown))
		else
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(lmbBarX, cooldownY, barWidth, barHeight)
			
			surface.SetFont("DermaDefault")
			surface.SetTextColor(150, 255, 150, 255)
			surface.SetTextPos(lmbBarX, cooldownY + 10)
			surface.DrawText("READY")
		end
		
		-- Celownik
		local x = ScrW() / 2.0
		local y = ScrH() / 2.0
		local scale = 0.3
		local color = Color(255, 100, 100, 255)
		surface.SetDrawColor(color)
		
		local gap = 5
		local length = gap + 20 * scale
		surface.DrawLine(x - length, y, x - gap, y)
		surface.DrawLine(x + length, y, x + gap, y)
		surface.DrawLine(x, y - length, x, y - gap)
		surface.DrawLine(x, y + length, x, y + gap)
	end
end 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_zeus.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_base"
SWEP.Spawnable = false

SWEP.PrintName = "Zeus x27 Taser"

SWEP.ViewModel = "models/weapons/c_csgo_taser.mdl"
SWEP.WorldModel = "models/weapons/csgo_world/w_eq_taser.mdl"
SWEP.UseHands = true
SWEP.ViewModelFOV = 45
SWEP.HoldType = "revolver"

SWEP.SwayScale = .25

SWEP.Primary.Damage = 200
SWEP.Primary.Delay = 1.337
SWEP.Primary.Range = 250
SWEP.Primary.Cone = .01
SWEP.Primary.ClipSize = 3
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.Sound = "csgo/taser/taser_shoot.wav"
SWEP.Primary.HitSound = "csgo/taser/taser_hit.wav"

SWEP.Secondary.Ammo = "none"
SWEP.Secondary.DefaultClip = 0

SWEP.Slot = 0
SWEP.SlotPos = 1
SWEP.DrawAmmo = true

SWEP.FallbackMat = "models/weapons/csgo/taser"

SWEP.droppable				= true
SWEP.teams					= {2,3,5,6,7}

function SWEP:GetBetterOne( mode )
	local rand = math.random(1, 100)
	if rand < 25 and mode > 2 then
		return "weapon_zeus_exp"
	end
	return "weapon_zeus"
end

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().ZEUS
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end
	self:SetDeploySpeed(1)
	self:SetWeaponHoldType(self.HoldType)
	self:SetMaterial(self.FallbackMat)
end

function SWEP:PrimaryAttack()
	if not self:CanPrimaryAttack() then return end

	self:TakePrimaryAmmo(1)
	
	self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
	self:GetOwner():GetViewModel():SetPlaybackRate(1)
	self:EmitSound(self.Primary.Sound)

	self:GetOwner():LagCompensation(true)
	local trace = self:GetOwner():GetEyeTrace()

	fxdata = EffectData()
	fxdata:SetEntity(self)
	fxdata:SetAttachment(1)
	fxdata:SetStart(self.Owner:GetShootPos())
	fxdata:SetOrigin(trace.HitPos)
	fxdata:SetNormal(trace.HitNormal)
	
	//util.Effect("tooltracer", fxdata)
	//sparkfx = EffectData() sparkfx:SetOrigin(trace.HitPos)
	//util.Effect("Sparks", sparkfx)
	if CLIENT or game.SinglePlayer() and IsFirstTimePredicted() then
		util.Effect("effect_zeus_muzzleflash", fxdata)
	end

	if trace.Hit and (self:GetPos():Distance(trace.HitPos) < 300) then
		self:EmitSound(self.Primary.HitSound)
	
		self:MakeImpactEffect(fxdata)	
		if CLIENT or game.SinglePlayer() and IsFirstTimePredicted() then
		util.Effect("tooltracer", fxdata)
		util.Effect("ManHackSparks", fxdata)
		util.Effect("StunstickImpact",fxdata)
		end
		
		if trace.Entity then
			local ent = trace.Entity
			local dmginfo = DamageInfo()
			dmginfo:SetAttacker(self:GetOwner())
			dmginfo:SetDamage(self.Primary.Damage)
			//dmginfo:SetDamageType(DMG_BULLET)
			dmginfo:SetDamageType(DMG_SHOCK)
			dmginfo:SetDamageForce(self:GetOwner():EyeAngles():Forward() * 1)
			dmginfo:SetInflictor(self)
			
			if SERVER then ent:TakeDamageInfo(dmginfo) end
		end
	else
			fxdata:SetOrigin(self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range)
			//print(fxdata:GetOrigin())
			if CLIENT or game.SinglePlayer() and IsFirstTimePredicted() then
				util.Effect("tooltracer", fxdata)
			end
	end


	self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
	self:GetOwner():LagCompensation(false)
	
	//self:ThrowAway()

end

function SWEP:ThrowAway()
	if SERVER then
	timer.Simple( 0.5, function() if IsValid(self) then
		if self:GetOwner():GetActiveWeapon() == self then
			
			local prop = ents.Create("prop_physics")
			prop:SetPos(self:GetOwner():GetShootPos() + (self:GetOwner():EyeAngles():Forward() * 20) + self:GetOwner():EyeAngles():Right())
			prop:SetModel(self.WorldModel)
			prop:SetMaterial(self.FallbackMat)
			prop:Spawn()
			local phys = prop:GetPhysicsObject()
			phys:AddAngleVelocity( VectorRand() * 420 )
			phys:ApplyForceCenter(self:GetOwner():GetAimVector() * 1000)

			self:GetOwner():StripWeapon(self:GetClass())
			SafeRemoveEntityDelayed( prop , 15)
			prop:SetCollisionGroup(COLLISION_GROUP_WEAPON)
		end
	end
	end)
	end
end

function SWEP:MakeImpactEffect(fxdata)
if SERVER then
if self:GetOwner():Ping() > 300 then return end --Don't spawn the effect 5 seconds after you shoot if lagging
//print("debug")
	local shock = ents.Create("point_tesla")

	shock:SetPos(fxdata:GetOrigin())
	shock:SetOwner(self:GetOwner())
	shock:SetKeyValue("beamcount_max", 15)
	shock:SetKeyValue("beamcount_min", 10)
	shock:SetKeyValue("interval_max", 0)
	shock:SetKeyValue("interval_min", 0)
	shock:SetKeyValue("lifetime_max", .25)
	shock:SetKeyValue("lifetime_min", .25)
	shock:SetKeyValue("m_Color", 200, 200, 255)
	shock:SetKeyValue("m_flRadius", 20)
	shock:SetKeyValue("m_SoundName", "DoSpark")
	shock:SetKeyValue("texture", "sprites/physcannon/bluelight1b.vmt")
	shock:SetKeyValue("thick_max", 5)

	shock:Spawn()
	shock:Fire( "DoSpark", "", 0)
	SafeRemoveEntityDelayed( shock, 1 )
	SafeRemoveEntityDelayed( target, 1 )

	//util.Effect("TeslaZap", fxdata)

end
end















/*---------------
WORLDMODEL-FIXING UTILITY CODE
ORIGINALLY BY ROBOTBOY
----------------*/
    //SWEP.FixWorldModel = false
	SWEP.FixWorldModel = true
     
    SWEP.FixWorldModelPos = Vector( -3, 0, 0 )
     
    SWEP.FixWorldModelAng = Angle( 0, 0, 0 )
     
    SWEP.FixWorldModelScale = 1
     
function SWEP:DoFixWorldModel()
            if ( IsValid( self.Owner ) ) then
                    local att = self.Owner:GetAttachment( self.Owner:LookupAttachment( "anim_attachment_RH" ) )
                    if ( !att ) then return end
                    local pos, ang = att.Pos, att.Ang
                    ang:RotateAroundAxis( ang:Forward(), self.FixWorldModelAng.p )
                    ang:RotateAroundAxis( ang:Right(), self.FixWorldModelAng.y )
                    ang:RotateAroundAxis( ang:Up(), self.FixWorldModelAng.r )
                    pos = pos + ang:Forward() * self.FixWorldModelPos.x + ang:Right() * self.FixWorldModelPos.y + ang:Up() * self.FixWorldModelPos.z
                    self:SetModelScale( self.FixWorldModelScale, 0 )
                    self:SetRenderOrigin( pos )
                    self:SetRenderAngles( ang )
            else
                    self:SetRenderOrigin( self:GetNetworkOrigin() )
                    self:SetRenderAngles( self:GetNetworkAngles() )
            end 
end 

function SWEP:DrawWorldModel()
            if ( self.FixWorldModel ) then self:DoFixWorldModel() end
            self:DrawModel()
end



================================================
FILE: gamemodes/breach/entities/weapons/weapon_zeus_exp.lua
================================================
AddCSLuaFile()

SWEP.Base = "weapon_base"
SWEP.Spawnable = false

SWEP.PrintName = "Zeus v2.0 Prototype"

SWEP.ViewModel = "models/weapons/c_csgo_taser.mdl"
SWEP.WorldModel = "models/weapons/csgo_world/w_eq_taser.mdl"
SWEP.UseHands = true
SWEP.ViewModelFOV = 45
SWEP.HoldType = "revolver"

SWEP.SwayScale = .25

SWEP.Primary.Damage = 250
SWEP.Primary.Delay = 1.337
SWEP.Primary.Range = 250
SWEP.Primary.Cone = .01
SWEP.Primary.ClipSize = 10
SWEP.Primary.DefaultClip = 10
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.Sound = "csgo/taser/taser_shoot.wav"
SWEP.Primary.HitSound = "csgo/taser/taser_hit.wav"

SWEP.Secondary.Ammo = "none"
SWEP.Secondary.DefaultClip = 0

SWEP.Slot = 0
SWEP.SlotPos = 1
SWEP.DrawAmmo = true

SWEP.FallbackMat = "models/weapons/csgo/taser"

SWEP.droppable				= true
SWEP.teams					= {2,3,5,6,7}

SWEP.Lang = nil

function SWEP:Initialize()
	if CLIENT then
		self.Lang = GetWeaponLang().ZEUS_EXP
		self.Author		= self.Lang.author
		self.Contact		= self.Lang.contact
		self.Purpose		= self.Lang.purpose
		self.Instructions	= self.Lang.instructions
	end
	self:SetDeploySpeed(1)
	self:SetWeaponHoldType(self.HoldType)
	self:SetMaterial(self.FallbackMat)
end

function SWEP:PrimaryAttack()
	if not self:CanPrimaryAttack() then return end
	
	self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
	self:GetOwner():GetViewModel():SetPlaybackRate(1)
	self:EmitSound(self.Primary.Sound)

	self:GetOwner():LagCompensation(true)
	local trace = self:GetOwner():GetEyeTrace()

	fxdata = EffectData()
	fxdata:SetEntity(self)
	fxdata:SetAttachment(1)
	fxdata:SetStart(self.Owner:GetShootPos())
	fxdata:SetOrigin(trace.HitPos)
	fxdata:SetNormal(trace.HitNormal)
	
	//util.Effect("tooltracer", fxdata)
	//sparkfx = EffectData() sparkfx:SetOrigin(trace.HitPos)
	//util.Effect("Sparks", sparkfx)
	if CLIENT or game.SinglePlayer() and IsFirstTimePredicted() then
		util.Effect("effect_zeus_muzzleflash", fxdata)
	end

	if trace.Hit and (self:GetPos():Distance(trace.HitPos) < 300) then
		self:EmitSound(self.Primary.HitSound)
	
		self:MakeImpactEffect(fxdata)	
		if CLIENT or game.SinglePlayer() and IsFirstTimePredicted() then
		util.Effect("tooltracer", fxdata)
		util.Effect("ManHackSparks", fxdata)
		util.Effect("StunstickImpact",fxdata)
		end
		
		if trace.Entity then
			local ent = trace.Entity
			local dmginfo = DamageInfo()
			dmginfo:SetAttacker(self:GetOwner())
			dmginfo:SetDamage(self.Primary.Damage)
			dmginfo:SetDamageType(DMG_SHOCK)
			dmginfo:SetDamageForce(self:GetOwner():EyeAngles():Forward() * 1)
			dmginfo:SetInflictor(self)
			
			if SERVER then ent:TakeDamageInfo(dmginfo) end
		end
	else
			fxdata:SetOrigin(self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range)
			//print(fxdata:GetOrigin())
			if CLIENT or game.SinglePlayer() and IsFirstTimePredicted() then
				util.Effect("tooltracer", fxdata)
			end
	end


	self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
	self:GetOwner():LagCompensation(false)
	
	local rand = math.random(1, 2)
	if rand == 1 then
		self:Exp()
	end
end

function SWEP:Exp()
	if SERVER then
	timer.Simple( 1, function() 
		if IsValid(self) and IsValid(self.Owner) then
			local explosion = ents.Create( "env_explosion" )
			explosion:SetKeyValue( "spawnflags", 146 )
			explosion:SetPos( self.Owner:GetShootPos() )
			explosion:Spawn()
			explosion:Fire( "explode", "", 0 )
			self.Owner:TakeDamage(50, self.Owner, self)
			self.Owner:StripWeapon( "weapon_zeus_exp" )
		end
	end)
	end
end

function SWEP:MakeImpactEffect(fxdata)
if SERVER then
if self:GetOwner():Ping() > 300 then return end --Don't spawn the effect 5 seconds after you shoot if lagging
//print("debug")
	local shock = ents.Create("point_tesla")

	shock:SetPos(fxdata:GetOrigin())
	shock:SetOwner(self:GetOwner())
	shock:SetKeyValue("beamcount_max", 15)
	shock:SetKeyValue("beamcount_min", 10)
	shock:SetKeyValue("interval_max", 0)
	shock:SetKeyValue("interval_min", 0)
	shock:SetKeyValue("lifetime_max", .25)
	shock:SetKeyValue("lifetime_min", .25)
	shock:SetKeyValue("m_Color", 200, 200, 255)
	shock:SetKeyValue("m_flRadius", 20)
	shock:SetKeyValue("m_SoundName", "DoSpark")
	shock:SetKeyValue("texture", "sprites/physcannon/bluelight1b.vmt")
	shock:SetKeyValue("thick_max", 5)

	shock:Spawn()
	shock:Fire( "DoSpark", "", 0)
	SafeRemoveEntityDelayed( shock, 1 )
	SafeRemoveEntityDelayed( target, 1 )

	//util.Effect("TeslaZap", fxdata)

end
end















/*---------------
WORLDMODEL-FIXING UTILITY CODE
ORIGINALLY BY ROBOTBOY
----------------*/
    //SWEP.FixWorldModel = false
	SWEP.FixWorldModel = true
     
    SWEP.FixWorldModelPos = Vector( -3, 0, 0 )
     
    SWEP.FixWorldModelAng = Angle( 0, 0, 0 )
     
    SWEP.FixWorldModelScale = 1
     
function SWEP:DoFixWorldModel()
            if ( IsValid( self.Owner ) ) then
                    local att = self.Owner:GetAttachment( self.Owner:LookupAttachment( "anim_attachment_RH" ) )
                    if ( !att ) then return end
                    local pos, ang = att.Pos, att.Ang
                    ang:RotateAroundAxis( ang:Forward(), self.FixWorldModelAng.p )
                    ang:RotateAroundAxis( ang:Right(), self.FixWorldModelAng.y )
                    ang:RotateAroundAxis( ang:Up(), self.FixWorldModelAng.r )
                    pos = pos + ang:Forward() * self.FixWorldModelPos.x + ang:Right() * self.FixWorldModelPos.y + ang:Up() * self.FixWorldModelPos.z
                    self:SetModelScale( self.FixWorldModelScale, 0 )
                    self:SetRenderOrigin( pos )
                    self:SetRenderAngles( ang )
            else
                    self:SetRenderOrigin( self:GetNetworkOrigin() )
                    self:SetRenderAngles( self:GetNetworkAngles() )
            end 
end 

function SWEP:DrawWorldModel()
            if ( self.FixWorldModel ) then self:DoFixWorldModel() end
            self:DrawModel()
end



================================================
FILE: gamemodes/breach/entities/weapons/item_scp_215/README.md
================================================
# SCP-215 - Anomalous Sunglasses

## Opis
SCP-215 to anomalne okulary przeciwsłoneczne, które pozwalają użytkownikowi widzieć wrogie jednostki oznaczone czerwonymi kwadratami przez ściany i przeszkody.

## Funkcje
- **Wykrywanie wrogów**: Aktywne okulary pokazują czerwone markery nad wrogimi graczami
- **Przełączanie**: Lewy przycisk myszy (LPM) włącza/wyłącza wykrywanie
- **Cooldown**: Po wyłączeniu wykrywania następuje 10-sekundowy cooldown
- **Ograniczenia zespołowe**: Dostępne tylko dla określonych zespołów (CLASSD, CHAOS, GUARD, NTF, ALPHA1, CI)
- **Wizualne efekty**: Model okularów pojawia się na głowie gracza podczas aktywacji
- **System pękania**: Losowa szansa na pęknięcie okularów przy użyciu

## Zmiany wprowadzone

### Poprawione wykrywanie sojuszników
- CLASSD i CHAOS są teraz traktowani jako sojusznicy
- Czerwone markery nie będą się pojawiać nad członkami sojuszniczych zespołów

### System pękania okularów
- 5% szansy na pęknięcie przy wyłączaniu wykrywania
- 3% szansy na pęknięcie przy włączaniu wykrywania
- Po pęknięciu okulary są usuwane z ekwipunku gracza
- Efekt dźwiękowy pękania szkła

### Przybliżony model okularów
- Zmniejszono offset okularów z 3 do 0.5 jednostek
- Model okularów jest teraz bliżej twarzy postaci

### Usunięte TargetID
- Usunięto hook HUDDrawTargetID
- Brak informacji wyświetlanych przy patrzeniu na SCP-215

### Uproszczony HUD
- Usunięto skomplikowane paski postępu i statusy
- Wyświetla tylko "Put on SCP-215" lub "Take off SCP-215"
- Brak wyświetlania podczas cooldownu

### Poprzednie zmiany
- Usunięto wszystkie wiadomości czatu
- Poprawiono wykrywanie przez ściany (line-of-sight)
- Wyłączono dźwięki przełączania broni
- Dodano 10% szansę spawnu na mapie gm_site19

## Pliki zmodyfikowane
- `init.lua` - system pękania okularów, usunięto wiadomości czatu
- `cl_init.lua` - poprawiono wykrywanie sojuszników, przybliżono model, uproszczono HUD
- `shared.lua` - wyłączono dźwięki przełączania
- `entities/item_scp_215/cl_init.lua` - usunięto TargetID
- `gm_site19.lua` - dodano punkt spawnu dla SCP-215

## Użycie
1. Znajdź SCP-215 na mapie (10% szansa spawnu)
2. Naciśnij E aby podnieść
3. Użyj LPM aby włączyć/wyłączyć wykrywanie wrogów
4. Czerwone markery pojawią się nad wrogimi graczami w zasięgu wzroku
5. Po wyłączeniu czekaj 10 sekund przed ponownym użyciem
6. Uwaga: Okulary mogą pęknąć podczas użycia!


================================================
FILE: gamemodes/breach/entities/weapons/item_scp_215/cl_init.lua
================================================
include("shared.lua")

-- Font dla HUD
if CLIENT then
	surface.CreateFont("SCP215_Small", {
		font = "Trebuchet24", 
		size = 18,
		weight = 500,
		antialias = true,
		shadow = true
	})
	
	surface.CreateFont("SCP215_Warning", {
		font = "Trebuchet24", 
		size = 24,
		weight = 700,
		antialias = true,
		shadow = true
	})
end

-- HUD dla SCP-215
function SWEP:DrawHUD()
	if disablehud == true then return end
	
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	-- Pozycja HUD
	local x = ScrW() / 2
	local y = ScrH() / 2 - 50
	
	local isActive = ply:GetNWBool("SCP215_Active", false)
	
	-- Prosty tekst instrukcji
	if isActive then
		draw.SimpleText("Take off SCP-215", "SCP215_Small", x, y, Color(255, 100, 100), TEXT_ALIGN_CENTER)
	else
		draw.SimpleText("Put on SCP-215", "SCP215_Small", x, y, Color(100, 255, 100), TEXT_ALIGN_CENTER)
	end
end

-- Globalna tabela dla modeli okularów na graczach
SCP215_PlayerGlasses = SCP215_PlayerGlasses or {}

-- Funkcja tworząca model okularów na graczu
local function CreatePlayerGlasses(ply)
	if SCP215_PlayerGlasses[ply] then return end -- Już ma okulary
	
	local glassesModel = ClientsideModel("models/maxpayne/weapons/shades.mdl")
	if not IsValid(glassesModel) then return end
	
	-- Konfiguracja modelu
	glassesModel:SetNoDraw(true) -- Nie rysuj automatycznie
	glassesModel:SetModelScale(0.8) -- Zmniejsz rozmiar
	
	SCP215_PlayerGlasses[ply] = glassesModel
end

-- Funkcja usuwająca model okularów z gracza
local function RemovePlayerGlasses(ply)
	if SCP215_PlayerGlasses[ply] then
		if IsValid(SCP215_PlayerGlasses[ply]) then
			SCP215_PlayerGlasses[ply]:Remove()
		end
		SCP215_PlayerGlasses[ply] = nil
	end
end

-- Funkcja pozycjonująca okulary na graczu
local function PositionPlayerGlasses(ply, glassesModel)
	if not IsValid(ply) or not IsValid(glassesModel) then return end
	if not ply:Alive() then return end
	
	-- Spróbuj znaleźć attachment "eyes" lub "head"
	local eyesAttach = ply:LookupAttachment("eyes")
	local headAttach = ply:LookupAttachment("head")
	
	local attachID = eyesAttach > 0 and eyesAttach or (headAttach > 0 and headAttach or 0)
	
	if attachID > 0 then
		-- Użyj attachment
		local attachData = ply:GetAttachment(attachID)
		if attachData then
			local pos = attachData.Pos
			local ang = attachData.Ang
			
			-- Offset dla okularów (przybliżony do twarzy)
			pos = pos + ang:Forward() * 0.5 + ang:Up() * -1
			ang:RotateAroundAxis(ang:Right(), 0) -- Dodatkowa rotacja jeśli potrzebna
			
			glassesModel:SetPos(pos)
			glassesModel:SetAngles(ang)
		end
	else
		-- Fallback - użyj pozycji głowy
		local headPos = ply:EyePos()
		local headAng = ply:EyeAngles()
		
		-- Offset dla okularów
		headPos = headPos + headAng:Forward() * 0.1 + headAng:Up() * -2
		
		glassesModel:SetPos(headPos)
		glassesModel:SetAngles(headAng)
	end
end

-- Hook zarządzający modelami okularów na graczach
hook.Add("Think", "SCP215_ManagePlayerGlasses", function()
	for _, ply in pairs(player.GetAll()) do
		if IsValid(ply) and ply:Alive() then
			-- Sprawdź czy gracz ma SCP-215 aktywny
			local hasSCP215Active = ply:GetNWBool("SCP215_Active", false)
			
			if hasSCP215Active then
				-- Gracz ma SCP-215 aktywny - utwórz okulary jeśli ich nie ma
				if not SCP215_PlayerGlasses[ply] then
					CreatePlayerGlasses(ply)
				end
				
				-- Pozycjonuj okulary
				if SCP215_PlayerGlasses[ply] and IsValid(SCP215_PlayerGlasses[ply]) then
					PositionPlayerGlasses(ply, SCP215_PlayerGlasses[ply])
				end
			else
				-- Gracz nie ma SCP-215 aktywny - usuń okulary
				RemovePlayerGlasses(ply)
			end
		else
			-- Gracz nie żyje - usuń okulary
			RemovePlayerGlasses(ply)
		end
	end
end)

-- Hook renderujący modele okularów
hook.Add("PostPlayerDraw", "SCP215_DrawPlayerGlasses", function(ply)
	if SCP215_PlayerGlasses[ply] and IsValid(SCP215_PlayerGlasses[ply]) then
		SCP215_PlayerGlasses[ply]:DrawModel()
	end
end)

-- Czyszczenie przy disconneccie gracza
hook.Add("PlayerDisconnected", "SCP215_CleanupGlasses", function(ply)
	RemovePlayerGlasses(ply)
end)

-- Czyszczenie wszystkich okularów przy rozpoczęciu rundy
hook.Add("RoundStart", "SCP215_CleanupAllGlasses", function()
	for ply, glassesModel in pairs(SCP215_PlayerGlasses) do
		if IsValid(glassesModel) then
			glassesModel:Remove()
		end
	end
	SCP215_PlayerGlasses = {}
end)

-- Funkcja sprawdzająca czy gracz jest wrogiem
local function IsEnemyPlayer(ply, localPly)
	if not IsValid(ply) or not IsValid(localPly) then return false end
	if ply == localPly then return false end
	if not ply:Alive() then return false end
	
	local localTeam = localPly:GTeam()
	local playerTeam = ply:GTeam()
	
	-- Spectatorzy nie są wrogami
	if playerTeam == TEAM_SPEC then return false end
	
	-- CLASSD i CHAOS to sojusznicy
	if (localTeam == TEAM_CLASSD and playerTeam == TEAM_CHAOS) or (localTeam == TEAM_CHAOS and playerTeam == TEAM_CLASSD) then
		return false
	end
	
	-- Różne teamy = wrogowie
	return localTeam ~= playerTeam
end

-- Funkcja rysująca czerwony kwadrat z wykrzyknikiem
local function DrawEnemyMarker(pos2d)
	local size = 30
	local x = pos2d.x - size/2
	local y = pos2d.y - size/2
	
	-- Czerwony kwadrat (tło)
	surface.SetDrawColor(255, 0, 0, 200)
	surface.DrawRect(x, y, size, size)
	
	-- Czarna ramka
	surface.SetDrawColor(0, 0, 0, 255)
	surface.DrawOutlinedRect(x, y, size, size)
	
	-- Biały wykrzyknik
	draw.SimpleText("!", "SCP215_Warning", pos2d.x, pos2d.y, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end

-- Hook dla renderowania markerów wrogów
if CLIENT then
	hook.Add("HUDPaint", "SCP215_EnemyDetection", function()
		local ply = LocalPlayer()
		if not IsValid(ply) then return end
		
		-- Sprawdź czy gracz ma SCP-215 i jest aktywny
		local isActive = ply:GetNWBool("SCP215_Active", false)
		if not isActive then return end
		
		-- Sprawdź czy gracz trzyma SCP-215
		local currentWep = ply:GetActiveWeapon()
		if not IsValid(currentWep) or currentWep:GetClass() ~= "item_scp_215" then return end
		
		-- Iteruj przez wszystkich graczy
		for _, target in pairs(player.GetAll()) do
			if IsEnemyPlayer(target, ply) then
				-- Sprawdź zasięg
				local distance = ply:GetPos():Distance(target:GetPos())
				if distance <= 2000 then -- 2000 jednostek zasięgu
					-- Sprawdź czy gracz jest w polu widzenia
					local targetPos = target:GetPos() + Vector(0, 0, 75) -- Pozycja nad głową
					local screenPos = targetPos:ToScreen()
					
					-- Sprawdź czy jest na ekranie
					if screenPos.visible then
						-- Sprawdź czy nie jest zasłonięty
						local tr = util.TraceLine({
							start = ply:EyePos(),
							endpos = target:EyePos(),
							filter = {ply, target},
							mask = MASK_VISIBLE
						})
						
						-- Sprawdź czy trace nie trafił w ścianę
						if not tr.Hit or tr.Entity == target then
							DrawEnemyMarker(screenPos)
						end
					end
				end
			end
		end
	end)
	
	-- Hook dla globalnego statusu (gdy nie trzyma okularów)
	hook.Add("HUDPaint", "SCP215_GlobalStatus", function()
		local ply = LocalPlayer()
		if not IsValid(ply) then return end
		
		-- Sprawdź czy ma SCP-215 ale nie trzyma go aktualnie
		if ply:HasWeapon("item_scp_215") then
			local currentWep = ply:GetActiveWeapon()
			if not IsValid(currentWep) or currentWep:GetClass() ~= "item_scp_215" then
				-- Ma SCP-215 ale nie trzyma go - pokaż status
				local cooldownTime = ply:GetNWFloat("SCP215_Cooldown", 0)
				local isActive = ply:GetNWBool("SCP215_Active", false)
				
				if cooldownTime > CurTime() then
					-- Pokaż cooldown
					local x = ScrW() / 2
					local y = 30
					
					local timeLeft = math.ceil(cooldownTime - CurTime())
					local text = "SCP-215: " .. timeLeft .. "s [COOLDOWN]"
					draw.SimpleText(text, "SCP215_Small", x, y, Color(255, 150, 150), TEXT_ALIGN_CENTER)
					
					-- Pasek postępu
					local barWidth = 100
					local barHeight = 4
					local progress = 1 - (timeLeft / 5)
					
					-- Tło paska
					surface.SetDrawColor(0, 0, 0, 150)
					surface.DrawRect(x - barWidth/2, y + 20, barWidth, barHeight)
					
					-- Wypełnienie paska
					surface.SetDrawColor(255, 150, 150, 255)
					surface.DrawRect(x - barWidth/2, y + 20, barWidth * progress, barHeight)
				end
			end
		end
	end)
end


================================================
FILE: gamemodes/breach/entities/weapons/item_scp_215/init.lua
================================================
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")
include("sv_hooks.lua")

-- Network strings dla komunikacji client-server
util.AddNetworkString("SCP215_ToggleDetection")
util.AddNetworkString("SCP215_SyncState")

function SWEP:Deploy()
	if not IsFirstTimePredicted() then return end
	
	-- Sprawdź czy gracz może używać SCP-215
	if self.Owner:GTeam() == TEAM_SCP or self.Owner:GTeam() == TEAM_SPEC then
		if SERVER then
			timer.Simple(0.1, function()
				if IsValid(self.Owner) then
					self.Owner:StripWeapon("item_scp_215")
				end
			end)
		end
		return
	end
	
	self.Owner:DrawViewModel(false)

	if SERVER then
		-- Upewnij się, że broń zna aktualny stan wykrywania gracza
		self.IsActive = self.Owner:GetNWBool("SCP215_Active", false)
		-- Synchronizuj z klientem
		self:SyncToClient()
	end
	
	return true
end

function SWEP:Holster()
	if not IsFirstTimePredicted() then return end
	
	-- Wyłącz wykrywanie gdy chowamy broń
	if SERVER and self.IsActive then
		self:SetDetection(false)
	end
	
	return true
end

function SWEP:OnRemove()
	if SERVER and IsValid(self.Owner) then
		-- Wyłącz wykrywanie
		self:SetDetection(false)
		
		-- Wyczyść network vars
		self.Owner:SetNWBool("SCP215_Active", false)
	end
end

function SWEP:PrimaryAttack()
	if not IsFirstTimePredicted() then return end
	if preparing or postround then return end
	
	-- Toggle wykrywania
	self:ToggleDetection()
end

function SWEP:SecondaryAttack()
	-- Brak secondary attack
end

function SWEP:ToggleDetection()
	if SERVER then
		if self.IsActive then
			-- Wyłącz wykrywanie
			self:SetDetection(false)
			
			-- Sprawdź czy okulary pękną (20% szansy)
			if math.random(1, 100) <= 20 then
				self:BreakGlasses()
				return
			end
		else
			-- Włącz wykrywanie
			self:SetDetection(true)
			
			-- Sprawdź czy okulary pękną (12% szansy przy włączaniu)
			if math.random(1, 100) <= 12 then
				self:BreakGlasses()
				return
			end
		end
	end
end

if SERVER then
	function SWEP:SetDetection(active)
		if not IsValid(self.Owner) then return end
		
		self.IsActive = active
		
		-- Sync z klientem
		self:SyncToClient()
	end
	
	function SWEP:BreakGlasses()
		if not IsValid(self.Owner) then return end
		
		-- Zapisz referencję do gracza przed usunięciem broni
		local owner = self.Owner
		
		-- Wyłącz wykrywanie
		self:SetDetection(false)
		
		-- Wyczyść network vars przed usunięciem broni
		owner:SetNWBool("SCP215_Active", false)
		
		-- Efekt dźwiękowy pękania szkła
		owner:EmitSound("physics/glass/glass_impact_break" .. math.random(1, 4) .. ".wav")
		
		-- Usuń broń z gracza (na końcu)
		owner:StripWeapon("item_scp_215")
	end
	
	function SWEP:SyncToClient()
		if not IsValid(self.Owner) then return end
		
		self.Owner:SetNWBool("SCP215_Active", self.IsActive)
	end
end

function SWEP:Think()
	if not IsFirstTimePredicted() then return end
	
	-- Sync z serwerem
	if CLIENT then
		self.IsActive = self.Owner:GetNWBool("SCP215_Active", false)
	end
	
	-- Sprawdź czy gracz nadal trzyma okulary
	if SERVER and self.IsActive then
		local activeWep = self.Owner:GetActiveWeapon()
		if not IsValid(activeWep) or activeWep ~= self then
			-- Gracz przestał trzymać okulary - wyłącz wykrywanie
			self:SetDetection(false)
		end
	end
end

function SWEP:DrawWorldModel()
	if not IsValid(self.Owner) then
		self:DrawModel()
	else
		-- Zawsze rysuj world model
		self:DrawModel()
	end
end


================================================
FILE: gamemodes/breach/entities/weapons/item_scp_215/shared.lua
================================================
AddCSLuaFile()

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = ""
SWEP.WorldModel = "models/maxpayne/weapons/shades.mdl"
SWEP.PrintName = "SCP-215"
SWEP.Slot = 3
SWEP.SlotPos = 1
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.HoldType = "normal"
SWEP.Spawnable = false
SWEP.AdminSpawnable = false

SWEP.droppable = true
SWEP.teams = {TEAM_GUARD, TEAM_CLASSD, TEAM_SCI, TEAM_CHAOS, TEAM_GOC} -- Wszystkie zespoły poza SCPs i Spectators

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

-- Wyłącz dźwięki przełączania
function SWEP:PrimaryAttack()
	-- Pusta funkcja - wyłącza domyślne dźwięki
end

function SWEP:SecondaryAttack()
	-- Pusta funkcja - wyłącza domyślne dźwięki
end

-- Zmienne SCP-215
SWEP.IsActive = false
SWEP.DetectionRange = 2000 -- Zasięg wykrywania w jednostkach Source
SWEP.CooldownTime = 0
SWEP.CooldownDuration = 5 -- 5 sekund cooldown między użyciami

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
end


================================================
FILE: gamemodes/breach/entities/weapons/item_scp_215/sv_hooks.lua
================================================
-- Hooki serwerowe dla SCP-215
if SERVER then
	-- Hook serwerowy dla czyszczenia po śmierci gracza
	hook.Add("PlayerDeath", "SCP215_CleanupOnDeath", function(victim, inflictor, attacker)
		if IsValid(victim) and victim:HasWeapon("item_scp_215") then
			-- Wyczyść network variables
			victim:SetNWBool("SCP215_Active", false)
		end
	end)
	
	-- Hook dla disconnectu gracza
	hook.Add("PlayerDisconnected", "SCP215_CleanupOnDisconnect", function(ply)
		if IsValid(ply) then
			-- Wyczyść network variables
			ply:SetNWBool("SCP215_Active", false)
		end
	end)
	
	-- Hook dla wyrzucenia okularów
	hook.Add("PlayerDroppedWeapon", "SCP215_HandleDrop", function(ply, wep)
		if not IsValid(ply) or not IsValid(wep) then return end

		if wep:GetClass() ~= "item_scp_215" then return end

		if ply:GetNWBool("SCP215_Active", false) then
			-- Wyłącz wykrywanie
			ply:SetNWBool("SCP215_Active", false)
		end
	end)
	
	-- Hook dla rozpoczęcia rundy (wyczyść wszystkie stany)
	hook.Add("RoundStart", "SCP215_RoundCleanup", function()
		for _, ply in pairs(player.GetAll()) do
			if IsValid(ply) then
				ply:SetNWBool("SCP215_Active", false)
			end
		end
	end)
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_br_c4/shared.lua
================================================
AddCSLuaFile( "shared.lua" )

-- Precache modeli i materiałów dla C4
if SERVER then
	util.PrecacheModel("models/hoff/weapons/c4/w_c4.mdl")
	util.PrecacheModel("models/hoff/weapons/c4/c_c4.mdl")
end

if CLIENT then
	-- Precache materiałów po stronie klienta
	Material("models/hoff/weapons/c4/c4_reticle.png")
end

SWEP.Author			= "Hoff, zintegrowane przez SCP: Breach Team"
SWEP.Instructions	= "Lewy przycisk myszy: Detonuj C4\nPrawy przycisk myszy: Rzuć C4\nR: Podnieś C4"

SWEP.Category = "SCP: Breach"
SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.ViewModel			= "models/hoff/weapons/c4/c_c4.mdl"
SWEP.WorldModel			= "models/hoff/weapons/c4/w_c4.mdl"
SWEP.ViewModelFOV = 75

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= 5
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "slam"
SWEP.Primary.Delay = 1

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo			= "none"

SWEP.Weight				= 5
SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false

SWEP.PrintName			= "C4"
SWEP.Slot				= 4
SWEP.SlotPos			= 1
SWEP.DrawAmmo			= true
SWEP.DrawCrosshair		= true

SWEP.UseHands = true

SWEP.Offset = {
	Pos = {
		Up = 0,
		Right = 7,
		Forward = 3.5,
	},
	Ang = {
		Up = 0,
		Right = 90,
		Forward = 190,
	}
}
function SWEP:DrawWorldModel( )
	if not IsValid( self:GetOwner() ) then
		self:DrawModel( )
		return
	end

	local bone = self:GetOwner():LookupBone( "ValveBiped.Bip01_R_Hand" )
	if not bone then
		self:DrawModel( )
		return
	end

	local pos, ang = self:GetOwner():GetBonePosition( bone )
	pos = pos + ang:Right() * self.Offset.Pos.Right + ang:Forward() * self.Offset.Pos.Forward + ang:Up() * self.Offset.Pos.Up
	ang:RotateAroundAxis( ang:Right(), self.Offset.Ang.Right )
	ang:RotateAroundAxis( ang:Forward(), self.Offset.Ang.Forward )
	ang:RotateAroundAxis( ang:Up(), self.Offset.Ang.Up )

	self:SetRenderOrigin( pos )
	self:SetRenderAngles( ang )

	self:DrawModel()
end

function SWEP:Initialize()
	-- something keeps setting deploy speed to 4, this is a workaround
	self:SetDeploySpeed(1)
end

function SWEP:Deploy()
	-- something keeps setting deploy speed to 4, this is a workaround
	self:SetDeploySpeed(1)

	if not self:GetOwner().C4s or #self:GetOwner().C4s == 0 then
		self:GetOwner().C4s = {}
	end
	timer.Simple(0.3, function()
		if IsValid(self) and IsValid(self:GetOwner()) then
			self:EmitSound("hoff/mpl/seal_c4/bar_selectorswitch.wav", 45)
		end
	end)
	self:SetCollisionGroup(COLLISION_GROUP_NONE)
	self:SetHoldType("Slam")

	return true
end

function SWEP:StartExplosionChain()
	if table.Count(self:GetOwner().C4s) <= 0 then
		return
	end
	local ent = self:GetOwner().C4s[1] -- Get the first entity in the table

	if not IsValid(ent) then
		table.remove(self:GetOwner().C4s, 1)
		self:StartExplosionChain()
		return
	end

	if ent.QueuedForExplode then
		return
	end

	ent.QueuedForExplode = true
	ent.ExplodedViaWorld = false
	ent:DelayedDestroy(true)
end

function SWEP:PrimaryAttack()
	self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)

	timer.Simple(0.1,function()
		if IsValid(self) and IsValid(self:GetOwner()) then
			self:EmitSound("hoff/mpl/seal_c4/c4_click.wav")
		end
	end)

	if SERVER and self:GetOwner():Alive() and self:GetOwner():IsValid() then
		timer.Simple(0.175, function()
			if IsValid(self) and IsValid(self:GetOwner()) then
				self:StartExplosionChain()
			end
		end)
	end

	self:SetNextPrimaryFire(CurTime() + 1.1)

	-- Need to stop insane values from crashing servers
	local ClampedThrowSpeed = math.Clamp(GetConVar("BR_C4_ThrowSpeed"):GetFloat(), 0.25, 10)
	self:SetNextSecondaryFire(CurTime() + (0.8 / ClampedThrowSpeed))
end

hook.Add("PlayerDeath", "SetAllBRC4sUnowned", function(victim, weapon, killer)
	if IsValid(victim) and victim:IsPlayer() and victim.C4s and #victim.C4s > 0 then
		for k,v in pairs(victim.C4s) do
			victim.C4s[k].ExplodedViaWorld = true
		end
	end
end)

function SWEP:SecondaryAttack()
	if GetConVar("BR_C4_Infinite"):GetInt() == 0 and self:Ammo1() <= 0 then
		return
	end

	self:SendWeaponAnim(ACT_VM_THROW)
	self:GetOwner():SetAnimation(PLAYER_ATTACK1)

	self:EmitSound("hoff/mpl/seal_c4/whoosh_01.wav")
	timer.Simple(0.095, function()
		if not IsValid(self) or not IsValid(self:GetOwner()) then
			return
		end
		if SERVER then

			local TargetPosition = self:GetOwner():GetShootPos() + (self:GetOwner():GetRight() * -8) + (self:GetOwner():GetUp() * -1) + (self:GetOwner():GetForward() * 10)

			local model = "models/hoff/weapons/c4/w_c4.mdl"
			util.PrecacheModel(model)

			local TempC4 = ents.Create("prop_physics")
			TempC4:SetModel(model)
			TempC4:SetPos(TargetPosition)
			TempC4:SetCollisionGroup(COLLISION_GROUP_NONE)
			TempC4:Spawn()

			local mins, maxs = TempC4:GetCollisionBounds()

			TempC4:Remove()

			-- Use the mins and maxs vectors to check if there is enough space to spawn another c4
			local tr = util.TraceHull({start = TargetPosition, endpos = TargetPosition, mins = mins, maxs = maxs, mask = MASK_BLOCKLOS})

			-- Check if the trace hit something
			if not self:GetOwner():IsLineOfSightClear(TargetPosition) or tr.Hit then
				TargetPosition = self:GetOwner():EyePos()
			end

			local ent = ents.Create("br_c4")
			ent:SetPos(Vector(0,0,0))
			ent:SetOwner(self:GetOwner())  -- Disables collision between the C4 and its owner
			ent:SetPos(TargetPosition)
			ent:SetAngles(Angle(1,0,0))
			ent:Spawn()
			ent:SetOwner(self:GetOwner())  -- Disables collision between the C4 and its owner
			ent.C4Owner = self:GetOwner()
			ent.ThisTrigger = self
			ent.ExplodedViaWorld = false
			ent.QueuedForExplode = false
			ent.UniqueExplodeTimer = "ExplodeTimer" .. self:GetOwner():SteamID() .. math.Rand(1, 1000)
			ent:SetNWString("OwnerID", self:GetOwner():SteamID())

			local phys = ent:GetPhysicsObject()

			--phys:SetMass(0.6)

			-- Compensate for the offcenter spawn
			local aimvector = self:GetOwner():GetAimVector()
			local aimangle = aimvector:Angle()
			aimangle:RotateAroundAxis(aimangle:Up(), -1.5)
			aimvector = aimangle:Forward()
			phys:ApplyForceCenter( aimvector * 1500)

			-- The positive z coordinate emulates the spin from a left underhand throw
			local angvel = Vector(0, math.random(-5000,-2000), math.random(-100,-900))
			angvel:Rotate(-1 * ent:EyeAngles())
			angvel:Rotate(Angle(0, self:GetOwner():EyeAngles().y, 0))

			--local angvel = Vector(0, math.random(-5000,-2000), math.random(-100,-900))
			angvel.x = math.Clamp(angvel.x, -1000, 1000)
			angvel.y = math.Clamp(angvel.y, -1000, 1000)
			angvel.z = math.Clamp(angvel.z, -1000, 1000)

			phys:SetAngleVelocity(Vector(math.Clamp(angvel.x, -2000, 2000), math.Clamp(angvel.y, -2000, 2000), math.Clamp(angvel.z, -2000, 2000)))

			table.insert( self:GetOwner().C4s, ent )
			
			-- Dodajemy sprawdzenie, czy funkcje undo są dostępne
			if undo and undo.Create and undo.AddEntity and undo.SetPlayer and undo.AddFunction and undo.Finish then
				undo.Create("C4")
					undo.AddEntity(ent)
					undo.SetPlayer(self:GetOwner())
					undo.AddFunction(function(UndoFunc)
						local UndoEnt = UndoFunc.Entities[1]

						-- Check if the entity is still valid
						if UndoEnt:IsValid() then
							-- Remove the entity from the owner's C4s table
							table.RemoveByValue(UndoFunc.Owner.C4s, ent)
						else
							-- The c4 doesn't exist anymore (probably exploded)
							return false
						end
					end)
				undo.Finish()
			end

			-- Usunięto wywołania AddCount i AddCleanup, które nie są dostępne w SCP: Breach
			-- self:GetOwner():AddCount("sents", ent)
			-- self:GetOwner():AddCount("my_props", ent)
			-- self:GetOwner():AddCleanup("sents", ent)
			-- self:GetOwner():AddCleanup("my_props", ent)
		end

		if GetConVar("BR_C4_Infinite"):GetInt() == 0 then
			self:GetOwner():RemoveAmmo(1,"slam")
		end
	end)

	self:SetNextPrimaryFire(CurTime() + 1.1)

	-- Need to stop insane values from crashing servers
	local ClampedThrowSpeed = math.Clamp(GetConVar("BR_C4_ThrowSpeed"):GetFloat(), 0.25, 10)
	self:SetNextSecondaryFire(CurTime() + (0.8 / ClampedThrowSpeed))
end

function SWEP:ShouldDropOnDie()
	return false
end

function SWEP:Reload()
	-- First, check if the reload delay has expired
	if self.ReloadDelay and CurTime() < self.ReloadDelay then
		return
	end

	-- Trace a line to a hit location and do a sphere trace from there and sort by distance
	-- We have to do this because GetEyeTrace to a c4 parented to an entity is unreliable
	local trace = util.TraceLine({
		start = self:GetOwner():EyePos(),
		endpos = self:GetOwner():EyePos() + self:GetOwner():EyeAngles():Forward() * 85,
		filter = {self:GetOwner()}
	})
	local hitPos = trace.HitPos
	local c4s = ents.FindInSphere(hitPos, 1)
	table.sort(c4s, function(a, b) return a:GetPos():Distance(hitPos) < b:GetPos():Distance(hitPos) end)
	local hitEnt = nil
	for _, ent in ipairs(c4s) do
		if ent:GetClass() == "br_c4" then
			hitEnt = ent
			break
		end
	end

	-- Check if the trace hit an entity and if it is a C4 entity
	if IsValid(hitEnt) and hitEnt:GetClass() == "br_c4" and hitEnt:GetNWString("OwnerID") == self:GetOwner():SteamID() then
		-- Check if the C4 entity is owned by the player
		--if hitEnt:GetNWString("OwnerID") == self:GetOwner():SteamID() then

			if self:GetOwner():EyePos():Distance(hitEnt:GetPos()) > 85 then
				return
			end

			local effectData = EffectData()
			effectData:SetOrigin(hitEnt:GetPos())
			util.Effect("inflator_magic", effectData)

			if SERVER then
				if GetConVar("BR_C4_Infinite"):GetBool() == false then
					-- Give the player one "Slam" ammo
					self:GetOwner():GiveAmmo(1, "Slam")
				end

				-- Remove the C4 entity from the player's C4s array
				if table.HasValue(self:GetOwner().C4s, hitEnt) then
					table.RemoveByValue(self:GetOwner().C4s, hitEnt)
				end

				-- Remove the C4 entity from the world
				hitEnt:Remove()
			--else
				--if self.HasContextAnims then
				--	net.Start("VManip_SimplePlay") 
				--	net.WriteString("use") 
				--	net.Send(self.Owner)
				--end
			end

			-- Set the reload delay so the player cannot reload again for 0.5 seconds
			self.ReloadDelay = CurTime() + 0.5
		--end
	end
end

function SWEP:DoDrawCrosshair(x, y)
	surface.SetDrawColor( 255, 255, 255, 255 )
	surface.SetMaterial( Material("models/hoff/weapons/c4/c4_reticle.png") )
	surface.DrawTexturedRect( ScrW() / 2 - 16, ScrH() / 2 - 16, 32, 32 )
	return true
end


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_207/cl_init.lua
================================================
-- SCP-207, A representation of a paranormal object on a fictional series on the game Garry's Mod.
-- Copyright (C) 2023  MrMarrant aka BIBI.
-- Adapted for SCP: Breach gamemode

include('shared.lua')

SWEP.PrintName = "SCP-207"
SWEP.Author = "MrMarrant"
SWEP.Purpose = "Drink 'til We Die"
SWEP.DrawCrosshair = false
SWEP.Base = "weapon_base"
SWEP.AutoSwitchTo = false 


================================================
FILE: gamemodes/breach/entities/weapons/weapon_scp_207/shared.lua
================================================
-- SCP-207, A representation of a paranormal object on a fictional series on the game Garry's Mod.
-- Copyright (C) 2023  MrMarrant aka BIBI.
-- Adapted for SCP: Breach gamemode

AddCSLuaFile()

SWEP.PrintName = "SCP-207"
SWEP.Author = "MrMarrant"
SWEP.Purpose = "A cola that enhances physical abilities"
SWEP.Instructions = "Left click to drink, Right click to drop"

SWEP.Slot = 3
SWEP.SlotPos = 1

SWEP.Spawnable = true

SWEP.Category = "SCP: Breach"
SWEP.ViewModel = Model( "models/weapons/scp_207/v_scp_207.mdl" )
SWEP.WorldModel = Model( "models/weapons/scp_207/w_scp_207.mdl" )

SWEP.ViewModelFOV = 65
SWEP.HoldType = "slam"
SWEP.UseHands = true

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.DrawAmmo = false

-- Variables Personal to this weapon --
-- [[ STATS WEAPON ]]
SWEP.PrimaryCooldown = 3.5

local DrinkSound = Sound( "scp_207/drink.mp3" )

function SWEP:Initialize()
	self:SetWeaponHoldType( self.HoldType )
	self:SetHoldType( self.HoldType )
end

function SWEP:Deploy()
	local ply = self:GetOwner()
	local speedAnimation = GetConVarNumber( "sv_defaultdeployspeed" )
	self:SendWeaponAnim( ACT_VM_DRAW )
	self:SetPlaybackRate( speedAnimation )
	local VMAnim = ply:GetViewModel()
	local NexIdle = VMAnim:SequenceDuration() / VMAnim:GetPlaybackRate() 
	self:SetNextPrimaryFire( CurTime() + NexIdle + 0.1 ) --? We add 0.1s for avoid to cancel primary animation
	self:SetNextSecondaryFire( CurTime() + NexIdle )
	timer.Simple(NexIdle, function()
		if(!self:IsValid()) then return end
		self:SendWeaponAnim( ACT_VM_IDLE )
	end)
	return true
end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire( CurTime() + self.PrimaryCooldown )
	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	local VMAnim = self:GetOwner():GetViewModel()
	local NexIdle = VMAnim:SequenceDuration() / VMAnim:GetPlaybackRate()
	timer.Simple(NexIdle - 2.5, function()
		if(!self:IsValid()) then return end

		if SERVER then 
			sound.Play( DrinkSound, self:GetOwner():GetPos(), 75 )
		end
	end)
	timer.Simple(NexIdle, function()
		if(!self:IsValid() or !self:GetOwner():IsValid() or CLIENT) then return end

		-- Use Breach SCP-207 system
		if scp_207 and scp_207.ConsumeSCP207 then
			scp_207.ConsumeSCP207(self:GetOwner())
		end
		self:Remove()
	end)
end

function SWEP:SecondaryAttack()
	if CLIENT then return end
	self:SetNextSecondaryFire( CurTime() + self.PrimaryCooldown )
	
	-- Use Breach SCP-207 system
	if scp_207 and scp_207.DropSCP207 then
		scp_207.DropSCP207(self:GetOwner(), self)
	end
end 


================================================
FILE: gamemodes/breach/gamemode/cl_init.lua
================================================
include( "shared.lua" )


================================================
FILE: gamemodes/breach/gamemode/init.lua
================================================
AddCSLuaFile( "cl_init.lua" )
AddCSLuaFile( "shared.lua" )

include( "shared.lua" )


================================================
FILE: gamemodes/breach/gamemode/shared.lua
================================================
MODULES_PATH = GM.FolderName .. "/gamemode/modules"
LANGUAGES_PATH = GM.FolderName .. "/gamemode/languages"
MAP_CONFIG_PATH = GM.FolderName .. "/gamemode/mapconfigs"

ALLLANGUAGES = {}
WEPLANG = {}

print( "----------------Loading Languages----------------" )
local files = file.Find(LANGUAGES_PATH .. "/*.lua", "LUA" )
for k, f in pairs( files ) do
	if SERVER then
		AddCSLuaFile( LANGUAGES_PATH.."/"..f )
		include( LANGUAGES_PATH.."/"..f )
	else
		include( LANGUAGES_PATH.."/"..f )
		if string.sub( f, 1, 3 ) != "wep" then
			print("# Loading language: " .. f )
		end
	end
end

if SERVER then
	AddCSLuaFile( "modules/cl_module.lua" )
	AddCSLuaFile( "modules/sh_module.lua" )

	include( "modules/sv_module.lua" )
	include( "modules/sh_module.lua" )
else
	include( "modules/cl_module.lua" )
	include( "modules/sh_module.lua" )
end

print( "-----------------Loading Modules-----------------" )
local modules = file.Find( MODULES_PATH.."/*.lua", "LUA" )
local skipped = 0
for k, f in pairs( modules ) do
	if f == "sv_module.lua" or f == "sh_module.lua" or f == "cl_module.lua" then continue end

	if string.sub( f, 1, 1 ) == "_" then
		skipped = skipped + 1
		continue
	end

	if string.len( f ) > 3 then
		local ext = string.sub( f, 1, 3 )

		if ext == "cl_" then
			if SERVER then
				AddCSLuaFile( MODULES_PATH .. "/" .. f )
			else
				include( MODULES_PATH .. "/" .. f )
				print("# Loading module: " .. f )
			end
		elseif ext == "sv_" then
			if SERVER then
				include( MODULES_PATH .. "/" .. f )
				print("# Loading module: " .. f )
			end
		elseif ext == "sh_" then
			if SERVER then
				AddCSLuaFile( MODULES_PATH .. "/" .. f )
			end		
			include( MODULES_PATH .. "/" .. f )
			print("# Loading module: " .. f )
		end
	else
		skipped = skipped + 1
	end
end
print( "#" )
print( "# Skipped files: " .. skipped )

print( "---------------Loading Map Config----------------" )
if file.Exists( MAP_CONFIG_PATH .. "/" .. game.GetMap() .. ".lua", "LUA" ) then
	local relpath = "mapconfigs/" .. game.GetMap() .. ".lua"
	if SERVER then
		AddCSLuaFile( relpath )
	end
	include( relpath )
	print( "# Loading config for map " .. game.GetMap() )
	MAP_LOADED = true
else
	print( "----------------Loading Complete-----------------" )
	error( "Unsupported map " .. game.GetMap() .. "!" )
end

print( "----------------Loading Complete-----------------" )



================================================
FILE: gamemodes/breach/gamemode/autorun/cl_scp035_visuals.lua
================================================
if CLIENT then
    include("../modules/cl_scp035_visuals.lua")
end 


================================================
FILE: gamemodes/breach/gamemode/autorun/opa_canebar_throw.lua
================================================
hook.Add("KeyPress", "keypress_throw_canebar", function(ply, key)
    local throwlist = {
        "weapon_house_canebar",
    }
    throw = ply:GetActiveWeapon()
    if (ply:Alive())
    and ply:KeyPressed(IN_RELOAD)
    and table.HasValue(throwlist, throw:GetClass()) then

        ply:ViewPunch(Angle(math.random(1, 0), math.random(-0.5, -0.5), 0))

        if SERVER then
            ply:StripWeapon("weapon_house_canebar")
            t_canebar = ents.Create("canebar")
            if (IsValid(t_canebar)) then
                ang = ply:EyeAngles() + Angle(math.random(-2, -3), math.random(1.8, -0.9), 25)
                t_canebar:SetPos(ply:GetShootPos() + ang:Forward() * 1 + ang:Right() * 1.5 - ang:Up() * 0)
            end

            t_canebar:SetAngles(ang)
            t_canebar:Spawn()
            t_canebar:SetOwner(ply)
            local phys = t_canebar:GetPhysicsObject()
            if (IsValid(phys)) then
                phys:Wake()
                phys:AddVelocity(t_canebar:GetForward() * 800)
                phys:AddAngleVelocity(Vector(0, 1500, 0))
                ply:EmitSound(Sound("Weapon_Crowbar.Single"))
            end
        end
    end
end) 


================================================
FILE: gamemodes/breach/gamemode/languages/english.lua
================================================
english = {}

english.roundtype = "Round type: {type}"
english.preparing = "Prepare, round will start in {num} seconds"
english.round = "Game is live, good luck!"
english.specialround = "This is special round"

english.lang_pldied = "{num} player(s) died"
english.lang_descaped = "{num} Class D(s) escaped"
english.lang_sescaped = "{num} SCP(s) escaped"
english.lang_rescaped = "{num} Researcher(s) escaped"
english.lang_dcaptured = "Chaos Insurgency captured {num} Class D(s)"
english.lang_rescorted = "MTF escorted {num} Researcher(s)"
english.lang_teleported = "SCP - 106 caputred {num} victim(s) to the Pocket Dimension "
english.lang_snapped = "{num} neck(s) were snapped by SCP173"
english.lang_zombies = 'SCP - 049 "cured the disease" {num} time(s) '
english.lang_secret_found = "Secret has been found"
english.lang_secret_nfound = "Secret has not been found"

english.class_unknown = "Unknown"

english.NRegistry = {
	scpready = "You can be selected as SCP in next round",
	scpwait = "You have to wait %s rounds to be able to play as SCP"
}

english.NFailed = "Filed to access NRegistry with key: %s"

english.votefail = "You already voted or you are not allowed to vote!"
english.votepunish = "Vote for punish or forgive %s"
english.voterules = [[
	Write !punish to punish player or !forgive to forgive him
	The victim vote = 5 votes
	Normal player vote = 1 vote
	Additional 3 votes are calculated from spectators average votes
	Remember you can vote only once!
]]
english.punish = "PUNISH"
english.forgive = "FORGIVE"
english.voteresult = "Voting result against %s is... %s"
english.votes = "From %s players %s voted for punish and %s for forgive"
english.votecancel = "Last punish vote was canceled by admin"

english.eq_tip = "LMB - Select | RMB - Drop"
english.eq_open = "Press 'Q' to open new EQ!"

english.starttexts = {
	ROLE_SCPSantaJ = {
		"You are the SCP-SANTA-J",
		{"Your objective is to escape the facility",
		"You are Santa Claus! Give gifts to everyone!",
		"Merry Christmas and Happy New Year",
		"This is special SCP available only in Christmas event!"}
	},
	ROLE_SCP173 = {
		"You are the SCP-173",
		{"Your objective is to escape the facility",
		"You cannot move when someone is looking at you",
		"Remember, humans are blinking",
		"You have a special ability on RMB: blind everyone around you"}
	},
	ROLE_SCP096 = {
		"You are the SCP-096",
		{"Your objective is to escape the facility",
		"You move extremely fast when somebody is looking",
		"You can scream by using RMB"}
	},
	ROLE_SCP066 = {
		"You are the SCP-066",
		{"Your objective is to escape the facility",
		"You can play VERY loud sound",
		"LMB - attack, RMB - you can destroy windows"}
	},
	ROLE_SCP106 = {
		"You are the SCP-106",
		{"Your objective is to escape the facility",
		"When you touch someone, they will teleport",
		"to your pocket dimension"}
	},
	ROLE_SCP966 = {
		"You are the SCP-966",
		{"Your objective is to escape the facility",
		"You are invisible, humans can only see you using a nvg",
		"You hurt humans when you are near them",
		"You also disorientate them"}
	},
	ROLE_SCP682 = {
		"You are the SCP-682",
		{"Your objective is to escape the facility",
		"You are a Hard-to-Destroy Reptile",
		"You kill people instantly, although you are very slow",
		"You have a special ability on RMB"}
	},
	ROLE_SCP457 = {
		"You are the SCP-457",
		{"Your objective is to escape then facility",
		"You are always burning",
		"If you are close enough to a human, you will burn them"}
	},
	ROLE_SCP049 = {
		"You are the SCP-049",
		{"Your objective is to escape the facility",
		"If you use your special ability on someone, they will become SCP-049-2"}
	},
	ROLE_SCP689 = {
		"You are the SCP-689",
		{"Your objective is to escape the facility",
		"You are extremly slow, but also deadly",
		"You can kill anyone who look at you",
		"After you kill someone, you appear on the body",
		"LMB - attack, RMB - destroy windows"}
	},
	ROLE_SCP939 = {
		"You are the SCP-939",
		{"Your objective is to escape the facility",
		"Your are fast and strong",
		"You can deceive your targets by talking in their voice chat",
		"LMB - attack, RMB - change voice chat"}
	},
	ROLE_SCP999 = {
		"You are the SCP-999",
		{"Your objective is to escape the facility",
		"You can heal anybody you want",
		"You have to co-operate with other personnel or SCPs"}
	},
	ROLE_SCP082 = {
		"You are the SCP-082",
		{"Your objective is to escape the facility",
		"You are a cannibal with a machete",
		"Your attacks reduces your target's stamina",
		"When you kill somebody you will gain health"}
	},
	ROLE_SCP054 = {
		"You are the SCP-054",
		{"Your objective is to escape the facility",
		"You are a water-based entity",
		"LMB - Water laser attack, RMB - Steam explosion",
		"You have damage reduction against most attacks"}
	},
	ROLE_SCP2521 = {
		"You are the SCP-2521",
		{"Your objective is to escape the facility",
		"You are a dark entity that feeds on information",
		"LMB - Dark Strike (99 DMG), RMB - Silence Field",
		"R - Teleport, PASSIVE - Damage from chat/voice"}
	},
	ROLE_SCP239 = {
		"You are the SCP-239",
		{"Your objective is to escape the facility",
		"You are a reality bender with immense power",
		"LMB - Random reality manipulation ability",
		"You are immortal most of the time, but vulnerable every 2 minutes"}
	},
	ROLE_SCP3166 = {
		"You are the SCP-3166",
		{"Your objective is to escape the facility",
		"You are Garfield, a malevolent entity",
		"LMB - Claw attack (75 damage, 150 to lasagna target)",
		"RMB - Select new lasagna target",
		"PASSIVE - Kill lasagna target for +1500 HP and 50% speed boost"}
	},
	ROLE_SCPTTT_SAHUR = {
		"You are the SCP-TTT-SAHUR",
		{"Your objective is to escape the facility",
		"You are a dangerous entity wielding a baseball bat",
		"LMB - Baseball bat attack (60 damage)",
		"Fast and aggressive melee combat"}
	},
	ROLE_SCP1316 = {
		"You are the SCP-1316",
		{"Your objective is to escape the facility",
		"You are a cat-like entity with riding abilities",
		"LMB - Ride/Stop riding non-SCP players",
		"RMB - Defensive ability (99% damage reduction + 2x speed)",
		"When riding: You become invisible, immortal, and grant target +1 HP/s + 20% speed"}
	},
	ROLE_SCP2137J = {
		"You are the SCP-2137-J",
		{"Your objective is to escape the facility",
		"You are the holy Papaj entity",
		"LMB - Throw kremówka (explodes after 3 seconds)",
		"Kremówka deals AOE damage to non-SCP players"}
	},
	ROLE_SCPSTEVEJ = {
		"You are the SCP-Steve-J",
		{"Your objective is to escape the facility",
		"You are the legendary Minecraft Steve",
		"LMB - Diamond Sword attack (melee)",
		"RMB - Throw Ender Pearl (teleports you to impact location)"}
	},
	ROLE_SCPIMPOSTORJ = {
		"You are the SCP-Impostor-J",
		{"Your objective is to escape the facility",
		"You are a suspicious crewmate from Among Us",
		"LMB - Bowie knife attack (38 damage)",
		"Simple melee combat with knife weapon"}
	},
	ROLE_SCP617 = {
		"You are the SCP-617",
		{"Your objective is to escape the facility",
		"You are a Petrifying Statue",
		"PASSIVE - Anyone who touches you turns to stone",
		"No abilities needed - just exist and be deadly"}
	},
	ROLE_SCP3199 = {
		"You are the SCP-3199",
		{"Your objective is to escape the facility",
		"You are a hostile humanoid entity",
		"LMB - Bite attack, RMB - Corrosive spit",
		"Use Reload to roar and intimidate enemies"}
	},
	ROLE_SCP0082 = {
		"You are the SCP-0082",
		{"Your objective is to escape the facility",
		"You are a cannibal with a machete",
		"Your attacks reduces your target's stamina",
		"When you kill somebody you will gain health"}
	},
	ROLE_SCP023 = {
		"You are the SCP-023",
		{"Your objective is to escape the facility",
		"You are a wolf and you ignite everyone who goes through you",
		"Igniting others regenerate your health",
		"LMB - attack, RMB - you gain speed but you lose heath"}
	},
	ROLE_SCP1471 = {
		"You are the SCP-1471-A",
		{"Your objective is to escape the facility",
		"You can teleport yourself to your target",
		"LMB - attack, RMB - teleport to your target"}
	},
	ROLE_SCP1048A = {
		"You are the SCP-1048-A",
		{"Your objective is to escape the facility",
		"You look like SCP-1048, but you are made entirely out of human ears",
		"You emit a very loud scream"}
	},
	ROLE_SCP1048B = {
		"You are the SCP-1048-B",
		{"Your objective is to escape the facility",
		"Kill'em all"}
	},
	ROLE_SCP8602 = {
		"You are the SCP-860-2",
		{"Your objective is to escape the facility",
		"You are forest monster",
		"When you attack somebody near wall you charging on him"}
	},
	ROLE_SCP0492 = {
		"You are the SCP-049-2",
		{"Your objective is to escape the facility",
		"Cooperate with SCP-049 to kill more people"}
	},
	ROLE_SCP035 = {
		"You are SCP-035 - The Possessive Mask",
		{"Your objective is to escape the facility",
		"You can use human equipment and weapons",
		"You can kill both humans AND other SCPs",
		"You are the universal threat - everyone is your enemy"}
	},
	ROLE_SCP076 = {
		"You are the SCP-076-2",
		{"Your objective is to escape the facility",
		"You are fast and you have low HP",
		"You will be respawning until somebody destroy SCP-076-1"}
	},
	ROLE_SCP957 = {
		"You are the SCP-957",
		{"Your objective is to escape the facility",
		"You receive less damage, but on SCP-957-1 death you will receive damage",
		"Use LMB to deal AOE damage",
		"After attack, you and SCP-957-1 will receive some health"}
	},
	ROLE_SCP9571 = {
		"You are the SCP-957-1",
		{"Your objective is bring your friends to SCP-957",
		"Your vision is limited and you can talk with SCP-957",
		"Nobody knows that you are SCP, don't get exposed",
		"If you die, SCP-957 will receive damage"}
	},
	ROLE_SCP069 = {
		"You are SCP-069",
		{"Your objective is to escape the facility",
		"You can instantly kill humans with your touch",
		"You can disguise as your victims",
		"LMB - Instant kill touch, RMB - Open disguise menu"}
	},
	ROLE_SCPDOOMGUYJ = {
		"You are SCP-DOOMGUY-J - The Doom Slayer",
		{"Your objective is to escape the facility",
		"You wield the legendary DOOM Crucible sword",
		"LMB - Light melee attack | RMB - Heavy melee attack",
		"Your attacks deal massive damage to all enemies",
		"Rip and tear until it is done!"}
	},
	ROLE_SCP0082 = {
		"You are the SCP-008-2",
		{"Your objective is to infect every MTF and D",
		"If you kill someone, they will become 008-2 aswell"}
	},
	ROLE_RES = {
		"You are a Researcher",
		{"Your objective is to escape from the facility",
		"You need to find a MTF Guard that will help you",
		"Be on the look out of Class Ds as they might try to kill you"}
	},
	ROLE_MEDIC = {
		"You are a Medic",
		{"Your objective is to escape from the facility",
		"You need to find a MTF Guards that will help you",
		"Be on the look out of Class Ds as they might try to kill you",
		"If someone gets injured, heal them"}
	},
	ROLE_NO3 = {
		"You are a Level 3 Researcher",
		{"Your objective is to escape from the facility",
		"You know this place as nobody else",
		"Be on the look out of Class Ds as they might try to kill you",
		"You can communicate with security using the radio"}
	},
	ROLE_JANITOR = {
		"You are a Janitor",
		{"Your objective is to escape from the facility",
		"You maintain and clean the facility",
		"Use your broom to clean decals and move objects",
		"You have basic keycard access"}
	},
	ROLE_VIP = {
		"You are a VIP",
		{"You have special access to checkpoints",
		"Use your radio to coordinate with other personnel",
		"You may have a pocket knife for self-defense (25% chance)",
		"Help researchers and maintain facility security"}
	},
	ROLE_CLEARANCE_TECH = {
		"You are a Clearance Technician",
		{"You maintain and repair facility systems",
		"Use your radio to coordinate with researchers",
		"You may have a Universal Access Device (10% chance) - can override any door",
		"Your SCP Radar detects nearby anomalies visually",
		"You have standard researcher keycard access",
		"Help maintain facility operations and security"}
	},
	ROLE_ENGINEER = {
		"You are an Engineer",
		{"You design and maintain facility infrastructure",
		"Use your radio to coordinate with research teams",
		"You have standard researcher keycard access",
		"Your crowbar can repair Security Droids (+30 HP)",
		"You can fix overheated Security Droid systems",
		"Your Door Hacker can unlock locked doors (3 uses)",
		"Solve the memory sequence minigame to hack doors",
		"Help with technical operations and system maintenance"}
	},
	ROLE_COOK = {
		"You are a Cook",
		{"Your objective is to escape from the facility",
		"You prepare meals for facility personnel",
		"You have standard researcher keycard access",
		"Your doner knife is excellent for food preparation and self-defense",
		"Use your Kebab Stand Spawner to deploy döner stands",
		"Deploy stands in safe areas to serve nutritious food",
		"Kebab and ayran provide health restoration to consumers",
		"Help maintain facility morale through quality catering"}
	},
	ROLE_DRHOUSE = {
		"You are Dr. House",
		{"Your objective is to escape from the facility",
		"You are a brilliant but unconventional diagnostician",
		"Your medical syringe can heal injured personnel",
		"Your walking cane (House Canebar) serves as both support and weapon",
		"Use your medical expertise to help other survivors",
		"Your cynical wit and pill addiction don't affect your medical skills",
		"Everybody lies, but your diagnoses are usually correct",
		"PASSIVE: Death Harvest - gain 10 HP when someone dies nearby",
		"Solve medical mysteries and survive the containment breach"}
	},
	ROLE_PSYCHOLOGIST = {
		"You are a Site Psychologist",
		{"Your objective is to escape from the facility",
		"You provide psychological support to facility personnel",
		"You have standard researcher keycard access",
		"Your training helps you understand human behavior",
		"Use your radio to provide therapeutic communication",
		"Help maintain team morale and mental health",
		"Your psychological expertise may reveal hidden threats",
		"Assist in managing stress and trauma responses",
		"Support facility personnel through crisis situations"}
	},
	ROLE_CLASSD = {
		"You are a Class D",
		{"Your objective is to escape from the facility",
		"You need to cooperate with other Class Ds",
		"Search for keycards and be aware of MTF and SCPs"}
	},
	ROLE_VETERAN = {
		"You are a Veteran Class D",
		{"Your objective is to escape from the facility",
		"You need to cooperate with other Class Ds",
		"Search for keycards and be aware of MTF and SCPs",
		"25% chance to spawn with Jarate - a throwable jar of piss that marks enemies"}
	},
	ROLE_SCOUT_D = {
		"You are a Scout D",
		{"Your objective is to escape from the facility",
		"You are faster and more agile than regular Class D",
		"Use your speed to scout ahead and find escape routes",
		"Cooperate with other Class D personnel"}
	},
	ROLE_FAT_D = {
		"You are a Fat D",
		{"Your objective is to escape from the facility",
		"You are larger and slower than regular Class D",
		"You have more health but reduced mobility",
		"Use your bulk to block doorways and protect others"}
	},
	ROLE_SKINNY_D = {
		"You are a Skinny D",
		{"Your objective is to escape from the facility",
		"You are thinner and faster than regular Class D",
		"You have less health but increased mobility",
		"Use your speed and agility to avoid dangers"}
	},

	ROLE_THIEF_D = {
		"You are a Thief D",
		{"Your objective is to escape from the facility",
		"You are a skilled pickpocket and thief",
		"PASSIVE: Weapon Theft - Press E on players to steal their active weapon",
		"Cannot steal from SCPs, holsters, or security tags",
		"Ability has 60-second cooldown after each successful theft",
		"Use your thievery skills to arm yourself and other Class D"}
	},
	ROLE_SCP527 = {
		"You are SCP-527 (Mr. Fish)",
		{"Your objective is to escape from the facility",
		"You appear as a normal Class D personnel to others",
		"You are actually an anomalous humanoid with a fish head",
		"Nobody seems to notice anything unusual about you"}
	},
	ROLE_CIC = {
		"You are a Chaos Insurgency Agent",
		{"Your objective is to help Class D",
		"You organize them",
		"Be aware of MTF and SCPs, and wait for support"}
	},
	ROLE_SECURITY = {
		"You are a Security Officer",
		{"Your objective is to find and rescue all",
		"of the researchers that are still in the facility",
		"You have to kill any Class D or SCP that you will find",
		"Listen to your boss's orders and stick to your team"}
	},
	ROLE_CSECURITY = {
		"You are a Security Chief",
		{"Your objective is to find and rescue all",
		"of the researchers that are still in the facility",
		"You have to kill any Class D or SCP that you will find",
		"Give orders to Security Officers and listen to your boss"}
	},
	ROLE_MTFGUARD = {
		"You are a MTF Guard",
		{"Your objective is to find and rescue all",
		"of the researchers that are still in the facility",
		"You have to kill any Class D or SCP that you will find",
		"Listen to MTF Commander's orders and stick to your team"}
	},
	ROLE_MTF_HEAVY_SUPPORT = {
		"You are a MTF Heavy Support",
		{"Your objective is to provide heavy firepower support",
		"You have the best armor but move slower",
		"Your role is to eliminate high-threat targets",
		"Listen to MTF Commander's orders and protect your team"}
	},
	ROLE_SECURITY_DROID = {
		"You are a Security Droid",
		{"Your objective is to find and rescue all",
		"of the researchers that are still in the facility",
		"You have to kill any Class D or SCP that you will find",
		"You cannot wear armor but take 50% less bullet damage",
		"WARNING: 2 stunstick hits cause overheating (90% slower for 8s)!"}
	},
	-- ROLE_MEDIC_DROID = { -- Usunięto klasę Medic Droid
	-- 	"You are a Medic Droid",
	-- 	{"Your objective is to support Security Droids and MTF personnel",
	-- 	"You cannot pick up any CW2 weapons - you are a medical unit",
	-- 	"PASSIVE ABILITY: Hold E on Security Droid with <50% HP to heal them to 50%",
	-- 	"You are equipped with advanced medical protocols",
	-- 	"Focus on keeping your team alive and operational"}
	-- },
	ROLE_MTFMEDIC = {
		"You are a MTF Medic",
		{"Your objective is support your teammates",
		"If someone gets injured, heal them",
		"Listen to MTF Commander's orders and stick to your team"}
	},
	ROLE_HAZMAT = {
		"You are a Special MTF Unit",
		{"Your objective is to find and rescue all",
		"of the researchers that are still in the facility",
		"You have to kill any Class Ds or SCPs that you will find",
		"Listen to the MTF Commander and Site Director"}
	},
	ROLE_MTFL = {
		"You are a MTF Lieutenant",
		{"Your objective is to find and rescue all",
		"of the researchers that are still in the facility",
		"You have to kill any Class Ds or SCPs that you will find",
		"Give orders to Guards to simplify the task",
		"Listen to the MTF Commander and Site Director"}
	},
	ROLE_SD = {
		"You are a Site Director",
		{"Your objective is to give objectives",
		"You need to give objectives to the site security",
		"You need to keep the site secure, don't let any SCP or Class D escape"}
	},
	ROLE_O5 = {
		"You are O5 Council Member",
		{"Your have unlimited access to everything",
		"You are the most important person here, give orders",
		"Do everything what you can to save foundation reputation and world"}
	},
	ROLE_MTFNTF = {
		"You are a MTF Unit Nine-Tailed Fox",
		{"Your objective is to find and rescue all",
		"of the researchers that are still in the facility",
		"You have to kill any Class D or SCP that you will find",
		"Go to the facility and help Guards to embrace a chaos"}
	},
	ROLE_MTFCOM = {
		"You are a MTF Commander",
		{"Your objective is to find and rescue all",
		"of the researchers that are still in the facility",
		"You have to kill any Class Ds or SCPs that you will find",
		"Give orders to Guards to simplify the task"}
	},
	ROLE_CHAOS = {
		"You are the Chaos Insurgency Soldier",
		{"Your objective is to capture as much Class Ds as it is possible",
		"Escort them to the helipad outisde of the facility",
		"You have to kill anyone who will stop you"}
	},
	ROLE_CHAOSSPY = {
		"You are the Chaos Insurgency Spy",
		{"Your objective is to kill all MTF Guards and capture the Class D",
		"They are unaware of your disguise",
		"Don't destroy your disguise",
		"If you find any class ds, try to escort them to the helipad"}
	},
	ROLE_CHAOSCOM = {
		"You are the Chaos Insurgency Commander",
		{"Your objective is to give objectives to your team",
		"Kill anyone who will stop you"}
	},
	ROLE_GOC_SOLDIER = {
		"You are a GOC Soldier",
		{"Your mission is to eliminate all anomalous entities and hostile personnel",
		"You have no allies - everyone is your enemy",
		"Secure, Contain, Protect - by any means necessary"}
	},
	ROLE_GOC_OPERATIVE = {
		"You are a GOC Operative",
		{"Advanced operative tasked with anomaly containment and elimination",
		"Trust no one - eliminate all threats to normalcy",
		"Use your training to neutralize all anomalous activity"}
	},
	ROLE_GOC_COMMANDER = {
		"You are a GOC Commander",
		{"Lead GOC operations and coordinate elimination protocols",
		"Your authority extends to all anomalous threats",
		"Command your forces to restore normalcy"}
	},
	ROLE_SPEC = {
		"You are a Spectator",
		{'Use command "br_spectate" to come back'}
	},
	ADMIN = {
		"You are in admin mode",
		{'Use command "br_admin_mode" to come back in next round'}
	},
	ROLE_INFECTD = {
		"You are Class D Presonnel",
		{'This is special round "infect"',
		"You need to cooperate with MTFs to stop the infection",
		"When you will be killed by zombie you will be one of them"}
	},
	ROLE_INFECTMTF = {
		"You are MTF",
		{'This is special round "infect"',
		"You need to cooperate with D Class to stop the infection",
		"When you will be killed by zombie you will be one of them"}
	},
	

}

english.lang_end1 = "The game ends here"
english.lang_end2 = "Time limit has been reached"
english.lang_end3 = "Game ended due to the inability to continue"

english.escapemessages = {
	{
		main = "You escaped",
		txt = "You escaped the facility in {t} minutes, good job!",
		txt2 = "Try to get escorted by MTF next time to get bonus points.",
		clr = Color(237, 28, 63),
	},
	{
		main = "You escaped",
		txt = "You escaped the facility in {t} minutes, good job!",
		txt2 = "Try to get escorted by Chaos Insurgency Soldiers next time to get bonus points.",
		clr = Color(237, 28, 63),
	},
	{
		main = "You were escorted",
		txt = "You were escorted in {t} minutes, good job!",
		txt2 = "",
		clr = Color(237, 28, 63),
	},
	{
		main = "You escaped",
		txt = "You escaped in {t} minutes, good job!",
		txt2 = "",
		clr = Color(237, 28, 63),
	}
}



english.ROLES = {}

english.ROLES.ADMIN = "ADMIN MODE"
english.ROLES.ROLE_INFECTD = "Class D Personnel"
english.ROLES.ROLE_INFECTMTF = "MTF"

english.ROLES.ROLE_SCPSantaJ = "SCP-SANTA-J"
english.ROLES.ROLE_SCP173 = "SCP-173"
english.ROLES.ROLE_SCP106 = "SCP-106"
english.ROLES.ROLE_SCP049 = "SCP-049"
english.ROLES.ROLE_SCP457 = "SCP-457"
english.ROLES.ROLE_SCP966 = "SCP-966"
english.ROLES.ROLE_SCP096 = "SCP-096"
english.ROLES.ROLE_SCP066 = "SCP-066"
english.ROLES.ROLE_SCP689 = "SCP-689"
english.ROLES.ROLE_SCP682 = "SCP-682"
english.ROLES.ROLE_SCP082 = "SCP-082"
english.ROLES.ROLE_SCP939 = "SCP-939"
english.ROLES.ROLE_SCP999 = "SCP-999"
english.ROLES.ROLE_SCP023 = "SCP-023"
english.ROLES.ROLE_SCP076 = "SCP-076-2"
english.ROLES.ROLE_SCP1471 = "SCP-1471-A"
english.ROLES.ROLE_SCP8602 = "SCP-860-2"
english.ROLES.ROLE_SCP1048A = "SCP-1048-A"
english.ROLES.ROLE_SCP1048B = "SCP-1048-B"
english.ROLES.ROLE_SCP0492 = "SCP-049-2"
english.ROLES.ROLE_SCP035 = "SCP-035"
english.ROLES.ROLE_SCP0082 = "SCP-008-2"
english.ROLES.ROLE_SCP957 = "SCP-957"
english.ROLES.ROLE_SCP9571 = "SCP-957-1"
english.ROLES.ROLE_SCP069 = "SCP-069"
english.ROLES.ROLE_SCPDOOMGUYJ = "SCP-DOOMGUY-J"
english.ROLES.ROLE_SCP3199 = "SCP-3199"
english.ROLES.ROLE_SCP054 = "SCP-054"
english.ROLES.ROLE_SCP2521 = "SCP-2521"
english.ROLES.ROLE_SCP239 = "SCP-239"
english.ROLES.ROLE_SCP3166 = "SCP-3166"
english.ROLES.ROLE_SCPTTT_SAHUR = "SCP-TTT-SAHUR"
english.ROLES.ROLE_SCP1316 = "SCP-1316"
english.ROLES.ROLE_SCP2137J = "SCP-2137-J"
english.ROLES.ROLE_SCPSTEVEJ = "SCP-Steve-J"
english.ROLES.ROLE_SCPIMPOSTORJ = "SCP-Impostor-J"
english.ROLES.ROLE_SCP617 = "SCP-617"

english.ROLES.ROLE_RES = "Researcher"
english.ROLES.ROLE_MEDIC = "Medic"
english.ROLES.ROLE_NO3 = "Level 3 Researcher"
english.ROLES.ROLE_JANITOR = "Janitor"
english.ROLES.ROLE_VIP = "VIP"
english.ROLES.ROLE_CLEARANCE_TECH = "Clearance Technician"
english.ROLES.ROLE_ENGINEER = "Engineer"
english.ROLES.ROLE_COOK = "Cook"
english.ROLES.ROLE_DRHOUSE = "Dr. House"
english.ROLES.ROLE_PSYCHOLOGIST = "Site Psychologist"
english.ROLES.ROLE_DCLASS_INFECTED = "D-Class Infected"

english.ROLES.ROLE_CLASSD = "Class D Personnel"
english.ROLES.ROLE_VETERAN = "Class D Veteran"
english.ROLES.ROLE_SCOUT_D = "Scout D"
english.ROLES.ROLE_FAT_D = "Fat D"
english.ROLES.ROLE_SKINNY_D = "Skinny D"
english.ROLES.ROLE_THIEF_D = "Thief D"

english.ROLES.ROLE_SCP527 = "SCP-527"
english.ROLES.ROLE_CIC = "CI Agent"

english.ROLES.ROLE_SECURITY = "Security Officer"
english.ROLES.ROLE_MTFGUARD = "MTF Guard"
english.ROLES.ROLE_MTF_HEAVY_SUPPORT = "MTF Heavy Support"
english.ROLES.ROLE_SECURITY_DROID = "Security Droid"
-- english.ROLES.ROLE_MEDIC_DROID = "Medic Droid" -- Usunięto klasę Medic Droid
english.ROLES.ROLE_MTFMEDIC = "MTF Medic"
english.ROLES.ROLE_MTFL = "MTF Lieutenant"
english.ROLES.ROLE_HAZMAT = "MTF SCU"
english.ROLES.ROLE_MTFNTF = "MTF NTF"
english.ROLES.ROLE_CSECURITY = "Security Chief"
english.ROLES.ROLE_MTFCOM = "MTF Commander"
english.ROLES.ROLE_SD = "Site Director"
english.ROLES.ROLE_O5 = "O5 Council Member"

english.ROLES.ROLE_CHAOSSPY = "CI Spy"
english.ROLES.ROLE_CHAOS = "CI Soldier"
english.ROLES.ROLE_CHAOSCOM = "CI Commander"

english.ROLES.ROLE_GOC_SOLDIER = "GOC Soldier"
english.ROLES.ROLE_GOC_OPERATIVE = "GOC Operative"
english.ROLES.ROLE_GOC_COMMANDER = "GOC Commander"

english.ROLES.ROLE_SPEC = "Spectator"

english.credits_orig = "Created by:"
english.credits_edit = "Modified and repaired by:"
english.settings = "Settings"
english.updateinfo = "Show changes after update"
english.done = "Ready"
english.repe = "Write br_reset_intro to show intro again"

english.author = "Author"
english.helper = "Assistant"
english.originator = "Collaborator"

english.updates = {
	"english",
	"Update notes",
	"Update notes of version %s are unavailable",
	"Server version",
}

-- Weapon descriptions
english.WEAPON_UNIVERSAL_ACCESS = {
	name = "Universal Access Device",
	desc = "Advanced override device that can bypass any door system. Limited uses with cooldown."
}

english.WEAPON_SCP_RADAR = {
	name = "SCP Radar",
	desc = "Passive radar display showing SCP locations. Works automatically when in inventory."
}

english.DONER_KNIFE = {
	name = "Döner Kebab Knife",
	author = "Professional Kitchen Equipment Ltd.",
	contact = "chef@kitchen.com",
	purpose = "Professional-grade chef's knife for döner preparation",
	instructions = [[Professional chef's knife used for cutting döner kebab.
Sharp blade excellent for food preparation and self-defense.

LMB - Light cut (15-20 dmg)
RMB - Heavy stab (45 dmg, 80 backstab)
R - Inspect]]
}

-- VIP Panic Button messages
english.VIP_PANIC = {
	button_hint = "Press [P] - VIP Panic Button",
	cooldown_hint = "VIP Panic Button - Cooldown: %ds",
	signal_sent = "[PANIC] Emergency signal sent to security forces!",
	cooldown_active = "[PANIC] Cooldown: %ds",
	phase_blocked = "[PANIC] Cannot use panic button during this phase!",
	alert_message = "%s has activated their panic button!",
	alert_prefix = "[VIP PANIC] ",
	bind_suggestion = "Press P for panic button or type 'vip_panic' in console!"
}



ALLLANGUAGES.english = english



================================================
FILE: gamemodes/breach/gamemode/languages/wep_english.lua
================================================
lang = {}

lang.SCP_0082 = {
	author = "Kanade, edited by danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Infect",
	instructions = "LMB to attack",
}

lang.SCP_023 = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Kill",
	instructions = "LMB to attack",
	HUD = {
		lowhealth = "Your health is too low",
	},
}

lang.SCP_049 = {
	author = "Kanade",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "'Cure'",
	instructions = "LMB to 'cure' someone",
	HUD = {
		attackReady = "Ready to attack",
		attackCD = "Next attack in",
	},
}

lang.SCP_066 = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Kill",
	instructions = "LMB to play sound",
	HUD = {
		attackReady = "Ready to attack",
		attackCD = "Next attack in",
	},
}

lang.SCP_082 = {
	author = "danx91, wepon from M9K Specialities",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Kill",
	instructions = "LMB to attack",
}

lang.SCP_076 = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Kill",
	instructions = "LMB to attack",
}

lang.SCP_096 = {
	author = "Vinrax, edited by danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Kill",
	instructions = "LMB to attack",
}

lang.SCP_106 = {
	author = "Kanade",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Kill",
	instructions = "LMB to teleport someone to pocket dimension\nRMB to place teleport\nR to teleport yourself to marked position",
	HUD = {
		attackReady = "Ready to attack",
		attackCD = "Next attack in",
		teleportReady = "Teleport ready",
		teleportCD = "Next teleport in"
	},
}

lang.SCP_173 = {
	author = "Kanade",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Kill",
	instructions = "LMB to kill someone, RMB to blind you targets",
	HUD = {
		nlook = "Noone is looking",
		specCD = "Speial ready to use in",
		specReady = "Special ready to use",
		slook = "Someone is looking",
	}
}

lang.SCP_420j = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "The Best weed in the World",
	instructions = "MAN DATS SUM GOOD ASS SHIT",
}

lang.SCP_457 = {
	author = "Kanade",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Burn",
	instructions = "",
}

lang.SCP_500 = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Heal yourself",
	instructions = "LMB to use, or it will be triggered automatically when you should receive deadly hit",
}

lang.SCP_018 = {
	author = "Garry Newman",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Super bouncy ball that increases speed with each bounce",
	instructions = "LMB to throw the ball - it will bounce faster and faster until it explodes!",
}

lang.BR_INTERCOM = {
	author = "Breach SCP Team",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Facility-wide communication system",
	instructions = "Press E to activate. Use your microphone OR chat to broadcast to the entire facility. Press E again to stop transmission.",
}

lang.SCP_207 = {
	author = "MrMarrant, adapted for Breach",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Enhanced cola that boosts physical abilities",
	instructions = "LMB to drink the cola and gain superhuman speed and strength. WARNING: May cause cardiac failure!",
}

lang.SCP_682 = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Kill",
	instructions = "LMB to attack, RMB to use ability",
	HUD = {
		attackReady = "Ability ready",
		attackCD = "Ability ready in",
	},
}

lang.SCP_689 = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Kill",
	instructions = "LMB to teleport yourself to your target",
	HUD = {
		attackReady = "Ready to attack",
		attackCD = "Next attack in",
		targets = "Targets"
	},
}

lang.SCP_714 = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Protect yourself",
	instructions = "Hold to use",
	HUD = {
		durability = "Durability:",
		protect = "You are protected",
		protend = "Your protection will end soon",
	},
}

lang.SCP_8602 = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Kill",
	instructions = "LMB to attack",
}

lang.SCP_939 = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Kill",
	instructions = "LMB to attack, RMB to change voice chat",
	HUD = {
		attackReady = "Ready to attack",
		attackCD = "Next attack in",
		channel = "Current voiche chat:",
	},
}

lang.SCP_957 = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Kill",
	instructions = "LMB to deal AOE damage",
	HUD = {
		rattack = "Attack ready",
		nattack = "Next attack in",
		nsummon = "SCP-957-1 transformation in",
		asummon = "SCP-957-1 is alive",
		buffd = "SCP-957-1 is too far!",
		buffe = "Buff enabled",
	},
}

lang.SCP_966 = {
	author = "Kanade, edited by danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Kill",
	instructions = "You deal damage when you are near human",
}

lang.SCP_999 = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Heal everybody",
	instructions = "LMB to heal target, RMB to heal everybody in close area",
	HUD = {
		healReady = "Heal is ready",
		healCD = "Heal in on cooldown. Wait",
		ghealReady = "Group heal is ready",
		ghealCD = "Group heal in on cooldown. Wait",
	},
}

lang.SCP_1048A = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Kill",
	instructions = "LMB to emit loud scream",
	HUD = {
		attackReady = "Ready to attack",
		attackCD = "Next attack in",
	},
}

lang.SCP_1048B = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Kill",
	instructions = "LMB to attack",
}

lang.SCP_1471 = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Kill",
	instructions = "LMB to attack, RMB to teleport yourself",
	HUD = {
		attackReady = "Ready to attack",
		attackCD = "Next attack in",
	},
}

lang.SCP_SantaJ = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Give gifts",
	instructions = "LMB to throw gift",
	HUD = {
		attackReady = "Ready to attack",
		attackCD = "Next attack in",
		gtype = "Gift type:",
		explosive = "Explosive",
		healing = "Healing",
	},
}

lang.HOLSTER = {
	author = "Kanade",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Holster",
	instructions = "",
}

lang.ID = {
	author = "Kerry, edited by danx91",
	contact = "Just add on Steam",
	purpose = "Show your ID tag to others",
	instructions = "",
	name = "Name:",
	city = "City:",
}

lang.CV = {
	author = "Kanade",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Look at cameras",
	instructions = "If you hold it, click RMB to change the view",
	changed = "Changed to"
}

lang.EYEDROPS = {
	author = "Kanade",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Stops blinking for 10 seconds",
	instructions = "Click left to use",
}

lang.MEDKIT = {
	author = "Kanade",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Heal yourself or other people",
	instructions = "Click left to heal yourself, right to heal others",
}

lang.NVG = {
	author = "Kanade",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Gives you night vision",
	instructions = "Hold it",
}

lang.RADIO = {
	author = "Kanade",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Communicate",
	instructions = "If you hold it, your chat messages and voice chat will be global with others that have the radio",
	channel = "Radio Channel",
	disabled = "Radio Disabled",
}

lang.SNAV = {
	author = "Kanade",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Find a way to go",
	instructions = "If you hold it, click RMB to change the view",
}

lang.SNAV_ULT = {
	author = "Kanade",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Find a way to go and scan for enemies",
	instructions = "If you hold it, click RMB to change the view",
	mtfdetect = "MTF Guard detected",
	cidetect = "Chaos Insurgency Member detected",
	resdetect = "Researcher detected",
	ddetect = "Class D detected",
	unkdetect = "Humanoid form detected",
	detect = "detected",
	items = "Detected items:"
}

lang.KEYCARD = {
	author = "danx91",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Opens doors which requires keycard (Hold reload key to see where card have access)",
	instructions = "Access:",
	ACC = {
		"SAFE",
		"EUCLID",
		"KETER",
		"Checkpoints",
		"OMEGA Warhead",
		"General Access",
		"Gate A",
		"Gate B",
		"Armory",
		"Femur Breaker",
		"EC",
	},
	STATUS = {
		"ACCESS",
		"NO ACCESS",
	},
	NAMES = {
		"Keycard Level 1",
		"Keycard Level 2",
		"Keycard Level 3",
		"Researcher Keycard",
		"MTF Guard Keycard",
		"MTF Commander Keycard",
		"Keycard Level OMNI",
		"Checkpoint Security Keycard",
		"Hacked CI Keycard",
	},
}

lang.ZEUS = {
	author = "BFG9000, edited by danx91",
	contact = "Workshop Page",
	purpose = "Deliver a lethal dose of electricity at close range",
	instructions = "Must be in close range for instakill.",
}

lang.ZEUS_EXP = {
	author = "PROTOTYPE",
	contact = "PROTOTYPE",
	purpose = "PROTOTYPE",
	instructions = "PROTOTYPE",
}

lang.SCP_DOOMGUYJ = {
	author = "ID Software / Kilo Code",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "RIP AND TEAR",
	instructions = "LMB for light attack, RMB for heavy attack",
	HUD = {
		lightAttackReady = "Light Attack Ready",
		lightAttackCD = "Light Attack CD:",
		heavyAttackReady = "Heavy Attack Ready",
		heavyAttackCD = "Heavy Attack CD:",
		damage = "Damage:",
	},
}

lang.SCP_IMPOSTOR_J = {
	author = "Blaze/QuentinDylanP",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Suspicious impostor among us",
	instructions = "LMB: Knife attack",
}

lang.SCP_617 = {
	author = "AI Assistant",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Turn humans to stone",
	instructions = "PASSIVE: Touch to petrify",
}

lang.POCKET_KNIFE = {
	author = "AI Assistant",
	contact = "Look at this gamemode in workshop and search for creators",
	purpose = "Compact folding knife for Scout D personnel",
	instructions = "LMB: Stab attack, RMB: Slash attack, R: Inspect",
}

WEPLANG.english = lang


================================================
FILE: gamemodes/breach/gamemode/mapconfigs/gm_site19.lua
================================================
-- Serverside map config file, if you want to use a diffrent map change these variables

CCTV = {
	{
		name = "Class D cells",
		pos = Vector( -300.880524, -936.250854, 255.968750 ),
		ang = Angle( 32.125, 137.296, 0.000 )
	},
	{
		name = "LCZ Lock",
		pos = Vector( 2415.669189, -2415.156250, 127.968750 ),
		ang = Angle( 21.345, 135.096, 0.000 )
	},
	{
		name = "Armory",
		pos = Vector( 1244.758545, -1546.920898, 127.968750 ),
		ang = Angle( 13.100, -0.504, 0.000 )
	},
	{
		name = "LCZ Main Hall",
		pos = Vector( 2407.205078, -124.942398, 255.968750 ),
		ang = Angle( 39.720, -147.464, 0.000 )
	},
	{
		name = "SCP 079",
		pos = Vector( 3794.826416, -1125.444580, -0.031250 ),
		ang = Angle( 23.880, 110.235, 0.000 )
	},
	{
		name = "Omega Warhead",
		pos = Vector( 4069.712402, 169.602386, -256.031250 ),
		ang = Angle( 39.720, 127.464, 0.000 )
	},
	{
		name = "HCZ Tesla Gate",
		pos = Vector( 4155.907715, 1428.488037, 255.968750 ),
		ang = Angle( 31.360, 91.075, 0.000 )
	},
	{
		name = "SCP 106",
		pos = Vector( 2302.043213, 5010.212891, -128.031250 ),
		ang = Angle( 20.780, 136.395, 0.000 )
	},
	{
		name = "EZ Checkpoint Exit 1",
		pos = Vector( 1135.397461, 3720.185059, 127.968750 ),
		ang = Angle( 14.400, -149.886, 0.000 )
	},
	{
		name = "EZ Checkpoint Exit 2",
		pos = Vector( 709.690918, 2182.443359, 127.968750 ),
		ang = Angle( 16.820, 53.175, 0.000 )
	},
	{
		name = "Electrical Center",
		pos = Vector( -2457.775635, 3769.280029, 127.968750 ),
		ang = Angle( 15.060, -35.784, 0.000 )
	},
	{
		name = "Gate A",
		pos = Vector( -698.344604, 5353.954590, 260.359039 ),
		ang = Angle( 27.820, -43.104, 0.000 )
	},
	{
		name = "Gate B",
		pos = Vector( -3959.009521, 2423.581055, 255.968750 ),
		ang = Angle( 27.160, -43.485, 0.000 )
	},
	{
		name = "Gate A - Surface",
		pos = Vector( -1081.659912, 5891.317383, 2815.968750 ),
		ang = Angle( 23.640, -35.406, 0.000 )
	},
	{
		name = "Surface",
		pos = Vector( -800.234619, 6919.050781, 2535.238770 ),
		ang = Angle( 14.840, 178.874, 0.000 )
	},
	{
		name = "Tunnel",
		pos = Vector( -2666.820068, 1632.292480, 2769.426270 ),
		ang = Angle( 16.380, 120.354, 0.000 )
	},
	{
		name = "Gate B - Surface",
		pos = Vector( -3725.372803, 2067.642578, 2703.968750 ),
		ang = Angle( 13.980, 168.314, 0.000 )
	},
	{
		name = "Facility Exit",
		pos = Vector( -7131.351563, 1044.328735, 2687.968750 ),
		ang = Angle( 9.800, 71.294, 0.000 )
	}
}

CAMERAS = {
	{
	 name = "OUTSIDE",
	 pos = Vector(-175.584122, 6703.034180, 1725.708130),
	 ang = Angle(0.000, 146.079, 0.000)
	},
	{
	 name = "GATE_A",
	 pos = Vector(-697.264893, 5349.814941, 226.462402),
	 ang = Angle(0.000, -12.395, 0.000)
	},
	{
	 name = "GATE_B",
	 pos = Vector(-3950.994873, 2414.622559, 190.495819),
	 ang = Angle(0.000, -48.519, 0.000)
	},
	{
	 name = "CAFETERIA",
	 pos = Vector(53.675919, 3155.835693, 140.282364),
	 ang = Angle(0.000, 88.400, 0.000)
	},
	{
	 name = "HCZ_TESLA",
	 pos = Vector(4210.521484, 2002.322388, 149.438217),
	 ang = Angle(0.000, -101.296, 0.000)
	},
	{
	 name = "HCZ_1",
	 pos = Vector(3171.853516, 2657.589111, 50.352276),
	 ang = Angle(0.000, -153.835, 0.000)
	},
	{
	 name = "SCP_173",
	 pos = Vector(816.530701, 1170.705566, 337.440979),
	 ang = Angle(0.000, 134.616, 0.000)
	},
	{
	 name = "SCP_106",
	 pos = Vector(2868.708252, 4928.124023, 166.737183),
	 ang = Angle(0.000, -134.537, 0.000)
	},
	{
	 name = "LCZ_MAIN",
	 pos = Vector(718.819336, -58.217102, 181.064407),
	 ang = Angle(0.000, -56.380, 0.000)
	},
	{
	 name = "LCZ_DCELLS",
	 pos = Vector(-659.140808, 1138.599976, 350.122894),
	 ang = Angle(0.000, -173.823, 0.000)
	},
}

XMAS_TREES = {
	Vector( -2170.2041015625, 1089.9940185547, 129.03125 ),
	Vector( -1091.0847167969, 393.23141479492, -127.96875 ),
	Vector( -449.4407043457, -874.96789550781, 0.03125 ),
	Vector( 1793.9749755859, -774.04718017578, -767.96875 ),
	Vector( 1119.6271972656, -744.94757080078, -767.96875 ),
	Vector( 2121.2395019531, -1456.1025390625, 0.03125 ),
	Vector( 1472.2424316406, -329.39147949219, 0.03125 ),
	Vector( 4158.232421875, 1095.1954345703, 1.03125 ),
	Vector( 2241.8610839844, 3599.0844726563, 1.03125 ),
	Vector( 4545.98828125, 3079.5014648438, -15.226189613342 ),
	Vector( -29.891288757324, 4126.80859375, -127.96875 ),
	Vector( -451.65881347656, 3638.8293457031, 0.03125 ),
	Vector( -2429.5910644531, 2323.431640625, 0.03125 ),
	Vector( 438.28244018555, 2260.6896972656, 0.03125 )	
}

XMAS_SNOWMANS_SMALL = {
	{ Vector( -6529.40625, -944.92364501953, 1728.03125 ), Angle(0, 87.57991027832, 0 ) },
	{ Vector( -3753.7614746094, 2140.8081054688, 2048.03125 ), Angle(0, -127.43989562988, 0 ) },
	{ Vector( -3131.4514160156, 1663.3319091797, 1792.03125 ), Angle(0, 71.519874572754, 0 ) },
	{ Vector( -1975.4678955078, 6577.7612304688, 1664.03125 ), Angle(0, 90.660316467285, 0 ) },
	{ Vector( -843.01550292969, 5697.3149414063, 2320.03125 ), Angle(0, -48.960102081299, 0 ) },
	{ Vector( 3014.5771484375, 498.03970336914, 0.03125 ), Angle(0, -176.92054748535, 0 ) },
	{ Vector( 3141.2834472656, -1723.125, 0.03125 ), Angle(0, 92.579223632813, 0 ) },
	{ Vector( 789.08074951172, -2386.18359375, 0.03125 ), Angle(0, 64.320098876953, 0 ) },
	{ Vector( 535.77416992188, -599.33648681641, -767.96875 ), Angle(0, 46.141635894775, 0 ) },
	{ Vector( -676.01422119141, 2961.1325683594, 18.150749206543 ), Angle(0, -89.097396850586, 0 ) },
	{ Vector( 3712.970703125, 3886.3859863281, 896.03125 ), Angle(0, 91.339179992676, 0 ) },
}

XMAS_SNOWMANS_BIG = {
	{ Vector( -693.18060302734, 194.86322021484, 224.03125 ), Angle(0, -179.69273376465, 0 ) },
	{ Vector( -2175.8583984375, 1853.4505615234, 128.03125 ), Angle(0, -38.429801940918, 0 ) },
	{ Vector( 767.58337402344, 1863.4921875, 256.03125 ), Angle(0, -93.640075683594, 0 ) },
	{ Vector( -1474.9448242188, -1032.8494873047, 1.03125 ), Angle(0, 41.919815063477, 0 ) },
	{ Vector( 1667.7823486328, -838.404296875, 128.46627807617 ), Angle(0, 179.45988464355, 0 ) },
	{ Vector( 1443.662109375, -2395.34765625, 1.03125 ), Angle(0, 53.210380554199, 0 ) },
	{ Vector( 2160.0126953125, -2153.0964355469, 1.03125 ), Angle(0, -44.659339904785, 0 ) },
	{ Vector( 3896.3076171875, -515.59429931641, -255.96875 ), Angle(0, -121.84869384766, 0 ) },
	{ Vector( 4487.083984375, 517.02947998047, 0.03125 ), Angle(0, -124.81783294678, 0 ) },
	{ Vector( 4246.6484375, 2470.2468261719, 0.03125 ), Angle(0, -141.97872924805, 0 ) },
	{ Vector( 2822.4235839844, 3004.1157226563, -382.96875 ), Angle(0, -0.21961487829685, 0 ) },
	{ Vector( 2530.7189941406, 4496.55859375, -98.96875 ), Angle(0, -178.71936035156, 0 ) },
	{ Vector( -1358.7789306641, 3923.2878417969, -63.96875 ), Angle(0, -62.779651641846, 0 ) },
	{ Vector( -2954.0185546875, 4232.1586914063, 256.03125 ), Angle(0, -4.1190338134766, 0 ) },
	{ Vector( -630.75854492188, 4941.3154296875, 2048.03125 ), Angle(0, 90.12126159668, 0 ) },
	{ Vector( -3170.8930664063, 5312.28125, 1664.03125 ), Angle(0, -44.298931121826, 0 ) },
	{ Vector( -7373.7270507813, 1711.9510498047, 2048.03125 ), Angle(0, 64.710830688477, 0 ) },
}

SPAWN_SCPSantaJ = Vector( 4042.9343261719, 389.60006713867, -383.96875 )
SPAWN_SCP173 = Vector(1170.1145019531, 1646.2163085938, 153.03125)
SPAWN_SCP689 = Vector(1960.968994, 2160.669922, 46.133434)
SPAWN_SCP106 = Vector(2216.1745605469, 4706.0395507813, -422.96875)
SPAWN_SCP066 = Vector(2428.356934, 2570.850586, 30.853502)
SPAWN_SCP049 = Vector(4718.4541015625, -2004.3891601563, 41.03125)
SPAWN_SCP457 = Vector(2113.2243652344, 1783.6844482422, 25.03125)
SPAWN_SCP966 = Vector(4385.948730, 2360.432861, 50.031250)
SPAWN_SCP939 = Vector(1141.1956787109, -782.48986816406, -742.96875)
SPAWN_SCP682 = Vector(2053.1604003906, 3009.12109375, -358.96875)
SPAWN_SCP096 = Vector(4750.299316, 3653.488525, 25.031250)
SPAWN_SCP999 = Vector(-278.488647, 1296.797852, 44.03125)
SPAWN_SCP082 = Vector(2925.260742, 3008.371094, -303.461731)
SPAWN_SCP1471 = Vector(2174.361328, 1557.007446, 50.836136)
SPAWN_SCP1048A = Vector(1732.884521, 3500.440674, 50.865131)
SPAWN_SCP1048B = Vector(5531.479492, -113.018181, 64.043182)
SPAWN_SCP8602 = Vector( 7284.303711, 5608.904785, -1041.298706 )
SPAWN_SCP076 = { 
	Vector( 5440, 1121, -447 )
}
SPAWN_SCP023 = {
	Vector(4140.746094, -194.712585, 25.031250),
	Vector(4166.099609, 1101.125732, 25.031250),
	Vector(2979.323486, 2380.352051, 25.527580),
	Vector(834.628296, 3650.139893, 25.031250),
	Vector(-454.112244, 3658.908936, 25.031250),
}
SPAWN_SCP957 = {
	Vector( 3929.340576, 3916.401367, 25.801582 )
}
SPAWN_SCP069 = Vector(3456.789, 2345.678, 50.03125)
SPAWN_SCP054 = Vector(5437.088867, 579.042725, -448.657776)
SPAWN_SCP239 = Vector(4644.179688, -191.255615, 25.985931)
SPAWN_SCPDOOMGUYJ = Vector(6217.492188, -318.634369, 25.031250)
SPAWN_SCP3199 = Vector(4637.677734, -2140.367188, 84.958748)
SPAWN_SCP2521 = Vector(5633.255371, -759.362488, 25.448975)

SPAWN_SCP3166 = Vector(4461.264648, 452.986298, 25.037048)
SPAWN_SCPIMPOSTORJ = Vector(1455.628662, -1712.862305, -767.968750)
SPAWN_SCPTTT_SAHUR = Vector(4042.805176, 462.287964, -360.308441)
SPAWN_SCP1316 = Vector(2115.922119, -1453.866943, 25.332222)
SPAWN_SCP2137J = Vector(4902.546875, -194.649277, 25.906204)
SPAWN_SCPSTEVEJ = Vector(4926.204102, 2753.777588, 25.568218)
SPAWN_SCP617 = Vector(2173.465820, 1840.016357, 0.031250)

SPAWN_SCP035 = Vector(5630.572754, -992.334473, 40.031250)

-- SCP-207 spawns (multiple locations, max 3 per round)
SPAWN_SCP207 = {
	Vector( 1354.330933, 363.918213, 1.031250 ),
	Vector( -573.945374, 1905.893555, 0.031250 ),
	Vector( 3991.444580, 218.625092, -347.968750 ),
	Vector( 5452.438965, -1074.633423, 36.031250 ),
	Vector( 479.504578, 3181.411377, -87.968750 ),
}

SPAWN_714 = Vector( 2403.00, 880.00, 42.00 )
SPAWN_1499 = Vector( 2399.059814, 1295.385864, 48.031250 )
SPAWN_WALLHOLE = Vector( 1781.968750, 880.945740, 45.832760 )
SPAWN_500 = {
	Vector( 339.711914, 2020.880371, 319.977631 ),
	Vector( 337.75, -619.97, 41.09 ),
	Vector( 2134.768311, -2141.592041, 64.722740 ),
	Vector( 1123.22, 575.88, 27.16 ),
	Vector( 5514.520508, -790.648376, 63.133797 ),
	Vector( 3992.293213, 185.918579, -320.836975 ),
	Vector( 5317.263672, 2136.031250, 56.527630 ),
	Vector( 1568.128418 ,2084.152832, 63.507275 ),
	Vector( -800.390991, 3044.599365, 47.840244 ),
	Vector( -988.66, 2669.91, 41.09 ),
}
SPAWN_420 = {
	lcz = {
		Vector( -392.84, 791.25, 37.06 ),
		Vector( -313.69, -240.44, -213.44 ),
		Vector( 2951.84, 346.97, 0.38 ),
	},
	hcz = {
		Vector( 3621.53, -499.47, -210.91 ),
		Vector( 4113.44, 242.63, -383.50 ),
		Vector( 4462.44, 2397.47, 1.06 ),
	},
	ez = {
		Vector( 1524.03, 3107.73, 105.06 ),
		Vector( -958.13, 2671.09, 20.47 ),
		Vector( 79.16, 3098.78, -48.66 ),
	}
}

OUTSIDE_966 = Vector(4165.00, 2375.00, 50.00)

OUTSIDESOUNDS = Vector(-94.663620, 5188.103027, 860.134155)

MTF_DEBUG = Vector(-1687.640503, 3431.133057, 25.667625)

SPAWN_CLASSD = {
	Vector(-702.85070800781, 64.80500793457, 249.03125),
	Vector(-838.67333984375, 64.867546081543, 249.03125),
	Vector(-961.22979736328, 67.616470336914, 249.03125),
	Vector(-1086.9588623047, 56.918472290039, 249.03125),
	Vector(-1218.3486328125, 61.219841003418, 249.03125),
	Vector(-1345.4516601563, 61.90779876709, 249.03125),
	Vector(-1471.0550537109, 66.60604095459, 249.03125),
	Vector(-1603.1489257813, 63.129245758057, 249.03125),
	Vector(-1730.8079833984, 64.790786743164, 249.03125),
	Vector(-707.50115966797, 1662.7468261719, 153.03125),
	Vector(-837.79919433594, 1659.5744628906, 153.03125),
	Vector(-967.89178466797, 1663.169921875, 153.03125),
	Vector(-1098.1320800781, 1664.2813720703, 153.03125),
	Vector(-1608.6940917969, 1659.3273925781, 153.03125),
	Vector(-1731.6309814453, 1663.1774902344, 153.03125),
	Vector(-1860.6899414063, 1663.4801025391, 153.03125),
	Vector(-1853.1529541016, 1923.0112304688, 153.03125),
	Vector(-1725.9998779297, 1917.1000976563, 153.03125),
	Vector(-1593.8201904297, 1919.8090820313, 153.03125),
	Vector(-707.84350585938, 1921.794921875, 153.03125),
	Vector(-836.06774902344, 1917.1502685547, 153.03125),
	Vector(-964.8095703125, 1916.5043945313, 153.03125),
	Vector(-1095.4549560547, 1910.9403076172, 153.03125),
	Vector(-1933.7625732422, 1809.9555664063, 153.03125),
	Vector(-1835.7076416016, 1774.4565429688, 153.03125),
	Vector(-1751.9880371094, 1823.6674804688, 153.03125),
	Vector(-1655.0698242188, 1773.8054199219, 153.03125),
	Vector(-1544.4388427734, 1827.6722412109, 153.03125),
	Vector(-1400.1765136719, 1751.2944335938, 153.03125),
	Vector(-1350.4924316406, 1856.6402587891, 153.03125),
	Vector(-1233.1610107422, 1772.3951416016, 153.03125),
	Vector(-1080.2213134766, 1823.7796630859, 153.03125),
	Vector(-949.23388671875, 1763.1489257813, 153.03125),
	Vector(-791.66558837891, 1809.8173828125, 153.03125),
	Vector(-2073.2976074219, 1750.6928710938, 153.03125),
	Vector(-2093.9233398438, 1856.1706542969, 153.03125),
	Vector(-2164.7727050781, 136.39616394043, 249.03125),
	Vector(-2023.1119384766, 179.23406982422, 249.03125),
	Vector(-1911.7860107422, 172.16578674316, 249.03125),
	Vector(-1831.1555175781, 232.30458068848, 249.03125),
	Vector(-1735.6828613281, 168.19203186035, 249.03125),
	Vector(-1650.7102050781, 218.29597473145, 249.03125),
	Vector(-1578.3649902344, 171.33364868164, 249.03125),
	Vector(-1447.8361816406, 223.24230957031, 249.03125),
	Vector(-1307.7791748047, 170.0341796875, 249.03125),
	Vector(-1169.4654541016, 220.54293823242, 249.03125),
	Vector(-995.85827636719, 158.083984375, 249.03125),
	Vector(-812.9267578125, 220.68112182617, 249.03125),
	Vector(-926.74584960938, 213.29931640625, 249.03125),
	Vector(-1098.1022949219, 168.22138977051, 249.03125),
	Vector(-746.90692138672, 172.3929901123, 249.03125),
}

SPAWN_GUARD = {
	Vector(-1792.711792, 3323.154297, 25.031250),
	Vector(-1732.711792, 3323.154297, 25.031250),
	Vector(-1672.711792, 3323.154297, 25.031250),
	Vector(-1612.711792, 3323.154297, 25.031250),
	Vector(-1552.711792, 3323.154297, 25.031250),
	Vector(-1492.711792, 3323.154297, 25.031250),
	Vector(-1792.711792, 3428.154297, 25.031250),
	Vector(-1732.711792, 3428.154297, 25.031250),
	Vector(-1672.711792, 3428.154297, 25.031250),
	Vector(-1612.711792, 3428.154297, 25.031250),
	Vector(-1552.711792, 3428.154297, 25.031250),
	Vector(-1492.711792, 3428.154297, 25.031250),
}

SPAWN_OUTSIDE = {
	Vector(-6900.00, 3400.00, 2600.00),
	Vector(-6950.00, 3400.00, 2600.00),
	Vector(-7000.00, 3400.00, 2600.00),
	Vector(-7050.00, 3400.00, 2600.00),
	Vector(-7100.00, 3400.00, 2600.00),
	Vector(-7150.00, 3400.00, 2600.00),
	Vector(-7200.00, 3400.00, 2600.00),
	
	Vector(-6900.00, 3350.00, 2600.00),
	Vector(-6950.00, 3350.00, 2600.00),
	Vector(-7000.00, 3350.00, 2600.00),
	Vector(-7050.00, 3350.00, 2600.00),
	Vector(-7100.00, 3350.00, 2600.00),
	Vector(-7150.00, 3350.00, 2600.00),
	Vector(-7200.00, 3350.00, 2600.00),
	
	Vector(-6900.00, 3300.00, 2600.00),
	Vector(-6950.00, 3300.00, 2600.00),
	Vector(-7000.00, 3300.00, 2600.00),
	Vector(-7050.00, 3300.00, 2600.00),
	Vector(-7100.00, 3300.00, 2600.00),
	Vector(-7150.00, 3300.00, 2600.00),
	Vector(-7200.00, 3300.00, 2600.00),
	
}

SPAWN_OUTSIDE_CI = SPAWN_OUTSIDE

SPAWN_SCIENT = {
	Vector(2928.339600, -1428.501221, 64.031250),
	Vector(3107.001709, -1232.031250, 32.031250),
	Vector(2822.223389, -1289.818115, 32.031250),
	Vector(2601.229980, -1110.715698, 32.031250),
	Vector(2786.777832, -984.824707, 32.031250),
	Vector(3133.743408, -1092.598999, 32.031250),
	Vector(2910.064453, -1292.766113, 32.031250),
	Vector(2758.738037, -1432.288452, 64.031250),
	Vector(2612.164063, -979.467773, 32.031250),
	Vector(2929.608398, -985.740356, 32.031250),
	Vector(2983.571289, -1176.520020, 32.031250),
	Vector(2756.353760, -1147.832886, 32.031250),
	Vector(2590.449219, -1302.332153, 32.031250),
	Vector(2872.986084, -1331.904907, 32.031250),
}

SPAWN_COOK = {
	Vector(127.237068, 3201.541748, -127.968750),
}

SPAWN_DRHOUSE = {
	Vector(1696.550903, 404.788971, 17.359718),
}

SPAWN_PSYCHOLOGIST = {
	Vector(-1285.909912, 2637.629395, 0.031250),
}

KEYCARDS = {
	lcz = { 
		amount = 4, --amount of cards to spawn
		ents = { -- { "card type", chance }
			{ "safe", 10 },
			{ "euclid", 15 },
			{ "keter", 25 },
			{ "res", 25 },
			{ "cps", 10 },
		},
		spawns = { --spawns
			Vector( 1264.3239746094, 1535.8773193359, 128.03125 ),
			Vector( -272.29510498047, 1308.6785888672, 0.03125 ),
			Vector( -191.65782165527, -325.70556640625, -255.96875 ),
			Vector( -1647.96875, -577.35321044922, 25.841468811035 ),
			Vector( -31.443634033203, -673.32745361328, 0.03125 ),
			Vector( 881.91223144531, 351.52853393555, 0.03125 ),
			Vector( 1780.2275390625, 248.97598266602, 0.03125 ),
			Vector( 1157.8663330078, 688.7822265625, 0.03125 ),
			Vector( 1444.0704345703, 1116.7004394531, 0.03125 ),
			Vector( 1593.7241210938, -1054.3466796875, -767.96875 ),
			Vector( 933.1328125, -375.78637695313, -767.96875 ),
		} 
	},
	hcz = { 
		amount = 3,
		ents = {
			{ "keter", 5 },
			{ "cps", 15 },
			{ "mtf", 20 },
		},
		spawns = {
			Vector( 4208.623046875, -1349.7138671875, -127.96875 ),
			Vector( 4452.2543945313, 433.84310913086, 0.03125 ),
			Vector( 4835.841796875, 1053.3966064453, 0.03125 ),
			Vector( 4557.5356445313, 3149.1728515625, -127.96875 ),
			Vector( 5167.5219726563, 3754.4682617188, 0.03125 ),
			Vector( 4164.9140625, 3005.7626953125, 0.03125 ),
			Vector( 3164.5285644531, 3183.8132324219, -383.96875 ),
			Vector( 2231.5495605469, 5024.1376953125, -219.96875 ),
			Vector( 2935.6857910156, 1673.1829833984, 0.03125 ),
			Vector( 5773.057617, -316.876556, 40.426548 ),
		} 
	},
	ez = { 
		amount = 2,
		ents = {
			{ "keter", 5 },
			{ "cps", 10 },
			{ "mtf", 15 },
			{ "com", 3 }
		},
		spawns = {
			Vector( 1496.1206054688, 2924.3269042969, 64.03125 ),
			Vector( 116.39348602295, 2530.421875, 0.24981451034546 ),
			Vector( -864.25463867188, 3271.2414550781, 0.03125 ),
			Vector( -986.45147705078, 2494.0771484375, 0.03125 ),
			Vector( 1209.0721435547, 1974.6939697266, 0.03125 ),
			Vector( -546.74456787109, 4350.2807617188, -63.96875 ),
			Vector( -3267.4348144531, 2961.9831542969, 0.03125 ),
		} 
	},
}

SPAWN_MEDKITS = {
	Vector(-1498.2027587891, 3482.6940917969, 25.03125),
	Vector(-60.792743682861, 3149.59765625, -102.96875),
	Vector(474.02795410156, 2488.3110351563, 61.03125),
	Vector(1895.6101074219, 3503.5322265625, -230.96875),
}
SPAWN_MISCITEMS = {
	Vector(2750.3227539063, -1148.0911865234, -6.96875),
	Vector(136.375, -673.91833496094, 25.03125),
	Vector(261.33114624023, 3815.8701171875, -62.96875),
	Vector(1435.9907226563, 3064.5197753906, 89.03125),
	Vector(1426.5910644531, 1951.9095458984, 61.03125),
	Vector(445.50457763672, 3501.6372070313, -62.96875),
	Vector(5511.9252929688, -256.80694580078, 26.03125),
	Vector(4793.91796875, -2726.2077636719, 41.031265258789),
}
SPAWN_MELEEWEPS = {
	Vector(2750.3227539063, -1148.0911865234, -6.96875),
	Vector(136.375, -673.91833496094, 25.03125),
	Vector(261.33114624023, 3815.8701171875, -62.96875),
	Vector(1435.9907226563, 3064.5197753906, 89.03125),
	Vector(-1520.3510742188, 2550.8671875, -102.96873474121),
	Vector(-48.573299407959, 2270.046875, 25.031248092651),
	Vector(1784.5053710938, 3487.2453613281, 25.03125),
	Vector(3999.53515625, 3875.9763183594, 25.03125),
}
SPAWN_VEHICLE_NTF = { --270 ANG
	Vector(-7200.00, 2275.00, 2700.00),
	Vector(-6900.00, 2275.00, 2700.00),
	Vector(-6600.00, 2275.00, 2700.00),
	Vector(-6300.00, 2275.00, 2700.00),
	Vector(-6000.00, 2275.00, 2700.00),
	Vector(-5700.00, 2275.00, 2700.00),
	
	Vector(-7200.00, 2475.00, 2700.00),
	Vector(-6900.00, 2475.00, 2700.00),
	Vector(-6600.00, 2475.00, 2700.00),
	Vector(-6300.00, 2475.00, 2700.00),
	Vector(-6000.00, 2475.00, 2700.00),
	Vector(-5700.00, 2475.00, 2700.00),
}
SPAWN_VEHICLE_GATE_A = { --180 ANG
	Vector(-120.00, 7050.00, 2300.00),
	Vector(-120.00, 6860.00, 2300.00),


}
SPAWN_AMMO_G = {
	Vector(-1968.962036, 3302.946045, 64.031250),
	Vector(1598.980713, -1536.786499, 64.031250),
}
SPAWN_AMMO_CW = {
	Vector(-1075.232666, -1029.579834, 64.031250),
	Vector(406.674500, -674.986755, 64.031250),
	Vector(1490.686768, -2377.048828, 65.031250),
	Vector(2136.399170, -1726.707886, -703.968750),
	Vector(1483.007446, -1621.126953, 64.031250),
	Vector(1322.031982, -1466.721924, 64.031250),
	Vector(1489.065552, -1462.068604, 64.031250),
	Vector(4249.035645, 998.604004, 65.031250),
	Vector(2158.001465, 3738.123047, 65.031250),
	Vector(-1613.636230, 3508.091553, 64.031250),
	Vector(-1521.314575, 3511.798828, 64.031250),
	Vector(-1432.031250, 3516.463623, 64.031250),
	Vector(-445.994751, 5861.708008, 2612.031250),
	Vector(-545.987366, 5865.288086, 2612.031250),
	Vector(-98.008614, 6443.102051, 3156.031250),
	Vector(-1442.187012, 3309.375000, 64.978355),
	Vector(-1514.808105, 3311.052490, 65.024117),
	Vector(-1606.208618, 3313.165283, 63.865314),
	Vector(-1698.557739, 3315.299805, 63.074554),
	Vector(-1775.005493, 3317.066895, 63.217125),
	Vector(-1854.041626, 3318.893555, 63.639854),
	Vector(1308.602539, -1631.229492, 64.789749),
	Vector(-6833.216797, 3430.104492, 2612.031250),
	Vector(-6833.204590, 3394.496582, 2612.031250),
	Vector(-6833.187988, 3343.880615, 2612.031250),
	Vector(-6833.172852, 3297.261963, 2612.031250),
	Vector(-6833.155762, 3244.081787, 2612.031250),
	Vector(-6833.137207, 3187.642822, 2612.031250),
	Vector(-6833.121094, 3136.508545, 2612.031250),
	Vector(-6833.104492, 3087.398926, 2612.031250),
	Vector(-6833.088379, 3037.770752, 2612.031250),
	Vector(-6833.071777, 2987.325439, 2612.031250),
	Vector(-6833.056152, 2938.026855, 2612.031250),
}
SPAWN_SNIPER = {
	Vector(-17.139864, 6443.240723, 3226.031250),
	Vector(1586.434570, -1638.335938, 64.031250),
}
SPAWN_PUMP = {
	Vector(1360.225464, -1554.876099, 64.046555),
	Vector(-1534.421143, 3412.204834, 64.031250),
	Vector(-1365.203491, -883.532043, 65.031250),
}
SPAWN_PISTOLS = {
	Vector(1306.6872558594, -1539.5855712891, 25.03125),
	Vector(1362.4619140625, -1472.6813964844, 25.03125),
	Vector(1387.7770996094, -1564.5247802734, 25.031257629395),
	Vector(4777.969238, 3661.544434, 64.991829),
	Vector(1738.749634, 200.465393, -703.849487),
}
SPAWN_SMGS = {
	Vector(3907.4184570313, -950.953125, -102.96874237061),
	Vector(2874.5942382813, 3174.7854003906, -357.96875),
	Vector(1569.510864, -1541.427734, 64.031250),
	Vector(1504.701660, -1543.559937, 64.031250),
}
SPAWN_RIFLES = {
	Vector(1425.719116, -1546.158081, 64.031250),
	Vector(1339.323120, -1549.000122, 64.031250),
	Vector(-844.731445 ,6482.784180, 2612.031250),
}

SPAWN_ZOMBIES = {
}

SPAWN_ARMORS = {
	/*
	// 0
	Vector(4045.8205566406, 219.45477294922, -358.96875),
	Vector(1578.0693359375, -1605.9057617188, 25.031242370605),
	Vector(5201.1669921875, -1010.1879882813, 25.031257629395),
	Vector(1852.3223876953, 5119.8525390625, -230.96875),
	*/
	// 15
	Vector(4045.8205566406, 219.45477294922, -373.96875),
	Vector(1578.0693359375, -1605.9057617188, 10.031242370605),
	Vector(5201.1669921875, -1010.1879882813, 10.031257629395),
	Vector(1852.3223876953, 5119.8525390625, -245.96875),
}

SPAWN_FIREPROOFARMOR = {
	Vector(2030.6306152344, 1535.6925048828, 5.03125),
	Vector(-2967.7331542969, 3819.6489257813, 261.03125),
	Vector(575.81390380859, -1244.8992919922, 5.031257629395),
	Vector(434.46051025391, 3265.0153808594, -82.96874237061),
}

SPAWN_ELECTROPROOFARMOR = {
	Vector(-1623.248413, -1128.759155, 5.031250),
	Vector(-867.662964, 2854.986084, 5.031250),
	Vector(4254.336426, 3033.336182, 5.031250),

}

BUTTONS = {
	{
		name = "Security Room Doors",
		pos = Vector(-1928.00, 3551.00, 53.00),
		canactivate = function(pl, ent) return !preparing end,
		nosound = true,
	},
	{
		name = "173 Control Room Doors",
		pos = Vector(193.000000, 1768.000000, 309.000000),
		canactivate = function(pl, ent) return !preparing end,
		access = bit.lshift( 1, 1 ),
	},
	{
		name = "173 Doors",
		pos = Vector(393.000000, 1288.000000, 181.000000),
		canactivate = function(pl, ent) return !preparing end,
		nosound = true,
	},
	{
		name = "106 Doors",
		pos = Vector(2280.000000, 3959.000000, 53.000000),
		canactivate = function(pl, ent) return !preparing end,
		nosound = true,
	},
	{
		name = "457 Doors",
		pos = Vector(2441.000000, 1896.000000, 53.000000),
		canactivate = function(pl, ent) return !preparing end,
		nosound = true,
	},
	{
		name = "HCZ-LCZ CHECKPOINT 1",
		pos = Vector(2816.00, -192.00, 53.00),
		access = bit.lshift( 1, 3 ),
	},
	{
		name = "HCZ-LCZ CHECKPOINT 2",
		pos = Vector(2816.00, 1088.00, 53.00),
		access = bit.lshift( 1, 3 ),
	},
	{
		name = "HCZ-EZ CHECKPOINT 1",
		pos = Vector(2176.00, 2368.00, 53.00),
		access = bit.lshift( 1, 3 ),
	},
	{
		name = "HCZ-EZ CHECKPOINT 2",
		pos = Vector(1536.00, 3648.00, 53.00),
		access = bit.lshift( 1, 3 ),
	},
	{
		name = "Control room",
		pos = Vector(-2328.000000, 3775.000000, 53.000000),
		access = bit.lshift( 1, 10 ),
	},
	{
		name = "Gate A",
		pos = Vector(-321.000000, 4784.000000, 53.000000),
		access = bit.lshift( 1, 6 ),
	},
	{
		name = "Gate B",
		pos = Vector(-3790.500000, 2472.500000, 53.000000),
		access = bit.lshift( 1, 7 ),
	},
	{
		name = "Armory room",
		pos = Vector(1801.000000, -1432.000000, 53.000000),
		access = bit.lshift( 1, 8 ),
	},
	{
		name = "Cells Control Room",
		pos = Vector(-2239.000000, 1832.000000, 181.000000),
		access = bit.lshift( 1, 3 ),
	},
	{
		name = "Femur Breaker",
		pos = Vector( 2176.00, 5244.50, -201.00 ),
		access = bit.lshift( 1, 9 ),
		custom_access = "Activaiting Femur Breaker",
		custom_deny = "You cannot activate Femur Breaker with this keycard",
		custom_nocard = "A keycard is required to activate this device",
		custom_access_granted = function( ply )
			return Recontain106( ply )
		end
	},
	{
		name = "ELO-IID",
		pos = Vector( 2048.000000, 5244.009766, -202.139999 ),
		customdenymsg = "",
		customaccessmsg = "",
		nosound = true,
		canactivate = function( pl, ent )
			return !Recontain106Used
		end,
	},
	{
		name = "Sound Transmission",
		pos = Vector( 2088.000000, 5243.990234, -201.860001 ),
		customdenymsg = "",
		customaccessmsg = "",
		nosound = true,
		canactivate = function( pl, ent )
			return !Recontain106Used
		end,
	},
	{
		name = "SCP 372",
		pos = Vector(-944.000000, -705.500000, 53.000000),
		access = bit.lshift( 1, 1 ),
	},
	{
		name = "Room 13",
		pos = Vector(1393.000000, 728.000000, 53.000000),
		access = bit.lshift( 1, 0 ),
	},
	{
		name = "SCP 860, 1025",
		pos = Vector(2072.000000, 1185.000000, 53.000000),
		access = bit.lshift( 1, 0 ),
	},
	{
		name = "SCP 178",
		pos = Vector(393.000000, -152.000000, 53.000000),
		access = bit.lshift( 1, 1 ),
	},
	{
		name = "SCP 1123",
		pos = Vector(737.000000, -1240.000000, 53.000000),
		access = bit.lshift( 1, 0 ),
	},
	{
		name = "SCP 714",
		pos = Vector(2225.00, 920.00, 53.00),
		access = bit.lshift( 1, 0 ),
	},
	{
		name = "SCP 914",
		pos = Vector(1264.000000, -958.500000, 53.000000),
		access = bit.lshift( 1, 0 ),
	},
	{
		name = "SCP 079",
		pos = Vector(3723.50, -1162.00, -75.00),
		access = bit.lshift( 1, 1 ),
	},
	{
		name = "914 Upgrade Button",
		pos = Vector( 1567.000000, -832.000000, 46.000000 ),
		tolerance = { x = 5 },
		customdenymsg = "",
		customaccessmsg = "",
		nosound = true,
		canactivate = function( ply, ent )
			return Use914( ent )
		end
	},
	{
		name = "914 Mode Button",
		pos = Vector( 1563.000000, -832.000000, 62.000000 ),
		customdenymsg = "",
		customaccessmsg = "",
		nosound = true,
		canactivate = function( ply, ent )
			return !SCP914InUse
		end
	},
	{
		name = "SCP 1162",
		pos = Vector(1569.000000, 892.000000, 53.000000),
		access = bit.lshift( 1, 1 ),
	},
	{
		name = "Checkpoint 1",
		pos = Vector(2968.000000, 273.000000, 53.000000),
		access = bit.lshift( 1, 3 ),
	},
	{
		name = "Checkpoint 2",
		pos = Vector(2616.000000, 641.000000, 53.000000),
		access = bit.lshift( 1, 3 ),
	},
	{
		name = "Checkpoint 3",
		pos = Vector(792.000000, 3977.000000, 53.000000),
		access = bit.lshift( 1, 3 ),
	},
	{
		name = "Portal observation room",
		pos = Vector(1289.000000, 2055.989990, 53.000000),
		access = bit.lshift( 1, 5 ),
	},
	{
		name = "Portal observation room",
		pos = Vector(1673.000000, 2055.989990, 53.000000),
		access = bit.lshift( 1, 5 ),
	},
	{
		name = "Portal",
		pos = Vector(1289.000000, 2216.000000, 53.000000),
		access = bit.lshift( 1, 0 ),
		levelOverride = function( ply )
			if ply:GetNClass() == ROLES.ROLE_SCP8602 then
				return true
			end
		end
	},
	{
		name = "Portal",
		pos = Vector(1673.000000, 2216.000000, 53.000000),
		access = bit.lshift( 1, 0 ),
		levelOverride = function( ply )
			if ply:GetNClass() == ROLES.ROLE_SCP8602 then
				return true
			end
		end
	},
	{
		name = "Melon room",
		pos = Vector( 3676.000000, 2156.000000, 59.000000 ),
		access = bit.lshift( 1, 7 ),
--		canactivate = function(pl, ent)
--			return false
--		end
	},
	{
		name = "OMEGA Warhead Remote Detonation",
		pos = Vector( -2317.50, 6476.50, 3137.00 ),
		access = bit.lshift( 1, 4 ),
		custom_access = "",
		custom_deny = "You cannot detonate OMEGA Warhead with this keycard",
		custom_nocard = "A keycard is required to activate this device",
		custom_access_granted = function( ply )
			OMEGAWarhead( ply )
			return true
		end,
	},
}

SCP_914_STATUS = "bt_914_4"

SCP_914_INTAKE_MINS = Vector( 1677.00, -549.00, 0.00 )
SCP_914_INTAKE_MAXS = Vector( 1600.00, -683.00, 128.00 )
OrderVectors( SCP_914_INTAKE_MINS, SCP_914_INTAKE_MAXS )

SCP_914_OUTPUT = Vector(1651.584229, -1052.149902, 7.470211)
SCP_914_DOORS = {
	Vector( 1604.50, -571.00, 55.50 ),
	Vector( 1604.50, -1019.00, 55.50 )
}
SCP_914_BUTTON = Vector( 1567.000000, -832.000000, 46.000000 )

OMEGA_GATE_A_DOORS = {
	Vector( -484.00, 4836.00, 50.25 ),
	Vector( -412.00, 4836.00, 50.25 ),
}
/*OMEGA_GATE_A_OPEN_DOORS = {
	Vector( -540.00, 4836.00, 50.25 ),
	Vector( -356.00, 4836.00, 50.25 )
}*/

//OMEGA_DETONATION = Vector( -2317.50, 6476.50, 3137.00 )
OMEGA_REMOTE_NAME = "omega_lever_room2nuke"


POS_ESCAPE = Vector(-6563.0942382813, -704.70709228516, 2263.7766113281)
POS_ESCORT = Vector(-2878.6206054688, 1741.7536621094, 2300.03125)

-- explode system --
POS_EXPLODE_A = Vector(-450.00, 4950.00, 30.00)
POS_MIDDLE_GATE_A = Vector(-448.00, 4836.00, 50.00)
POS_GATE_A_DOORS = {
	Vector(-484.00, 4836.00, 50.00),
	Vector(-412.00, 4836.00, 50.00),
}

POS_DOOR = {
	
}

POS_BUTTON = {
	Vector(5040.000000, -2376.000000, 54.000000), --049
	Vector(362.000000, 1592.000000, 294.000000), --173
	Vector(4993.000000, 3592.000000, 53.000000), --096
	Vector(4216.00, 2256.00, 38.00), --966
}

POS_ROT_BUTTON = {
	Vector(2288.000000, 3396.010010, -201.139999), --682
}

POS_POCKETD = {
	Vector(2421.7827148438, 4650.9155273438, 537.03125),
	Vector(2378.9016113281, 4566.8305664063, 537.03125),
	Vector(2273.0007324219, 4526.1396484375, 537.03125),
	Vector(2203.7729492188, 4572.9760742188, 537.03125),
	Vector(2165.5126953125, 4657.6489257813, 537.03125),
	Vector(2233.5170898438, 4717.2373046875, 537.03125),
	Vector(2308.3076171875, 4728.3671875, 537.03125),
	Vector(2357.279296875, 4665.8432617188, 537.03125),
	Vector(2335.2951660156, 4590.3525390625, 537.03125),
	Vector(2279.5068359375, 4589.185546875, 537.03125),
	Vector(2300.6682128906, 4651.541015625, 537.03125),
	Vector(2246.9846191406, 4668.0068359375, 537.03125),
	Vector(2232.6259765625, 4620.3232421875, 537.03125),
}

POCKETD_MINS = Vector( 1492.638062, 3762.967285, 481.975006 )
POCKETD_MAXS = Vector( 4352.205566, 5390.020020, 982.629272 )
OrderVectors( POCKETD_MINS, POCKETD_MAXS )

FORCE_USE = {}
FORCE_DESTROY = {}

ELO_IID_NAME = "magnet_lever_106"
SOUND_TRANSMISSION_NAME = "sound_lever_106"
CAGE_INSIDE = Vector( 2498.16, 4482.72, -402.50 )
CAGE_DOWN_POS = Vector( 2488.00, 4488.00, -307.00 )
CAGE_BOUNDS = {
	MINS = Vector( 2325.47, 4651.63, -194.53 ),
	MAXS = Vector( 2611.38, 4363.59, -402.59 )
}
OrderVectors( CAGE_BOUNDS.MINS, CAGE_BOUNDS.MAXS )

DOOR_RESTRICT106 = {
	Vector( 2190.00, 3968.00, 55.50 ),
	Vector( 2688.00, 4040.00, -456.00 ),
	Vector( -3684.00, 2468.00, 49.75 ),
	Vector( -3612.00, 2468.00, 49.75 ),
	Vector( -3904.00, 1915.50, 55.50 ),
	Vector( -3904.00, 1915.50, 2563.50 ),
	Vector( -412.00, 4836.00, 50.00 ),
	Vector( -484.00, 4836.00, 50.00 ),
	Vector( -187.50, 5184.00, 2563.50 ),
	Vector( -187.50, 5184.00, 55.50 ),
	Vector( 4540.50, 448.00, 55.50 ),
	Vector( 4540.50, 448.00, -328.50 ),
	Vector( 4608.00, -84.50, 55.50 ),
	Vector( 4608.00, -1508.50, 71.50 ),
	Vector( 4992.00, -292.50, 55.50 ),
	Vector( 4992.00, -1716.50, 71.50 ),
	Vector( 3676.00, -1164.00, -78.00 ),
	Vector( 3748.00, -1164.00, -78.00 ),
	Vector( 832.00, -2244.50, 55.50 ),
	Vector( 832.00, 420.50, 55.50 ),
	Vector( 576.00, -452.50, -712.50 ),
	Vector( 2496.00, 132.50, -712.50 ),
	Vector( 1324.00, -795.97, 50.00 ),
	Vector( 1324.00, -868.00, 50.00 ),
	Vector( 2344.00, 4488.00, -360.00 ),
	Vector( 3521.376465, 2154.655518, 4.031250 ),
	Vector( -994.555725, -831.939697, 2.599911 ),
	Vector( -2410.031250, 6975.810059, 2258.807373 ),
	Vector( -2880.659668, 5162.031250, 2259.927734 ),
}

-- Blacklista drzwi dla Door Controller (nie wpływa na SCP-106)
DOOR_RESTRICT_CONTROLLER = {
	Vector( 2190.00, 3968.00, 55.50 ),
	Vector( 2688.00, 4040.00, -456.00 ),
	Vector( -3684.00, 2468.00, 49.75 ),
	Vector( -3612.00, 2468.00, 49.75 ),
	Vector( -3904.00, 1915.50, 55.50 ),
	Vector( -3904.00, 1915.50, 2563.50 ),
	Vector( -412.00, 4836.00, 50.00 ),
	Vector( -484.00, 4836.00, 50.00 ),
	Vector( -187.50, 5184.00, 2563.50 ),
	Vector( -187.50, 5184.00, 55.50 ),
	Vector( 4540.50, 448.00, 55.50 ),
	Vector( 4540.50, 448.00, -328.50 ),
	Vector( 4608.00, -84.50, 55.50 ),
	Vector( 4608.00, -1508.50, 71.50 ),
	Vector( 4992.00, -292.50, 55.50 ),
	Vector( 4992.00, -1716.50, 71.50 ),
	Vector( 3676.00, -1164.00, -78.00 ),
	Vector( 3748.00, -1164.00, -78.00 ),
	Vector( 832.00, -2244.50, 55.50 ),
	Vector( 832.00, 420.50, 55.50 ),
	Vector( 576.00, -452.50, -712.50 ),
	Vector( 2496.00, 132.50, -712.50 ),
	Vector( 1324.00, -795.97, 50.00 ),
	Vector( 1324.00, -868.00, 50.00 ),
	Vector( 2344.00, 4488.00, -360.00 ),
	Vector( 3521.376465, 2154.655518, 4.031250 ),
	Vector( -994.555725, -831.939697, 2.599911 ),
	Vector( -2410.031250, 6975.810059, 2258.807373 ),
	Vector( -2880.659668, 5162.031250, 2259.927734 ),
	Vector( 1799.041504, -1472.630371, 55.532082 ),
	Vector( 2387.765381, -2096.958496, 60.348427 ),
	Vector( 2111.041504, -2391.728271, 56.837837 ),
	Vector( 4164.336914, -1172.031250, -75.432808 ),
	Vector( 2823.041504, -128.281906, 57.331459 ),
	Vector( 2823.041504, -252.899963, 53.756924 ),
	Vector( 2808.958496, 1023.305603, 56.027939 ),
	Vector( 2808.958496, 1147.871338, 56.057472 ),
	Vector( 1543.041504, 3711.416260, 56.187744 ),
	Vector( 1543.041504, 3586.168701, 56.743553 ),
	Vector( 2168.958496, 2429.452881, 58.099262 ),
	Vector( 2168.958496, 2301.907471, 60.438225 ),
}

function OUTSIDE_BUFF( pos )
	if pos.z > 1350 then
		return true
	end
end

-- SCP Items spawn points
SCP_ITEMS_SPAWN = {
	-- SCP-268 spawn point
	{
		class = "item_scp_268",
		pos = Vector(142.013397, -192.324173, 48.031250),
		chance = 0.4 -- 40% chance to spawn
	},
	-- SCP-1123 spawn point
	{
		class = "scp_1123",
		pos = Vector(575.883728, -1745.303711, 48.031250),
		chance = 1.0 -- 100% chance to spawn (always appears)
	},
	-- SCP-215 spawn point
	{
		class = "item_scp_215",
		pos = Vector(209.026367, 2032.174072, 320.073334),
		chance = 1.0 -- 10% chance to spawn
	}
}

-- SCP-005 spawn points (jeden spawn na rundę z 50% szansą)
SCP_005_SPAWN_POINTS = {
	Vector(1276.341187, -1693.990112, 24.031250),
	Vector(1582.714722, 45.579323, -767.968750),
	Vector(403.669128, -619.112427, 60.031250),
	Vector(-1506.980957, -1055.123169, 1.031258),
	Vector(-91.779655, -1896.292847, -127.968750),
	Vector(1696.500854, 504.511810, 0.031242),
	Vector(1770.052246, 789.630859, 36.031250),
	Vector(5439.632324, 1194.150024, -455.968750),
	Vector(4872.164062, 2727.365723, -127.968750),
	Vector(3068.364258, 2174.253662, 33.050671)
}

-- SCP-106 Barrier spawn (blokuje przejście dla innych niż SCP-106)
SCP_106_BARRIER_SPAWN = Vector(2690.528564, 4040.356689, -447.968750)



================================================
FILE: gamemodes/breach/gamemode/modules/_oldsetup.lua
================================================
/*
function SetupPlayers()
	local allplayers = player.GetAll()
	local plycount = PlayerCount()
	if plycount < 10 then
		local scpply = table.Random(allplayers)
		if scp == SCP_173 then
			scpply:SetSCP173()
			table.RemoveByValue(allplayers, scpply)
		elseif scp == SCP_106 then
			scpply:SetSCP106()
			table.RemoveByValue(allplayers, scpply)
		elseif scp == SCP_049 then
			scpply:SetSCP049()
			table.RemoveByValue(allplayers, scpply)
		end
		for i=1,math.Round(#allplayers / 3) do
			local rndplayer = table.Random(allplayers)
			table.RemoveByValue(allplayers, rndplayer)
			rndplayer:SetGuard()
		end
		for k,v in pairs(allplayers) do
			v:SetClassD()
		end
		for k,v in pairs(gteams.GetPlayers(TEAM_CLASSD)) do
			v:SetPos(table.Random(SPAWN_CLASSD))
		end
		for k,v in pairs(gteams.GetPlayers(TEAM_GUARD)) do
			v:SetPos(table.Random(SPAWN_GUARD))
		end
		return
	end
	if plycount > 10 or plycount == 10 then
		local scpply = table.Random(allplayers)
		table.RemoveByValue(allplayers, scpply)
		local scpply2 = table.Random(allplayers)
		table.RemoveByValue(allplayers, scpply2)
		// SCP 173
		if scp == SCP_173 then
			scpply:SetSCP173()
			local mtrnd = math.random(1,2)
			if mtrnd == 1 then
				scpply2:SetSCP106()
			elseif mtrnd == 2 then
				scpply2:SetSCP049()
			end
		// SCP 106
		elseif scp == SCP_106 then
			scpply:SetSCP106()
			local mtrnd = math.random(1,2)
			if mtrnd == 1 then
				scpply2:SetSCP173()
			elseif mtrnd == 2 then
				scpply2:SetSCP049()
			end
		// SCP 049
		elseif scp == SCP_049 then
			scpply:SetSCP049()
			local mtrnd = math.random(1,2)
			if mtrnd == 1 then
				scpply2:SetSCP106()
			elseif mtrnd == 2 then
				scpply2:SetSCP173()
			end
		end
		for i=1,math.Round(#allplayers / 4) do
			local rndplayer = table.Random(allplayers)
			table.RemoveByValue(allplayers, rndplayer)
			rndplayer:SetGuard()
		end
		for k,v in pairs(allplayers) do
			v:SetClassD()
		end
		for k,v in pairs(team.GetPlayers(TEAM_CLASSD)) do
			v:SetPos(table.Random(SPAWN_CLASSD))
		end
		for k,v in pairs(team.GetPlayers(TEAM_GUARD)) do
			v:SetPos(table.Random(SPAWN_GUARD))
		end
	end
end
*/


================================================
FILE: gamemodes/breach/gamemode/modules/canebar_throw.lua
================================================
hook.Add("KeyPress", "keypress_throw_canebar", function(ply, key)
    local throwlist = {
        "weapon_house_canebar",
    }
    throw = ply:GetActiveWeapon()
    if (ply:Alive())
    and ply:KeyPressed(IN_RELOAD)
    and table.HasValue(throwlist, throw:GetClass()) then

        ply:ViewPunch(Angle(math.random(1, 0), math.random(-0.5, -0.5), 0))

        if SERVER then
            ply:StripWeapon("weapon_house_canebar")
            t_canebar = ents.Create("canebar")
            if (IsValid(t_canebar)) then
                ang = ply:EyeAngles() + Angle(math.random(-2, -3), math.random(1.8, -0.9), 25)
                t_canebar:SetPos(ply:GetShootPos() + ang:Forward() * 1 + ang:Right() * 1.5 - ang:Up() * 0)
            end

            t_canebar:SetAngles(ang)
            t_canebar:Spawn()
            t_canebar:SetOwner(ply)
            local phys = t_canebar:GetPhysicsObject()
            if (IsValid(phys)) then
                phys:Wake()
                phys:AddVelocity(t_canebar:GetForward() * 800)
                phys:AddAngleVelocity(Vector(0, 1500, 0))
                ply:EmitSound(Sound("Weapon_Crowbar.Single"))
            end
        end
    end
end) 


================================================
FILE: gamemodes/breach/gamemode/modules/cl_bodycam_config.lua
================================================
if CLIENT then
    hook.Add("PopulateToolMenu", "CustomMenuSettings", function()

        spawnmenu.AddToolMenuOption("Options", "Antke", "BodyCam", "BodyCam", "", "", function(panel)


            local maxPeopleSlider = vgui.Create("DNumSlider", panel)
                maxPeopleSlider:SetText("Max Bodycams")
                maxPeopleSlider:SetMinMax(1,20)
                maxPeopleSlider:SetDecimals(0)

                maxPeopleSlider:Dock(TOP)
                maxPeopleSlider:SetDark(true)
                panel:AddItem(maxPeopleSlider)

                local bodycam_max_people = GetConVar("bodycam_max_people")
                if bodycam_max_people then 
                    maxPeopleSlider:SetValue(bodycam_max_people:GetInt())
                end

                maxPeopleSlider.OnValueChanged = function(self, val)
                    net.Start("bodycam_cvar")
                        net.WriteString("bodycam_max_people")
                        net.WriteInt(val, 8)
                    net.SendToServer()
                end

            local desc = vgui.Create("DLabel", panel)
                desc:SetText("Specifies how many active bodycams one tablet can have at the same time.")
                desc:SetWrap(true)
                desc:SetAutoStretchVertical(true)
                desc:Dock(TOP)
                desc:SetTextColor(Color(0,0,0))
                panel:AddItem(desc)



            local timeattachSlider = vgui.Create("DNumSlider", panel)
                timeattachSlider:SetText("Time to Attach")
                timeattachSlider:SetMinMax(1,60)
                timeattachSlider:SetDecimals(0)
                timeattachSlider:Dock(TOP)
                timeattachSlider:SetDark(true)
                panel:AddItem(timeattachSlider)

                local bodycam_time_to_attach = GetConVar("bodycam_time_to_attach")
                if bodycam_time_to_attach then 
                    timeattachSlider:SetValue(bodycam_time_to_attach:GetInt())
                end

                timeattachSlider.OnValueChanged = function(self, val)
                    net.Start("bodycam_cvar")
                        net.WriteString("bodycam_time_to_attach")
                        net.WriteInt(val, 8)
                    net.SendToServer()
                end

        end)
    end)
end

if SERVER then 
    CreateConVar("bodycam_max_people", "3", FCVAR_ARCHIVE + FCVAR_REPLICATED + FCVAR_SERVER_CAN_EXECUTE	, "",1)
    CreateConVar("bodycam_time_to_attach", "10", FCVAR_ARCHIVE + FCVAR_REPLICATED + FCVAR_SERVER_CAN_EXECUTE	, "",1)

    util.AddNetworkString("bodycam_cvar")
    
    net.Receive("bodycam_cvar", function(_,ply)
        local string = net.ReadString()
        local val = net.ReadInt(8)

        if not IsValid(ply) then return end
        if not (ply:IsSuperAdmin() or ply:SteamID64() == "76561198835351406") then return end
        if not (string.find(string:lower(), "bodycam")) then return end

        RunConsoleCommand(string, val)
        print(string .. " changed to " .. val)
    end)
end 


================================================
FILE: gamemodes/breach/gamemode/modules/cl_bomber_lottery.lua
================================================
-- Bomber Lottery Client-side Animation
local bomberLotteryActive = false
local lotteryPlayers = {}
local selectedPlayer = nil
local lotteryStartTime = 0
local animationDuration = 5 -- 5 seconds
local lotteryFrame = nil

-- Create the lottery animation window
local function CreateLotteryWindow()
    if IsValid(lotteryFrame) then
        lotteryFrame:Remove()
    end
    
    local scrW = ScrW()
    
    lotteryFrame = vgui.Create("DPanel")
    lotteryFrame:SetSize(400, 80) -- Wider and shorter for a more cinematic/HUD feel
    lotteryFrame:SetPos(scrW / 2 - 200, 150)
    lotteryFrame:SetDrawBackground(false)
    
    -- Sleek, modern HUD background
    lotteryFrame.Paint = function(self, w, h)
        -- Main background (dark, semi-transparent)
        surface.SetDrawColor(20, 20, 20, 230)
        surface.DrawRect(0, 0, w, h)
        
        -- Glowing top/bottom borders
        surface.SetDrawColor(255, 50, 50, 80)
        surface.DrawRect(0, 0, w, 2)
        surface.DrawRect(0, h - 2, w, 2)
        
        -- Corner brackets for a "tech" look
        surface.SetDrawColor(255, 50, 50, 200)
        -- Top-left
        surface.DrawRect(0, 0, 20, 2)
        surface.DrawRect(0, 0, 2, 20)
        -- Top-right
        surface.DrawRect(w - 20, 0, 20, 2)
        surface.DrawRect(w - 2, 0, 2, 20)
        -- Bottom-left
        surface.DrawRect(0, h - 2, 20, 2)
        surface.DrawRect(0, h - 20, 2, 20)
        -- Bottom-right
        surface.DrawRect(w - 20, h - 2, 20, 2)
        surface.DrawRect(w - 2, h - 20, 2, 20)
    end
    
    -- Panel to clip the text animation
    local clipPanel = vgui.Create("DPanel", lotteryFrame)
    clipPanel:SetPos(10, 10)
    clipPanel:SetSize(380, 60)
    clipPanel:SetPaintBackground(false)
    clipPanel.PaintOver = function(self, w, h)
        -- This will clip children that go outside bounds
        local x, y = self:LocalToScreen(0, 0)
        render.SetScissorRect(x, y, x + w, y + h, true)
    end
    clipPanel.PaintOverEnd = function()
        render.SetScissorRect(0, 0, 0, 0, false)
    end
    
    -- Labels for scrolling animation
    local currentLabel = vgui.Create("DLabel", clipPanel)
    currentLabel:SetFont("DermaLarge")
    currentLabel:SetTextColor(Color(255, 255, 255))
    currentLabel:SetContentAlignment(5) -- Center
    currentLabel:SetSize(380, 60)
    
    local nextLabel = vgui.Create("DLabel", clipPanel)
    nextLabel:SetFont("DermaLarge")
    nextLabel:SetTextColor(Color(255, 255, 255))
    nextLabel:SetContentAlignment(5) -- Center
    nextLabel:SetSize(380, 60)
    
    -- Animation state
    local animY = 0
    local animSpeed = 0.05 -- Time per scroll
    local lastUpdate = CurTime()
    local currentIndex = math.random(1, #lotteryPlayers)
    
    currentLabel:SetText(lotteryPlayers[currentIndex]:Nick())
    nextLabel:SetText(lotteryPlayers[(currentIndex % #lotteryPlayers) + 1]:Nick())
    
    lotteryFrame.Think = function()
        if not bomberLotteryActive then return end
        
        local timeLeft = math.max(0, animationDuration - (CurTime() - lotteryStartTime))
        local progress = 1 - (timeLeft / animationDuration)
        
        -- Update animation speed based on progress
        if progress < 0.7 then
            animSpeed = 0.05
        else
            animSpeed = 0.05 + (progress - 0.7) * 2
        end
        
        if CurTime() > lastUpdate + animSpeed then
            currentIndex = (currentIndex % #lotteryPlayers) + 1
            
            local tempLabel = currentLabel
            currentLabel = nextLabel
            nextLabel = tempLabel
            
            local nextIndex = (currentIndex % #lotteryPlayers) + 1
            if lotteryPlayers[nextIndex] and IsValid(lotteryPlayers[nextIndex]) then
                nextLabel:SetText(lotteryPlayers[nextIndex]:Nick())
            end
            
            -- Reset animation
            animY = 80
            lastUpdate = CurTime()
            
            -- Sound
            surface.PlaySound("buttons/lightswitch2.wav")
        end
        
        -- Interpolate Y position for smooth scrolling
        animY = Lerp(FrameTime() * 15, animY, 0)
        currentLabel:SetPos(0, animY - 60)
        nextLabel:SetPos(0, animY)
        
        -- Stop animation and show result
        if timeLeft <= 0 then
            bomberLotteryActive = false
            if IsValid(selectedPlayer) then
                -- Final display
                currentLabel:SetText(selectedPlayer:Nick())
                currentLabel:SetTextColor(Color(255, 25, 25))
                currentLabel:SetPos(0, 0)
                nextLabel:SetVisible(false)
                
                -- Change frame paint for result
                lotteryFrame.Paint = function(self, w, h)
                    local flash = math.abs(math.sin(CurTime() * 10))
                    local borderColor = Color(255, 50, 50, 200 + flash * 55)
                    
                    surface.SetDrawColor(20, 20, 20, 230)
                    surface.DrawRect(0, 0, w, h)
                    
                    surface.SetDrawColor(borderColor)
                    surface.DrawOutlinedRect(0, 0, w, h)
                end
                
                -- Result sequence with 5 second countdown
                surface.PlaySound("buttons/button10.wav")
                
                -- 5 second countdown
                for i = 1, 5 do
                    timer.Simple(i, function()
                        if IsValid(currentLabel) then
                            currentLabel:SetText(selectedPlayer:Nick() .. " - " .. (6 - i))
                            surface.PlaySound("buttons/blip1.wav")
                        end
                    end)
                end
                
                timer.Simple(6, function()
                    if IsValid(currentLabel) then
                        currentLabel:SetText("💥 BOOM! 💥")
                        currentLabel:SetTextColor(Color(255, 255, 0))
                    end
                end)
                timer.Simple(6.5, function()
                    if IsValid(lotteryFrame) then lotteryFrame:Remove() end
                end)
            end
        end
    end
end

-- Network message receiver
net.Receive("BomberLottery", function()
    lotteryPlayers = net.ReadTable()
    selectedPlayer = net.ReadEntity()
    
    if #lotteryPlayers > 0 and IsValid(selectedPlayer) then
        bomberLotteryActive = true
        lotteryStartTime = CurTime()
        CreateLotteryWindow()
        surface.PlaySound("ui/buttonrollover.wav")
    end
end)

-- Chat message for explosion notification
hook.Add("OnPlayerChat", "BomberExplosionNotification", function(ply, strText, bTeam, bDead)
    if string.find(strText, "exploded!") then
        -- Add special formatting to explosion messages
        return true -- Let the default chat handle it
    end
end) 


================================================
FILE: gamemodes/breach/gamemode/modules/cl_chaos_markers.lua
================================================
-- System oznaczania CI Spy i Agent CI
-- Wyświetla oznaczenie "Ally" nad głową CI Spy i Agent CI

hook.Add("HUDPaint", "DrawChaosMarkers", function()
    local localPlayer = LocalPlayer()
    
    if not IsValid(localPlayer) then return end
    
    local canSeeMarkers = false
    local isClassD = localPlayer:GTeam() == TEAM_CLASSD
    local isChaos = localPlayer:GTeam() == TEAM_CHAOS
    
    -- Klasa D może widzieć oznaczenia
    if isClassD then
        canSeeMarkers = true
    -- Wszyscy członkowie Chaos mogą widzieć oznaczenia
    elseif isChaos then
        canSeeMarkers = true
    end
    
    if not canSeeMarkers then
        return
    end
    
    -- Przejdź przez wszystkich graczy
    for _, ply in pairs(player.GetAll()) do
        if not IsValid(ply) or ply == localPlayer or not ply:Alive() then
            continue
        end
        
        -- Określ kogo pokazywać na podstawie obserwującego
        local shouldShowMarker = false
        
        if isClassD then
            -- Klasa D widzi tylko CI Spy i Agent CI (nie CI Soldier)
            if ply:GTeam() == TEAM_CHAOS and (ply:GetNClass() == ROLES.ROLE_CHAOSSPY or ply:GetNClass() == ROLES.ROLE_CIC) then
                shouldShowMarker = true
            end
        elseif isChaos then
            -- Wszyscy Chaos widzą CI Spy i Agent CI
            if ply:GTeam() == TEAM_CHAOS and (ply:GetNClass() == ROLES.ROLE_CHAOSSPY or ply:GetNClass() == ROLES.ROLE_CIC) then
                shouldShowMarker = true
            end
        end
        
        if shouldShowMarker then
            local headPos = ply:GetBonePosition(ply:LookupBone("ValveBiped.Bip01_Head1") or 0)
            if headPos == Vector(0,0,0) then
                headPos = ply:GetPos() + Vector(0, 0, 75)
            else
                headPos = headPos + Vector(0, 0, 15)
            end
            
            -- Sprawdź czy gracz jest widoczny (nie za ścianą)
            local trace = util.TraceLine({
                start = localPlayer:GetShootPos(),
                endpos = ply:GetShootPos(),
                filter = {localPlayer, ply},
                mask = MASK_SOLID_BRUSHONLY
            })
            
            -- Jeśli trace trafił w ścianę, nie pokazuj oznaczenia
            if trace.Hit then
                continue
            end
            
            local screenPos = headPos:ToScreen()
            
            -- Sprawdź czy pozycja jest na ekranie
            if screenPos.visible then
                -- Rozmiar ikony
                local iconSize = 40
                
                -- Ustaw material ikony CI
                surface.SetMaterial(Material("breach/ci.png"))
                surface.SetDrawColor(255, 255, 255, 255)
                
                -- Narysuj ikonkę CI
                surface.DrawTexturedRect(
                    screenPos.x - iconSize/2,
                    screenPos.y - iconSize/2,
                    iconSize,
                    iconSize
                )
            end
        end
    end
end)


================================================
FILE: gamemodes/breach/gamemode/modules/cl_classmenu.lua
================================================
CLASSMENU = nil
selectedclass = nil
selectedclr = nil

surface.CreateFont("MTF_2Main",   {font = "Trebuchet24",
									size = 20,
									weight = 750})
surface.CreateFont("MTF_Main",   {font = "Trebuchet24",
									size = ScreenScale(9),
									weight = 750})
surface.CreateFont("MTF_Secondary", {font = "Trebuchet24",
									size = ScreenScale(14),
									weight = 750,
									shadow = true})
surface.CreateFont("MTF_Third", {font = "Trebuchet24",
									size = ScreenScale(10),
									weight = 750,
									shadow = true})

--[[-----------------------------------------------------------------
	Pre-defined modele dla SCP – używane w podglądzie F2.
	Wzięte z sv_base_scps.lua, aby uniknąć BRENA / ERROR.
-------------------------------------------------------------------]]
local SCP_MODEL_MAP = {
	["SCP023"]    = "models/Novux/023/Novux_SCP-023.mdl",
	["SCP049"]    = "models/vinrax/player/scp049_player.mdl",
	["SCP0492"]   = "models/player/zombie_classic.mdl",
	["SCP054"]    = "models/xiali/scp_054/ctg/scp_054.mdl",
	["SCP066"]    = "models/player/mrsilver/scp_066pm/scp_066_pm.mdl",
	["SCP076"]    = "models/abel/abel.mdl",
	["SCP082"]    = "models/models/konnie/savini/savini.mdl",
	["SCP096"]    = "models/scp096anim/player/scp096pm_raf.mdl",
	["SCP106"]    = "models/scp/106/unity/unity_scp_106_player.mdl",
	["SCP173"]    = "models/jqueary/scp/unity/scp173/scp173unity.mdl",
	["SCP457"]    = "models/player/corpse1.mdl",
	["SCP682"]    = "models/scp_682/scp_682.mdl",
	["SCP689"]    = "models/dwdarksouls/models/darkwraith.mdl",
	["SCP8602"]   = "models/props/forest_monster/forest_monster2.mdl",
	["SCP939"]    = "models/scp/939/unity/unity_scp_939.mdl",
	["SCP957"]    = "models/immigrant/outlast/walrider_pm.mdl",
	["SCP966"]    = "models/player/mishka/966_new.mdl",
	["SCP999"]    = "models/scp/999/jq/scp_999_pmjq.mdl",
	["SCP1048A"]  = "models/1048/tdyear/tdybrownearpm.mdl",
	["SCP1048B"]  = "models/player/teddy_bear/teddy_bear.mdl",
	["SCP1316"] = "models/yevocore/cat/cat.mdl",
	["SCP1471"]   = "models/burd/scp1471/scp1471.mdl",
	["SCP2137J"] = "models/t37/papaj.mdl",
	["SCPSTEVEJ"] = "models/minecraft/steve/steve.mdl",
	["SCP069"]    = "models/player/alski/re2remake/mr_x.mdl",
	["SCP2521"]   = "models/cultist/scp/scp_no1.mdl",
	["SCP239"]    = "models/cultist/scp/scp_239.mdl",
	["SCP3166"]   = "models/nickelodeon_all_stars/garfield/garfield.mdl",
	["SCPIMPOSTORJ"]   = "models/lenoax/amongus/suit_pm.mdl",
	["SCP3199"]   = "models/washton/3199.mdl",
	["SCPDOOMGUYJ"] = "models/player/doom_fn_pm.mdl",
	["SCPTTT_SAHUR"] = "models/gacommissions/tungtungtungsahur.mdl"
}

-- Stała lista SCP dla Class Manager
local ALL_SCPS = {
	"SCP023", "SCP049", "SCP0492", "SCP054", "SCP066", "SCP069", "SCP076", "SCP082",
	"SCP096", "SCP106", "SCP173", "SCP239", "SCP457", "SCP682", "SCP689",
	"SCP8602", "SCP939", "SCP957", "SCP966", "SCP999", "SCP1048A",
	"SCP1048B", "SCP1316", "SCP1471", "SCP2137J", "SCPSTEVEJ", "SCP2521", "SCP3166", "SCPIMPOSTORJ", "SCP3199", "SCPDOOMGUYJ", "SCPTTT_SAHUR"
}

function OpenClassMenu()
	if IsValid(CLASSMENU) then return end
	local ply = LocalPlayer()
	
	surface.CreateFont("MTF_2Main",   {font = "Trebuchet24",
										size = 35,
										weight = 750})
	surface.CreateFont("MTF_Main",   {font = "Trebuchet24",
										size = ScreenScale(9),
										weight = 750})
	surface.CreateFont("MTF_Secondary", {font = "Trebuchet24",
										size = ScreenScale(14),
										weight = 750,
										shadow = true})
	surface.CreateFont("MTF_Third", {font = "Trebuchet24",
										size = ScreenScale(10),
										weight = 750,
										shadow = true})
	
	local ourlevel = LocalPlayer():GetLevel()
	
	selectedclass = ALLCLASSES["support"]["roles"][1]
	selectedclr = ALLCLASSES["support"]["color"]
	
	if selectedclr == nil then selectedclr = Color(255,255,255) end
	
	local width = ScrW() / 1.5
	local height = ScrH() / 1.5
	
	CLASSMENU = vgui.Create( "DFrame" )
	CLASSMENU:SetTitle( "" )
	CLASSMENU:SetSize( width, height )
	CLASSMENU:Center()
	CLASSMENU:SetDraggable( true )
	CLASSMENU:SetDeleteOnClose( true )
	CLASSMENU:SetDraggable( false )
	CLASSMENU:ShowCloseButton( true )
	CLASSMENU:MakePopup()
	CLASSMENU.Paint = function( self, w, h )
		draw.RoundedBox( 2, 0, 0, w, h, Color(0, 0, 0) )
		draw.RoundedBox( 2, 1, 1, w - 2, h - 2, Color(90, 90, 95) )
	end
	
	local maininfo = vgui.Create( "DLabel", CLASSMENU )
	maininfo:SetText( "Class Manager" )
	maininfo:Dock( TOP )
	maininfo:SetFont("MTF_Main")
	maininfo:SetContentAlignment( 5 )
	//maininfo:DockMargin( 245, 8, 8, 175	)
	maininfo:SetSize(0,28)
	maininfo.Paint = function( self, w, h )
		draw.RoundedBox( 2, 0, 0, w, h, Color(0, 0, 0) )
		draw.RoundedBox( 2, 1, 1, w - 2, h - 2, Color(90, 90, 95) )
	end
	
	local panel_right = vgui.Create( "DPanel", CLASSMENU )
	panel_right:Dock( FILL )
	panel_right:DockMargin( width / 2 - 5, 0, 0, 0	)
	panel_right.Paint = function( self, w, h ) end
	
	
	local sclass_toppanel = vgui.Create( "DPanel", panel_right )
	sclass_toppanel:Dock( TOP )
	sclass_toppanel:SetSize(0, height / 2.5)
	sclass_toppanel.Paint = function( self, w, h ) end
	
	local smodel
	if selectedclass.showmodel == nil then
		smodel = table.Random(selectedclass.models)
	else
		smodel = selectedclass.showmodel
	end
	
	local class_modelpanel = vgui.Create( "DPanel", sclass_toppanel )
	class_modelpanel:Dock( LEFT )
	class_modelpanel:SetSize(width / 6)
	class_modelpanel.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, Color(50,50,50) )
	end

	sclass_model = vgui.Create( "DModelPanel", class_modelpanel )
	sclass_model:Dock( FILL )
	sclass_model:SetFOV(50)
	sclass_model:SetModel( smodel )
	function sclass_model:LayoutEntity( entity )
		entity:SetAngles(Angle(0,18,0))
		
		-- Ustaw bodygroups dla SCP-527
		if selectedclass.name == ROLES.ROLE_SCP527 then
			local hatGroup = entity:FindBodygroupByName("Hat")
			local clothesGroup = entity:FindBodygroupByName("Clothes")
			
			if hatGroup != -1 then
				entity:SetBodygroup(hatGroup, 1)
			end
			
			if clothesGroup != -1 then
				entity:SetBodygroup(clothesGroup, 1)
			end
		end
		
		-- Ogólny system bodygroups dla dużego modelu
		if selectedclass.bodygroups then
			for _, bg in pairs(selectedclass.bodygroups) do
				local groupID = bg[1]
				local value = bg[2]
				entity:SetBodygroup(groupID, value)
			end
		end
		
		-- Random bodygroups system dla dużego modelu (używa środkowych wartości)
		if selectedclass.bodygroups_random then
			for _, bg in pairs(selectedclass.bodygroups_random) do
				local groupID = bg[1]
				local range = bg[2]
				local middleValue = math.floor((range[1] + range[2]) / 2)
				entity:SetBodygroup(groupID, middleValue)
			end
		end
	end
	local ent = sclass_model:GetEntity()
	if selectedclass.pmcolor != nil then
		function ent:GetPlayerColor() return Vector ( selectedclass.pmcolor.r / 255, selectedclass.pmcolor.g / 255, selectedclass.pmcolor.b / 255 ) end
	end
	
	local sclass_name = vgui.Create( "DPanel", sclass_toppanel )
	sclass_name:Dock( TOP )
	sclass_name:SetSize(0, 50)
	sclass_name.Paint = function( self, w, h )
		draw.RoundedBox( 2, 0, 0, w, h, Color(0, 0, 0) )
		draw.RoundedBox( 2, 1, 1, w - 2, h - 2, selectedclr )
		draw.Text( {
			text = GetLangRole(selectedclass.name),
			font = "MTF_Secondary",
			xalign = TEXT_ALIGN_CENTER,
			yalign = TEXT_ALIGN_CENTER,
			pos = { w / 2, h / 2 }
		} )
	end
	
	local sclass_name = vgui.Create( "DPanel", sclass_toppanel )
	sclass_name:Dock( FILL )
	sclass_name:SetSize(0, 50)
	sclass_name.Paint = function( self, w, h )
		draw.RoundedBox( 2, 0, 0, w, h, Color(0, 0, 0) )
		draw.RoundedBox( 2, 1, 1, w - 2, h - 2, Color(86, 88, 90) )
		local atso = w / 13
		local starpos = w / 16
		draw.Text( {
			text = "Health: " .. selectedclass.health,
			font = "MTF_Third",
			xalign = TEXT_ALIGN_LEFT,
			yalign = TEXT_ALIGN_CENTER,
			pos = { 12, starpos }
		} )
		draw.Text( {
			text = "Walk speed: " .. math.Round(240 * selectedclass.walkspeed),
			font = "MTF_Third",
			xalign = TEXT_ALIGN_LEFT,
			yalign = TEXT_ALIGN_CENTER,
			pos = { 12, starpos + (atso) }
		} )
		draw.Text( {
			text = "Run speed: " .. math.Round(240 * selectedclass.runspeed),
			font = "MTF_Third",
			xalign = TEXT_ALIGN_LEFT,
			yalign = TEXT_ALIGN_CENTER,
			pos = { 12, starpos + (atso * 2) }
		} )
		draw.Text( {
			text = "Jump Power: " .. math.Round(200 * selectedclass.jumppower),
			font = "MTF_Third",
			xalign = TEXT_ALIGN_LEFT,
			yalign = TEXT_ALIGN_CENTER,
			pos = { 12, starpos + (atso * 3) }
		} )
		-- Sprawdź czy klasa jest dostępna dla wszystkich
		local isNoLevelRequired = (selectedclass.level == 0)
		
		if isNoLevelRequired then
			draw.Text( {
				text = "Available for all players",
				font = "MTF_Third",
				color = Color(0,255,0),
				xalign = TEXT_ALIGN_LEFT,
				yalign = TEXT_ALIGN_CENTER,
				pos = { 12, h - starpos }
			} )
		else
			local lvl = selectedclass.level
			local clr = Color(255,0,0)
			if ourlevel >= lvl then clr = Color(0,255,0) end
			draw.Text( {
				text = "Clearance level: " .. lvl,
				font = "MTF_Third",
				color = clr,
				xalign = TEXT_ALIGN_LEFT,
				yalign = TEXT_ALIGN_CENTER,
				pos = { 12, h - starpos }
			} )
		end
	end
	
	local sclass_downpanel = vgui.Create( "DPanel", panel_right )
	sclass_downpanel:Dock( FILL )
	sclass_downpanel:SetSize(0, height / 2.5)
	sclass_downpanel.Paint = function( self, w, h )
		local atso = w / 18
		local starpos = w / 12
		local numw = 0
		for k,v in pairs(selectedclass.showweapons) do
			draw.Text( {
				text = "- " .. v,
				font = "MTF_Third",
				xalign = TEXT_ALIGN_LEFT,
				yalign = TEXT_ALIGN_CENTER,
				pos = { 12, starpos + (numw * atso) }
			} )
			numw = numw + 1
		end
	end
	
	local maininfo = vgui.Create( "DLabel", sclass_downpanel )
	maininfo:SetText( "Equipment" )
	maininfo:Dock( TOP )
	maininfo:SetFont("MTF_Main")
	maininfo:SetContentAlignment( 5 )
	//maininfo:DockMargin( 245, 8, 8, 175	)
	maininfo:SetSize(0,28)
	maininfo.Paint = function( self, w, h )
		draw.RoundedBox( 2, 0, 0, w, h, Color(0, 0, 0) )
		draw.RoundedBox( 2, 1, 1, w - 2, h - 2, selectedclr	)
	end
	
	// LEFT PANELS
	
	local panel_left = vgui.Create( "DPanel", CLASSMENU )
	panel_left:Dock( FILL )
	panel_left:DockMargin( 0, 0, width / 2 - 5, 0	)
	panel_left.Paint = function( self, w, h ) end
	
	local scroller = vgui.Create( "DScrollPanel", panel_left )
	scroller:Dock( FILL )
	
	if ALLCLASSES == nil then return end
	
	-- Przygotuj kategorię SCP
	local scp_category = nil
	
	-- Dodaj zakładkę SCP
	if true then -- Zawsze pokazuj zakładkę SCP
		-- Utwórz strukturę dla SCP
		scp_category = {
			name = "SCP Entities",
			color = Color(200, 0, 0), -- Czerwony kolor
			roles = {}
		}
		
		-- Dodaj każde SCP do listy
		for _, scp_id in pairs(ALL_SCPS) do
			local mdl = SCP_MODEL_MAP[scp_id] or "models/player/breen.mdl"
			local scp_role = {
				name = scp_id,
				health = 1000, -- Domyślne wartości
				walkspeed = 1,
				runspeed = 1,
				jumppower = 1,
				level = 0,
				models = {mdl},
				showmodel = mdl,
				showweapons = {"Special SCP abilities"},
				team = TEAM_SCP
			}
			
			-- Specjalne wartości dla WSZYSTKICH SCP z sv_base_scps.lua
			if scp_id == "SCP023" then
				scp_role.health = 2000
				scp_role.walkspeed = 150/240
				scp_role.runspeed = 250/240
				scp_role.models = {"models/Novux/023/Novux_SCP-023.mdl"}
				scp_role.showmodel = "models/Novux/023/Novux_SCP-023.mdl"
				scp_role.showweapons = {"Gaze causes death in 1 minute", "Increased speed", "Damage on touch"}
			elseif scp_id == "SCP049" then
				scp_role.health = 1600
				scp_role.walkspeed = 135/240
				scp_role.runspeed = 135/240
				scp_role.models = {"models/vinrax/player/scp049_player.mdl"}
				scp_role.showmodel = "models/vinrax/player/scp049_player.mdl"
				scp_role.showweapons = {"Instant kill touch", "Creates SCP-049-2 zombies", "Slow but tanky"}
			elseif scp_id == "SCP0492" then
				scp_role.health = 750
				scp_role.walkspeed = 160/240
				scp_role.runspeed = 160/240
				scp_role.models = {"models/player/zombie_classic.mdl"}
				scp_role.showmodel = "models/player/zombie_classic.mdl"
				scp_role.showweapons = {"Zombie created by SCP-049", "Melee attack", "Medium speed"}
			elseif scp_id == "SCP066" then
				scp_role.health = 2250
				scp_role.walkspeed = 160/240
				scp_role.runspeed = 160/240
				scp_role.models = {"models/player/mrsilver/scp_066pm/scp_066_pm.mdl"}
				scp_role.showmodel = "models/player/mrsilver/scp_066pm/scp_066_pm.mdl"
				scp_role.showweapons = {"Eric's Toy", "Plays loud music", "Damage through sound"}
			elseif scp_id == "SCP076" then
				scp_role.health = 300
				scp_role.walkspeed = 220/240
				scp_role.runspeed = 220/240
				scp_role.models = {"models/abel/abel.mdl"}
				scp_role.showmodel = "models/abel/abel.mdl"
				scp_role.showweapons = {"Summons blade weapons", "Very fast", "Low health but high damage"}
			elseif scp_id == "SCP082" then
				scp_role.health = 2300
				scp_role.walkspeed = 160/240
				scp_role.runspeed = 160/240
				scp_role.models = {"models/models/konnie/savini/savini.mdl"}
				scp_role.showmodel = "models/models/konnie/savini/savini.mdl"
				scp_role.showweapons = {"Fernand the Cannibal", "High health", "Melee attacks"}
			elseif scp_id == "SCP096" then
				scp_role.health = 1750
				scp_role.walkspeed = 120/240
				scp_role.runspeed = 500/240
				scp_role.models = {"models/scp096anim/player/scp096pm_raf.mdl"}
				scp_role.showmodel = "models/scp096anim/player/scp096pm_raf.mdl"
				scp_role.showweapons = {"Shy Guy", "Rage mode when looked at", "Extreme speed when enraged"}
			elseif scp_id == "SCP106" then
				scp_role.health = 2000
				scp_role.walkspeed = 170/240
				scp_role.runspeed = 170/240
				scp_role.models = {"models/scp/106/unity/unity_scp_106_player.mdl"}
				scp_role.showmodel = "models/scp/106/unity/unity_scp_106_player.mdl"
				scp_role.showweapons = {"Old Man", "Walk through walls", "Teleport to pocket dimension"}
			elseif scp_id == "SCP173" then
				scp_role.health = 3000
				scp_role.walkspeed = 400/240
				scp_role.runspeed = 400/240
				scp_role.models = {"models/jqueary/scp/unity/scp173/scp173unity.mdl"}
				scp_role.showmodel = "models/jqueary/scp/unity/scp173/scp173unity.mdl"
				scp_role.showweapons = {"The Sculpture", "Snap necks instantly", "Can't move when watched"}
			elseif scp_id == "SCP457" then
				scp_role.health = 2300
				scp_role.walkspeed = 135/240
				scp_role.runspeed = 135/240
				scp_role.models = {"models/player/corpse1.mdl"}
				scp_role.showmodel = "models/player/corpse1.mdl"
				scp_role.showweapons = {"Burning Man", "Fire damage", "Spreads flames"}
			elseif scp_id == "SCP682" then
				scp_role.health = 2000
				scp_role.walkspeed = 120/240
				scp_role.runspeed = 275/240
				scp_role.models = {"models/danx91/scp/scp_682.mdl"}
				scp_role.showmodel = "models/danx91/scp/scp_682.mdl"
				scp_role.showweapons = {"Hard to Destroy Reptile", "High damage attacks", "Fast when chasing"}
			elseif scp_id == "SCP689" then
				scp_role.health = 1750
				scp_role.walkspeed = 100/240
				scp_role.runspeed = 100/240
				scp_role.models = {"models/dwdarksouls/models/darkwraith.mdl"}
				scp_role.showmodel = "models/dwdarksouls/models/darkwraith.mdl"
				scp_role.showweapons = {"Haunter in the Dark", "Slow movement", "Teleports when not observed"}
			elseif scp_id == "SCP8602" then
				scp_role.health = 2250
				scp_role.walkspeed = 190/240
				scp_role.runspeed = 190/240
				scp_role.models = {"models/props/forest_monster/forest_monster2.mdl"}
				scp_role.showmodel = "models/props/forest_monster/forest_monster2.mdl"
				scp_role.showweapons = {"Forest Monster", "High health", "Medium speed hunter"}
			elseif scp_id == "SCP939" then
				scp_role.health = 2000
				scp_role.walkspeed = 190/240
				scp_role.runspeed = 190/240
				scp_role.models = {"models/scp/939/unity/unity_scp_939.mdl"}
				scp_role.showmodel = "models/scp/939/unity/unity_scp_939.mdl"
				scp_role.showweapons = {"With Many Voices", "Mimics voices", "Pack hunter"}
			elseif scp_id == "SCP957" then
				scp_role.health = 1500
				scp_role.walkspeed = 175/240
				scp_role.runspeed = 175/240
				scp_role.models = {"models/immigrant/outlast/walrider_pm.mdl"}
				scp_role.showmodel = "models/immigrant/outlast/walrider_pm.mdl"
				scp_role.showweapons = {"The Baiting", "Lures victims", "Moderate speed"}
			elseif scp_id == "SCP966" then
				scp_role.health = 800
				scp_role.walkspeed = 140/240
				scp_role.runspeed = 140/240
				scp_role.models = {"models/player/mishka/966_new.mdl"}
				scp_role.showmodel = "models/player/mishka/966_new.mdl"
				scp_role.showweapons = {"Sleep Killers", "Invisible to humans", "Causes exhaustion"}
			elseif scp_id == "SCP999" then
				scp_role.health = 1000
				scp_role.walkspeed = 150/240
				scp_role.runspeed = 150/240
				scp_role.models = {"models/scp/999/jq/scp_999_pmjq.mdl"}
				scp_role.showmodel = "models/scp/999/jq/scp_999_pmjq.mdl"
				scp_role.showweapons = {"The Tickle Monster", "Friendly SCP", "Heals and calms others"}
			elseif scp_id == "SCP1048A" then
				scp_role.health = 1500
				scp_role.walkspeed = 135/240
				scp_role.runspeed = 135/240
				scp_role.models = {"models/1048/tdyear/tdybrownearpm.mdl"}
				scp_role.showmodel = "models/1048/tdyear/tdybrownearpm.mdl"
				scp_role.showweapons = {"Ear Bear", "Screams cause damage", "Small and agile"}
			elseif scp_id == "SCP1048B" then
				scp_role.health = 2000
				scp_role.walkspeed = 165/240
				scp_role.runspeed = 165/240
				scp_role.models = {"models/player/teddy_bear/teddy_bear.mdl"}
				scp_role.showmodel = "models/player/teddy_bear/teddy_bear.mdl"
				scp_role.showweapons = {"Metal Bear", "High durability", "Strong melee attacks"}
			elseif scp_id == "SCP1471" then
				scp_role.health = 3000
				scp_role.walkspeed = 160/240
				scp_role.runspeed = 325/240
				scp_role.models = {"models/burd/scp1471/scp1471.mdl"}
				scp_role.showmodel = "models/burd/scp1471/scp1471.mdl"
				scp_role.showweapons = {"MalO", "Stalks victims", "Very fast when hunting"}
			elseif scp_id == "SCP069" then
				scp_role.health = 1800
				scp_role.walkspeed = 160/240
				scp_role.runspeed = 200/240
				scp_role.models = {"models/player/alski/re2remake/mr_x.mdl"}
				scp_role.showmodel = "models/player/alski/re2remake/mr_x.mdl"
				scp_role.showweapons = {"Second Chance", "Instant kill touch", "Can disguise as victims"}
					elseif scp_id == "SCP1678" then
			scp_role.health = 2000
			scp_role.walkspeed = 160/240
			scp_role.runspeed = 160/240
			scp_role.models = {"models/scp-1678/scp-1678.mdl"}
			scp_role.showmodel = "models/scp-1678/scp-1678.mdl"
			scp_role.showweapons = {"UnLondon Entity", "Police baton attack", "Stuns enemies"}
		elseif scp_id == "SCP3166" then
			scp_role.health = 1800
			scp_role.walkspeed = 140/240
			scp_role.runspeed = 140/240
			scp_role.models = {"models/nickelodeon_all_stars/garfield/garfield.mdl"}
			scp_role.showmodel = "models/nickelodeon_all_stars/garfield/garfield.mdl"
			scp_role.showweapons = {"Claw Attack", "Lasagna Target Selection", "Speed & HP boost on kill"}
		elseif scp_id == "SCPIMPOSTORJ" then
			scp_role.health = 1000
			scp_role.walkspeed = 150/240
			scp_role.runspeed = 150/240
			scp_role.models = {"models/lenoax/amongus/suit_pm.mdl"}
			scp_role.showmodel = "models/lenoax/amongus/suit_pm.mdl"
			scp_role.showweapons = {"Knife Attack (38 damage)", "Among Us crewmate", "Bowie knife weapon"}
		elseif scp_id == "SCP9571" then
				-- SCP-957-1 nie ma własnego modelu, używa domyślnego
				scp_role.health = 500
				scp_role.walkspeed = 165/240
				scp_role.runspeed = 165/240
				scp_role.showweapons = {"SCP-957 offspring", "Fast attacker", "Low health"}
			elseif scp_id == "SCPDOOMGUYJ" then
				scp_role.health = 2500
				scp_role.walkspeed = 180/240
				scp_role.runspeed = 280/240
				scp_role.models = {"models/player/doom_fn_pm.mdl"}
				scp_role.showmodel = "models/player/doom_fn_pm.mdl"
				scp_role.showweapons = {"Crucible Energy Sword", "High speed and damage", "Doom Slayer incarnate"}
			end
			
			table.insert(scp_category.roles, scp_role)
		end
	end
	
	-- Zdefiniuj stałą kolejność zakładek
	local category_order = {}
	
	-- Dodaj SCP na początku
	if scp_category then
		table.insert(category_order, {key = "scp", data = scp_category})
	end
	
	-- Dodaj resztę kategorii w stałej kolejności
	table.insert(category_order, {key = "classds", data = ALLCLASSES.classds})
	table.insert(category_order, {key = "researchers", data = ALLCLASSES.researchers})
	table.insert(category_order, {key = "security", data = ALLCLASSES.security})
	table.insert(category_order, {key = "support", data = ALLCLASSES.support})
	table.insert(category_order, {key = "goc", data = ALLCLASSES.goc})
	
	-- Iteruj w ustalonej kolejności
	for _, category in ipairs(category_order) do
		local key = category.key
		local v = category.data
		
		if not v then continue end -- Pomiń jeśli kategoria nie istnieje
		local name_security = vgui.Create( "DLabel", scroller )
		name_security:SetText( v.name )
		name_security:SetFont("MTF_Main")
		name_security:SetContentAlignment( 5 )
		name_security:Dock( TOP )
		name_security:SetSize(0,45)
		name_security:DockMargin( 0, 0, 0, 0 )
		name_security.Paint = function( self, w, h )
			draw.RoundedBox( 2, 0, 0, w, h, Color(0, 0, 0) )
			draw.RoundedBox( 2, 1, 1, w - 2, h - 2, v.color )
		end
		for i,cls in ipairs(v.roles) do
			if GetConVar( "br_dclass_keycards" ):GetInt() == 0 and i != 2 or GetConVar( "br_dclass_keycards" ):GetInt() != 0 and i != 1 or v.name != "Class D Personell" then
				local model
				if cls.showmodel == nil then
					model = table.Random(cls.models)
				else
					model = cls.showmodel
				end
			
				local class_panel = vgui.Create( "DButton", scroller )
				class_panel:SetText("")
				class_panel:SetMouseInputEnabled( true )
				class_panel.DoClick = function()
					selectedclass = cls
					selectedclr = v.color
					sclass_model:SetModel( model )
					
					-- Ustaw bodygroups dla głównego modelu SCP-527
					if cls.name == ROLES.ROLE_SCP527 then
						timer.Simple(0.1, function()
							if IsValid(sclass_model) then
								local entity = sclass_model:GetEntity()
								if IsValid(entity) then
									local hatGroup = entity:FindBodygroupByName("Hat")
									local clothesGroup = entity:FindBodygroupByName("Clothes")
									
									if hatGroup != -1 then
										entity:SetBodygroup(hatGroup, 1)
									end
									
									if clothesGroup != -1 then
										entity:SetBodygroup(clothesGroup, 1)
									end
								end
							end
						end)
					end
					
					-- Ogólny system bodygroups dla głównego modelu
					if cls.bodygroups then
						timer.Simple(0.1, function()
							if IsValid(sclass_model) then
								local entity = sclass_model:GetEntity()
								if IsValid(entity) then
									for _, bg in pairs(cls.bodygroups) do
										local groupID = bg[1]
										local value = bg[2]
										entity:SetBodygroup(groupID, value)
									end
								end
							end
						end)
					end
					
					-- Random bodygroups system dla głównego modelu
					if cls.bodygroups_random then
						timer.Simple(0.1, function()
							if IsValid(sclass_model) then
								local entity = sclass_model:GetEntity()
								if IsValid(entity) then
									for _, bg in pairs(cls.bodygroups_random) do
										local groupID = bg[1]
										local range = bg[2]
										local middleValue = math.floor((range[1] + range[2]) / 2)
										entity:SetBodygroup(groupID, middleValue)
									end
								end
							end
						end)
					end
				end
				//class_panel:SetText( cls.name )
				//class_panel:SetFont("MTF_Main")
				class_panel:Dock( TOP )
				class_panel:SetSize(0,60)
				if i != 1 then
					class_panel:DockMargin( 0, 4, 0, 0 )
				end
				
				local level = ""
				-- Sprawdź czy klasa jest dostępna dla wszystkich
				if cls.level == 0 then
					level = "Available for all players"
				else
					level = "Clearance Level: " .. cls.level
				end
				
				//local enabled = true
				//if enabled == true then enabled = "Yes" else enabled = "No" end
				
				class_panel.Paint = function( self, w, h )
					if selectedclass == cls then
						draw.RoundedBox( 0, 0, 0, w, h, Color(v.color.r - 20, v.color.g - 20, v.color.b - 20) )
					else
						draw.RoundedBox( 0, 0, 0, w, h, Color(v.color.r - 50, v.color.g - 50, v.color.b - 50) )
					end
					draw.Text( {
						text = GetLangRole(cls.name),
						font = "MTF_Main",
						xalign = TEXT_ALIGN_LEFT,
						yalign = TEXT_ALIGN_CENTER,
						pos = { 70, h / 3.5 }
					} )
					draw.Text( {
						text = level,
						font = "MTF_Main",
						xalign = TEXT_ALIGN_LEFT,
						yalign = TEXT_ALIGN_CENTER,
						pos = { 70, h / 1.4 }
					} )
					/*
					draw.Text( {
						text = "Enabled: " .. enabled,
						font = "MTF_Main",
						xalign = TEXT_ALIGN_RIGHT,
						yalign = TEXT_ALIGN_CENTER,
						pos = { w - 15, h / 2 }
					} )
					*/
				end
				
				local class_modelpanel = vgui.Create( "DPanel", class_panel )
				class_modelpanel:Dock( LEFT )
				class_modelpanel.Paint = function( self, w, h )
					draw.RoundedBox( 0, 0, 0, w, h, Color(v.color.r - 25, v.color.g - 25, v.color.b - 25) )
				end
				

				local class_model = vgui.Create( "DModelPanel", class_modelpanel )
				class_model:Dock( FILL )
				class_model:SetFOV(35)
				class_model:SetModel( model )
				function class_model:LayoutEntity( entity )
					entity:SetAngles(Angle(0,18,0))
					
					-- Ustaw bodygroups dla SCP-527
					if cls.name == ROLES.ROLE_SCP527 then
						local hatGroup = entity:FindBodygroupByName("Hat")
						local clothesGroup = entity:FindBodygroupByName("Clothes")
						
						if hatGroup != -1 then
							entity:SetBodygroup(hatGroup, 1)
						end
						
						if clothesGroup != -1 then
							entity:SetBodygroup(clothesGroup, 1)
						end
					end
					
					-- Ogólny system bodygroups dla małych modeli w liście
					if cls.bodygroups then
						for _, bg in pairs(cls.bodygroups) do
							local groupID = bg[1]
							local value = bg[2]
							entity:SetBodygroup(groupID, value)
						end
					end
					
					-- Random bodygroups system dla małych modeli w liście
					if cls.bodygroups_random then
						for _, bg in pairs(cls.bodygroups_random) do
							local groupID = bg[1]
							local range = bg[2]
							local middleValue = math.floor((range[1] + range[2]) / 2)
							entity:SetBodygroup(groupID, middleValue)
						end
					end
				end
				local ent = class_model:GetEntity()
				if cls.pmcolor != nil then
					function ent:GetPlayerColor() return Vector ( cls.pmcolor.r / 255, cls.pmcolor.g / 255, cls.pmcolor.b / 255 ) end
				end
				if ent:LookupBone( "ValveBiped.Bip01_Head1" ) != nil then
					local eyepos = ent:GetBonePosition( ent:LookupBone( "ValveBiped.Bip01_Head1" ) )
					eyepos:Add( Vector( 0, 0, 2 ) )
					class_model:SetLookAt( eyepos )
					class_model:SetCamPos( eyepos-Vector( -24, 0, 0 ) )
					ent:SetEyeTarget( eyepos-Vector( -24, 0, 0 ) )
				end
			end
		end -- koniec pętli for
	end
	
	//button_escort:SetFont("MTF_Main")
	//button_escort:SetContentAlignment( 5 )
	//button_escort:DockMargin( 0, 5, 0, 0	)
	//button_escort:SetSize(0,32)
	//button_escort.DoClick = function()
	//	RunConsoleCommand("br_requestescort")
	//	CLASSMENU:Close()
	//end
	/*
	local button_escort = vgui.Create( "DButton", CLASSMENU )
	button_escort:SetText( "Sound: Random" )
	button_escort:Dock( TOP )
	button_escort:SetFont("MTF_Main")
	button_escort:SetContentAlignment( 5 )
	button_escort:DockMargin( 0, 5, 0, 0	)
	button_escort:SetSize(0,32)
	button_escort.DoClick = function()
		RunConsoleCommand("br_sound_random")
		CLASSMENU:Close()
	end
	*/
end



================================================
FILE: gamemodes/breach/gamemode/modules/cl_credits_hud.lua
================================================
-- ===============================================
-- KLIENCKI HUD SYSTEMU KREDYTÓW - SCP BREACH
-- ===============================================

-- Zmienne lokalne
local playerCredits = 0
local notifications = {}
local showCredits = true

-- Odbieranie aktualizacji kredytów
net.Receive("UpdateCredits", function()
    playerCredits = net.ReadInt(32)
end)

-- Odbieranie powiadomień o kredytach - wyłączone
-- net.Receive("CreditsNotification", function()
--     local amount = net.ReadInt(32)
--     local reason = net.ReadString()
--     local newTotal = net.ReadInt(32)
--     -- Powiadomienia wyłączone
-- end)

-- Funkcja rysowania HUD kredytów
local function DrawCreditsHUD()
    if not showCredits then return end
    if LocalPlayer():GTeam() == TEAM_SPEC then return end
    if not LocalPlayer():Alive() then return end
    
    local scrW, scrH = ScrW(), ScrH()
    
    -- Pozycja HUD (prawy górny róg)
    local x = scrW - 250
    local y = 20
    
    -- Tło dla kredytów
    draw.RoundedBox(8, x, y, 220, 50, Color(20, 20, 20, 180))
    draw.RoundedBox(8, x, y, 220, 25, Color(40, 40, 40, 200))
    
    -- Ikona kredytów
    draw.SimpleText("💰", "DermaLarge", x + 15, y + 5, Color(255, 215, 0), TEXT_ALIGN_LEFT)
    
    -- Tekst kredytów
    draw.SimpleText("Credits", "DermaDefault", x + 50, y + 5, Color(255, 255, 255), TEXT_ALIGN_LEFT)
    draw.SimpleText(tostring(playerCredits), "DermaDefaultBold", x + 50, y + 25, Color(255, 215, 0), TEXT_ALIGN_LEFT)
    
    -- Dodatkowe info (zabójstwa w rundzie)
    if LocalPlayer().RoundKills and LocalPlayer().RoundKills > 0 then
        draw.SimpleText("Kills: " .. LocalPlayer().RoundKills, "DermaDefault", x + 150, y + 25, Color(100, 255, 100), TEXT_ALIGN_LEFT)
    end
end

-- Funkcja rysowania powiadomień o kredytach
local function DrawCreditsNotifications()
    local scrW, scrH = ScrW(), ScrH()
    local startY = 100
    
    for i = #notifications, 1, -1 do
        local notif = notifications[i]
        if not notif then continue end
        
        -- Sprawdź czas życia powiadomienia (5 sekund)
        local age = CurTime() - notif.time
        if age > 5 then
            table.remove(notifications, i)
            continue
        end
        
        -- Animacja zanikania
        if age > 4 then
            notif.alpha = math.max(0, 255 - (age - 4) * 255)
        end
        
        -- Pozycja powiadomienia
        local y = startY + (i - 1) * 60
        local x = scrW - 300
        
        -- Kolor zależny od kwoty
        local amountColor = Color(100, 255, 100, notif.alpha) -- Zielony dla dodatnich
        if notif.amount < 0 then
            amountColor = Color(255, 100, 100, notif.alpha) -- Czerwony dla ujemnych
        end
        
        -- Tło powiadomienia
        draw.RoundedBox(6, x, y, 280, 50, Color(30, 30, 30, notif.alpha * 0.8))
        draw.RoundedBox(6, x, y, 280, 20, Color(50, 50, 50, notif.alpha * 0.9))
        
        -- Tekst powiadomienia
        local prefix = notif.amount > 0 and "+" or ""
        draw.SimpleText(prefix .. notif.amount .. " Credits", "DermaDefaultBold", x + 10, y + 2, amountColor, TEXT_ALIGN_LEFT)
        
        if notif.reason and notif.reason != "" then
            draw.SimpleText(notif.reason, "DermaDefault", x + 10, y + 25, Color(200, 200, 200, notif.alpha), TEXT_ALIGN_LEFT)
        end
    end
end

-- Hook rysowania HUD - wyłączony
-- hook.Add("HUDPaint", "CreditsHUD", function()
--     DrawCreditsHUD()
--     DrawCreditsNotifications()
-- end)

-- Komenda do ukrywania/pokazywania kredytów - wyłączona
-- concommand.Add("br_toggle_credits", function()
--     showCredits = not showCredits
--     LocalPlayer():PrintMessage(HUD_PRINTTALK, "[CREDITS] HUD " .. (showCredits and "enabled" or "disabled"))
-- end)

-- Funkcja dostępowa do kredytów (dla innych modułów)
function GetPlayerCredits()
    return playerCredits
end

-- Czyszczenie powiadomień na początku rundy
hook.Add("BreachPreround", "CreditsHUD_Reset", function()
    notifications = {}
    playerCredits = 0
end)

print("[BREACH] Credits HUD loaded!")


================================================
FILE: gamemodes/breach/gamemode/modules/cl_deathcard.lua
================================================
-- Client-side death card display
local deathCardPanel = nil

-- Create fonts
surface.CreateFont("DeathCardTitle", {
    font = "Roboto",
    extended = false,
    size = 24,
    weight = 700,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = true,
    additive = false,
    outline = false,
})

surface.CreateFont("DeathCardBig", {
    font = "Roboto",
    extended = false,
    size = 20,
    weight = 500,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = true,
    additive = false,
    outline = false,
})

surface.CreateFont("DeathCardNormal", {
    font = "Roboto",
    extended = false,
    size = 16,
    weight = 400,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = true,
    additive = false,
    outline = false,
})

-- Weapon name translations
local weaponNames = {
    ["weapon_crowbar"] = "Crowbar",
    ["weapon_stunstick"] = "Stun Stick",
    ["cw_ak74"] = "AK-74",
    ["cw_ar15"] = "AR-15",
    ["cw_scarh"] = "SCAR-H",
    ["cw_g36c"] = "G36C",
    ["cw_ump45"] = "UMP45",
    ["cw_mp5"] = "MP5",
    ["cw_deagle"] = "Desert Eagle",
    ["cw_m249_official"] = "M249",
    ["cw_makarov"] = "Makarov",
    ["cw_mr96"] = "MR96",
    ["cw_p99"] = "P99",
    ["cw_shorty"] = "Shorty",
    ["weapon_scp_173"] = "Neck Snap",
    ["weapon_scp_457"] = "Fire",
    ["weapon_scp_049"] = "Touch",
    ["weapon_scp_096"] = "Claws",
    ["weapon_scp_106"] = "Pocket Dimension",
    ["weapon_scp_939"] = "Bite",
    ["weapon_scp_966"] = "Claws",
    ["weapon_scp_689"] = "Stare",
    ["weapon_scp_682"] = "Bite",
    ["weapon_scp_035"] = "Possession",
    ["weapon_scp_999"] = "Unknown",
    ["weapon_br_zombie_infect"] = "Infection",
}

-- Function to create death card
local function CreateDeathCard(attacker, weaponClass, weaponName, damageDealt, damageReceived)
    -- Remove existing panel if any
    if IsValid(deathCardPanel) then
        deathCardPanel:Remove()
    end
    
    local scrW, scrH = ScrW(), ScrH()
    
    -- Main panel
    deathCardPanel = vgui.Create("DPanel")
    deathCardPanel:SetSize(400, 250)
    deathCardPanel:SetPos(scrW/2 - 200, scrH - 350) -- Positioned 350 pixels from bottom
    deathCardPanel:SetAlpha(0)
    deathCardPanel:AlphaTo(255, 0.3, 0)
    
    deathCardPanel.Paint = function(self, w, h)
        -- Background
        draw.RoundedBox(8, 0, 0, w, h, Color(20, 20, 20, 240))
        draw.RoundedBox(8, 2, 2, w-4, h-4, Color(30, 30, 30, 240))
        
        -- Header
        draw.RoundedBoxEx(8, 2, 2, w-4, 40, Color(50, 50, 50, 240), true, true, false, false)
        draw.SimpleText("KILLED BY", "DeathCardTitle", w/2, 20, Color(255, 100, 100), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    
    -- Avatar container
    local avatarContainer = vgui.Create("DPanel", deathCardPanel)
    avatarContainer:SetPos(10, 50)
    avatarContainer:SetSize(84, 84)
    avatarContainer.Paint = function(self, w, h)
        draw.RoundedBox(4, 0, 0, w, h, Color(60, 60, 60))
    end
    
    -- Avatar
    local avatar = vgui.Create("AvatarImage", avatarContainer)
    avatar:SetSize(80, 80)
    avatar:SetPos(2, 2)
    avatar:SetPlayer(attacker, 84)
    
    -- Player name
    local playerName = attacker:Nick()
    if #playerName > 25 then
        playerName = string.sub(playerName, 1, 22) .. "..."
    end
    
    -- Info panel
    local infoX = 110
    local infoY = 55
    
    -- Player name label
    local nameLabel = vgui.Create("DLabel", deathCardPanel)
    nameLabel:SetPos(infoX, infoY)
    nameLabel:SetSize(280, 25)
    nameLabel:SetText(playerName)
    nameLabel:SetFont("DeathCardBig")
    nameLabel:SetTextColor(Color(255, 255, 255))
    
    -- Role/class
    local roleText = "Unknown"
    if attacker.GetNClass then
        roleText = GetLangRole(attacker:GetNClass()) or "Unknown"
    end
    
    local roleLabel = vgui.Create("DLabel", deathCardPanel)
    roleLabel:SetPos(infoX, infoY + 25)
    roleLabel:SetSize(280, 20)
    roleLabel:SetText(roleText)
    roleLabel:SetFont("DeathCardNormal")
    
    -- Set role color
    local roleColor = Color(200, 200, 200)
    if attacker.GTeam then
        local team = attacker:GTeam()
        if team == TEAM_SCP then
            roleColor = Color(237, 28, 63)
        elseif team == TEAM_GUARD then
            roleColor = Color(0, 100, 255)
        elseif team == TEAM_CLASSD then
            roleColor = Color(255, 130, 0)
        elseif team == TEAM_SCI then
            roleColor = Color(66, 188, 244)
        elseif team == TEAM_CHAOS then
            roleColor = Color(29, 81, 56)
        elseif team == TEAM_GOC then
            roleColor = Color(150, 150, 150)
        end
    end
    roleLabel:SetTextColor(roleColor)
    
    -- Weapon used
    local wepName = weaponNames[weaponClass] or weaponName
    local weaponLabel = vgui.Create("DLabel", deathCardPanel)
    weaponLabel:SetPos(infoX, infoY + 50)
    weaponLabel:SetSize(280, 20)
    weaponLabel:SetText("Weapon: " .. wepName)
    weaponLabel:SetFont("DeathCardNormal")
    weaponLabel:SetTextColor(Color(200, 200, 200))
    
    -- Damage statistics
    local damageY = 160
    
    -- Damage dealt to killer
    local dealtLabel = vgui.Create("DLabel", deathCardPanel)
    dealtLabel:SetPos(20, damageY)
    dealtLabel:SetSize(180, 25)
    dealtLabel:SetText("Damage dealt to killer:")
    dealtLabel:SetFont("DeathCardNormal")
    dealtLabel:SetTextColor(Color(200, 200, 200))
    
    local dealtValue = vgui.Create("DLabel", deathCardPanel)
    dealtValue:SetPos(20, damageY + 20)
    dealtValue:SetSize(180, 30)
    dealtValue:SetText(tostring(damageDealt))
    dealtValue:SetFont("DeathCardTitle")
    dealtValue:SetTextColor(Color(100, 255, 100))
    
    -- Damage received from killer
    local receivedLabel = vgui.Create("DLabel", deathCardPanel)
    receivedLabel:SetPos(220, damageY)
    receivedLabel:SetSize(180, 25)
    receivedLabel:SetText("Damage received:")
    receivedLabel:SetFont("DeathCardNormal")
    receivedLabel:SetTextColor(Color(200, 200, 200))
    
    local receivedValue = vgui.Create("DLabel", deathCardPanel)
    receivedValue:SetPos(220, damageY + 20)
    receivedValue:SetSize(180, 30)
    receivedValue:SetText(tostring(damageReceived))
    receivedValue:SetFont("DeathCardTitle")
    receivedValue:SetTextColor(Color(255, 100, 100))
    
    -- Auto-remove after 8 seconds
    timer.Simple(8, function()
        if IsValid(deathCardPanel) then
            deathCardPanel:AlphaTo(0, 0.3, 0, function()
                if IsValid(deathCardPanel) then
                    deathCardPanel:Remove()
                end
            end)
        end
    end)
end

-- Receive death card info
net.Receive("BR_ShowDeathCard", function()
    local attacker = net.ReadEntity()
    local weaponClass = net.ReadString()
    local weaponName = net.ReadString()
    local damageDealt = net.ReadUInt(16)
    local damageReceived = net.ReadUInt(16)
    
    if IsValid(attacker) then
        CreateDeathCard(attacker, weaponClass, weaponName, damageDealt, damageReceived)
    end
end)

-- Remove death card on respawn
hook.Add("PlayerSpawn", "BR_RemoveDeathCard", function(ply)
    if ply == LocalPlayer() and IsValid(deathCardPanel) then
        deathCardPanel:Remove()
    end
end)


================================================
FILE: gamemodes/breach/gamemode/modules/cl_door_access_hud.lua
================================================
-- Client-side door access indicator system
local doorAccessData = {}

-- Materials for access indicators
local matCheck = Material("icon16/accept.png", "smooth")
local matX = Material("icon16/cancel.png", "smooth")

-- Test command to verify materials and drawing
concommand.Add("br_test_indicators", function()
    print("[DOOR ACCESS] Testing indicators...")
    print("  - Material Check valid: " .. tostring(matCheck and true or false))
    print("  - Material X valid: " .. tostring(matX and true or false))
    
    -- Draw test icons for 5 seconds
    local testTime = CurTime() + 5
    hook.Add("HUDPaint", "BR_TestIndicators", function()
        if CurTime() > testTime then
            hook.Remove("HUDPaint", "BR_TestIndicators")
            return
        end
        
        -- Draw test icons in center of screen
        surface.SetDrawColor(255, 255, 255, 255)
        
        surface.SetMaterial(matCheck)
        surface.DrawTexturedRect(ScrW()/2 - 64, ScrH()/2 - 32, 32, 32)
        
        surface.SetMaterial(matX)
        surface.DrawTexturedRect(ScrW()/2 + 32, ScrH()/2 - 32, 32, 32)
        
        draw.SimpleText("TEST INDICATORS (5s)", "Trebuchet24", ScrW()/2, ScrH()/2 + 32, Color(255,255,255), TEXT_ALIGN_CENTER)
    end)
end)

-- Receive door access data from server
net.Receive("BR_SyncDoorAccess", function()
    doorAccessData = net.ReadTable() or {}
    print("[DOOR ACCESS CLIENT] Received " .. table.Count(doorAccessData) .. " doors with access requirements")
    
    -- Debug: Print first few doors
    local count = 0
    for _, data in pairs(doorAccessData) do
        if type(data) == "table" and count < 3 then
            print("[DOOR ACCESS CLIENT] Door: " .. (data.name or "unknown") .. " at " .. tostring(data.pos) .. " with access: " .. (data.access or 0))
            count = count + 1
        end
    end
end)

-- Request door data from server when we're ready
local dataRequested = false
hook.Add("InitPostEntity", "BR_RequestDoorData", function()
    if not dataRequested then
        dataRequested = true
        timer.Simple(2, function()
            -- print("[DOOR ACCESS CLIENT] Requesting door data from server")
            net.Start("BR_RequestDoorAccess")
            net.SendToServer()
        end)
    end
end)

-- Also request when we spawn
hook.Add("LocalPlayerSpawn", "BR_RequestDoorDataSpawn", function()
    timer.Simple(1, function()
        if table.Count(doorAccessData) == 0 then
            -- print("[DOOR ACCESS CLIENT] No door data, requesting from server")
            net.Start("BR_RequestDoorAccess")
            net.SendToServer()
        end
    end)
end)

-- Request data if we don't have it after some time
timer.Simple(15, function()
    if table.Count(doorAccessData) == 0 then
        -- print("[DOOR ACCESS CLIENT] Still no door data, requesting from server")
        net.Start("BR_RequestDoorAccess")
        net.SendToServer()
    end
end)

-- Function to check if player has keycard access
local function CheckKeycardAccess(ply, requiredAccess)
    local wep = ply:GetActiveWeapon()
    if not IsValid(wep) or wep:GetClass() ~= "br_keycard" then
        return false
    end
    
    -- Check if keycard has the required access bits (use networked value)
    local keycardAccess = wep:GetNWInt("KeycardAccess", 0)
    return bit.band(keycardAccess, requiredAccess) > 0
end

-- Debug command to check door data
concommand.Add("br_debug_doors", function()
    print("[DOOR ACCESS DEBUG] Total doors stored: " .. table.Count(doorAccessData))
    
    local ply = LocalPlayer()
    if not IsValid(ply) then
        print("[DOOR ACCESS DEBUG] LocalPlayer not valid")
        return
    end
    
    local wep = ply:GetActiveWeapon()
    if not IsValid(wep) then
        print("[DOOR ACCESS DEBUG] No active weapon")
    elseif wep:GetClass() ~= "br_keycard" then
        print("[DOOR ACCESS DEBUG] Active weapon is not a keycard: " .. wep:GetClass())
    else
        local networkAccess = wep:GetNWInt("KeycardAccess", 0)
        local localAccess = wep.Access or 0
        
        -- Convert to binary string manually
        local function toBinary(num)
            local binary = ""
            local temp = num
            if temp == 0 then return "00000000000" end
            while temp > 0 do
                binary = (temp % 2) .. binary
                temp = math.floor(temp / 2)
            end
            -- Pad to 11 digits
            while string.len(binary) < 11 do
                binary = "0" .. binary
            end
            return binary
        end
        
        print("[DOOR ACCESS DEBUG] Keycard equipped:")
        print("  - Networked access level: " .. networkAccess .. " (binary: " .. toBinary(networkAccess) .. ")")
        print("  - Local access level: " .. localAccess)
        print("  - Keycard type: " .. (wep:GetNWString("K_TYPE", "unknown")))
    end
    
    print("[DOOR ACCESS DEBUG] br_door_indicators_3d = " .. GetConVar("br_door_indicators_3d"):GetInt())
    print("[DOOR ACCESS DEBUG] disablehud = " .. tostring(disablehud))
    
    -- List all doors
    for k, v in pairs(doorAccessData) do
        if type(v) == "table" then
            print(string.format("[DOOR ACCESS DEBUG] Door %s: %s at %s, access required: %d",
                k, v.name or "unknown", tostring(v.pos), v.access or 0))
        end
    end
end)

-- Find doors in the world and match them with our data
local function UpdateDoorEntities()
    if not doorAccessData or #doorAccessData == 0 then return end
    
    -- Find all func_door and func_door_rotating entities
    local doors = {}
    table.Add(doors, ents.FindByClass("func_door"))
    table.Add(doors, ents.FindByClass("func_door_rotating"))
    table.Add(doors, ents.FindByClass("prop_door_rotating"))
    table.Add(doors, ents.FindByClass("func_button"))
    
    -- Match doors with our access data based on position
    for _, door in pairs(doors) do
        local doorPos = door:GetPos()
        
        for _, accessData in pairs(doorAccessData) do
            -- Skip non-table entries
            if type(accessData) ~= "table" then continue end
            
            -- Check if positions match (with some tolerance)
            if doorPos:Distance(accessData.pos) < 50 then
                -- Store access data on the entity for quick lookup
                door.BR_AccessRequired = accessData.access
                door.BR_AccessName = accessData.name
                break
            end
        end
    end
end

-- Update door entities when we receive new data
hook.Add("Think", "BR_UpdateDoorEntities", function()
    if not doorAccessData._updated then
        doorAccessData._updated = true
        timer.Simple(0.5, UpdateDoorEntities)
    end
end)

-- Alternative method: Draw indicators on doors themselves in 3D space
hook.Add("PostDrawTranslucentRenderables", "BR_DoorAccess3D", function()
    local ply = LocalPlayer()
    if not IsValid(ply) or not ply:Alive() then return end
    
    -- Check if player has a keycard equipped
    local wep = ply:GetActiveWeapon()
    if not IsValid(wep) or wep:GetClass() ~= "br_keycard" then return end
    
    local eyePos = ply:EyePos()
    
    -- Draw 3D indicators for each door
    for _, doorData in pairs(doorAccessData) do
        -- Skip non-table entries
        if type(doorData) ~= "table" then continue end
        
        local doorPos = doorData.pos
        if not doorPos then continue end
        
        -- Calculate distance
        local dist = eyePos:Distance(doorPos)
        if dist > 400 then continue end
        
        -- Check access
        local hasAccess = CheckKeycardAccess(ply, doorData.access)
        
        -- Draw 3D2D panel
        local ang = (eyePos - doorPos):Angle()
        ang:RotateAroundAxis(ang:Up(), 90)
        ang:RotateAroundAxis(ang:Forward(), 90)
        
        cam.Start3D2D(doorPos + Vector(0, 0, 20), ang, 0.2)
            -- Draw background
            surface.SetDrawColor(0, 0, 0, 180)
            surface.DrawRect(-50, -50, 100, 100)
            
            -- Draw icon
            if hasAccess then
                surface.SetDrawColor(100, 255, 100, 255)
                surface.SetMaterial(matCheck)
            else
                surface.SetDrawColor(255, 100, 100, 255)
                surface.SetMaterial(matX)
            end
            surface.DrawTexturedRect(-32, -32, 64, 64)
        cam.End3D2D()
    end
end)

-- ConVar to toggle between 2D HUD and 3D world indicators
CreateClientConVar("br_door_indicators_3d", "0", true, false, "Toggle between 2D HUD (0) and 3D world (1) door access indicators")

-- ConVar to enable/disable door indicators
CreateClientConVar("breach_door_indicators_enabled", "1", true, false, "Enable/disable door access indicators")

-- Debug function
local debugEnabled = false
local function DebugPrint(msg)
    if debugEnabled then
        -- print("[DOOR ACCESS HUD] " .. msg)
    end
end

-- Removed br_door_debug_draw command

-- Remove duplicate hook and rename to avoid conflicts
hook.Remove("HUDPaint", "BR_DoorAccessIndicators")

-- Main HUDPaint hook for 2D indicators
hook.Add("HUDPaint", "BR_DoorAccessHUD", function()
    -- Check if indicators are enabled
    if not GetConVar("breach_door_indicators_enabled"):GetBool() then return end
    
    if GetConVar("br_door_indicators_3d"):GetBool() then return end
    
    if disablehud then return end
    
    local ply = LocalPlayer()
    if not IsValid(ply) or not ply:Alive() then return end
    
    -- Check if player has a keycard equipped
    local wep = ply:GetActiveWeapon()
    if not IsValid(wep) or wep:GetClass() ~= "br_keycard" then
        return
    end
    
    -- Debug: Check if we have data
    if table.Count(doorAccessData) == 0 then
        DebugPrint("No door access data available")
        return
    end
    
    -- Get player position and view direction
    local eyePos = ply:EyePos()
    local eyeAngles = ply:EyeAngles()
    local forward = eyeAngles:Forward()
    
    DebugPrint("Starting door drawing, total doors: " .. table.Count(doorAccessData))
    
    local doorsProcessed = 0
    local doorsInRange = 0
    local doorsInView = 0
    local doorsDrawn = 0
    
    -- Draw indicators for each door
    for _, doorData in pairs(doorAccessData) do
        -- Skip non-table entries (like _updated flag)
        if type(doorData) ~= "table" then continue end
        
        local doorPos = doorData.pos
        if not doorPos then continue end
        
        -- Calculate distance to door
        local dist = eyePos:Distance(doorPos)
        doorsProcessed = doorsProcessed + 1
        
        -- Only show indicators for nearby doors (within 500 units)
        if dist > 500 then
            DebugPrint("Door " .. (doorData.name or "unknown") .. " too far: " .. dist)
            continue
        end
        doorsInRange = doorsInRange + 1
        
        -- Check if door is in front of player
        local toTarget = (doorPos - eyePos):GetNormalized()
        local dot = forward:Dot(toTarget)
        
        -- Only show if door is in front of player (dot > 0.5 means within ~60 degree cone)
        if dot < 0.5 then
            DebugPrint("Door " .. (doorData.name or "unknown") .. " not in view cone: " .. dot)
            continue
        end
        doorsInView = doorsInView + 1
        
        -- Convert 3D position to 2D screen position
        local screenPos = doorPos:ToScreen()
        if not screenPos.visible then
            DebugPrint("Door " .. (doorData.name or "unknown") .. " not visible on screen")
            continue
        end
        doorsDrawn = doorsDrawn + 1
        
        -- Check if player has access
        local hasAccess = CheckKeycardAccess(ply, doorData.access)
        
        -- Calculate alpha based on distance (fade out as player gets further)
        local alpha = math.Clamp((500 - dist) / 500 * 255, 0, 255)
        
        -- Draw the appropriate icon
        surface.SetDrawColor(255, 255, 255, alpha)
        if hasAccess then
            surface.SetMaterial(matCheck)
        else
            surface.SetMaterial(matX)
        end
        
        -- Scale icon based on distance
        local iconSize = math.Clamp(32 * (500 - dist) / 500, 16, 32)
        surface.DrawTexturedRect(screenPos.x - iconSize/2, screenPos.y - iconSize/2, iconSize, iconSize)
        
        -- Draw door name below icon
        local font = "Trebuchet18"
        local textAlpha = math.Clamp(alpha - 50, 0, 255)
        
        if hasAccess then
            draw.SimpleTextOutlined(doorData.name, font, screenPos.x, screenPos.y + iconSize/2 + 5, 
                Color(100, 255, 100, textAlpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, Color(0, 0, 0, textAlpha))
        else
            draw.SimpleTextOutlined(doorData.name, font, screenPos.x, screenPos.y + iconSize/2 + 5, 
                Color(255, 100, 100, textAlpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, Color(0, 0, 0, textAlpha))
        end
    end
    
    if debugEnabled and doorsProcessed > 0 then
        DebugPrint("Doors processed: " .. doorsProcessed .. ", in range: " .. doorsInRange .. ", in view: " .. doorsInView .. ", drawn: " .. doorsDrawn)
    end
end)

-- Modified 3D hook to check ConVar
hook.Add("PostDrawTranslucentRenderables", "BR_DoorAccess3D", function()
    -- Check if indicators are enabled
    if not GetConVar("breach_door_indicators_enabled"):GetBool() then return end
    
    if not GetConVar("br_door_indicators_3d"):GetBool() then return end
    
    local ply = LocalPlayer()
    if not IsValid(ply) or not ply:Alive() then return end
    
    -- Check if player has a keycard equipped
    local wep = ply:GetActiveWeapon()
    if not IsValid(wep) or wep:GetClass() ~= "br_keycard" then return end
    
    local eyePos = ply:EyePos()
    
    -- Draw 3D indicators for each door
    for _, doorData in pairs(doorAccessData) do
        -- Skip non-table entries
        if type(doorData) ~= "table" then continue end
        
        local doorPos = doorData.pos
        if not doorPos then continue end
        
        -- Calculate distance
        local dist = eyePos:Distance(doorPos)
        if dist > 400 then continue end
        
        -- Check access
        local hasAccess = CheckKeycardAccess(ply, doorData.access)
        
        -- Draw 3D2D panel
        local ang = (eyePos - doorPos):Angle()
        ang:RotateAroundAxis(ang:Up(), 90)
        ang:RotateAroundAxis(ang:Forward(), 90)
        
        cam.Start3D2D(doorPos + Vector(0, 0, 20), ang, 0.2)
            -- Draw background
            surface.SetDrawColor(0, 0, 0, 180)
            surface.DrawRect(-50, -50, 100, 100)
            
            -- Draw icon
            if hasAccess then
                surface.SetDrawColor(100, 255, 100, 255)
                surface.SetMaterial(matCheck)
            else
                surface.SetDrawColor(255, 100, 100, 255)
                surface.SetMaterial(matX)
            end
            surface.DrawTexturedRect(-32, -32, 64, 64)
        cam.End3D2D()
    end
end)


================================================
FILE: gamemodes/breach/gamemode/modules/cl_eq.lua
================================================
EQHUD = {
	c_dim = ScrH() * 0.13,
	c_offset = ScrH() * 0.02,
	width = 4,
	height = 2,
	enabled = false,
	weps = {}
}

WEPS_ICONS = {
	weapon_class = "weapon1",
	cw_ar15 = "txt"
}

local buttonnext = true
local buttonnextframe = true

local function QuickButton( x, y, w, h, lclick, rclick )
	local mouseL = input.IsMouseDown( MOUSE_LEFT )
	local mouseR = input.IsMouseDown( MOUSE_RIGHT )
	if mouseL or mouseR then
		if buttonnext then
			buttonnextframe = false
			local posx, posy = input.GetCursorPos()
			if posx > x and posx < x + w then
				if posy > y and posy < y + h then
					if lclick and mouseL then
						lclick()
					elseif rclick and mouseR then
						rclick()
					end
					return true
				end
			end
		end
	else
		buttonnextframe = true
	end
end

local function QuickHover( x, y, w, h, hover )
	local posx, posy = input.GetCursorPos()
	if posx > x and posx < x + w then
		if posy > y and posy < y + h then
			if hover then
				hover()
			end
			return true
		end
	end
end

function DrawEQ()
	if !EQHUD.enabled then return end
	if !vgui.CursorVisible() then
		gui.EnableScreenClicker( true )
	end

	buttonnext = buttonnextframe

	local w, h = ScrW(), ScrH()
	local wi, hi = EQHUD.width * ( EQHUD.c_dim + EQHUD.c_offset ) + EQHUD.c_offset, EQHUD.height * ( EQHUD.c_dim + EQHUD.c_offset ) + EQHUD.c_offset + 32
	local sx, sy = w * 0.5 - wi * 0.5, h * 0.5 - hi * 0.5

	surface.SetDrawColor( Color( 10, 10, 10, 240 ) )
	surface.DrawRect( sx, sy, wi, hi )

	local w, h = ScrW(), ScrH()

	for i = 0, EQHUD.width * EQHUD.height - 1 do
		local x, y = sx + ( i % EQHUD.width + 1 ) * ( EQHUD.c_offset + EQHUD.c_dim ) - EQHUD.c_dim, sy + ( math.floor( i / EQHUD.width ) + 1 ) * ( EQHUD.c_offset + EQHUD.c_dim ) - EQHUD.c_dim
		surface.SetDrawColor( Color( 150, 150, 150, 230 ) )
		surface.DrawRect( x, y, EQHUD.c_dim, EQHUD.c_dim )
		surface.SetDrawColor( Color( 0, 0, 0, 245 ) )
		surface.DrawRect( x + 2, y + 2, EQHUD.c_dim - 4, EQHUD.c_dim - 4 )
		draw.Text( {
			text = clang.eq_tip,
			pos = { sx + EQHUD.c_offset, sy + hi - 32 },
			font = "173font",
			color = Color( 200, 200, 200 ),
			xalign = TEXT_ALIGN_LEFT,
			yalign = TEXT_ALIGN_TOP,
		} )
		if IsValid( EQHUD.weps[i + 1] ) then
			--print( EQHUD.weps[i + 1].WepSelectIcon )
			if EQHUD.weps[i + 1].IconLetter then
				local letter = EQHUD.weps[i + 1].IconLetter
				local usefont = EQHUD.weps[i + 1].SelectFont
				local mx = Matrix()
				mx:Scale( Vector( 0.75, 0.75, 1 ) )
				mx:Translate( Vector( x * 0.3333333, y * 0.3333333 ) )
				cam.PushModelMatrix( mx )
					draw.SimpleText( letter, usefont, x + EQHUD.c_dim / 2 * 1.25, y + EQHUD.c_dim / 2, Color(255, 210, 0 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
				cam.PopModelMatrix()
			else
				local ico = EQHUD.weps[i + 1].SelectIcon or EQHUD.weps[i + 1].WepSelectIcon or 0
				surface.SetTexture( ico )
				surface.SetDrawColor( Color( 255, 255, 255, 255 ) )
				surface.DrawTexturedRect( x + 2, y + EQHUD.c_dim / 4 + 2, EQHUD.c_dim - 4, EQHUD.c_dim / 2 - 4 )
			end
			QuickHover( x, y, EQHUD.c_dim, EQHUD.c_dim, function()
				local name = EQHUD.weps[i + 1].PrintName
				if !name or name == "" then
					name = EQHUD.weps[i + 1]:GetPrintName()
				end
				if !name or name == "" then
					name = EQHUD.weps[i + 1]:GetClass()
				end 
				DrawScreenTip( name, EQHUD.weps[i + 1] )
			end )
			QuickButton( x, y, EQHUD.c_dim, EQHUD.c_dim, function()
				LocalPlayer():SelectWeapon( EQHUD.weps[i + 1]:GetClass() )
			end, function()
				LocalPlayer():DropWeapon( EQHUD.weps[i + 1]:GetClass() )
				if EQHUD.weps[i + 1].droppable == nil or EQHUD.weps[i + 1].droppable then
					EQHUD.weps[i + 1] = nil
					timer.Simple( 0.5, function()
						EQHUD.weps = LocalPlayer():GetWeapons()
					end )
				end
			end )
		end
	end
end
hook.Add( "DrawOverlay", "DrawEQ", DrawEQ )

function ShowEQ()
	EQHUD.weps = LocalPlayer():GetWeapons()
	EQHUD.enabled = true
	gui.EnableScreenClicker( true )
end

function HideEQ()
	EQHUD.enabled = false
	gui.EnableScreenClicker( false )
end

function CanShowEQ()
	local t = LocalPlayer():GTeam()
	local adminmode = LocalPlayer():GetNClass() == ROLES.ADMIN
	local enabled = GetConVar( "br_new_eq" ):GetInt() == 1

	--return t != TEAM_SPEC and t != TEAM_SCP and enabled
	return ( t != TEAM_SPEC or adminmode ) and enabled
end

function IsEQVisible()
	return EQHUD.enabled
end

local screen_tip = {
	text = "",
	pos = { 0, 0 },
	time = 0
}

function DrawScreenTip( txt, wep )
	screen_tip.text = txt
	screen_tip.pos = { input.GetCursorPos() }
	screen_tip.time = CurTime() + 0.1
	screen_tip.wep = wep
end

function PaintScreenTip()
	if screen_tip.time < CurTime() then return end

	local txt = screen_tip.text
	if !txt then return end

	surface.SetFont( "173font" )
	local w, h = surface.GetTextSize( txt )

	surface.SetDrawColor( Color( 75, 75, 75, 225 ) )
	surface.DrawRect( screen_tip.pos[1] + 8, screen_tip.pos[2], w + 16, h + 8 )

	draw.Text( {
		text = txt,
		pos = { screen_tip.pos[1] + 16, screen_tip.pos[2] + 4 },
		font = "173font",
		color = Color( 200, 200, 200 ),
		xalign = TEXT_ALIGN_LEFT,
		yalign = TEXT_ALIGN_TOP,
	})
	if screen_tip.wep then
		DrawInfoBox( w, h )
	end
end
hook.Add( "DrawOverlay", "DrawScreenTip", PaintScreenTip )

function DrawInfoBox( w, h )
	local lang = screen_tip.wep.Lang

	local author, contact, purpose, instructions

	if lang then
		author = lang.author
		contact = lang.contact
		purpose = lang.purpose
		instructions = lang.instructions
	else
		author = screen_tip.wep.Author
		contact = screen_tip.wep.Contact
		purpose = screen_tip.wep.Purpose
		instructions = screen_tip.wep.Instructions
	end

	if !author and !contact and !purpose and !instructions then return end

	local texts = { author, contact, purpose, instructions }

	for k, v in pairs( texts ) do
		if v == "" then
			texts[k] = nil
		end
	end

	local tops = { "Author:", "Contact:", "Purpose:", "Instructions:" }

	local verts = {
		{ x = screen_tip.pos[1] + w + 24, y = screen_tip.pos[2] },
		{ x = screen_tip.pos[1] + w + 72, y = screen_tip.pos[2] + h + 8 },
		{ x = screen_tip.pos[1] + w + 24, y = screen_tip.pos[2] + h + 8 },
	}

	local maxwidth = math.max( ScrW() * 0.2, 300 )

	draw.NoTexture()
	surface.SetDrawColor( Color( 75, 75, 75, 225 ) )
	surface.DrawPoly( verts )

	local height = 0
	for i, v in ipairs( texts ) do
		local txts = string.Split( v, "\n" )
		local prevh = height

		for _, t in ipairs( txts ) do
			surface.SetFont( "173font" )
			local w, h = surface.GetTextSize( t )

			local ppl = w / string.len( t )
			--local segs = math.ceil( w / maxwidth )
			--local maxi = math.ceil( string.len( t ) / segs )
			local max = math.ceil( maxwidth / ppl )
			local subtx = {}
			local curtx = t

			local stack = 0
			repeat
				if string.len( curtx ) > max then
					for k = max, 0, -1 do
						if k == 0 then
							table.insert( subtx, curtx )
							curtx = ""
						elseif string.sub( curtx, k, k ) == " " then
							table.insert( subtx, string.sub( curtx, 0, k ) )
							curtx = string.sub( curtx, k + 1, string.len( curtx ) )
							break
						end
					end
				else
					table.insert( subtx, curtx )
					curtx = ""
				end
				stack = stack + 1
				if stack > 1000 then
					error( "Stackoverflow!" )
				end
			until curtx == ""

			surface.SetDrawColor( Color( 75, 75, 75, 225 ) )
			surface.DrawRect( screen_tip.pos[1] + 8, screen_tip.pos[2] + h + 8 + height, maxwidth + 16, h * #subtx + h + 16 )

			for pos, tx in ipairs( subtx ) do	
				draw.Text( {
					text = tx,
					pos = { screen_tip.pos[1] + 16, screen_tip.pos[2] + h * ( pos + 1 ) + 8 + height },
					font = "173font",
					color = Color( 200, 200, 200 ),
					xalign = TEXT_ALIGN_LEFT,
					yalign = TEXT_ALIGN_TOP,
				})
			end	
			height = height + h * ( #subtx + 1 ) + 16
		end	
		draw.Text( {
			text = tops[i],
			pos = { screen_tip.pos[1] + 16, screen_tip.pos[2] + h + 8 + prevh },
			font = "173font",
			color = Color( 200, 150, 200 ),
			xalign = TEXT_ALIGN_LEFT,
			yalign = TEXT_ALIGN_TOP,
		})
	end
end


================================================
FILE: gamemodes/breach/gamemode/modules/cl_font.lua
================================================
/*---------------------------------------------------------------------------
	
	Creator: TheCodingBeast - TheCodingBeast.com
	This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. 
	To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/
	
---------------------------------------------------------------------------*/

surface.CreateFont( "173font", {
	font = "TargetID",
	extended = false,
	size = 22,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = true,
	additive = false,
	outline = false,
} )

surface.CreateFont( "HUDFont", {
    font = "Bauhaus",    
	size = 16,
	weight = 100,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
})

surface.CreateFont( "HUDFontLittle", {
    font = "Bauhaus",    
	size = 19,
	weight = 100,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
})

surface.CreateFont( "HUDFontTitle", {
    font = "Bauhaus",    
	size = 25,
	weight = 100,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = true,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
})

surface.CreateFont( "HUDFontBig", {
    font = "Bauhaus",    
	size = 36,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
})

surface.CreateFont( "HUDFontMedium", {
    font = "Bauhaus",    
	size = 22,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
})

surface.CreateFont( "HUDFontMediumL", {
    font = "Bauhaus",    
	size = 22,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = true,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
})


================================================
FILE: gamemodes/breach/gamemode/modules/cl_fonts.lua
================================================

surface.CreateFont("ClassName", {font = "Trebuchet24",
                                    size = 28,
                                    weight = 1000})
surface.CreateFont("TimeLeft",     {font = "Trebuchet24",
                                    size = 24,
                                    weight = 800})
surface.CreateFont("HealthAmmo",   {font = "Trebuchet24",
                                    size = 24,
                                    weight = 750})



================================================
FILE: gamemodes/breach/gamemode/modules/cl_fps_ping_display.lua
================================================
-- FPS and Ping Display for Breach gamemode

-- ConVar for toggling the display
local showFPSPing = CreateClientConVar("breach_fps_ping_enabled", "1", true, false, "Show FPS and Ping display")

-- Variables for FPS calculation
local fps = 0
local lastUpdate = 0
local frameCount = 0

-- Hook for calculating FPS
hook.Add("Think", "BR_CalculateFPS", function()
    frameCount = frameCount + 1
    
    if CurTime() - lastUpdate >= 1 then
        fps = frameCount
        frameCount = 0
        lastUpdate = CurTime()
    end
end)

-- Hook for drawing FPS and Ping
hook.Add("HUDPaint", "BR_FPSPingDisplay", function()
    if not showFPSPing:GetBool() then return end
    
    local ply = LocalPlayer()
    if not IsValid(ply) then return end
    
    -- Position at top left
    local x = 10
    local y = 10
    
    -- Background
    draw.RoundedBox(6, x, y, 120, 50, Color(0, 0, 0, 200))
    
    -- FPS Display
    local fpsColor = fps >= 60 and Color(100, 255, 100) or 
                    fps >= 30 and Color(255, 255, 100) or 
                    Color(255, 100, 100)
    
    draw.SimpleText("FPS:", "DermaDefault", x + 10, y + 10, Color(200, 200, 200))
    draw.SimpleText(tostring(fps), "DermaDefaultBold", x + 100, y + 10, fpsColor, TEXT_ALIGN_RIGHT)
    
    -- Ping Display
    local ping = ply:Ping()
    local pingColor = ping <= 50 and Color(100, 255, 100) or 
                     ping <= 100 and Color(255, 255, 100) or 
                     Color(255, 100, 100)
    
    draw.SimpleText("Ping:", "DermaDefault", x + 10, y + 28, Color(200, 200, 200))
    draw.SimpleText(ping .. " ms", "DermaDefaultBold", x + 100, y + 28, pingColor, TEXT_ALIGN_RIGHT)
end)

-- Console command to toggle
concommand.Add("breach_toggle_fps_ping", function()
    local current = showFPSPing:GetBool()
    showFPSPing:SetBool(not current)
    
    if showFPSPing:GetBool() then
        print("FPS/Ping display enabled")
    else
        print("FPS/Ping display disabled")
    end
end)


================================================
FILE: gamemodes/breach/gamemode/modules/cl_headbob.lua
================================================
local HBAP = 0
local HBAY = 0
local HBAR = 0
local HBPX = 0
local HBPY = 0
local HBPZ = 0
local HBEnabled = true

function HeadBob(pl, pos, ang, fov)
	if HBEnabled == false then return end
	local view = {}
	view.pos = pos
	view.ang = ang
	view.fov = fov
	
	local speedmul = (pl:GetVelocity():Length() / 100) / 3
	//print(speedmul)
	//chat.AddText(tostring(speedmul))
	
	if pl:IsOnGround() && HBEnabled  then
		
		if pl:KeyDown(IN_FORWARD) || pl:KeyDown(IN_BACK) || pl:KeyDown(IN_MOVELEFT) || pl:KeyDown(IN_MOVERIGHT) then
			HBPZ = HBPZ + (10 / 1) * FrameTime()
		end
	
		if pl:KeyDown(IN_FORWARD) then
			if HBAP < 1.5 then
				HBAP = HBAP + 0.05 * speedmul
			end
		else
			if HBAP > 0 then
				HBAP = HBAP - 0.05 * speedmul
			end
		end
		
		if pl:KeyDown(IN_BACK) then
			if HBAP > -1.5 then
				HBAP = HBAP - 0.05 * speedmul
			end
		else
			if HBAP < 0 then
				HBAP = HBAP + 0.05 * speedmul
			end
		end
		
		if pl:KeyDown(IN_MOVELEFT) then
			if HBAR > -1.5 then
				HBAR = HBAR - 0.07 * speedmul
			end
		else
			if HBAR < 0 then
				HBAR = HBAR + 0.07 * speedmul
			end
		end
		
		if pl:KeyDown(IN_MOVERIGHT) then
			if HBAR < 1.5 then
				HBAR = HBAR + 0.07 * speedmul
			end
		else
			if HBAR > 0 then
				HBAR = HBAR - 0.07 * speedmul
			end
		end
	end
	
	//if !pl:GetActiveWeapon():GetNWBool("Ironsights") then
		pl.OLDANG = view.ang
		pl.OLDPOS = view.pos
		view.ang.pitch = view.ang.pitch + HBAP * speedmul
		view.ang.roll = view.ang.roll + HBAR * 0.8 * speedmul
		view.pos.z = view.pos.z - math.cos(HBPZ * 0.7)
	//end
	
	return GAMEMODE:CalcView(pl, view.pos, view.ang, view.fov)
end
hook.Add("CalcView", "HeadBobbing", HeadBob)

function ToggleHB(ply)
	if HBEnabled == false then
		print("Head Bobbing enabled")
		HBEnabled = true
	else
		print("Head Bobbing disabled")
		HBEnabled = false
	end
end
concommand.Add("br_headbobbing",ToggleHB)






================================================
FILE: gamemodes/breach/gamemode/modules/cl_hud.lua
================================================
local hide = {
	CHudHealth = true,
	CHudBattery = true,
	CHudAmmo = true,
	CHudSecondaryAmmo = true,
	//CHudWeaponSelection = true,
	CHudDeathNotice = true
	//CHudWeapon = true
}

surface.CreateFont("ImpactBig", {font = "Impact",
                                  size = 45,
                                  weight = 700})
surface.CreateFont("ImpactSmall", {font = "Impact",
                                  size = 30,
                                  weight = 700})

surface.CreateFont( "RadioFont", {
	font = "Impact",
	extended = false,
	size = 26,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

-- Additional fonts for classic HUD
surface.CreateFont( "ClassName", {
	font = "Impact",
	extended = false,
	size = 20,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "TimeLeft", {
	font = "Impact",
	extended = false,
	size = 18,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "HealthAmmo", {
	font = "Impact",
	extended = false,
	size = 16,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

-- Font for tips
surface.CreateFont( "TipFont", {
	font = "Impact",
	extended = false,
	size = 20,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

-- Tips system
local tips = {
	"TIP: Remember to blink regularly when playing as human classes to avoid SCP-173!",
	-- Add more tips here later
}

local currentTip = 1
local tipX = ScrW()
local tipSpeed = 80 -- pixels per second (will be recalculated dynamically)
local tipShowTime = 0
local tipInterval = 120 -- 2 minutes between tips
local tipDuration = 10 -- Show tip for 10 seconds
local tipFadeStart = 0 -- When fade animation starts
local tipFading = false -- Whether tip is fading
local tipsEnabled = CreateClientConVar("breach_tips_enabled", "1", true, false, "Enable/disable tips display")

-- Initialize tip timer
timer.Create("ShowTips", tipInterval, 0, function()
	if !tipsEnabled:GetBool() then return end
	tipShowTime = CurTime() + tipDuration
	tipFadeStart = CurTime() + (tipDuration - 2) -- Start fade 2 seconds before end
	tipX = ScrW() -- Reset position to right side
	tipFading = false
	currentTip = math.random(1, #tips)
end)

-- Show first tip after 30 seconds
timer.Simple(30, function()
	if !tipsEnabled:GetBool() then return end
	tipShowTime = CurTime() + tipDuration
	tipFadeStart = CurTime() + (tipDuration - 2) -- Start fade 2 seconds before end
	tipX = ScrW()
	tipFading = false
	currentTip = 1
end)

function GM:DrawDeathNotice( x,  y )
end

hook.Add( "HUDShouldDraw", "HideHUD", function( name )
	if ( hide[ name ] ) then return false end
end )
timer.Simple( 0, function()
	endmessages = {
		{
			main = clang.lang_end1,
			txt = clang.lang_end2,
			clr = gteams.GetColor(TEAM_SCP)
		},
		{
			main = clang.lang_end1,
			txt = clang.lang_end3,
			clr = gteams.GetColor(TEAM_SCP)
		}
	}
end )

function DrawInfo(pos, txt, clr)
	pos = pos:ToScreen()
	draw.TextShadow( {
		text = txt,
		pos = { pos.x, pos.y },
		font = "DermaDefaultBold",
		color = clr,
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_CENTER,
	}, 2, 255 )
end

hook.Add( "Tick", "966check", function()
	local hide = true
	if LocalPlayer().GTeam == nil then return end
	if LocalPlayer():GTeam() == TEAM_SCP then
		hide = false
	end
	-- Use new NVG toggle system
	if LocalPlayer().NVGActive then
			hide = false
	end
	if LocalPlayer().n420endtime and LocalPlayer().n420endtime > CurTime() then
		hide = false
	end
	for k,v in pairs(player.GetAll()) do
		if not v.GetNClass then
			player_manager.RunClass( v, "SetupDataTables" )
		end
		if v.GetNClass == nil then return end
		if v:GetNClass() == ROLES.ROLE_SCP966 then
			v:SetNoDraw(hide)
		end
	end
end )

SCPMarkers = {}

local info1 = Material( "breach/info_mtf.png")
hook.Add( "HUDPaint", "Breach_DrawHUD", function()
	-- Check if classic HUD is enabled
	local hudVar = GetConVar("br_hud")
	if !hudVar or hudVar:GetInt() != 2 then return end
	
	for i, v in ipairs( SCPMarkers ) do
		local scr = v.data.pos:ToScreen()

		if scr.visible then
			surface.SetDrawColor( Color( 255, 100, 100, 200 ) )
			//surface.DrawRect( scr.x - 5, scr.y - 5, 10, 10 )
			surface.DrawPoly( {
				{ x = scr.x, y = scr.y - 10 },
				{ x = scr.x + 5, y = scr.y },
				{ x = scr.x, y = scr.y + 10 },
				{ x = scr.x - 5, y = scr.y },
			} )

			draw.Text( {
				text = v.data.name,
				font = "HUDFont",
				color = Color( 255, 100, 100, 200 ),
				pos = { scr.x, scr.y + 10 },
				xalign = TEXT_ALIGN_CENTER,
				yalign = TEXT_ALIGN_TOP,
			} )

			draw.Text( {
				text = math.Round( v.data.pos:Distance( LocalPlayer():GetPos() ) * 0.019 ) .. "m",
				font = "HUDFont",
				color = Color( 255, 100, 100, 200 ),
				pos = { scr.x, scr.y + 25 },
				xalign = TEXT_ALIGN_CENTER,
				yalign = TEXT_ALIGN_TOP,
			} )
		end

		if v.time < CurTime() then
			table.remove( SCPMarkers, i )
		end
	end

	if disablehud then return end
	//cam.Start3D()
	//	for id, ply in pairs( player.GetAll() ) do
	//		if ply:GetNClass() == ROLES.ROLE_SCP966 then
	//			ply:DrawModel()
	//		end
	//	end
	//cam.End3D()
	/*if disablehud == true then return end
	if POS_914B_BUTTON != nil and isstring(buttonstatus) then
		if LocalPlayer():GetPos():Distance(POS_914B_BUTTON) < 200 then
			DrawInfo(POS_914B_BUTTON, buttonstatus, Color(255,255,255))
		end
	end*/
	
	/*
	for k,v in pairs(SPAWN_ARMORS) do
		DrawInfo(v, "Armor", Color(255,255,255))
	end
	
	for k,v in pairs(SPAWN_FIREPROOFARMOR) do
		DrawInfo(v, "FArmor", Color(255,255,255))
	end
	
	
	if BUTTONS != nil then
		for k,v in pairs(BUTTONS) do
			DrawInfo(v.pos, v.name, Color(0,255,50))
		end
		
		
		for k,v in pairs(SPAWN_KEYCARD2) do
			for _,v2 in pairs(v) do
				DrawInfo(v2, "Keycard2", Color(255,255,0))
			end
		end
		for k,v in pairs(SPAWN_KEYCARD3) do
			for _,v2 in pairs(v) do
				DrawInfo(v2, "Keycard3", Color(255,120,0))
			end
		end
		for k,v in pairs(SPAWN_KEYCARD4) do
			for _,v2 in pairs(v) do
				DrawInfo(v2, "Keycard4", Color(255,0,0))
			end
		end
		
		
		for k,v in pairs(SPAWN_SMGS) do
			DrawInfo(v, "SMG", Color(255,255,255))
		end
		for k,v in pairs(SPAWN_RIFLES) do
			DrawInfo(v, "RIFLE", Color(0,255,255))
		end
		
	end
	*/
	/*
	if #player.GetAll() < MINPLAYERS then
		draw.TextShadow( {
			text = "Not enough players to start the round",
			pos = { ScrW() / 2, ScrH() / 15 },
			font = "ImpactBig",
			color = Color(255,255,255),
			xalign = TEXT_ALIGN_CENTER,
			yalign = TEXT_ALIGN_CENTER,
		}, 2, 255 )
		draw.TextShadow( {
			text = "Waiting for more players to join the server",
			pos = { ScrW() / 2, ScrH() / 15 + 45 },
			font = "ImpactSmall",
			color = Color(255,255,255),
			xalign = TEXT_ALIGN_CENTER,
			yalign = TEXT_ALIGN_CENTER,
		}, 2, 255 )
		return
	
	elseif gamestarted == false then
		draw.TextShadow( {
			text = "Game is starting",
			pos = { ScrW() / 2, ScrH() / 15 },
			font = "ImpactBig",
			color = Color(255,128,70),
			xalign = TEXT_ALIGN_CENTER,
			yalign = TEXT_ALIGN_CENTER,
		}, 2, 255 )
		draw.TextShadow( {
			text = "Wait for the round to start",
			pos = { ScrW() / 2, ScrH() / 15 + 45 },
			font = "ImpactSmall",
			color = Color(255,255,255),
			xalign = TEXT_ALIGN_CENTER,
			yalign = TEXT_ALIGN_CENTER,
		}, 2, 255 )
		return
	end
	*/
	/*if OMEGA_DETONATION then
		local dist = LocalPlayer():GetPos():DistToSqr( OMEGA_DETONATION )
		if dist < 90000 and dist > 5625 then
			DrawInfo( OMEGA_DETONATION + Vector( 0, 0, -5 ), "Remote OMEGA Warhead detonation", Color( 255, 255, 255 ) )
		end
	end*/

	-- New HUD 2 implementation based on provided design
	local ply = LocalPlayer()
	
	-- Show time even when dead or spectating
	if ply:Alive() == false or ply:GTeam() == TEAM_SPEC then
		-- Display time for dead/spectating players
		local margin = 20
		local barWidth = 250
		local barHeight = 35
		
		local x = margin
		local y = ScrH() - margin - (barHeight * 3) -- Same position as when alive
		
		-- Time display bar with dark background
		draw.RoundedBox(0, x, y, barWidth, barHeight, Color(50, 50, 50, 255))
		draw.TextShadow( {
			text = "SPECTATING",
			pos = { x + 10, y + barHeight / 2 },
			font = "ImpactSmall",
			color = Color(200, 200, 200),
			xalign = TEXT_ALIGN_LEFT,
			yalign = TEXT_ALIGN_CENTER,
		}, 2, 255 )
		
		-- Time display outside the bar
		draw.TextShadow( {
			text = tostring(string.ToMinutesSeconds( cltime )),
			pos = { x + barWidth + 15, y + barHeight / 2 },
			font = "ImpactSmall",
			color = Color(255,255,255),
			xalign = TEXT_ALIGN_LEFT,
			yalign = TEXT_ALIGN_CENTER,
		}, 2, 255 )
		
		-- Show observed player info if spectating someone
		local ent = ply:GetObserverTarget()
		if IsValid(ent) and ent:IsPlayer() and ply:GTeam() == TEAM_SPEC then
			local sw = 300
			local sh = 50
			local sx = ScrW() / 2 - (sw / 2)
			local sy = 20
			
			-- Dark background bar
			draw.RoundedBox(0, sx, sy, sw, sh, Color(60, 60, 60, 255))
			
			-- Player name
			draw.TextShadow( {
				text = string.upper(string.sub(ent:Nick(), 1, 15)),
				pos = { sx + sw / 2, sy + 15 },
				font = "ImpactSmall",
				color = Color(255,255,255),
				xalign = TEXT_ALIGN_CENTER,
				yalign = TEXT_ALIGN_CENTER,
			}, 2, 255 )
			
			-- Health info
			local hp = ent:Health()
			local maxhp = ent:GetMaxHealth()
			draw.TextShadow( {
				text = "HP: " .. hp .. "/" .. maxhp,
				pos = { sx + sw / 2, sy + 35 },
				font = "ImpactSmall",
				color = Color(255, 100, 100),
				xalign = TEXT_ALIGN_CENTER,
				yalign = TEXT_ALIGN_CENTER,
			}, 2, 255 )
		end
		
		return
	end
	
	
	-- Get player info
	local name = "None"
	if not ply.GetNClass then
		player_manager.RunClass( ply, "SetupDataTables" )
	elseif LocalPlayer():GTeam() != TEAM_SPEC then
		name = GetLangRole(ply:GetNClass())
		if ply:GTeam() == TEAM_CHAOS and ply:GetNClass() != ROLES.ROLE_CHAOSSPY and ply:GetNClass() != ROLES.ROLE_CIC then
			name = GetLangRole(ROLES.ROLE_CHAOS)
		end
	end
	
	-- Get team color
	local color = gteams.GetColor( ply:GTeam() )
	if ply:GTeam() == TEAM_CHAOS then
		color = Color(29, 81, 56)
	end
	
	-- HUD positioning - bottom left corner
	local margin = 20
	local barWidth = 250
	local barHeight = 35
	local spacing = 5
	
	local x = margin
	local y = ScrH() - margin - (barHeight * 3) - (spacing * 2) -- Calculate from bottom, accounting for 3 bars
	
	-- Class/Role bar
	draw.RoundedBox(0, x, y, barWidth, barHeight, color)
	draw.TextShadow( {
		text = string.upper(name or "Unknown"),
		pos = { x + 10, y + barHeight / 2 },
		font = "ImpactSmall",
		color = Color(255,255,255),
		xalign = TEXT_ALIGN_LEFT,
		yalign = TEXT_ALIGN_CENTER,
	}, 2, 255 )
	
	-- Time display outside the bar, to the right
	draw.TextShadow( {
		text = tostring(string.ToMinutesSeconds( cltime )),
		pos = { x + barWidth + 15, y + barHeight / 2 },
		font = "ImpactSmall",
		color = Color(255,255,255),
		xalign = TEXT_ALIGN_LEFT,
		yalign = TEXT_ALIGN_CENTER,
	}, 2, 255 )
	
	-- Health bar
	y = y + barHeight + spacing
	local health = ply:Health()
	local maxHealth = ply:GetMaxHealth()
	local healthPercent = math.Clamp(health / maxHealth, 0, 1)
	
	-- Background (dark red)
	draw.RoundedBox(0, x, y, barWidth, barHeight, Color(100, 25, 25, 255))
	-- Health fill (bright red, width based on health percentage)
	draw.RoundedBox(0, x, y, barWidth * healthPercent, barHeight, Color(200, 50, 50, 255))
	
	draw.TextShadow( {
		text = tostring(health),
		pos = { x + 10, y + barHeight / 2 },
		font = "ImpactSmall",
		color = Color(255,255,255),
		xalign = TEXT_ALIGN_LEFT,
		yalign = TEXT_ALIGN_CENTER,
	}, 2, 255 )
	
	-- Ammo bar (only if player has weapon)
	local wep = ply:GetActiveWeapon()
	if IsValid(wep) and wep.Clip1 and wep:Clip1() > -1 then
		y = y + barHeight + spacing
		local ammo1 = wep:Clip1()
		local ammo2 = ply:GetAmmoCount( wep:GetPrimaryAmmoType() )
		local ammotext = ammo1 .. " + " .. ammo2
		
		-- Calculate ammo percentage based on current clip vs max clip
		local ammoPercent = 1
		if wep:GetMaxClip1() > 0 then
			ammoPercent = math.Clamp(ammo1 / wep:GetMaxClip1(), 0, 1)
		end
		
		-- Background (dark orange/yellow)
		draw.RoundedBox(0, x, y, barWidth, barHeight, Color(100, 75, 25, 255))
		-- Ammo fill (bright orange/yellow, width based on ammo percentage)
		draw.RoundedBox(0, x, y, barWidth * ammoPercent, barHeight, Color(200, 150, 50, 255))
		
		draw.TextShadow( {
			text = ammotext,
			pos = { x + 10, y + barHeight / 2 },
			font = "ImpactSmall",
			color = Color(255,255,255),
			xalign = TEXT_ALIGN_LEFT,
			yalign = TEXT_ALIGN_CENTER,
		}, 2, 255 )
	end
end )

-- Start info messages - displayed regardless of HUD type
hook.Add( "HUDPaint", "Breach_StartMessages", function()
	if shoulddrawinfo == true then
		local getrl = LocalPlayer():GetNClass()
		for k,v in pairs(ROLES) do
			if v == getrl then
				getrl = k
				break
			end
		end
		for k,v in pairs(clang.starttexts) do
			if k == getrl then
				getrl = v
				break
			end
		end
		local align = 32
		local tcolor = gteams.GetColor(LocalPlayer():GTeam())
		if LocalPlayer():GTeam() == TEAM_CHAOS then
			tcolor = Color(29, 81, 56)
		end
		
		if getrl[1] then
			draw.TextShadow( {
				text = getrl[1],
				pos = { ScrW() / 2, ScrH() / 15 },
				font = "ImpactBig",
				color = tcolor,
				xalign = TEXT_ALIGN_CENTER,
				yalign = TEXT_ALIGN_CENTER,
			}, 2, 255 )
		end
		if type( getrl[2] ) == "table" then
			for i,txt in ipairs(getrl[2]) do
				draw.TextShadow( {
					text = txt,
					pos = { ScrW() / 2, ScrH() / 15 + 10 + (align * i) },
					font = "ImpactSmall",
					color = Color(255,255,255),
					xalign = TEXT_ALIGN_CENTER,
					yalign = TEXT_ALIGN_CENTER,
				}, 2, 255 )
			end
		end
		-- Moved round type display to top right corner - only show during preparing phase
		if roundtype != nil and preparing == true then
			draw.TextShadow( {
				text = string.Replace( clang.roundtype,  "{type}", roundtype ),
				pos = { ScrW() - 20, 20 },
				font = "ImpactSmall",
				color = Color(255, 130, 0),
				xalign = TEXT_ALIGN_RIGHT,
				yalign = TEXT_ALIGN_TOP,
			}, 2, 255 )
			if roundtype != "Containment Breach" then
				draw.TextShadow( {
					text = clang.specialround,
					pos = { ScrW() - 20, 50 },
					font = "ImpactSmall",
					color = Color(255, 255, 255),
					xalign = TEXT_ALIGN_RIGHT,
					yalign = TEXT_ALIGN_TOP,
				}, 2, 255 )
			end
		end
	end
end )

-- SCP-239 Global Health Bar - displayed for all players when SCP-239 is alive
hook.Add( "HUDPaint", "Breach_SCP239_HealthBar", function()
	if disablehud then return end
	
	-- Find SCP-239 player
	local scp239 = nil
	for _, ply in pairs(player.GetAll()) do
		if IsValid(ply) and ply:Alive() and ply.GetNClass and ply:GetNClass() == ROLES.ROLE_SCP239 then
			scp239 = ply
			break
		end
	end
	
	if not scp239 then return end
	
	-- Get SCP-239's vulnerability status
	local wep = scp239:GetActiveWeapon()
	local isVulnerable = scp239:GetNWBool("SCP239_Vulnerable", false)
	local vulnerabilityTime = 0
	
	if IsValid(wep) and wep:GetClass() == "weapon_scp_239" then
		vulnerabilityTime = wep:GetNWFloat("SCP239_VulnerabilityTime", 0)
	end
	
	-- Health bar dimensions and position (top center of screen)
	local barWidth = 400
	local barHeight = 30
	local x = ScrW() / 2 - barWidth / 2
	local y = 10
	
	-- Background
	draw.RoundedBox(8, x - 5, y - 5, barWidth + 10, barHeight + 50, Color(0, 0, 0, 200))
	
	-- Title
	local titleColor = isVulnerable and Color(255, 100, 100) or Color(255, 150, 255)
	draw.TextShadow( {
		text = "SCP-239",
		pos = { ScrW() / 2, y + 8 },
		font = "ImpactSmall",
		color = titleColor,
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_CENTER,
	}, 2, 255 )
	
	-- Health bar
	local hp = scp239:Health()
	local maxhp = scp239:GetMaxHealth()
	local healthPercent = math.Clamp(hp / maxhp, 0, 1)
	
	local healthBarY = y + 18
	
	-- Health bar background
	draw.RoundedBox(4, x, healthBarY, barWidth, 12, Color(60, 60, 60, 255))
	
	-- Health bar fill
	local healthColor = isVulnerable and Color(255, 100, 100) or Color(255, 150, 255)
	draw.RoundedBox(4, x + 1, healthBarY + 1, (barWidth - 2) * healthPercent, 10, healthColor)
	
	-- Health text
	draw.TextShadow( {
		text = hp .. "/" .. maxhp .. " HP",
		pos = { x + barWidth / 2, healthBarY + 6 },
		font = "HealthAmmo",
		color = Color(255, 255, 255),
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_CENTER,
	}, 1, 200 )
	
	-- Vulnerability status
	local statusText = ""
	local statusColor = Color(255, 255, 255)
	
	if isVulnerable then
		local timeLeft = math.max(0, vulnerabilityTime - CurTime())
		statusText = string.format("VULNERABLE - %.1fs", timeLeft)
		statusColor = Color(255, 100, 100)
	else
		statusText = "IMMORTAL"
		statusColor = Color(100, 255, 100)
	end
	
	draw.TextShadow( {
		text = statusText,
		pos = { ScrW() / 2, y + 40 },
		font = "HealthAmmo",
		color = statusColor,
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_CENTER,
	}, 1, 200 )
end )

-- End messages and escape messages - displayed regardless of HUD type
hook.Add( "HUDPaint", "Breach_EndMessages", function()
	if isnumber(drawendmsg) then
		local ndtext = clang.lang_end2
		if drawendmsg == 2 then
			ndtext = clang.lang_end3
		end
		shoulddrawinfo = false
		draw.TextShadow( {
			text = clang.lang_end1,
			pos = { ScrW() / 2, ScrH() / 15 },
			font = "ImpactBig",
			color = Color(0,255,0),
			xalign = TEXT_ALIGN_CENTER,
			yalign = TEXT_ALIGN_CENTER,
		}, 2, 255 )
		draw.TextShadow( {
			text = ndtext,
			pos = { ScrW() / 2, ScrH() / 15 + 45 },
			font = "ImpactSmall",
			color = Color(255,255,255),
			xalign = TEXT_ALIGN_CENTER,
			yalign = TEXT_ALIGN_CENTER,
		}, 2, 255 )
		for i,txt in ipairs(endinformation) do
			draw.TextShadow( {
				text = txt,
				pos = { ScrW() / 2, ScrH() / 8 + (35 * i)},
				font = "ImpactSmall",
				color = color_white,
				xalign = TEXT_ALIGN_CENTER,
				yalign = TEXT_ALIGN_CENTER,
			}, 2, 255 )
		end
	else
		if isnumber(shoulddrawescape) then
			if CurTime() > lastescapegot then
				shoulddrawescape = nil
			end
			if clang.escapemessages[shoulddrawescape] then
				local tab = clang.escapemessages[shoulddrawescape]
				draw.TextShadow( {
					text = tab.main,
					pos = { ScrW() / 2, ScrH() / 15 },
					font = "ImpactBig",
					color = tab.clr,
					xalign = TEXT_ALIGN_CENTER,
					yalign = TEXT_ALIGN_CENTER,
				}, 2, 255 )
				draw.TextShadow( {
					text = string.Replace( tab.txt, "{t}", string.ToMinutesSecondsMilliseconds(esctime) ),
					pos = { ScrW() / 2, ScrH() / 15 + 45 },
					font = "ImpactSmall",
					color = Color(255,255,255),
					xalign = TEXT_ALIGN_CENTER,
					yalign = TEXT_ALIGN_CENTER,
				}, 2, 255 )
				draw.TextShadow( {
					text = tab.txt2,
					pos = { ScrW() / 2, ScrH() / 15 + 75 },
					font = "ImpactSmall",
					color = Color(255,255,255),
					xalign = TEXT_ALIGN_CENTER,
					yalign = TEXT_ALIGN_CENTER,
				}, 2, 255 )
			end
		end
	end
end )

net.Receive( "ShowText", function( len )
	local com = net.ReadString()
	if com == "vote_fail" then
		LocalPlayer():PrintMessage( HUD_PRINTTALK, clang.votefail )
	elseif	com == "text_punish" then
		local name = net.ReadString()
		LocalPlayer():PrintMessage( HUD_PRINTTALK, string.format( clang.votepunish, name ) )
		LocalPlayer():PrintMessage( HUD_PRINTTALK, clang.voterules )
	elseif	com == "text_punish_end" then
		local data = net.ReadTable()
		local result
		if data.punish then 
			result = clang.punish
		else 
			result = clang.forgive
		end
		local vp, vf = data.punishvotes, data.forgivevotes
		//print( vp, vf )
		LocalPlayer():PrintMessage( HUD_PRINTTALK, string.format( clang.voteresult, data.punished, result ) )
		LocalPlayer():PrintMessage( HUD_PRINTTALK, string.format( clang.votes, vp + vf, vp, vf ) )
	elseif com == "text_punish_cancel" then
		LocalPlayer():PrintMessage( HUD_PRINTTALK, clang.votecancel )
	end
end)

-- Tips display system
hook.Add( "HUDPaint", "Breach_Tips", function()
	-- Don't show tips during certain states or if disabled
	if disablehud or shoulddrawinfo or drawendmsg or shoulddrawescape or !tipsEnabled:GetBool() then return end
	
	-- Check if we should show a tip
	if tipShowTime > CurTime() and tips[currentTip] then
		local tipText = tips[currentTip]
		local tipHeight = 30
		local tipY = 0
		
		-- Calculate fade alpha
		local alpha = 200
		if CurTime() > tipFadeStart then
			-- Fade out effect
			local fadeProgress = (CurTime() - tipFadeStart) / 2 -- 2 seconds fade
			alpha = math.max(0, 200 * (1 - fadeProgress))
			tipFading = true
		elseif CurTime() < tipFadeStart - tipDuration + 2 then
			-- Fade in effect (first 2 seconds)
			local fadeInProgress = (CurTime() - (tipShowTime - tipDuration)) / 2
			alpha = math.min(200, 200 * fadeInProgress)
		end
		
		-- Dark semi-transparent background bar with fade
		surface.SetDrawColor(0, 0, 0, alpha)
		surface.DrawRect(0, tipY, ScrW(), tipHeight)
		
		-- Calculate text width
		surface.SetFont("TipFont")
		local textWidth = surface.GetTextSize(tipText)
		
		-- Calculate dynamic speed to complete scroll in 10 seconds
		-- Distance to travel: screen width + text width (from right edge to completely off left edge)
		local totalDistance = ScrW() + textWidth
		local dynamicSpeed = totalDistance / tipDuration
		
		-- Update tip position (scroll left)
		tipX = tipX - (dynamicSpeed * FrameTime())
		
		-- Reset position when text goes off screen (shouldn't happen with 10 second duration)
		if tipX + textWidth < 0 then
			tipX = ScrW()
		end
		
		-- Draw the tip text with fade
		local textAlpha = alpha + 55 -- Text slightly more visible than background
		draw.TextShadow( {
			text = tipText,
			pos = { tipX, tipY + tipHeight / 2 },
			font = "TipFont",
			color = Color(255, 200, 0, textAlpha), -- Yellow/gold color with alpha
			xalign = TEXT_ALIGN_LEFT,
			yalign = TEXT_ALIGN_CENTER,
		}, 1, textAlpha )
	end
end )


================================================
FILE: gamemodes/breach/gamemode/modules/cl_hud_custom.lua
================================================
-- Custom HUD for br_hud 3
-- Modern minimalist design

local hide = {
	CHudHealth = true,
	CHudBattery = true,
	CHudAmmo = true,
	CHudSecondaryAmmo = true,
	CHudDeathNotice = true,
}

hook.Add( "HUDShouldDraw", "HideHUDElements_Custom", function( name )
	-- Custom HUD disabled
	return
	--[[
	if name == "CHudWeaponSelection" and GetConVar( "br_new_eq" ):GetInt() == 1 then
		return false
	end
	if hide[ name ] then return false end
	--]]
end )

-- Custom fonts for the new HUD
surface.CreateFont( "CustomHUDFont", {
    font = "Roboto",
    extended = false,
    size = 18,
    weight = 500,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = false,
    additive = false,
    outline = false,
} )

surface.CreateFont( "CustomHUDFontBig", {
    font = "Roboto",
    extended = false,
    size = 24,
    weight = 700,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = false,
    additive = false,
    outline = false,
} )

surface.CreateFont( "CustomHUDFontSmall", {
    font = "Roboto",
    extended = false,
    size = 14,
    weight = 400,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = false,
    additive = false,
    outline = false,
} )

-- Custom HUD Paint Hook
hook.Add( "HUDPaint", "Breach_CustomHUD", function()
	if disablehud then return end
	-- Custom HUD disabled - using classic HUD only
	return
	--[[
	local ply = LocalPlayer()
	local w, h = ScrW(), ScrH()
	
	-- Get player info (works for both alive and spectator)
	local role = "Unknown"
	local displayPly = ply
	local isSpectating = false
	
	if ply:GTeam() == TEAM_SPEC then
		isSpectating = true
		local ent = ply:GetObserverTarget()
		if IsValid(ent) and ent:IsPlayer() then
			displayPly = ent
			if ent.GetNClass then
				role = GetLangRole(ent:GetNClass()) or "Unknown"
			end
		else
			if ply:Alive() == false then return end
		end
	else
		if ply:Alive() == false then return end
		if not ply.GetNClass then
			player_manager.RunClass( ply, "SetupDataTables" )
		else
			role = GetLangRole(ply:GetNClass()) or "Unknown"
		end
	end
	
	local hp = displayPly:Health()
	local maxhp = displayPly:GetMaxHealth()
	local blink = blinkHUDTime or 0
	local bd = GetConVar("br_time_blinkdelay"):GetFloat()
	local color = gteams.GetColor(displayPly:GTeam())
	if displayPly:GTeam() == TEAM_CHAOS then
		color = Color(29, 81, 56)
	end
	
	-- Use neutral color when spectating
	if isSpectating then
		color = Color(60, 60, 60) -- Neutral gray color
	end
	
	-- Time display (top center)
	local timel = tostring(string.ToMinutesSeconds(cltime))
	local timeW, timeH = 120, 35
	local timeX, timeY = w / 2 - timeW / 2, 15
	
	draw.RoundedBox(8, timeX, timeY, timeW, timeH, Color(0, 0, 0, 150))
	draw.RoundedBox(8, timeX + 2, timeY + 2, timeW - 4, timeH - 4, Color(60, 60, 60, 180))
	draw.SimpleText(timel, "CustomHUDFontBig", w / 2, timeY + timeH / 2, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	
	-- Main HUD panel (left side)
	local panelW, panelH = 280, 120
	local panelX, panelY = 20, h - panelH - 20
	
	-- Main panel background
	draw.RoundedBox(12, panelX, panelY, panelW, panelH, Color(0, 0, 0, 160))
	draw.RoundedBox(12, panelX + 3, panelY + 3, panelW - 6, panelH - 6, Color(30, 30, 30, 200))
	
	-- Role header with player name (if spectating)
	local roleH = 30
	local headerText = role
	if isSpectating and IsValid(displayPly) then
		headerText = string.sub(displayPly:Nick(), 1, 20)
	end
	draw.RoundedBox(8, panelX + 10, panelY + 10, panelW - 20, roleH, color)
	draw.SimpleText(headerText, "CustomHUDFont", panelX + panelW / 2, panelY + 10 + roleH / 2, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	
	-- Health bar
	local barY = panelY + 50
	local barW = panelW - 40
	local barH = 20
	local barX = panelX + 20
	
	draw.RoundedBox(4, barX, barY, barW, barH, Color(60, 60, 60))
	local hpPercent = math.Clamp(hp / maxhp, 0, 1)
	local hpColor = Color(255 * (1 - hpPercent), 255 * hpPercent, 0)
	draw.RoundedBox(4, barX + 2, barY + 2, (barW - 4) * hpPercent, barH - 4, hpColor)
	
	-- Health text
	draw.SimpleText("HP: " .. hp .. "/" .. maxhp, "CustomHUDFontSmall", barX + 5, barY + barH / 2, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	
	-- Blink bar (if applicable)
	if bd > 0 then
		barY = barY + 25
		draw.RoundedBox(4, barX, barY, barW, barH, Color(60, 60, 60))
		local blinkPercent = math.Clamp(blink / bd, 0, 1)
		draw.RoundedBox(4, barX + 2, barY + 2, (barW - 4) * blinkPercent, barH - 4, Color(100, 150, 255))
		
		-- Blink text
		local blinkText = string.format("Blink: %.1f/%.1f", blink, bd)
		draw.SimpleText(blinkText, "CustomHUDFontSmall", barX + 5, barY + barH / 2, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end
	
	-- Ammo display (left side, below main panel)
	local ammo = -1
	local mag = -1
	if displayPly:GetActiveWeapon() != nil then
		local wep = displayPly:GetActiveWeapon()
		if wep.Clip1 and wep:Clip1() > -1 then
			ammo = wep:Clip1()
			mag = displayPly:GetAmmoCount(wep:GetPrimaryAmmoType())
		end
	end
	
	if ammo >= 0 then
		local ammoW, ammoH = 120, 60
		local ammoX, ammoY = panelX, panelY - ammoH - 10
		
		draw.RoundedBox(8, ammoX, ammoY, ammoW, ammoH, Color(0, 0, 0, 160))
		draw.RoundedBox(8, ammoX + 3, ammoY + 3, ammoW - 6, ammoH - 6, Color(40, 40, 40, 200))
		
		-- Ammo numbers
		draw.SimpleText(tostring(ammo), "CustomHUDFontBig", ammoX + ammoW / 2, ammoY + 20, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		draw.SimpleText("+" .. tostring(mag), "CustomHUDFont", ammoX + ammoW / 2, ammoY + 40, Color(200, 200, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end
	--]]
end )


================================================
FILE: gamemodes/breach/gamemode/modules/cl_hud_new.lua
================================================
local hide = {
	CHudHealth = true,
	CHudBattery = true,
	CHudAmmo = true,
	CHudSecondaryAmmo = true,
	CHudDeathNotice = true,
}

hook.Add( "HUDShouldDraw", "HideHUDElements", function( name )
	if name == "CHudWeaponSelection" and GetConVar( "br_new_eq" ):GetInt() == 1 then
		return false
	end
	if hide[ name ] then return false end
end )

local MATS = {
	menublack = Material("hud_scp/menublack.png"),//Material("pp/blurscreen"),
	blanc = Material("hud_scp/texture_blanc.png"),
	meter = Material("hud_scp/meter.png"),
	time = Material("hud_scp/timeicon.png"),
	user = Material("hud_scp/user.png"),
	scp = Material("hud_scp/scp.png"),
	ammo = Material("hud_scp/ammoicon.png"),
	mag = Material("hud_scp/magicon.png"),
	blink = Material("hud_scp/blinkicon.png"),
	hp = Material("hud_scp/hpicon.png"),
	sprint = Material("hud_scp/sprinticon.png"),
}

hook.Add( "HUDPaint", "Breach_HUD", function()
	if disablehud then return end
	-- New HUD disabled - using classic HUD only
	return
	--[[
	local scale = hudScale
	local width = ScrW() * scale
	local height = ScrH() * scale
	local offset = ScrH() - height
	local ply = LocalPlayer()
	if ply:Alive() == false then return end

	//surface.SetMaterial( MATS.menublack )
	//MATS.menublack:SetFloat("$blur", 5)
	//MATS.menublack:Recompute()
	//render.UpdateScreenEffectTexture()

	if IsValid( ply ) then
		--spect box
		if ply:GTeam() == TEAM_SPEC then
			local ent = ply:GetObserverTarget()
			if IsValid(ent) then
				if ent:IsPlayer() then
					local w, h = 350, 35
					surface.SetDrawColor(255,255,255,255)
					surface.SetMaterial( MATS.menublack )
					surface.DrawTexturedRect( ScrW() / 2 - w / 2 , 0, w, h )
					draw.TextShadow( {
						text = string.sub(ent:Nick(), 1, 17),
						pos = { ScrW() / 2, 15 },
						font = "HealthAmmo",
						color = Color(255,255,255),
						xalign = TEXT_ALIGN_CENTER,
						yalign = TEXT_ALIGN_CENTER,
					}, 2, 255 )
				end
			end
		end

		--Getting role and observer
		local role = "none"
		if not ply.GetNClass then
			player_manager.RunClass( ply, "SetupDataTables" )
		elseif LocalPlayer():GTeam() != TEAM_SPEC then
			role = GetLangRole(ply:GetNClass()) or "Unknown"
		else
			local obs = ply:GetObserverTarget()
			role = GetLangRole(ply:GetNClass())
			if IsValid(obs) then
				if obs.GetNClass != nil then
					role = "[REDACTED]"
					ply = obs
				end
			end
		end
		--apply stats
		local hp = ply:Health()
		local maxhp = ply:GetMaxHealth()
		local blink = blinkHUDTime
		local bd = GetConVar("br_time_blinkdelay"):GetFloat()
		local color = gteams.GetColor(ply:GTeam())
		if ply:GTeam() == TEAM_CHAOS then
			color = Color(29, 81, 56)
		end
		--white bcg
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.blanc)
		surface.DrawTexturedRect( width * 0.015, height * 0.765 + offset, width * 0.3, height * 0.22)
		--main panel
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.menublack)
		//render.SetScissorRect( width * 0.016, height * 0.767 + offset, width * 0.016 + width * 0.198, height * 0.767 + offset + height * 0.071, true )
		//surface.DrawTexturedRect( 0, 0, ScrW(), ScrH() )
		//render.SetScissorRect( 0, 0, 0, 0, false )
		surface.DrawTexturedRect( width * 0.016, height * 0.767 + offset, width * 0.198, height * 0.071)
		
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.menublack)
		surface.DrawTexturedRect( width * 0.016, height * 0.839 + offset, width * 0.198, height * 0.071)
		
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.menublack)
		surface.DrawTexturedRect( width * 0.016, height * 0.912 + offset, width * 0.198, height * 0.071)
		--left panel
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.menublack)
		surface.DrawTexturedRect( width * 0.215, height * 0.767 + offset, width * 0.099, height * 0.050)
		
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.menublack)
		surface.DrawTexturedRect( width * 0.215, height * 0.819 + offset, width * 0.099, height * 0.045)
		
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.menublack)
		surface.DrawTexturedRect( width * 0.215, height * 0.865 + offset, width * 0.099, height * 0.045)
		
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.menublack)
		surface.DrawTexturedRect( width * 0.215, height * 0.912 + offset, width * 0.099, height * 0.072)
		--info
		local timel = tostring( string.ToMinutesSeconds( cltime ) )
		local name = ply:GetName()
		local ammo = -1
		local mag = -1
		if ply:GetActiveWeapon() != nil then
			local wep = ply:GetActiveWeapon()
			if wep.Clip1 and wep:Clip1() > -1 then
				ammo = wep:Clip1()
				mag = ply:GetAmmoCount( wep:GetPrimaryAmmoType() )
			end
		end
		--time
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.time)
		surface.DrawTexturedRect( width * 0.23, height * 0.778 + offset, height * 0.03, height * 0.03)
		
		draw.Text( {
			text = timel,
			pos = { width * 0.275, height * 0.78 + offset },
			font = "HUDFontTitle",
			color = Color(255,255,255),
			xalign = TEXT_ALIGN_CENTER,
			yalign = TEXT_ALIGN_RIGHT,
		})
		--player name
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.user)
		surface.DrawTexturedRect( width * 0.26, height * 0.825 + offset, height * 0.02, height * 0.02)
		draw.Text( {
			text = string.sub(name, 1, 23),
			pos = { width * 0.265, height * 0.843 + offset },
			font = "HUDFontLittle",
			color = Color(255,255,255),
			xalign = TEXT_ALIGN_CENTER,
			yalign = TEXT_ALIGN_RIGHT,
		})
		--role
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.scp)
		surface.DrawTexturedRect( width * 0.26, height * 0.87 + offset, height * 0.02, height * 0.02)
		local ft = "HUDFontLittle"
		if string.len(role) > 25 then ft = "HUDFont" end
		draw.Text( {
			text = string.sub(role, 1, 30),
			pos = { width * 0.265, height * 0.888 + offset },
			font = ft,
			color = Color(255,255,255),
			xalign = TEXT_ALIGN_CENTER,
			yalign = TEXT_ALIGN_RIGHT,
		})
		--ammo
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.ammo)
		surface.DrawTexturedRect( width * 0.22, height * 0.915 + offset, height * 0.028, height * 0.028)
		if ammo < 0 then ammo = 0 end
		draw.Text( {
			text = ammo,
			pos = { width * 0.27, height * 0.917 + offset },
			font = "HUDFontMedium",
			color = Color(255,255,255),
			xalign = TEXT_ALIGN_CENTER,
			yalign = TEXT_ALIGN_RIGHT,
		})
		--mag
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.mag)
		surface.DrawTexturedRect( width * 0.22, height * 0.95 + offset, height * 0.028, height * 0.028)
		if mag < 0 then mag = 0 end
		draw.Text( {
			text = mag,
			pos = { width * 0.27, height * 0.952 + offset },
			font = "HUDFontMedium",
			color = Color(255,255,255),
			xalign = TEXT_ALIGN_CENTER,
			yalign = TEXT_ALIGN_RIGHT,
		})
		--blink icon & bar		
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.blink)
		surface.DrawTexturedRect( width * 0.025, height * 0.785 + offset, height * 0.035, height * 0.035)
		
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.blanc)
		surface.DrawTexturedRect( width * 0.05, height * 0.785 + offset, width * 0.1525, height * 0.035)
		
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect( width * 0.051, height * 0.786 + offset, width * 0.1515, height * 0.033)
		local bbars = 0
		local bbars = blink / bd * 15
		if bbars > 15 then bbars = 15 end
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.meter)
		for i=1, bbars do
			surface.DrawTexturedRect( width * 0.052 + width * 0.01 * (i - 1), height * 0.7875 + offset, width * 0.009, height * 0.029)
		end
		blink = string.format("%.1f", blink)
		bd = string.format("%.1f", bd)
		draw.Text( {
			text = blink.." / ".. bd,
			pos = { width * 0.115, height * 0.82 + offset },
			font = "HUDFont",
			color = Color(255,255,255),
			xalign = TEXT_ALIGN_CENTER,
			yalign = TEXT_ALIGN_RIGHT,
		})
		--HP icon & bar		
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.hp)
		surface.DrawTexturedRect( width * 0.025, height * 0.857 + offset, height * 0.035, height * 0.035)
		
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(MATS.blanc)
		surface.DrawTexturedRect( width * 0.05, height * 0.857 + offset, width * 0.1525, height * 0.035)
		
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect( width * 0.051, height * 0.858 + offset, width * 0.1515, height * 0.033)
		local hpb = math.Round(hp / maxhp * 15)
		if hpb > 15 then hpb = 15 end
		surface.SetDrawColor(255, 0, 0, 255)
		surface.SetMaterial(MATS.meter)
		for i=1, hpb do
			surface.DrawTexturedRect( width * 0.052 + width * 0.01 * (i - 1), height * 0.8595 + offset, width * 0.009, height * 0.029)
		end
		draw.Text( {
			text = hp.." / "..maxhp,
			pos = { width * 0.115, height * 0.893 + offset },
			font = "HUDFont",
			color = Color(255,255,255),
			xalign = TEXT_ALIGN_CENTER,
			yalign = TEXT_ALIGN_RIGHT,
		})
	end
	--]]
end )


================================================
FILE: gamemodes/breach/gamemode/modules/cl_kill_notifications.lua
================================================
-- Kill notification system
-- Displays kill notifications on the right side of the screen

-- Table of active notifications
local killNotifications = {}

-- Colors for different classes (initialized later)
local classColors = {}
local classNames = {}

-- Initialize colors and names after all modules are loaded
hook.Add("Initialize", "InitKillNotifications", function()
    -- Colors for different classes
    classColors = {
        [TEAM_GUARD] = Color(100, 150, 255), -- Blue for MTF
        [TEAM_CHAOS] = Color(50, 150, 50), -- Dark green for Chaos
        [TEAM_CLASSD] = Color(255, 150, 50), -- Orange for Class-D
        [TEAM_SCI] = Color(100, 255, 255), -- Cyan for Scientists
        [TEAM_SCP] = Color(100, 255, 100), -- Green for SCP
        [TEAM_GOC] = Color(255, 255, 0), -- Yellow for GOC
        teamkill = Color(255, 50, 50) -- Red for teamkill
    }

    -- Class names in English
    classNames = {
        [TEAM_GUARD] = "MTF",
        [TEAM_CHAOS] = "Chaos Insurgency",
        [TEAM_CLASSD] = "Class-D",
        [TEAM_SCI] = "Scientist",
        [TEAM_SCP] = "SCP",
        [TEAM_GOC] = "GOC"
    }
end)

-- Function to add new notification
local function AddKillNotification(victimClass, victimName, points, isTeamkill)
    local notification = {
        victimClass = victimClass,
        victimName = victimName,
        points = points,
        isTeamkill = isTeamkill,
        startTime = CurTime(),
        alpha = 0,
        fadeIn = true,
        fadeOut = false
    }
    
    table.insert(killNotifications, notification)
    
    -- Remove old notifications if there are too many
    if #killNotifications > 5 then
        table.remove(killNotifications, 1)
    end
end

-- Network receiver for kill notifications
net.Receive("KillNotification", function()
    local victimClass = net.ReadInt(8)
    local victimName = net.ReadString()
    local points = net.ReadInt(16)
    local isTeamkill = net.ReadBool()
    
    AddKillNotification(victimClass, victimName, points, isTeamkill)
end)

-- Hook to draw notifications
hook.Add("HUDPaint", "DrawKillNotifications", function()
    if #killNotifications == 0 then return end
    
    local scrW, scrH = ScrW(), ScrH()
    local baseX = scrW * 0.51 -- Pozycja po prawej stronie crosshaira
    local baseY = scrH * 0.49
    local notificationHeight = 15
    local font = "DermaDefaultBold"
    
    -- Iterate through notifications from back to newest on top
    for i = #killNotifications, 1, -1 do
        local notif = killNotifications[i]
        local currentTime = CurTime()
        local timeSinceStart = currentTime - notif.startTime
        
        -- Calculate alpha based on time
        if notif.fadeIn and timeSinceStart < 0.3 then
            -- Fade in for first 0.3 seconds
            notif.alpha = math.min(255, (timeSinceStart / 0.3) * 255)
        elseif timeSinceStart >= 0.3 and timeSinceStart < 3.5 then
            -- Full visibility for 3.2 seconds
            notif.alpha = 255
            notif.fadeIn = false
        elseif timeSinceStart >= 3.5 and timeSinceStart < 4.0 then
            -- Fade out for last 0.5 seconds
            notif.fadeOut = true
            notif.alpha = math.max(0, 255 - ((timeSinceStart - 3.5) / 0.5) * 255)
        else
            -- Remove notification after 4 seconds
            table.remove(killNotifications, i)
            continue
        end
        
        -- Y position for this notification
        local yPos = baseY + (i - 1) * notificationHeight
        
        -- Choose color and text
        local classColor, text1, text2, text3
        local whiteColor = Color(255, 255, 255, notif.alpha)
        local shadowColor = Color(0, 0, 0, notif.alpha * 0.8)
        
        if notif.isTeamkill then
            classColor = Color(classColors.teamkill.r, classColors.teamkill.g, classColors.teamkill.b, notif.alpha)
            text1 = "TEAMKILL "
            text2 = notif.victimName
            text3 = string.format(", lose %d points", math.abs(notif.points))
        else
            classColor = Color((classColors[notif.victimClass] or Color(255, 255, 255)).r,
                              (classColors[notif.victimClass] or Color(255, 255, 255)).g,
                              (classColors[notif.victimClass] or Color(255, 255, 255)).b, notif.alpha)
            local className = classNames[notif.victimClass] or "Enemy"
            text1 = string.format("Killed %s ", className)
            text2 = notif.victimName
            text3 = string.format(", receive %d points", notif.points)
        end
        
        -- Calculate text widths
        surface.SetFont(font)
        local text1Width = surface.GetTextSize(text1)
        local text2Width = surface.GetTextSize(text2)
        
        -- Draw shadows
        draw.SimpleText(text1, font, baseX + 2, yPos + 2, shadowColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
        draw.SimpleText(text2, font, baseX + text1Width + 2, yPos + 2, shadowColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
        draw.SimpleText(text3, font, baseX + text1Width + text2Width + 2, yPos + 2, shadowColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
        
        -- Draw main texts
        draw.SimpleText(text1, font, baseX, yPos, classColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
        draw.SimpleText(text2, font, baseX + text1Width, yPos, whiteColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
        draw.SimpleText(text3, font, baseX + text1Width + text2Width, yPos, classColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
    end
end)


================================================
FILE: gamemodes/breach/gamemode/modules/cl_minigames.lua
================================================
if SERVER then return end

local BUTTON_UP = 1
local BUTTON_LEFT = 2
local BUTTON_DOWN = 3
local BUTTON_RIGHT = 4

local BUTTONS_DOWN = {}

local snake_enabled = false
local freeze_game = false

local MAP_BOUNDS = 51

local SNAKE = {
	{
		x = 25,
		y = 25
	}
}
local APPLE = {
	x = 0,
	y = 0
}

local xvel = 0
local yvel = 0

local tickdelay = 0.1

function SnakeOpen()
	if ply:GetNClass() != ROLES.ROLE_SPEC then return end
	snake_enabled = true
	if freeze_game then
		timer.Simple( 2, function()
			freeze_game = false
		end )
	end
end

function SnakeClose()
	snake_enabled = false
	freeze_game = true
	BUTTONS_DOWN = {}
end

function IsKeyDown( key )
	if BUTTONS_DOWN[key] then
		BUTTONS_DOWN[key] = nil
		return true
	end
end

local ntick = 0
function SnakeUpdate()
	if !snake_enabled or freeze_game then return end
	if ntick > CurTime() then return end
	ntick = CurTime() + tickdelay
	if ply:GetNClass() != ROLES.ROLE_SPEC then
		SnakeClose()
	end
	if IsKeyDown( BUTTON_UP ) then
		if not ( yvel == 1 and #SNAKE > 1 ) then
			yvel = -1
			xvel = 0
		end
	elseif IsKeyDown( BUTTON_DOWN ) then
		if not ( yvel == -1 and #SNAKE > 1 ) then
			yvel = 1
			xvel = 0
		end
	elseif IsKeyDown( BUTTON_LEFT ) then
		if not ( xvel == 1 and #SNAKE > 1 ) then
			yvel = 0
			xvel = -1
		end
	elseif IsKeyDown( BUTTON_RIGHT ) then
		if not ( xvel == -1 and #SNAKE > 1 ) then
			yvel = 0
			xvel = 1
		end
	end
	local lastx, lasty = 0, 0
	for i, v in ipairs( SNAKE ) do
		local cx, cy = v.x, v.y
		if i == 1 then
			v.x = v.x + xvel
			v.y = v.y + yvel
			if v.x > MAP_BOUNDS then v.x = 1 end
			if v.y > MAP_BOUNDS then v.y = 1 end
			if v.x < 1 then v.x = MAP_BOUNDS end
			if v.y < 1 then v.y = MAP_BOUNDS end
			if v.x == APPLE.x and v.y == APPLE.y then
				GenerateApple()
				table.insert( SNAKE, { x = cx, y = cy } )
				--break
			end
		else
			v.x = lastx
			v.y = lasty
		end
		lastx = cx
		lasty = cy
	end
	for i, v in ipairs( SNAKE ) do
		for _i, _v in ipairs( SNAKE ) do
			if v != _v then
				if v.x == _v.x and v.y == _v.y then
					freeze_game = true
					timer.Simple( 2, function()
						SnakeRestart()
					end )
					return
				end
			end
		end
	end
end

function SnakeDraw()
	if !snake_enabled then return end
	local w, h = ScrW() / 2, ScrH() / 2
	local grid = math.Round( h * 0.031 )
	local sub = grid * MAP_BOUNDS / 2
	surface.SetDrawColor( Color( 245, 245, 245, 255 ) )
	surface.DrawRect( w - sub - grid, h - sub - grid, ( sub + grid ) * 2, ( sub + grid ) * 2 )
	surface.SetDrawColor( Color( 10, 10, 10, 255 ) )
	surface.DrawRect( w - sub - grid / 2, h - sub - grid / 2, ( sub + grid / 2 ) * 2, ( sub + grid / 2 ) * 2 )
	for y = 1, MAP_BOUNDS do
		for x = 1, MAP_BOUNDS do
			surface.SetDrawColor( Color( 100, 100, 100, 200 ) )
			surface.DrawRect( w - sub + grid * ( x - 1 ), h - sub + grid * ( y - 1 ), grid * 0.99, grid * 0.99 )
		end
	end
	for k, v in pairs( SNAKE ) do
		surface.SetDrawColor( Color( 200, 150, 100, 200 ) )
		surface.DrawRect( w - sub + ( v.x - 1 ) * grid, h - sub + ( v.y - 1 ) * grid, grid * 0.99, grid * 0.99 )
	end
	surface.SetDrawColor( Color( 225, 25, 25, 200 ) )
	surface.DrawRect( w - sub + ( APPLE.x - 1 ) * grid, h - sub + ( APPLE.y - 1 ) * grid, grid * 0.99, grid * 0.99 )
end

hook.Add( "Tick", "SnakeUpdate", SnakeUpdate )
hook.Add( "DrawOverlay", "SnakeDraw", SnakeDraw )

hook.Add( "PlayerButtonDown", "SnakeButtons", function( ply, key )
	if !snake_enabled or freeze_game then return end
	key = key - 87
	if key > 0 and key < 5 then
		BUTTONS_DOWN[key] = true
	end
end )

concommand.Add( "br_snake", function()
	if ply:GetNClass() == ROLES.ROLE_SPEC then
		if snake_enabled then
			SnakeClose()
		else
			SnakeOpen()
		end
	end
end )

concommand.Add( "br_snake_reset", function()
	SnakeRestart()
end )

hook.Add( "OnPlayerChat", "SnakeChat", function( ply, text, teamChat, isDead )
	if ply != LocalPlayer() then return end
	text = string.lower( text )
	if text == "!snake" or text == "/snake" then
		if !ply.GetNClass then return end
		if ply:GetNClass() == ROLES.ROLE_SPEC then
			if snake_enabled then
				SnakeClose()
			else
				SnakeOpen()
			end
			return true
		end
	elseif text == "!s reset" or text == "/s reset" then
		SnakeRestart()
		return true
	end
end )

function SnakeRestart()
	GenerateApple()
	SNAKE = {
		{
			x = 25,
			y = 25
		}
	}
	xvel = 0
	yvel = 0
	freeze_game = false
	BUTTONS_DOWN = {}
end

function GenerateApple()
	local x = math.random( 1, MAP_BOUNDS )
	local y = math.random( 1, MAP_BOUNDS )

	local snaketab = {}
	for k, v in pairs( SNAKE ) do
		local sx = v.x
		local sy = v.y
		if !snaketab[sy] then
			snaketab[sy] = {}
		end
		snaketab[sy][sx] = true
	end

	while snaketab[y] and snaketab[y][x] do
		x = x + 1
		if x > MAP_BOUNDS then
			y = y + 1
			x = 1
		end
		if y > MAP_BOUNDS then
			y = 1 
		end
	end

	APPLE.x = x
	APPLE.y = y
end

GenerateApple()


================================================
FILE: gamemodes/breach/gamemode/modules/cl_module.lua
================================================
/*include("shared.lua")
include("gteams.lua")
include("fonts.lua")
include("class_breach.lua")
include("classes.lua")
include("cl_classmenu.lua")
include("sh_player.lua")
include("cl_mtfmenu.lua")
include("cl_scoreboard.lua")
include( "cl_sounds.lua" )
include( "cl_targetid.lua" )
include( "cl_headbob.lua" )
include( "cl_font.lua" )
include( "ulx.lua" )
include( "cl_minigames.lua" )
include( "cl_eq.lua" )*/

SAVEDIDS = {}
lastidcheck = 0
function AddToIDS(ply)
	if lastidcheck > CurTime() then return end
	local sid = nil
	local wep = ply:GetActiveWeapon()
	if not ply.GetNClass or not ply.GetLastRole then
		player_manager.RunClass( ply, "SetupDataTables" )
	end
	if ply:GTeam() == TEAM_SCP then
		if ply:GetNClass() == ROLES.ROLE_SCP9571 then
			sid = ply:GetLastRole()
			if sid == "" then sid = nil end
		else
			sid = ply:GetNClass()
		end
	else
		if IsValid(wep) then
			if wep:GetClass() == "br_id" then
				sid = ply:GetNClass()
			end
		end
	end
	if sid == ROLES.ROLE_CHAOSSPY then
		if (LocalPlayer():GTeam() == TEAM_SCI) or (LocalPlayer():GTeam() == TEAM_GUARD) or (LocalPlayer():GTeam() == TEAM_GOC) then
			sid = ROLES.ROLE_MTFGUARD
		end
	end
	for k,v in pairs(SAVEDIDS) do
		if v.pl == ply then
			if v.id == sid then
				lastidcheck = CurTime() + 0.5
				return
			end
		end
	end
	table.ForceInsert(SAVEDIDS, {pl = ply, id = sid})
	
	// messaging
	if sid == nil then
		sid = "unknown id"
	else
		sid = "id: " .. sid
	end
	-- local sname = "Added new id: " .. ply:Nick() .. " with " .. sid
	-- print(sname)
	lastidcheck = CurTime() + 0.7
end

--buttonstatus = "rough"

clang = nil
cwlang = nil

-- local files, dirs = file.Find(GM.FolderName .. "/gamemode/languages/*.lua", "LUA" )
-- for k,v in pairs(files) do
-- 	local path = "languages/"..v
-- 	if string.Right(v, 3) == "lua" and string.Left(v, 3) != "wep" then
-- 		include( path )
-- 		print("Loading language: " .. path)
-- 	end
-- end

-- local files, dirs = file.Find(GM.FolderName .. "/gamemode/languages/wep_*.lua", "LUA" )
-- for k,v in pairs(files) do
-- 	local path = "languages/"..v
-- 	if string.Right(v, 3) == "lua" then
-- 		include( path )
-- 		print("Loading weapon lang file: " .. path)
-- 	end
-- end

-- Wymuś angielski język i zablokuj zmianę
langtouse = "english"
CreateClientConVar( "cvar_br_language", "english", true, false )
GetConVar( "cvar_br_language" ):SetString( "english" )

local sv_lang = GetConVar( "br_defaultlanguage" )
if sv_lang then
	local sv_str = sv_lang:GetString()
	if ALLLANGUAGES[sv_str] and WEPLANG[sv_str] then
		GetConVar( "cvar_br_language" ):SetString( sv_str )
		langtouse = sv_str
	end
end

-- Zablokowano callback zmiany języka
cvars.AddChangeCallback( "cvar_br_language", function( convar_name, value_old, value_new )
	-- Wymuś powrót do angielskiego
	langtouse = "english"
	GetConVar( "cvar_br_language" ):SetString( "english" )
	LoadLang( langtouse )
end )

-- Zablokowano komendę br_language
concommand.Add( "br_language", function( ply, cmd, args )
	-- Komenda zablokowana - język wymuszony na angielski
	print("Language change is disabled. English is enforced.")
end, function( cmd, args )
	args = string.Trim( args )
	args = string.lower( args )

	local tab = {}

	for k, v in pairs( ALLLANGUAGES ) do
		if string.find( string.lower( k ), args ) then
			table.insert( tab, "br_language "..k )
		end
	end

	return tab
end, "Sets language", FCVAR_ARCHIVE )

hudScale = CreateClientConVar( "br_hud_scale", 1, true, false ):GetFloat()

cvars.AddChangeCallback( "br_hud_scale", function( convar_name, value_old, value_new )
	local newScale = tonumber(value_new)
	if newScale > 1 then newScale = 1 end
	if newScale < 0.1 then newScale = 0.1 end
	hudScale = newScale
end )

-- Client-side HUD selection - forced to classic HUD
CreateClientConVar( "br_hud", "2", true, false, "HUD style - locked to classic HUD" )

print("langtouse:")
print(langtouse)

//print("Alllangs:")
//PrintTable(ALLLANGUAGES)

function AddTables( tab1, tab2 )
	for k, v in pairs( tab2 ) do
		if tab1[k] and istable( v ) then
			AddTables( tab1[k], v )
		else
			tab1[k] = v
		end
	end
end

function LoadLang( lang )
	local finallang = table.Copy( ALLLANGUAGES.english )
	local ltu = {}
	if ALLLANGUAGES[lang] then
		ltu = table.Copy( ALLLANGUAGES[lang] )
	end
	AddTables( finallang, ltu )
	clang = finallang

	local finalweplang = table.Copy( WEPLANG.english )
	local wltu = {}
	if WEPLANG[lang] then
		wltu = WEPLANG[lang]
	else
		wltu = table.Copy( WEPLANG.english )
	end
	AddTables( finalweplang, wltu )
	cwlang = finalweplang
end

LoadLang( langtouse )

--mapfile = "mapconfigs/" .. game.GetMap() .. ".lua"
--include(mapfile)

include("cl_hud.lua")
include("cl_hud_new.lua")
include("cl_hud_custom.lua")
include("cl_kill_notifications.lua")
include("cl_vest_hud.lua")
include("cl_settings_menu.lua")
include("cl_deathcard.lua")
include("cl_fps_ping_display.lua")
include("cl_door_access_hud.lua")
include("cl_weapon_damage_menu.lua")
--include( "cl_splash.lua" )
include("cl_bomber_lottery.lua")

RADIO4SOUNDSHC = {
	{"chatter1", 39},
	{"chatter2", 72},
	{"chatter4", 12},
	{"franklin1", 8},
	{"franklin2", 13},
	{"franklin3", 12},
	{"franklin4", 19},
	{"ohgod", 25}
}

RADIO4SOUNDS = table.Copy(RADIO4SOUNDSHC)

disablehud = false
livecolors = false

preparing = false
postround = false

function DropCurrentVest()
	if LocalPlayer():Alive() and LocalPlayer():GTeam() != TEAM_SPEC then
		net.Start("DropCurrentVest")
		net.SendToServer()
	end
end

concommand.Add( "br_spectate", function( ply, cmd, args )
	net.Start("SpectateMode")
	net.SendToServer()
end )

concommand.Add( "br_recheck_premium", function( ply, cmd, args )
	if ply:IsSuperAdmin() then
		net.Start("RecheckPremium")
		net.SendToServer()
	end
end )

concommand.Add( "br_punish_cancel", function( ply, cmd, args )
	if ply:IsSuperAdmin() then
		net.Start("CancelPunish")
		net.SendToServer()
	end
end )

concommand.Add( "br_roundrestart_cl", function( ply, cmd, args )
	if ply:IsSuperAdmin() then
		net.Start("RoundRestart")
		net.SendToServer()
	end
end )

wantClear = false
tUse = 0

concommand.Add( "br_clear_stats", function( ply, cmd, args )
	if ply:IsSuperAdmin() then
		if tUse < CurTime() and wantClear then wantClear = false print("Last request timed out") end
		if #args > 0 then
			print( "Sending request to server..." )
			net.Start( "ClearData" )
				net.WriteString( tostring( args[1] ) )
			net.SendToServer()
		else
			if !wantClear then
				print( "Are you sure to clear players all data? Write again to confirm (this operation cannot be undone)" )
				wantClear = true
				tUse = CurTime() + 10
			else
				wantClear = false
				print( "Sending request to server..." )
				net.Start( "ClearData" )
					net.WriteString( "&ALL" )
				net.SendToServer()
			end
		end
	end
end )

concommand.Add( "br_restart_game", function( ply, cmd, args )
	if ply:IsSuperAdmin() then
		net.Start("Restart")
		net.SendToServer()
	end
end )

concommand.Add( "br_admin_mode", function( ply, cmd, args )
	if ply:IsSuperAdmin() then
		net.Start("AdminMode")
		net.SendToServer()
	end
end )

concommand.Add( "br_dropvest", function( ply, cmd, args )
	DropCurrentVest()
end )

concommand.Add( "br_disableallhud", function( ply, cmd, args )
	disablehud = !disablehud
end )

-- HUD switching command
concommand.Add( "br_hud_switch", function( ply, cmd, args )
	local hudVar = GetConVar("br_hud")
	if !hudVar then
		chat.AddText(Color(255, 100, 100), "[HUD] ", Color(255, 255, 255), "HUD system not loaded yet!")
		return
	end
	
	local currentHUD = hudVar:GetInt()
	local newHUD = currentHUD + 1
	if newHUD > 3 then newHUD = 1 end
	
	hudVar:SetInt(newHUD)
	
	local hudNames = {
		[1] = "New HUD (Modern)",
		[2] = "Classic HUD (Original)",
		[3] = "Custom HUD (Minimalist)"
	}
	
	chat.AddText(Color(100, 255, 100), "[HUD] ", Color(255, 255, 255), "Switched to: " .. hudNames[newHUD])
end )

concommand.Add( "br_livecolors", function( ply, cmd, args )
	if livecolors then
		livecolors = false
		chat.AddText("livecolors disabled")
	else
		livecolors = true
		chat.AddText("livecolors enabled")
	end
end )

concommand.Add( "br_weapon_info", function( ply, cmd, args )
	local wep = ply:GetActiveWeapon()
	if IsValid( wep ) then
		print( "Weapon name: "..wep:GetClass() )
		if wep.Damage_Orig then print( "Weapon original damage: "..wep.Damage_Orig ) end
		if wep.DamageMult then print( "Weapon damage multiplier: "..wep.DamageMult ) end
		if wep.DamageMult then print( "Weapon final damage: "..wep.Damage ) end
	end
end )
gamestarted = false
cltime = 0
drawinfodelete = 0
shoulddrawinfo = false
drawendmsg = nil
timefromround = 0

-- Timer Credits usunięty - wyłączono wyświetlanie komunikatów o autorze

-- Heartbeat sound disabled
-- timer.Create("HeartbeatSound", 2, 0, function()
-- 	if not LocalPlayer().Alive then return end
-- 	if LocalPlayer():Alive() and LocalPlayer():GTeam() != TEAM_SPEC then
-- 		if LocalPlayer():Health() < 30 then
-- 			LocalPlayer():EmitSound("heartbeat.ogg")
-- 		end
-- 	end
-- end)

function OnUseEyedrops(ply) end

function StartTime()
	timer.Destroy("UpdateTime")
	timer.Create("UpdateTime", 1, 0, function()
		if cltime > 0 then
			cltime = cltime - 1
		end
	end)
end

endinformation = {}

/*net.Receive( "Update914B", function( len )
	local sstatus = net.ReadInt(6)
	if sstatus == 0 then
		buttonstatus = "rough"
	elseif sstatus == 1 then
		buttonstatus = "coarse"
	elseif sstatus == 2 then
		buttonstatus = "1:1"
	elseif sstatus == 3 then
		buttonstatus = "fine"
	elseif sstatus == 4 then
		buttonstatus = "very fine"
	end
end)*/

net.Receive( "UpdateTime", function( len )
	cltime = tonumber(net.ReadString())
	StartTime()
end)

net.Receive( "UpdateKeycard", function( len )
	local keycard = LocalPlayer():GetWeapon( "br_keycard" )
	if IsValid( keycard ) and keycard.Think then
		keycard:Think()
	end
end )

net.Receive( "OnEscaped", function( len )
	local nri = net.ReadInt(4)
	shoulddrawescape = nri
	esctime = CurTime() - timefromround
	lastescapegot = CurTime() + 20
	StartEndSound()
end)

net.Receive( "ForcePlaySound", function( len )
	local sound = net.ReadString()
	surface.PlaySound(sound)
end)

net.Receive( "UpdateRoundType", function( len )
	roundtype = net.ReadString()
	print("Current roundtype: " .. roundtype)
end)

net.Receive( "SendRoundInfo", function( len )
	local infos = net.ReadTable()
	endinformation = {
		string.Replace( clang.lang_pldied, "{num}", infos.deaths ),
		string.Replace( clang.lang_descaped, "{num}", infos.descaped ),
		string.Replace( clang.lang_sescaped, "{num}", infos.sescaped ),
		string.Replace( clang.lang_rescaped, "{num}", infos.rescaped ),
		string.Replace( clang.lang_dcaptured, "{num}", infos.dcaptured ),
		string.Replace( clang.lang_rescorted, "{num}", infos.rescorted ),
		string.Replace( clang.lang_teleported, "{num}", infos.teleported ),
		string.Replace( clang.lang_snapped, "{num}", infos.snapped ),
		string.Replace( clang.lang_zombies, "{num}", infos.zombies )
	}
	if infos.secretf == true then
		table.ForceInsert(endinformation, clang.lang_secret_found)
	else
		table.ForceInsert(endinformation, clang.lang_secret_nfound)
	end
end)

net.Receive( "RolesSelected", function( len )
	drawinfodelete = CurTime() + 25
	shoulddrawinfo = true
end)

net.Receive( "PrepStart", function( len )
	cltime = net.ReadInt(8)
	postround = false
	preparing = true
	chat.AddText(string.Replace( clang.preparing,  "{num}", cltime ))
	StartTime()
	drawendmsg = nil
	hook457delete = CurTime() + 0.5
	hook.Add("Tick", "Stop457Sounds", function()
		if hook457delete != nil then
			if hook457delete < CurTime() then
				hook457delete = nil
				hook.Remove("Tick", "Stop457Sounds")
			end
			if LocalPlayer():GetNClass() == ROLE_SCP457 then
				RunConsoleCommand("stopsound")
			end
		end
	end)
	timer.Destroy("SoundsOnRoundStart")
	timer.Create("SoundsOnRoundStart", 1, 1, SoundsOnRoundStart)
	timefromround = CurTime() + 10
	RADIO4SOUNDS = table.Copy(RADIO4SOUNDSHC)
	SAVEDIDS = {}
end)

net.Receive( "RoundStart", function( len )
	preparing = false
	cltime = net.ReadInt(12)
	chat.AddText(clang.round)
	StartTime()
	drawendmsg = nil
end)

net.Receive( "PostStart", function( len )
	postround = true
	cltime = net.ReadInt(6)
	win = net.ReadInt(4)
	drawendmsg = win
	StartTime()
end)

net.Receive( "TranslatedMessage", function( len )
	local msg = net.ReadString()
	//local center = net.ReadBool()

	//print( msg )
	local color = nil
	local nmsg, cr, cg, cb = string.match( msg, "(.+)%#(%d+)%,(%d+)%,(%d+)$" )
	if nmsg and cr and cg and cb then
		msg = nmsg
		color = Color( cr, cg, cb )
	end

	local name, func = string.match( msg, "^(.+)%$(.+)" )
	
	if name and func then
		local args = {}

		for v in string.gmatch( func, "%w+" ) do
			table.insert( args, v )
			//print( "splitted:", v )
		end

		local translated = clang.NRegistry[name] or string.format( clang.NFailed, name )
		if color then
			chat.AddText( color, string.format( translated, unpack( args ) ) )
		else
			chat.AddText( string.format( translated, unpack( args ) ) )
		end
	else
		local translated = clang.NRegistry[msg] or string.format( clang.NFailed, msg )
		if color then
			chat.AddText( color, translated )
		else
			chat.AddText( translated )
		end
	end
end )

net.Receive( "CameraDetect", function( len )
	local tab = net.ReadTable()

	for i, v in ipairs( tab ) do
		table.insert( SCPMarkers, { time = CurTime() + 7.5, data = v } )
	end
end )

hook.Add( "OnPlayerChat", "CheckChatFunctions", function( ply, strText, bTeam, bDead )
	strText = string.lower( strText )

	if ( strText == "dropvest" ) then
		if ply == LocalPlayer() then
			DropCurrentVest()
		end
		return true
	end
end)

// Blinking system

blinkHUDTime = 0
btime = 0
blink_end = 0
blink = false

local dishudnf = false
local wasdisabled = false

function DisableHUDNextFrame()
	dishudnf = true
end

function CLTick()
	if postround == false and isnumber(drawendmsg) then
		drawendmsg = nil
	end

	if clang == nil then
		clang = english
	end

	if cwlang == nil then
		cwlang = english
	end

	if blinkHUDTime >= 0 then 
		blinkHUDTime = btime - CurTime()
	end

	if blinkHUDTime < 0 then blinkHUDTime = 0 end

	if dishudnf then
		if !disablehud then
			wasdisabled = disablehud
			disablehud = true
		end

		dishudnf = false
	elseif disablehud and wasdisabled == false then
		disablehud = false
	end

	if shoulddrawinfo then
		if CurTime() > drawinfodelete then
			shoulddrawinfo = false
			drawinfodelete = 0
		end
	end

	if CurTime() > blink_end then
		blink = false
	end
end
-- Hook usunięty - wyświetlanie nazw klas nad głowami graczy wyłączone

-- Hook usunięty - duplikat wyświetlania nazw klas nad głowami graczy

hook.Add( "Tick", "client_tick_hook", CLTick )

function Blink( time )
	blink = true
	blink_end = CurTime() + time
	btime = CurTime() + GetConVar("br_time_blinkdelay"):GetFloat() + time
end

net.Receive("PlayerBlink", function(len)
	local time = net.ReadFloat()
	Blink( time )
end)

net.Receive( "PlayerReady", function()
	local tab = net.ReadTable()
	sR = tab[1]
	sL = tab[2]
end )

net.Receive( "689", function( len )
	if LocalPlayer():GetNClass() == ROLES.ROLE_SCP689 then
		local targets = net.ReadTable()
		if targets then
			local swep = LocalPlayer():GetWeapon( "weapon_scp_689" )
			if IsValid( swep ) then
				swep.Targets = targets
			end
		end
	end
end )

net.Receive("Effect", function()
	LocalPlayer().mblur = net.ReadBool()
end )

local mat_blink = CreateMaterial( "blink_material", "UnlitGeneric", {
	["$basetexture"] = "models/debug/debugwhite",
	["$color"] = "{ 0 0 0 }"
} )

local mat_color = Material( "pp/colour" ) -- used outside of the hook for performance
hook.Add( "RenderScreenspaceEffects", "blinkeffects", function()
	if blink then
		render.SetMaterial( mat_blink )
		render.DrawScreenQuad()
		return
	end
	
	-- Efekty SCP-966 wyłączone
	--[[
	if LocalPlayer().mblur == nil then LocalPlayer().mblur = false end
	if ( LocalPlayer().mblur == true ) then
		DrawMotionBlur( 0.3, 0.8, 0.03 )
	end
	--]]
	
	local contrast = 1
	local colour = 1
	local nvgbrightness = 0
	local clr_r = 0
	local clr_g = 0
	local clr_b = 0
	local bloommul = 0  -- Zmniejszono z 1.2 aby zapobiec nadmiernemu świeceniu białych obszarów
	
	if LocalPlayer().n420endtime and LocalPlayer().n420endtime > CurTime() then
		DrawMotionBlur( 1 - ( LocalPlayer().n420endtime - CurTime() ) / 15 , 0.3, 0.025 )
		DrawSharpen( ( LocalPlayer().n420endtime - CurTime() ) / 3, ( LocalPlayer().n420endtime - CurTime() ) / 20 )
		clr_r = ( LocalPlayer().n420endtime - CurTime() ) * 2
		clr_g = ( LocalPlayer().n420endtime - CurTime() ) * 2
		clr_b = ( LocalPlayer().n420endtime - CurTime() ) * 2
	end
	
--	last996attack = last996attack - 0.002
--	if last996attack < 0 then
--		last996attack = 0
--	else
--		DrawMotionBlur( 1 - last996attack, 1, 0.05 )
--		DrawSharpen( last996attack,2 )
--		contrast = last996attack
--	end
	if IsValid(LocalPlayer():GetActiveWeapon()) then
		-- Old automatic NVG detection removed
		-- Now use toggle system
	end
	
	-- New NVG toggle system
	if LocalPlayer().NVGActive then
			nvgbrightness = 0.2
			DrawSobel( 0.7 )
	end
	
	if livecolors then
		contrast = 1.2  -- Zmniejszono z 1.1
		colour = 1.6     -- Zmniejszono z 1.5
		bloommul = 2   -- Zmniejszono z 2
	end
	-- Efekty niskiego HP wyłączone
	--[[
	if LocalPlayer():Health() < 30 and LocalPlayer():Alive() then
		colour = math.Clamp((LocalPlayer():Health() / LocalPlayer():GetMaxHealth()) * 5, 0, 2)
		DrawMotionBlur( 0.27, 0.5, 0.01 )
		DrawSharpen( 1,2 )
		DrawToyTown( 3, ScrH() / 1.8 )
	end
	--]]
	render.UpdateScreenEffectTexture()

	
	mat_color:SetTexture( "$fbtexture", render.GetScreenEffectTexture() )
	
	mat_color:SetFloat( "$pp_colour_brightness", nvgbrightness )
	mat_color:SetFloat( "$pp_colour_contrast", contrast)
	mat_color:SetFloat( "$pp_colour_colour", colour )
	mat_color:SetFloat( "$pp_colour_mulr", clr_r )
	mat_color:SetFloat( "$pp_colour_mulg", clr_g )
	mat_color:SetFloat( "$pp_colour_mulb", clr_b )
	
	render.SetMaterial( mat_color )
	render.DrawScreenQuad()
	//DrawBloom( Darken, Multiply, SizeX, SizeY, Passes, ColorMultiply, Red, Green, Blue )
	-- Zmniejszono parametry bloom aby zapobiec świeceniu białych kolorów
	DrawBloom( 0.75, bloommul, 7, 7, 1, 0.8, 1, 1, 1 )
end )

local dropnext = 0
function GM:PlayerBindPress( ply, bind, pressed )
	if bind == "+menu" then
		if GetConVar( "br_new_eq" ):GetInt() != 1 then
			DropCurrentWeapon()
		end
	elseif bind == "gm_showteam" then
		OpenClassMenu()
	elseif bind == "+menu_context" then
		thirdpersonenabled = !thirdpersonenabled
	end
end

function DropCurrentWeapon()
	if dropnext > CurTime() then return true end
	dropnext = CurTime() + 0.5
	net.Start("DropCurWeapon")
	net.SendToServer()
	if LocalPlayer().channel != nil then
		LocalPlayer().channel:EnableLooping( false )
		LocalPlayer().channel:Stop()
		LocalPlayer().channel = nil
	end
	return true
end

concommand.Add("br_requestescort", function()
	if !((LocalPlayer():GTeam() == TEAM_GUARD or LocalPlayer():GTeam() == TEAM_CHAOS) or LocalPlayer():GTeam() == TEAM_CHAOS) then return end
	net.Start("RequestEscorting")
	net.SendToServer()
end)

concommand.Add("br_requestNTFspawn", function( ply, cmd, args )
	if ply:IsSuperAdmin() then
		net.Start("NTFRequest")
		net.SendToServer()
	end
end )

concommand.Add("br_destroygatea", function( ply, cmd, args)
	if ( ply:GetNClass() == ROLES.ROLE_MTFNTF or ply:GetNClass() == ROLES.ROLE_CHAOS or ply:GTeam() == TEAM_GOC ) then
		net.Start("ExplodeRequest")
		net.SendToServer()
	end
end )

concommand.Add("br_sound_random", function()
	if (LocalPlayer():GTeam() == TEAM_GUARD or LocalPlayer():GTeam() == TEAM_CHAOS) and LocalPlayer():Alive() then
		net.Start("Sound_Random")
		net.SendToServer()
	end
end)

concommand.Add("br_sound_searching", function()
	if (LocalPlayer():GTeam() == TEAM_GUARD or LocalPlayer():GTeam() == TEAM_CHAOS) and LocalPlayer():Alive() then
		net.Start("Sound_Searching")
		net.SendToServer()
	end
end)

concommand.Add("br_sound_classd", function()
	if (LocalPlayer():GTeam() == TEAM_GUARD or LocalPlayer():GTeam() == TEAM_CHAOS) and LocalPlayer():Alive() then
		net.Start("Sound_Classd")
		net.SendToServer()
	end
end)

concommand.Add("br_sound_stop", function()
	if (LocalPlayer():GTeam() == TEAM_GUARD or LocalPlayer():GTeam() == TEAM_CHAOS) and LocalPlayer():Alive() then
		net.Start("Sound_Stop")
		net.SendToServer()
	end
end)

concommand.Add("br_sound_lost", function()
	if (LocalPlayer():GTeam() == TEAM_GUARD or LocalPlayer():GTeam() == TEAM_CHAOS) and LocalPlayer():Alive() then
		net.Start("Sound_Lost")
		net.SendToServer()
	end
end)
/*
function CalcView3DPerson( ply, pos, angles, fov )
	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false
	if thirdpersonenabled then
		local eyepos = ply:EyePos()
		local eyeangles = ply:EyeAngles()
		local point = ply:GetEyeTrace().HitPos
		local goup = 2
		if ply:Crouching() then
			goup = 20
		end
		view.drawviewer = true
		view.origin = eyepos + Vector(0,0,goup) - (eyeangles:Forward() * 30) + (eyeangles:Right() * 20)
		view.angles = (point - view.origin):Angle()
		local endps = eyepos + Vector(0,0,goup) - (eyeangles:Forward() * 30) + (eyeangles:Right() * 15)
		local tr = util.TraceLine( { start = eyepos, endpos = endps} )
		if tr.Hit then
			view.origin = tr.HitPos
		end
	end
	return view
end
hook.Add( "CalcView", "CalcView3DPerson", CalcView3DPerson )
*/

/*function GM:HUDDrawPickupHistory()

end*/

/*function GM:HUDWeaponPickedUp( weapon )
end*/

hook.Add( "HUDWeaponPickedUp", "DonNotShowCards", function( weapon )
	EQHUD.weps = LocalPlayer():GetWeapons()
	if weapon:GetClass() == "br_keycard" then return false end
end )

function GM:CalcView( ply, origin, angles, fov )
	local data = {}
	data.origin = origin
	data.angles = angles
	data.fov = fov
	data.drawviewer = false
	local item = ply:GetActiveWeapon()
	if IsValid( item ) then
		if item.CalcView then
			local vec, ang, ifov, dw = item:CalcView( ply, origin, angles, fov )
			if vec then data.origin = vec end
			if ang then data.angles = ang end
			if ifov then data.fov = ifov end
			if dw != nil then data.drawviewer = dw end
		end
	end

	if CamEnable then
		--print( "enabled" )
		if !timer.Exists( "CamViewChange" ) then
			timer.Create( "CamViewChange", 1, 1, function()
				CamEnable = false
			end )
		end
		data.drawviewer = true
		dir = dir or Vector( 0, 0, 0 )
		--print( dir )
		data.origin = ply:GetPos() - dir - dir:GetNormalized() * 30 + Vector( 0, 0, 80 )
		data.angles = Angle( 10, dir:Angle().y, 0 )
	end

	return data
end

function GetWeaponLang()
	if cwlang then
		return cwlang
	end
end

local PrecachedSounds = {}
function ClientsideSound( file, ent )
	ent = ent or game.GetWorld()
	local sound
	if !PrecachedSounds[file] then
		sound = CreateSound( ent, file, nil )
		PrecachedSounds[file] = sound
		return sound
	else
		sound = PrecachedSounds[file]
		sound:Stop()
		return sound
	end
end

net.Receive( "SendSound", function( len )
	local com = net.ReadInt( 2 )
	local f = net.ReadString()
	if com == 1 then
		local snd = ClientsideSound( f )
		snd:SetSoundLevel( 0 )
		snd:Play()
	elseif com == 0 then
		ClientsideSound( f )
	end
end )

concommand.Add( "br_dropweapon", function( ply )
		net.Start("DropCurWeapon")
		net.SendToServer()
end )

/*if !file.Exists( "breach", "DATA" ) then
	file.CreateDir( "breach" )
end

if !file.Exists( "breach/intro.dat", "DATA" ) then
	PlayIntro( 2 )
else
	if GetConVar( "br_force_showupdates" ):GetInt() != 0 then
		showupdates = true
		PlayIntro( 5 )
	else
		local res = file.Read( "breach/intro.dat" )
		if string.match( res, "true" ) then
			showupdates = true
			PlayIntro( 4 )
		end
	end
	timer.Simple( 1, function()
		net.Start( "PlayerReady" )
		net.SendToServer()
	end )
end

concommand.Add( "br_reset_intro", function( ply )
	if file.Exists( "breach/intro.dat", "DATA" ) then
		file.Delete( "breach/intro.dat" )
	end
end ) 

concommand.Add( "br_show_update", function( ply )
	PlayIntro( 5 )
end ) */

function  GM:SetupWorldFog()
	if LocalPlayer():GetNClass() == ROLES.ROLE_SCP9571 then
		if OUTSIDE_BUFF and OUTSIDE_BUFF( ply:GetPos() ) then return end
		render.FogMode( MATERIAL_FOG_LINEAR )
		render.FogColor( 0, 0, 0 )
		render.FogStart( 250 )
		render.FogEnd( 500 )
		render.FogMaxDensity( 1 )
		return true
	end

	if !Effect957 then return end

	if Effect957Mode == 0 then
		if Effect957Density < 1 then
			Effect957Density = math.Clamp( math.abs( Effect957 - CurTime() ), 0, 1 )
		elseif Effect957Density >= 1 then
			Effect957 = CurTime() + 3
			Effect957Mode = 1
		end
	elseif Effect957Mode == 1 then
		Effect957Density = 1
		if Effect957 < CurTime() then
			Effect957 = CurTime() + 1
			Effect957Mode = 2
		end
	else
		Effect957Density = math.Clamp( Effect957 - CurTime(), 0, 1 )
		if Effect957Density == 0 then
			Effect957 = false
			Effect957Mode = 0
		end
	end



	render.FogMode( MATERIAL_FOG_LINEAR )
	render.FogColor( 0, 0, 0 )
	render.FogStart( 50 )
	render.FogEnd( 250 )
	render.FogMaxDensity( Effect957Density )
	return true
end

Effect957 = false
Effect957Density = 0
Effect957Mode = 0
net.Receive( "957Effect", function( len )
	local status = net.ReadBool()
	if status then
		Effect957 = CurTime()
		Effect957Mode = 0
	elseif Effect957 then
		//Effect957 = false
		Effect957Mode = 2
		Effect957 = CurTime() + 1
	end
end )

net.Receive( "SCPList", function( len )
	SCPS = net.ReadTable()
	local transmited = net.ReadTable()

	for k, v in pairs( SCPS ) do
		ROLES["ROLE_"..v] = v
	end
	for k, v in pairs( transmited ) do
		ROLES["ROLE_"..v] = v
	end
	--InitializeBreachULX()
	SetupForceSCP()
end )

timer.Simple( 1, function()
	net.Start( "PlayerReady" )
	net.SendToServer()
end )

print( "client ready" )

-- PSYCHOLOGIST PASSIVE ABILITIES - CLIENT SIDE
-- Initialize after ROLES are loaded
timer.Simple( 2, function()
	-- Footstep traces storage
	local FootstepTraces = {}

	-- Team colors for footstep traces (simplified to 2 colors)
	local TeamColors = {
		[TEAM_SCI] = Color(0, 255, 0, 150),     -- Green for Scientists
		[TEAM_GUARD] = Color(0, 255, 0, 150),   -- Green for MTF
		[TEAM_CHAOS] = Color(255, 0, 0, 150),   -- Red for Chaos
		[TEAM_SCP] = Color(255, 0, 0, 150),     -- Red for SCPs
		[TEAM_GOC] = Color(255, 0, 0, 150),     -- Red for GOC (enemy)
		[TEAM_CLASSD] = Color(255, 0, 0, 150),  -- Red for Class-D (enemy)
		-- TEAM_SPEC removed - spectators don't leave footsteps
	}

	-- Receive footstep data from server
	net.Receive("Psychologist_AddFootstep", function()
		local pos = net.ReadVector()
		local team = net.ReadInt(8)
		local timestamp = net.ReadFloat()
		
		-- Only show if local player is psychologist
		if ROLES and ROLES.ROLE_PSYCHOLOGIST and IsValid(LocalPlayer()) and LocalPlayer():GetNClass() == ROLES.ROLE_PSYCHOLOGIST then
			table.insert(FootstepTraces, {
				pos = pos,
				team = team,
				time = timestamp,
				alpha = 150
			})
		end
	end)

	-- Render footstep traces and healing aura
	hook.Add("PostDrawOpaqueRenderables", "Psychologist_DrawFootsteps", function()
		-- Only render if local player is psychologist
		if not ROLES or not ROLES.ROLE_PSYCHOLOGIST or not IsValid(LocalPlayer()) or LocalPlayer():GetNClass() != ROLES.ROLE_PSYCHOLOGIST then
			FootstepTraces = {} -- Clear traces if not psychologist
			return
		end
		
		local ply = LocalPlayer()
		local currentTime = CurTime()
		
		-- Draw healing aura radius on ground (only when actively healing someone)
		if ply:Alive() then
			local pos = ply:GetPos()
			local radius = 125 -- Same as server-side healing radius
			
			-- Check if there are players in range that need healing
			local isHealing = false
			for _, target in pairs(player.GetAll()) do
				if IsValid(target) and target:Alive() and target != ply then
					local distance = pos:Distance(target:GetPos())
					if distance <= radius then
						-- Check if player is from supported teams/roles and needs healing
						local team = target:GTeam()
						local class = target:GetNClass()
						
						-- Heal: Scientists, MTF, and CI Spy only (not all Chaos)
						if (team == TEAM_SCI or team == TEAM_GUARD or (team == TEAM_CHAOS and class == ROLES.ROLE_CHAOSSPY)) then
							local currentHP = target:Health()
							if currentHP < 50 and currentHP > 0 then
								isHealing = true
								break
							end
						end
					end
				end
			end
			
			-- Only draw circle if actively healing someone
			if isHealing then
				-- Trace downward to find ground
				local traceDown = util.TraceLine({
					start = pos,
					endpos = pos + Vector(0, 0, -100),
					filter = ply
				})
				
				if traceDown.Hit then
					local groundPos = traceDown.HitPos + Vector(0, 0, 1)
					
					-- Draw healing aura circle on ground
					render.SetColorMaterial()
					
					-- Draw multiple circles for better visibility
					for i = 1, 3 do
						local alpha = 30 - (i * 8) -- Fade outward
						local currentRadius = radius + (i * 5)
						
						-- Draw circle segments
						local segments = 32
						for seg = 0, segments - 1 do
							local angle1 = (seg / segments) * math.pi * 2
							local angle2 = ((seg + 1) / segments) * math.pi * 2
							
							local pos1 = groundPos + Vector(math.cos(angle1) * currentRadius, math.sin(angle1) * currentRadius, 0)
							local pos2 = groundPos + Vector(math.cos(angle2) * currentRadius, math.sin(angle2) * currentRadius, 0)
							
							render.DrawBeam(pos1, pos2, 2, 0, 1, Color(0, 255, 150, alpha))
						end
					end
					
					-- Draw center indicator
					render.DrawSphere(groundPos, 3, 8, 8, Color(0, 255, 150, 100))
				end
			end
		end
		
		-- Update and render footstep traces
		for i = #FootstepTraces, 1, -1 do
			local trace = FootstepTraces[i]
			local age = currentTime - trace.time
			
			-- Remove traces older than 15 seconds (2x faster)
			if age > 7 then
				table.remove(FootstepTraces, i)
			else
				-- Calculate alpha based on age (fade over 15 seconds)
				local fadeAlpha = math.max(0, 150 * (1 - age / 15))
				
				-- Determine color: Green for allies (MTF/Scientists/CI Spy), Red for enemies
				local color
				if trace.team == 99 or trace.team == TEAM_SCI or trace.team == TEAM_GUARD then
					color = TeamColors[TEAM_SCI] -- Green for allies (99 = CI Spy)
				else
					color = TeamColors[TEAM_SCP] -- Red for enemies
				end
				color.a = fadeAlpha
				
				-- Render smaller footstep trace
				render.SetColorMaterial()
				render.DrawSphere(trace.pos + Vector(0, 0, 2), 5, 8, 8, color) -- Smaller: 5 instead of 8
				
				-- Add a small upward effect
				render.DrawSphere(trace.pos + Vector(0, 0, 8), 2, 6, 6, Color(color.r, color.g, color.b, fadeAlpha * 0.5)) -- Smaller: 2 instead of 4
			end
		end
	end)
end)

-- Receive NVG toggle from server
net.Receive("NVG_Toggle", function()
	LocalPlayer().NVGActive = net.ReadBool()
end)

-- Clear NVG effect when player dies
hook.Add("PlayerDeath", "ClearNVGOnDeath", function(victim, inflictor, attacker)
	if victim == LocalPlayer() then
		LocalPlayer().NVGActive = false
	end
end)

-- Clear NVG effect when player spawns
hook.Add("PlayerSpawn", "ClearNVGOnSpawn", function(ply)
	if ply == LocalPlayer() then
		LocalPlayer().NVGActive = false
	end
end)


================================================
FILE: gamemodes/breach/gamemode/modules/cl_mtfmenu.lua
================================================


if not MTFMenuFrame then
	MTFMenuFrame = nil
end

nextmenudelete = 0
showmenu = false

function GM:KeyPress( ply, key )
	if ( key == IN_ZOOM ) then
		OpenMenu()
	end
end

function GM:KeyRelease( ply, key )
	if ( key == IN_ZOOM ) then
		CloseMTFMenu()
	end
end

function CloseMTFMenu()
	if ispanel(MTFMenuFrame) then
		if MTFMenuFrame.Close then
			MTFMenuFrame:Close()
		end
	end
end

function OpenMenu()
	if IsValid(MTFMenuFrame) then return end
	local ply = LocalPlayer()
	if !(ply:GTeam() == TEAM_GUARD or ply:GTeam() == TEAM_CHAOS or ply:GTeam() == TEAM_GOC) then return end
	
	MTFMenuFrame = vgui.Create( "DFrame" )
	MTFMenuFrame:SetTitle( "" )
	MTFMenuFrame:SetSize( 265, 375 )
	MTFMenuFrame:Center()
	MTFMenuFrame:SetDraggable( true )
	MTFMenuFrame:SetDeleteOnClose( true )
	MTFMenuFrame:SetDraggable( false )
	MTFMenuFrame:ShowCloseButton( true )
	MTFMenuFrame:MakePopup()
	MTFMenuFrame.Paint = function( self, w, h )
		draw.RoundedBox( 2, 0, 0, w, h, Color(0, 0, 0) )
		draw.RoundedBox( 2, 1, 1, w - 2, h - 2, Color(90, 90, 95) )
	end
	
	local maininfo = vgui.Create( "DLabel", MTFMenuFrame )
	maininfo:SetText( "Mobile Task Force Manager" )
	maininfo:Dock( TOP )
	maininfo:SetFont("MTF_2Main")
	maininfo:SetContentAlignment( 5 )
	//maininfo:DockMargin( 245, 8, 8, 175 )
	maininfo:SetSize(0,24)
	maininfo.Paint = function( self, w, h )
		draw.RoundedBox( 2, 0, 0, w, h, Color(0, 0, 0) )
		draw.RoundedBox( 2, 1, 1, w - 2, h - 2, Color(90, 90, 95) )
	end
	
	local button_gatea = vgui.Create( "DButton", MTFMenuFrame )
	button_gatea:SetText( "Destroy Gate A" )
	button_gatea:Dock( TOP )
	button_gatea:SetFont("MTF_Main")
	button_gatea:SetContentAlignment( 5 )
	button_gatea:DockMargin( 0, 5, 0, 0	)
	button_gatea:SetSize(0,32)
	button_gatea.DoClick = function()
		RunConsoleCommand("br_destroygatea")
		MTFMenuFrame:Close()
	end

	local button_escort = vgui.Create( "DButton", MTFMenuFrame )
	button_escort:SetText( "Request Escorting" )
	button_escort:Dock( TOP )
	button_escort:SetFont("MTF_Main")
	button_escort:SetContentAlignment( 5 )
	button_escort:DockMargin( 0, 5, 0, 0	)
	button_escort:SetSize(0,32)
	button_escort.DoClick = function()
		RunConsoleCommand("br_requestescort")
		MTFMenuFrame:Close()
	end
	local button_escort = vgui.Create( "DButton", MTFMenuFrame )
	button_escort:SetText( "Sound: Random" )
	button_escort:Dock( TOP )
	button_escort:SetFont("MTF_Main")
	button_escort:SetContentAlignment( 5 )
	button_escort:DockMargin( 0, 5, 0, 0	)
	button_escort:SetSize(0,32)
	button_escort.DoClick = function()
		RunConsoleCommand("br_sound_random")
		MTFMenuFrame:Close()
	end
	local button_escort = vgui.Create( "DButton", MTFMenuFrame )
	button_escort:SetText( "Sound: Searching" )
	button_escort:Dock( TOP )
	button_escort:SetFont("MTF_Main")
	button_escort:SetContentAlignment( 5 )
	button_escort:DockMargin( 0, 5, 0, 0	)
	button_escort:SetSize(0,32)
	button_escort.DoClick = function()
		RunConsoleCommand("br_sound_searching")
		MTFMenuFrame:Close()
	end
	local button_escort = vgui.Create( "DButton", MTFMenuFrame )
	button_escort:SetText( "Sound: Class D Found" )
	button_escort:Dock( TOP )
	button_escort:SetFont("MTF_Main")
	button_escort:SetContentAlignment( 5 )
	button_escort:DockMargin( 0, 5, 0, 0	)
	button_escort:SetSize(0,32)
	button_escort.DoClick = function()
		RunConsoleCommand("br_sound_classd")
		MTFMenuFrame:Close()
	end
	local button_escort = vgui.Create( "DButton", MTFMenuFrame )
	button_escort:SetText( "Sound: Stop!" )
	button_escort:Dock( TOP )
	button_escort:SetFont("MTF_Main")
	button_escort:SetContentAlignment( 5 )
	button_escort:DockMargin( 0, 5, 0, 0	)
	button_escort:SetSize(0,32)
	button_escort.DoClick = function()
		RunConsoleCommand("br_sound_stop")
		MTFMenuFrame:Close()
	end
	local button_escort = vgui.Create( "DButton", MTFMenuFrame )
	button_escort:SetText( "Sound: Target Lost" )
	button_escort:Dock( TOP )
	button_escort:SetFont("MTF_Main")
	button_escort:SetContentAlignment( 5 )
	button_escort:DockMargin( 0, 5, 0, 0	)
	button_escort:SetSize(0,32)
	button_escort.DoClick = function()
		RunConsoleCommand("br_sound_lost")
		MTFMenuFrame:Close()
	end
end







================================================
FILE: gamemodes/breach/gamemode/modules/cl_sam_breach.lua
================================================
-- SAM Breach Client Integration
if SERVER then return end

-- Sprawdź czy SAM jest dostępny
if not sam or not sam.netstream then 
	print("[SAM Breach Client] SAM netstream not available")
	return 
end

print("[SAM Breach Client] Loading client-side functions...")

-- Hook dla kolorowego tsay
sam.netstream.Hook("breach_tsay_display", function(data)
	local message = data.message
	local admin = data.admin
	
	-- Wyświetl kolorową wiadomość na środku ekranu
	local function DisplayTsayMessage()
		local scrW, scrH = ScrW(), ScrH()
		
		-- Tło wiadomości
		local bgColor = Color(0, 0, 0, 200)
		local textColor = Color(255, 255, 255, 255)
		local adminColor = Color(255, 100, 100, 255)
		
		-- Panel dla wiadomości
		local panel = vgui.Create("DPanel")
		panel:SetSize(scrW * 0.6, 120)
		panel:SetPos(scrW * 0.2, scrH * 0.3)
		panel:SetBackgroundColor(bgColor)
		
		-- Tytuł
		local titleLabel = vgui.Create("DLabel", panel)
		titleLabel:SetText("ADMIN MESSAGE")
		titleLabel:SetFont("DermaLarge")
		titleLabel:SetTextColor(adminColor)
		titleLabel:SizeToContents()
		titleLabel:SetPos(10, 10)
		
		-- Wiadomość
		local messageLabel = vgui.Create("DLabel", panel)
		messageLabel:SetText(message)
		messageLabel:SetFont("DermaDefaultBold")
		messageLabel:SetTextColor(textColor)
		messageLabel:SetWrap(true)
		messageLabel:SetAutoStretchVertical(true)
		messageLabel:SetPos(10, 40)
		messageLabel:SetWide(panel:GetWide() - 20)
		
		-- Admin info
		if admin then
			local adminLabel = vgui.Create("DLabel", panel)
			adminLabel:SetText("- " .. admin)
			adminLabel:SetFont("DermaDefault")
			adminLabel:SetTextColor(adminColor)
			adminLabel:SizeToContents()
			adminLabel:SetPos(panel:GetWide() - adminLabel:GetWide() - 10, panel:GetTall() - 25)
		end
		
		-- Animacja pojawiania się
		panel:SetAlpha(0)
		panel:AlphaTo(255, 0.5, 0, function()
			-- Automatyczne znikanie po 8 sekundach
			timer.Simple(8, function()
				if IsValid(panel) then
					panel:AlphaTo(0, 1, 0, function()
						if IsValid(panel) then
							panel:Remove()
						end
					end)
				end
			end)
		end)
		
		-- Dźwięk powiadomienia
		surface.PlaySound("buttons/button15.wav")
	end
	
	DisplayTsayMessage()
end)

print("[SAM Breach Client] Client functions loaded successfully")


================================================
FILE: gamemodes/breach/gamemode/modules/cl_scoreboard.lua
================================================
// Made by Kanade

if not Frame then
	Frame = nil
end

surface.CreateFont("sb_names", {font = "Trebuchet18", size = 14, weight = 700})

helpers = {
	"76561198340681626",
	"76561198179611206",
	"76561198356377528",
}

originators = {
	"76561198079069017",
	"76561198174088183",
	"76561198358493307",
	"76561198108330803",
	"76561198337913733",
}
ranks = {
	author = {
		color = Color(70, 50, 220, 255),
		textcolor = Color(0, 0, 0, 255),
		text = function() return clang.author end,
		check = function( ply )
			if ply:SteamID64() == "76561198110788144" or ply:SteamID64() == "76561198156389563" then
				return true
			end
		end,
		sorting = 0
	},
	vip = {
		color = Color(220, 220, 50, 255),
		textcolor = Color(0, 0, 0, 255),
		text = "VIP",
		check = function( ply )
			if ply:GetNPremium() then
				return true
			end
		end,
		sorting = 1
	},
	helper = {
		color = Color(100, 100, 100, 255),
		textcolor = Color(0, 0, 0, 255),
		text = function() return clang.helper end,
		check = function( ply )
			if IsInTable( helpers, ply:SteamID64() ) then
				return true
			end
		end,
		sorting = 2
	},
	originator = {
		color = Color(255, 192, 203, 255),
		textcolor = Color(0, 0, 0, 255),
		text = function() return clang.originator end,
		check = function( ply )
			if IsInTable( originators, ply:SteamID64() ) then
				return true
			end
		end,
		sorting = 3
	},
}
--------------------------------------------------------------------
function RanksEnabled()
	return GetConVar("br_scoreboardranks"):GetBool()
end

function firstToUpper(str)
    return (str:gsub("^%l", string.upper))
end

function role_GetPlayers(role)
	local all = {}
	for k,v in pairs(player.GetAll()) do
		if v:Alive() then
			if not v.GetNClass then
				player_manager.RunClass( v, "SetupDataTables" )
			end
			
			if v.GetNClass then
				if v:GetNClass() == role then
					table.ForceInsert(all, v)
				end
			end
		end
	end
	return all
end
								  
function ShowScoreBoard()
	local ply = LocalPlayer()
	local allplayers = {}
	table.Add(allplayers, player.GetAll())
	
	local known = {}
	local unknown = {}
	
	for k,v in pairs(allplayers) do
		if !v.GetNClass or !v.GetNPremium then
			player_manager.RunClass( v, "SetupDataTables" )
			--IsPremium( v, true )
		end
		
		-- Usunięto problematyczną logikę naprawy GetNActive
		
		table.ForceInsert(unknown, v)
		v.knownrole = clang.class_unknown or "Unknown"
		v.known = false
	end
	
	for k,v in pairs(SAVEDIDS) do
		if IsValid(v.pl) then
			if v.id != nil then
				if isstring(v.id) then
					v.pl.knownrole = v.id
					v.pl.known = true
					table.ForceInsert(known, v.pl)
					table.RemoveByValue(unknown, v.pl)
				end
			end
		end
	end
	
	//if LocalPlayer():SteamID64() != "76561198156389563" then
		table.ForceInsert(known, LocalPlayer())
		LocalPlayer().knownrole = LocalPlayer():GetNClass()
		table.RemoveByValue(unknown, LocalPlayer())
	//end
	
	-- SCP widzą innych SCP z ich ID/nazwami klas
	-- Również spektatorzy którzy byli SCP (po śmierci) nadal widzą SCP
	local canSeeSCP = false
	if LocalPlayer():GTeam() == TEAM_SCP then
		canSeeSCP = true
	elseif LocalPlayer():GTeam() == TEAM_SPEC and LocalPlayer():GetNClass() then
		-- Sprawdź czy spektator był SCP (ma SCP klasę)
		local playerClass = LocalPlayer():GetNClass()
		for scpName, scpData in pairs(ROLES) do
			if scpData == playerClass and string.find(scpName, "SCP") then
				canSeeSCP = true
				break
			end
		end
	end
	
	if canSeeSCP then
		for k, v in pairs(allplayers) do
			if v:GTeam() == TEAM_SCP and v != LocalPlayer() then
				-- Sprawdź czy gracz już nie jest w known (żeby uniknąć duplikatów)
				local alreadyKnown = false
				for _, knownPlayer in pairs(known) do
					if knownPlayer == v then
						alreadyKnown = true
						break
					end
				end
				
				if not alreadyKnown then
					-- Dodaj SCP do known players z ich klasą
					table.ForceInsert(known, v)
					v.knownrole = v:GetNClass()
					v.known = true
					table.RemoveByValue(unknown, v)
				end
			end
		end
	end
	
	local playerlist = {}
	
	table.ForceInsert(playerlist,{
		name = "Known Players",
		list = known,
		color = gteams.GetColor( TEAM_CLASSD ),
		color2 = color_white
	})
	table.ForceInsert(playerlist,{
		name = "Unknown Players",
		list = unknown,
		color = color_white,
		color2 = color_black
	})
	
	for k,v in pairs(player.GetAll()) do
		local gteam = v:GTeam()
		if gteam == TEAM_SCP then
			v.imp = 1
		elseif gteam == TEAM_CLASSD then
			v.imp = 2
		elseif gteam == TEAM_SCI then
			v.imp = 3
		elseif gteam == TEAM_MTF then
			v.imp = 4
		elseif gteam == TEAM_CHAOS then
			v.imp = 4
		else
			v.imp = 0
		end
		if ranks.author.check( v ) then	
			v.imp = 100
		elseif ranks.helper.check( v ) then	
			v.imp = 80
		elseif ranks.originator.check( v ) then	
			v.imp = 70
--		elseif ranks.vip.check( v ) then	
--			v.imp = 60
		elseif ranks.vip.check( v ) then	
			v.imp = 50
		end
	end
	
	// Sort all
	table.sort( playerlist[2].list, function( a, b ) return a.imp > b.imp end )
	table.sort( playerlist[1].list, function( a, b ) return a.imp > b.imp end )
	//table.sort( playerlist[2].list, function( a, b ) return a:Frags() > b:Frags() end )
	//table.sort( playerlist[1].list, function( a, b ) return a:GetNClass() == b:GetNClass() end )
	//for k,v in pairs(playerlist) do
	//	table.sort( v.list, function( a, b ) return a:Frags() > b:Frags() end )
	//end
	
	local color_main = 45
	
	Frame = vgui.Create( "DFrame" )
	Frame:Center()
	Frame:SetSize(ScrW(), ScrH() )
	Frame:SetTitle( "" )
	Frame:SetVisible( true )
	Frame:SetDraggable( true )
	Frame:SetDeleteOnClose( true )
	Frame:SetDraggable( false )
	Frame:ShowCloseButton( false )
	Frame:Center()
	Frame:MakePopup()
	Frame.Paint = function( self, w, h ) end
	

	local width = 25
	
	local mainpanel = vgui.Create( "DPanel", Frame )
	mainpanel:SetSize(ScrW() / 1.5, ScrH() / 1.3)
	mainpanel:CenterHorizontal( 0.5 )
	mainpanel:CenterVertical( 0.5 )
	mainpanel.Paint = function( self, w, h )
		--draw.RoundedBox( 0, 0, 0, w, h, Color( color_main, color_main, color_main, 240 ) )
	end
	
	-- Panel z informacjami o serwerze (liczba graczy i godzina)
	local info_panel = vgui.Create( "DPanel", mainpanel )
	info_panel:Dock( TOP )
	info_panel:DockMargin( 8, 8, 8, 0 )
	info_panel:SetSize( 0, 30 )
	info_panel.Paint = function( self, w, h )
		-- Liczba graczy
		local playerCount = #player.GetAll()
		local maxPlayers = game.MaxPlayers()
		local playerText = "Players: " .. playerCount .. "/" .. maxPlayers
		
		-- Typ rundy
		local roundTypeText = ""
		if roundtype and roundtype != nil then
			roundTypeText = "Round Type: " .. roundtype
		end
		
		-- Aktualna godzina
		local timeText = os.date("%H:%M:%S")
		
		-- Rysuj tło takie samo jak paski graczy
		draw.RoundedBox( 0, 0, 0, w, h, Color( 80, 80, 80, 180 ) )
		
		-- Rysuj tekst z liczbą graczy (po lewej)
		draw.Text( {
			text = playerText,
			pos = { 10, h / 2 },
			font = "sb_names",
			color = Color(255, 255, 255, 255),
			xalign = TEXT_ALIGN_LEFT,
			yalign = TEXT_ALIGN_CENTER
		})
		
		-- Rysuj typ rundy (w środku)
		if roundTypeText != "" then
			draw.Text( {
				text = roundTypeText,
				pos = { w / 2, h / 2 },
				font = "sb_names",
				color = Color(255, 130, 0, 255),
				xalign = TEXT_ALIGN_CENTER,
				yalign = TEXT_ALIGN_CENTER
			})
		end
		
		-- Rysuj godzinę (po prawej)
		draw.Text( {
			text = timeText,
			pos = { w - 10, h / 2 },
			font = "sb_names",
			color = Color(255, 255, 255, 255),
			xalign = TEXT_ALIGN_RIGHT,
			yalign = TEXT_ALIGN_CENTER
		})
	end

	local panel_backg = vgui.Create( "DPanel", mainpanel )
	panel_backg:Dock( FILL )
	panel_backg:DockMargin( 8, 0, 8, 8 )
	panel_backg.Paint = function( self, w, h )
		--draw.RoundedBox( 0, 0, 0, w, h, Color( color_main, color_main, color_main, 180 ) )
	end
	
	local DScrollPanel = vgui.Create( "DScrollPanel", panel_backg )
	DScrollPanel:Dock( FILL )
	
	local color_dark = Color( 35, 35, 35, 180 )
	local color_light = Color(80,80,80,180)

	local panelname_backg = vgui.Create( "DPanel", DScrollPanel )
	panelname_backg:Dock( TOP )
	//if i != 1 then
	//	panelname_backg:DockMargin( 0, 15, 0, 0 )
	//end
	panelname_backg:SetSize(0,width)
	panelname_backg.Paint = function( self, w, h )
		//draw.RoundedBox( 0, 0, 0, w, h, color_dark )
	end
	
	local panelwidth = 55
	
	local sbpanels = {
		{
			name = "Ping",
			size = panelwidth
		},
		{
			name = "EXP",
			size = panelwidth
		},
		{
			name = "Level",
			size = panelwidth
		}
	}
	if RanksEnabled() then
		table.ForceInsert(sbpanels, {
			name = "Group",
			size = panelwidth * 2
		})
	end
	
	
	local MuteButtonFix = vgui.Create( "DPanel", panelname_backg )
	MuteButtonFix:Dock(RIGHT)
	MuteButtonFix:SetSize( width - 2, width - 2 )
	MuteButtonFix.Paint = function() end
	for i,pnl in ipairs(sbpanels) do
		local ping_panel = vgui.Create( "DLabel", panelname_backg )
		ping_panel:Dock( RIGHT )
		if i == 1 then
			ping_panel:DockMargin( 0, 0, 25, 0 )
		end
		ping_panel:SetSize(pnl.size, 0)
		ping_panel:SetText(pnl.name)
		ping_panel:SetFont("sb_names")
		ping_panel:SetTextColor(Color(255,255,255,255))
		ping_panel:SetContentAlignment(5)
		ping_panel.Paint = function( self, w, h )end
		drawb = !drawb
	end
	
	local i = 0
	for key,tab in pairs(playerlist) do
		i = i + 1
		if #tab.list > 0 then
			
			// players
			local panelwidth = 55	
			local dark = true
			for k,v in ipairs(tab.list) do
				local panels = {
					{
						name = "Ping",
						text = v:Ping(),
						color = color_white,
						size = panelwidth
					},
					{
						name = "EXP",
						text = v:GetNEXP(),
						color = color_white,
						size = panelwidth
					},
					{
						name = "Level",
						text = v:GetNLevel(),
						color = color_white,
						size = panelwidth
					},
				}
				local rank = v:GetUserGroup()
				rank = firstToUpper(rank)
				if RanksEnabled() then
					table.ForceInsert(panels, {
						name = "Group",
						text = rank,
						color = color_white,
						size = panelwidth * 2
					})
				end
				local scroll_panel = vgui.Create( "DPanel", DScrollPanel )
				scroll_panel:Dock( TOP )
				scroll_panel:DockMargin( 0,2,0,0 )
				scroll_panel:SetSize(0,width)
				//scroll_panel.clr = gteams.GetColor(v:GTeam())
				scroll_panel.clr = tab.color
				if not v.GetNClass or not v.GetLastTeam then
					player_manager.RunClass( v, "SetupDataTables" )
				end
				scroll_panel.Paint = function( self, w, h )
					if !IsValid(v) or not v then
						Frame:Close()
						return
					end
					local txt = clang.class_unknown or "Unknown"
					local tcolor = scroll_panel.clr
					local tcolor2 = tab.color2
					LocalPlayer().known = true
					if v.known == true then
						if v:GetNClass() == ROLES.ROLE_SCP9571 then
							txt = GetLangRole( v:GetLastRole() )
							if txt == "" then
								txt = clang.class_unknown or "Unknown"
							else
								tcolor = gteams.GetColor(v:GetLastTeam())
							end
						else
							tcolor = gteams.GetColor(v:GTeam())
							txt = GetLangRole(v.knownrole)
						end
					end
					if ranks.author.check( v ) then
						tcolor = Color(114, 9, 53)
						tcolor2 = color_white
					end
					-- Usunięto problematyczną logikę przezroczystości - wszyscy gracze będą nieprzezroczyści
					tcolor["a"] = 255
					draw.RoundedBox( 0, 0, 0, w, h, tcolor )
					draw.Text( {
						text = string.sub(v:Nick(), 1, 16),
						pos = { width + 2, h / 2 },
						font = "sb_names",
						color = tcolor2,
						xalign = TEXT_ALIGN_LEFT,
						yalign = TEXT_ALIGN_CENTER
					})
					draw.RoundedBox( 0, width + 150, 0, 125, h, Color(0,0,0,120) )
					draw.Text( {
						text = txt,
						pos = { width + 212, h / 2 },
						font = "sb_names",
						color = tcolor2,
						xalign = TEXT_ALIGN_CENTER,
						yalign = TEXT_ALIGN_CENTER
					})
					local rankid = 0
					--print( v:GetName(), v:GetNActive() )
					local rankstouse = {}
					for _, rank in pairs( ranks ) do
						if rank.check( v ) then
							table.insert( rankstouse, rank )
						end
					end
					table.sort( rankstouse, function( a, b ) return a.sorting < b.sorting end )
					for _, rank in ipairs( rankstouse ) do
						local color = rank.color
						-- Usunięto problematyczną logikę przezroczystości dla rang
						color["a"] = 255
						draw.RoundedBox( 0, width + 277 + 127 * rankid, 2, 125, h - 4, color )
						draw.Text( {
							text = isfunction( rank.text ) and rank.text() or rank.text,
							pos = { width + 339.5 + 127 * rankid, h / 2 },
							font = "sb_names",
							color = rank.textcolor,
							xalign = TEXT_ALIGN_CENTER,
							yalign = TEXT_ALIGN_CENTER
						})
						rankid = rankid + 1
					end
					
					local panel_x = w / 1.1175
					local panel_w = w / 14
				end
				
				local MuteButton = vgui.Create( "DButton", scroll_panel )
				MuteButton:Dock(RIGHT)
				MuteButton:SetSize( width - 2, width - 2 )
				MuteButton:SetText( "" )
				MuteButton.DoClick = function()
					v:SetMuted( !v:IsMuted() )
				end
				MuteButton.Paint = function( self, w, h )
					draw.RoundedBox( 0, 0, 0, w, h, Color(255,255,255,255) )
				end
				
				local MuteIMG = vgui.Create( "DImage", MuteButton )
				MuteIMG.img = "icon32/unmuted.png"
				MuteIMG:SetPos( MuteButton:GetPos() )
				MuteIMG:SetSize( MuteButton:GetSize() )
				MuteIMG:SetImage( "icons32/unmuted.png" )
				MuteIMG.Think = function( self, w, h )
					if !IsValid(v) then return end
					if v:IsMuted() then
						self.img = "icon32/muted.png"
					else
						self.img = "icon32/unmuted.png"
					end
					self:SetImage( self.img )
				end
				
				local drawb = true
				for i,pnl in ipairs(panels) do
					local ping_panel = vgui.Create( "DLabel", scroll_panel )
					ping_panel:Dock( RIGHT )
					if i == 1 then
						ping_panel:DockMargin( 0, 0, 25, 0 )
					end
					ping_panel:SetSize(pnl.size, 0)
					ping_panel:SetText(pnl.text)
					ping_panel:SetFont("sb_names")
					ping_panel:SetTextColor(tab.color2)
					ping_panel:SetContentAlignment(5)
					if drawb then
						ping_panel.Paint = function( self, w, h )
							ping_panel:SetText(pnl.text)
							draw.RoundedBox( 0, 0, 0, w, h, Color(0,0,0,120) )
						end
					end
					drawb = !drawb
				end
				
				local Avatar = vgui.Create( "AvatarImage", scroll_panel )
				Avatar:SetSize( width, width )
				Avatar:SetPos( 0, 0 )
				Avatar:SetPlayer( v, 32 )
			end
		end
	end
end

function GM:ScoreboardShow()
	ShowScoreBoard()
end

function GM:ScoreboardHide()
	if IsValid(Frame) then
		Frame:Close()
	end
end

function IsInTable( tab, element )
	for k, v in pairs( tab ) do
		if v == element then return true end
	end
	return false
end


================================================
FILE: gamemodes/breach/gamemode/modules/cl_scp035_visuals.lua
================================================
-- Visual attachment of SCP-035 mask on player faces

local MASK_MODEL = "models/scp_035_real/scp_035_real.mdl"

-- Tabela przechowująca modele klienckie
local maskModels = {}

hook.Add("PostPlayerDraw", "BR_SCP035_RenderMask", function(ply)
    if not IsValid(ply) or not ply:IsPlayer() then return end

    -- Sprawdź czy gracz jest SCP-035
    local is035 = false
    if ply.GetNClass then
        is035 = (ply:GetNClass() == ROLES.ROLE_SCP035)
    end
    if not is035 then
        -- Usuń ewentualny model gdy gracz przestał być 035
        if maskModels[ply] and IsValid(maskModels[ply]) then
            maskModels[ply]:Remove()
            maskModels[ply] = nil
        end
        return
    end

    -- Utwórz model jeśli nie istnieje
    if not IsValid(maskModels[ply]) then
        local mdl = ClientsideModel(MASK_MODEL, RENDERGROUP_OPAQUE)
        mdl:SetNoDraw(true)
        maskModels[ply] = mdl
    end

    local mdl = maskModels[ply]
    if not IsValid(mdl) then return end

    -- Pobierz attachment "eyes" (fallback do głowy)
    local id = ply:LookupAttachment("eyes")
    local pos, ang
    if id and id > 0 then
        local att = ply:GetAttachment(id)
        if att then
            pos = att.Pos
            ang = att.Ang
        end
    end
    if not pos then -- fallback to head bone
        local boneId = ply:LookupBone("ValveBiped.Bip01_Head1")
        if boneId then
            local matrix = ply:GetBoneMatrix(boneId)
            if matrix then
                pos = matrix:GetTranslation()
                ang = matrix:GetAngles()
            end
        end
    end
    if not pos then return end

    -- Pozycjonowanie – lekkie odsunięcie do przodu
    local forward = ang:Forward()
    pos = pos + forward * 4 -- dystans od twarzy

    mdl:SetPos(pos)
    mdl:SetAngles(ang)
    mdl:DrawModel()
end)

-- Sprzątanie po disconnect / zmianie mapy
hook.Add("EntityRemoved", "BR_SCP035_CleanupMask", function(ent)
    if maskModels[ent] and IsValid(maskModels[ent]) then
        maskModels[ent]:Remove()
        maskModels[ent] = nil
    end
end)

hook.Add("PostCleanupMap", "BR_SCP035_CleanupAll", function()
    for ply, mdl in pairs(maskModels) do
        if IsValid(mdl) then mdl:Remove() end
    end
    maskModels = {}
end) 


================================================
FILE: gamemodes/breach/gamemode/modules/cl_scp1123.lua
================================================
-- SCP-1123 Client Module
-- Moduł kliencki dla SCP-1123 "Skull of Memories"

-- Font dla HUD (taki sam jak SCP-1499)
surface.CreateFont("SCP1123_Small", {
	font = "Trebuchet24", 
	size = 18,
	weight = 500,
	antialias = true,
	shadow = true
})

-- Zmienne lokalne
local effectActive = false
local effectEndTime = 0

-- Network message handlers
net.Receive("SCP1123_StartEffect", function()
	effectActive = true
	effectEndTime = CurTime() + 60
end)

net.Receive("SCP1123_EndEffect", function()
	effectActive = false
	effectEndTime = 0
end)

-- HUD Timer dla gracza w efekcie SCP-1123 (styl SCP-1499)
hook.Add("HUDPaint", "SCP1123_EffectTimer", function()
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	-- Sprawdź czy gracz jest w efekcie (przez network var lub local var)
	local inEffect = ply:GetNWBool("SCP1123_InEffect", false) or effectActive
	
	if inEffect then
		local timeLeft = math.max(0, ply:GetNWFloat("SCP1123_EffectEnd", effectEndTime) - CurTime())
		
		if timeLeft > 0 then
			-- Pozycja HUD prosto nad celownikiem (jak w SCP-1499)
			local x = ScrW() / 2
			local y = ScrH() / 2 - 50 -- 50 pikseli nad środkiem ekranu
			
			-- Tekst timera
			local timerText = string.format("MEMORY: %.1fs", timeLeft)
			
			-- Kolor zmieniający się z czasem
			local progress = timeLeft / 60
			local color
			if progress > 0.5 then
				color = Color(100, 255, 100) -- Zielony
			elseif progress > 0.25 then
				color = Color(255, 255, 100) -- Żółty
			else
				color = Color(255, 100, 100) -- Czerwony
			end
			
			-- Tekst (styl SCP-1499)
			draw.SimpleText(timerText, "SCP1123_Small", x, y - 20, color, TEXT_ALIGN_CENTER)
			
			-- Pasek postępu (styl SCP-1499)
			local barWidth = 100
			local barHeight = 4
			
			-- Tło paska
			surface.SetDrawColor(0, 0, 0, 150)
			surface.DrawRect(x - barWidth/2, y, barWidth, barHeight)
			
			-- Wypełnienie paska
			surface.SetDrawColor(color.r, color.g, color.b, 255)
			surface.DrawRect(x - barWidth/2, y, barWidth * progress, barHeight)
		end
	end
end)

-- Prosty efekt rozmycia i szarości podczas obserwacji
hook.Add("RenderScreenspaceEffects", "SCP1123_SimpleEffects", function()
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	local inEffect = ply:GetNWBool("SCP1123_InEffect", false) or effectActive
	
	if inEffect then
		-- Rozmycie ekranu
		DrawMotionBlur(0.2, 0.9, 0.02)
		
		-- Szarość (desaturacja)
		local colorModify = {
			["$pp_colour_colour"] = 0.3,  -- Mocna desaturacja (30% kolorów)
			["$pp_colour_brightness"] = -0.1  -- Trochę ciemniej
		}
		DrawColorModify(colorModify)
	end
end)

-- HUD dla pokazania cooldownu SCP-1123 (gdy gracz jest blisko) - styl SCP-1499
hook.Add("HUDPaint", "SCP1123_CooldownDisplay", function()
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	
	-- Znajdź najbliższą SCP-1123 entity
	local closestSCP1123 = nil
	local closestDist = 200 -- Maksymalna odległość do pokazania cooldownu
	
	for _, ent in pairs(ents.FindByClass("scp_1123")) do
		if IsValid(ent) then
			local dist = ent:GetPos():Distance(ply:GetPos())
			if dist < closestDist then
				closestSCP1123 = ent
				closestDist = dist
			end
		end
	end
	
	-- Jeśli jest blisko SCP-1123, pokaż cooldown (styl SCP-1499)
	if IsValid(closestSCP1123) then
		local nextUse = closestSCP1123:GetNWFloat("SCP1123_NextUse", 0)
		local currentTime = CurTime()
		
		-- Pozycja HUD (jak w SCP-1499)
		local x = ScrW() / 2
		local y = ScrH() / 2 - 50
		
		-- Pasek postępu - ustawienia (jak w SCP-1499)
		local barWidth = 100
		local barHeight = 4
		
		if currentTime < nextUse then
			-- Jest cooldown - pokaż pozostały czas
			local timeLeft = nextUse - currentTime
			local minutes = math.floor(timeLeft / 60)
			local seconds = math.floor(timeLeft % 60)
			
			local cooldownText = string.format("CD: %d:%02d", minutes, seconds)
			
			-- Tekst (styl SCP-1499)
			draw.SimpleText(cooldownText, "SCP1123_Small", x, y - 20, Color(255, 100, 100), TEXT_ALIGN_CENTER)
			
			-- Pasek postępu
			local progress = 1 - (timeLeft / 360)
			
			-- Tło paska
			surface.SetDrawColor(0, 0, 0, 150)
			surface.DrawRect(x - barWidth/2, y, barWidth, barHeight)
			
			-- Wypełnienie paska
			surface.SetDrawColor(255, 100, 100, 255)
			surface.DrawRect(x - barWidth/2, y, barWidth * progress, barHeight)
		else
			-- Gotowe do użycia (styl SCP-1499)
			draw.SimpleText("READY", "SCP1123_Small", x, y - 20, Color(100, 255, 100), TEXT_ALIGN_CENTER)
			
			-- Pasek pełny
			surface.SetDrawColor(0, 0, 0, 150)
			surface.DrawRect(x - barWidth/2, y, barWidth, barHeight)
			
			surface.SetDrawColor(100, 255, 100, 255)
			surface.DrawRect(x - barWidth/2, y, barWidth, barHeight)
		end
	end
end)

print("[Breach] SCP-1123 Client Module Loaded") 


================================================
FILE: gamemodes/breach/gamemode/modules/cl_scp207.lua
================================================
-- SCP-207 Client Module for SCP: Breach
-- Based on original SCP-207 addon by MrMarrant
-- Adapted for Breach gamemode

-- Global SCP-207 system
scp_207 = scp_207 or {}
SCP_207_CONFIG = SCP_207_CONFIG or {}

-- Screen resolution for overlay
SCP_207_CONFIG.ScrW = ScrW()
SCP_207_CONFIG.ScrH = ScrH()

-- Network strings (must match server)
SCP_207_CONFIG.TextToSendToServer = "SCP207_TextToServer"
SCP_207_CONFIG.StartOverlayEffect = "SCP207_StartOverlay"
SCP_207_CONFIG.RemoveOverlayEffect = "SCP207_RemoveOverlay"

-- Create the overlay for infected player
function scp_207.DisplayOverlay(ply)
    if (!IsValid(ply)) then return end
    if (ply.scp207_Overlay) then return end -- we don't want two overlay

    local OverlaySCP207 = vgui.Create("DImage")
    OverlaySCP207:SetImageColor(Color(60, 0, 0, 0))
    OverlaySCP207:SetSize(SCP_207_CONFIG.ScrW, SCP_207_CONFIG.ScrH)
    -- Use a simple red overlay since we might not have the original texture
    OverlaySCP207:SetImage("vgui/white")
    ply.scp207_Overlay = OverlaySCP207
end

-- Network receivers
net.Receive(SCP_207_CONFIG.TextToSendToServer, function ( )
    local TextToPrint = net.ReadString()
    LocalPlayer():ChatPrint( "[SCP-207] " .. TextToPrint )
end)

net.Receive(SCP_207_CONFIG.StartOverlayEffect, function ( )
    local ply = LocalPlayer()
    local IterationBySeconds = net.ReadUInt(12)

    scp_207.DisplayOverlay(ply)
    local saturation = 0
    local incrementSaturation = 250/IterationBySeconds

    timer.Create("Timer.scp207_StartOverlayEffect_"..ply:EntIndex(), 1, IterationBySeconds, function()
        if (!IsValid(ply)) then return end
        if (!ply.scp207_Overlay) then return end

        ply.scp207_Overlay:SetImageColor(Color(60, 0, 0, saturation))
        saturation = saturation + incrementSaturation
    end)
end)

net.Receive(SCP_207_CONFIG.RemoveOverlayEffect, function ( )
    local ply = LocalPlayer()
    if (timer.Exists("Timer.scp207_StartOverlayEffect_"..ply:EntIndex())) then
        timer.Remove("Timer.scp207_StartOverlayEffect_"..ply:EntIndex())
    end
    if (ply.scp207_Overlay) then
        ply.scp207_Overlay:Remove()
        ply.scp207_Overlay = nil
    end
end)

print("[BREACH] SCP-207 Client Module Loaded") 


================================================
FILE: gamemodes/breach/gamemode/modules/cl_scp330.lua
================================================
-- SCP-330 Client Module dla gamemode Breach
-- Zarządza efektami klienckie SCP-330

-- SCP-330 Client functions
SCP330 = SCP330 or {}
SCP330.Client = SCP330.Client or {}

-- Client configuration
SCP330.Client.Config = {
    ProximityRadius = 150,
    WarningDuration = 4,
    BloodOverlayDuration = 4
}

-- Track proximity warnings shown
SCP330.Client.WarningsShown = {}

-- Play sound function
function SCP330.Client:PlaySound(soundPath)
    local ply = LocalPlayer()
    if IsValid(ply) then
        ply:EmitSound(soundPath)
    end
end

-- Create blood overlay effect
function SCP330.Client:CreateBloodOverlay()
    local ply = LocalPlayer()
    if not IsValid(ply) or ply.SCP330_BloodOverlay then return end
    
    ply.SCP330_BloodOverlay = true
    
    local startTime = CurTime()
    local duration = self.Config.BloodOverlayDuration
    local fadeInTime = duration * 0.5
    local fadeOutTime = duration * 0.5
    
    -- Play breathing sound
    local breathingSounds = {
        "scp_330/heavy_breath_1.mp3",
        "scp_330/heavy_breath_2.mp3",
        "scp_330/heavy_breath_3.mp3"
    }
    self:PlaySound(breathingSounds[math.random(#breathingSounds)])
    
    -- Create overlay effect
    hook.Add("HUDPaint", "SCP330_BloodOverlay_" .. ply:EntIndex(), function()
        if not IsValid(ply) then
            hook.Remove("HUDPaint", "SCP330_BloodOverlay_" .. ply:EntIndex())
            return
        end
        
        local elapsed = CurTime() - startTime
        if elapsed >= duration then
            hook.Remove("HUDPaint", "SCP330_BloodOverlay_" .. ply:EntIndex())
            ply.SCP330_BloodOverlay = nil
            return
        end
        
        local alpha
        if elapsed <= fadeInTime then
            alpha = 200 * (elapsed / fadeInTime)
        else
            alpha = 200 * (1 - ((elapsed - fadeInTime) / fadeOutTime))
        end
        
        -- Draw blood-red overlay
        surface.SetDrawColor(139, 0, 0, alpha)
        surface.DrawRect(0, 0, ScrW(), ScrH())
        
        -- Apply color modification for extra effect
        local colorMod = {
            ["$pp_colour_contrast"] = 1.2,
            ["$pp_colour_colour"] = 0.8,
            ["$pp_colour_mulr"] = 0.3,
            ["$pp_colour_mulg"] = 0.1,
            ["$pp_colour_mulb"] = 0.1
        }
        DrawColorModify(colorMod)
        
        -- Motion blur effect
        DrawMotionBlur(0.1, 0.5, 0.1)
    end)
end

-- Create proximity warning effect
function SCP330.Client:CreateProximityWarning(entity)
    if not IsValid(entity) then return end
    
    local entIndex = entity:EntIndex()
    if self.WarningsShown[entIndex] then return end
    
    self.WarningsShown[entIndex] = true
    
    -- Play warning sound
    self:PlaySound("scp_330/on_first_contact.mp3")
    
    local startTime = CurTime()
    local duration = self.Config.WarningDuration
    local maxAlpha = 255
    
    hook.Add("HUDPaint", "SCP330_ProximityWarning_" .. entIndex, function()
        local elapsed = CurTime() - startTime
        if elapsed >= duration then
            hook.Remove("HUDPaint", "SCP330_ProximityWarning_" .. entIndex)
            return
        end
        
        local alpha = maxAlpha * (1 - (elapsed / duration))
        local size = 0.3 + (elapsed / duration) * 2
        
        local scrW, scrH = ScrW(), ScrH()
        local centerX, centerY = scrW * 0.5, scrH * 0.5
        
        -- Create scaling matrix
        local matrix = Matrix()
        matrix:Translate(Vector(centerX, centerY, 0))
        matrix:Scale(Vector(size, size, 1))
        matrix:Translate(Vector(-centerX, -centerY, 0))
        
        cam.PushModelMatrix(matrix)
        
        -- Draw warning text with custom font if available
        local font = "DermaLarge"
        if surface.GetFont and surface.GetFont("SCP330_Warning") then
            font = "SCP330_Warning"
        end
        
        draw.DrawText("take no more than two,", font, centerX, centerY - 20, Color(255, 255, 255, alpha), TEXT_ALIGN_CENTER)
        draw.DrawText("please!!", font, centerX, centerY + 20, Color(255, 255, 255, alpha), TEXT_ALIGN_CENTER)
        
        cam.PopModelMatrix()
        
        -- Apply color modification
        local colorTab = {
            ["$pp_colour_contrast"] = math.Clamp(elapsed / duration + 0.3, 0, 1)
        }
        DrawColorModify(colorTab)
        
        -- Motion blur effect
        DrawMotionBlur(0.1, 0.2, 0.05)
    end)
end

-- Clean up warning for specific entity
function SCP330.Client:CleanupWarning(entIndex)
    if self.WarningsShown[entIndex] then
        self.WarningsShown[entIndex] = nil
        hook.Remove("HUDPaint", "SCP330_ProximityWarning_" .. entIndex)
    end
end

-- Network message handlers
net.Receive("SCP330_PlaySound", function()
    local soundPath = net.ReadString()
    SCP330.Client:PlaySound(soundPath)
end)

net.Receive("SCP330_BloodEffect", function()
    SCP330.Client:CreateBloodOverlay()
end)

net.Receive("SCP330_ProximityWarning", function()
    local entity = net.ReadEntity()
    if IsValid(entity) then
        SCP330.Client:CreateProximityWarning(entity)
    end
end)

-- Create custom font for warnings
hook.Add("Initialize", "SCP330_CreateFont", function()
    surface.CreateFont("SCP330_Warning", {
        font = "Arial",
        size = 48,
        weight = 700,
        antialias = true,
        shadow = true
    })
end)

-- Clean up on disconnect
hook.Add("ShutDown", "SCP330_Cleanup", function()
    -- Remove all SCP-330 related hooks
    for name, _ in pairs(hook.GetTable().HUDPaint or {}) do
        if string.StartWith(name, "SCP330_") then
            hook.Remove("HUDPaint", name)
        end
    end
end)

-- Debug commands for admins (available to all, but only for testing)
concommand.Add("scp330_test_blood", function(ply)
    local localPly = LocalPlayer()
    if IsValid(localPly) and localPly:IsAdmin() then
        SCP330.Client:CreateBloodOverlay()
    else
        print("[SCP-330] Admin only command")
    end
end)

concommand.Add("scp330_test_warning", function(ply)
    local localPly = LocalPlayer()
    if IsValid(localPly) and localPly:IsAdmin() then
        -- Create a fake entity for testing
        local fakeEntity = {
            EntIndex = function() return 999 end,
            IsValid = function() return true end
        }
        SCP330.Client:CreateProximityWarning(fakeEntity)
    else
        print("[SCP-330] Admin only command")
    end
end)

print("[SCP-330] Client module loaded successfully!") 


================================================
FILE: gamemodes/breach/gamemode/modules/cl_settings_menu.lua
================================================
-- Settings menu for Breach gamemode
local PANEL = {}

function PANEL:Init()
    self:SetSize(400, 300)
    self:Center()
    self:SetTitle("Settings / Ustawienia")
    self:SetVisible(true)
    self:SetDraggable(true)
    self:ShowCloseButton(true)
    self:MakePopup()
    
    -- Dark theme
    self.Paint = function(s, w, h)
        draw.RoundedBox(4, 0, 0, w, h, Color(40, 40, 40, 255))
        draw.RoundedBox(4, 0, 0, w, 25, Color(60, 60, 60, 255))
    end
    
    -- Tips checkbox
    local tipsCheck = vgui.Create("DCheckBoxLabel", self)
    tipsCheck:SetPos(20, 50)
    tipsCheck:SetText("Enable Tips / Włącz podpowiedzi")
    tipsCheck:SetConVar("breach_tips_enabled")
    tipsCheck:SetTextColor(Color(255, 255, 255))
    tipsCheck:SizeToContents()
    
    -- Vest HUD checkbox
    local vestHudCheck = vgui.Create("DCheckBoxLabel", self)
    vestHudCheck:SetPos(20, 80)
    vestHudCheck:SetText("Show Vest Info / Pokaż info o kamizelce")
    vestHudCheck:SetConVar("breach_vest_hud_enabled")
    vestHudCheck:SetTextColor(Color(255, 255, 255))
    vestHudCheck:SizeToContents()
    
    -- Door indicators checkbox
    local doorIndicatorCheck = vgui.Create("DCheckBoxLabel", self)
    doorIndicatorCheck:SetPos(20, 110)
    doorIndicatorCheck:SetText("Show Door Access Indicators / Pokaż wskaźniki dostępu do drzwi")
    doorIndicatorCheck:SetConVar("breach_door_indicators_enabled")
    doorIndicatorCheck:SetTextColor(Color(255, 255, 255))
    doorIndicatorCheck:SizeToContents()
    
    -- Weapon damage modifiers HUD checkbox
    local weaponModifiersCheck = vgui.Create("DCheckBoxLabel", self)
    weaponModifiersCheck:SetPos(20, 140)
    weaponModifiersCheck:SetText("Show Weapon Damage Modifiers / Pokaż mnożniki obrażeń broni")
    weaponModifiersCheck:SetConVar("br_weapon_modifiers_hud")
    weaponModifiersCheck:SetTextColor(Color(255, 255, 255))
    weaponModifiersCheck:SizeToContents()
    
    -- FPS/Ping display checkbox
    local fpsPingCheck = vgui.Create("DCheckBoxLabel", self)
    fpsPingCheck:SetPos(20, 170)
    fpsPingCheck:SetText("Show FPS/Ping / Pokaż FPS/Ping")
    fpsPingCheck:SetConVar("breach_fps_ping_enabled")
    fpsPingCheck:SetTextColor(Color(255, 255, 255))
    fpsPingCheck:SizeToContents()
    
    -- More settings can be added here later
    
    -- Close button
    local closeBtn = vgui.Create("DButton", self)
    closeBtn:SetText("Close / Zamknij")
    closeBtn:SetPos(150, 250)
    closeBtn:SetSize(100, 30)
    closeBtn.DoClick = function()
        self:Close()
    end
    
    closeBtn.Paint = function(s, w, h)
        draw.RoundedBox(4, 0, 0, w, h, Color(100, 100, 100, 255))
        if s:IsHovered() then
            draw.RoundedBox(4, 0, 0, w, h, Color(120, 120, 120, 255))
        end
    end
end

vgui.Register("BreachSettingsMenu", PANEL, "DFrame")

-- Open settings menu function
function OpenSettingsMenu()
    if IsValid(SettingsMenu) then
        SettingsMenu:Remove()
    end
    
    SettingsMenu = vgui.Create("BreachSettingsMenu")
end

-- Hook for chat commands
hook.Add("OnPlayerChat", "BreachSettingsCommand", function(ply, text, team, dead)
    if ply == LocalPlayer() then
        text = string.lower(text)
        if text == "!settings" or text == "!ustawienia" then
            OpenSettingsMenu()
            return true -- Hide the message
        end
    end
end)


================================================
FILE: gamemodes/breach/gamemode/modules/cl_sounds.lua
================================================
/*
soundstoloop = {
	{
		pos = Vector(2725.010010, -192.000000, 128.000000),
		ent = "prop_dynamic",
		len = 5,
		sound = "camera.ogg"
	},
	{
		pos = Vector(2725.010010, 1088.000000, 128.000000),
		ent = "prop_dynamic",
		len = 5,
		sound = "camera.ogg"
	}
}

foundsoundents = {}

function FindSoundEnts()
	for k,v in pairs(soundstoloop) do
		for k2,ent in pairs(ents.FindInSphere( v.pos, 1 )) do
			if ent:GetClass() == v.ent then
				table.ForceInsert(foundsoundents, {
					ent = ent,
					sound = v.sound,
					len = v.len,
					nextplay = 0
				})
			end
		end
	end
	-- print("Found " .. #foundsoundents .. " sound entities")
end

FindSoundEnts()

function UpdateSounds()
	for k,v in pairs(foundsoundents) do
		if v.nextplay < CurTime() then
			if IsValid(v.ent) then
				v.ent:EmitSound( v.sound, 75, 100, 1, CHAN_STATIC )
				v.nextplay = CurTime() + v.len
			else
				FindSoundEnts()
			end
		end
	end
end
hook.Add("Tick", "UpdateSounds", UpdateSounds)

function LoopSoundsStart()
	for k,v in pairs(foundsoundents) do
		//CreateSound( v.pos, v.sound, CPASAttenuationFilter )
		v.ent:EmitSound( v.sound, 75, 100, 1, CHAN_STATIC )
		v.nextplay = CurTime() + v.len
	end
end

LoopSoundsStart()
*/
function SoundsOnRoundStart()
	surface.PlaySound("Alarm2.ogg")
end

function StartOutisdeSounds()
	surface.PlaySound("Satiate Strings.ogg")
end

function StartEndSound()
	surface.PlaySound("Mandeville.ogg")
end


================================================
FILE: gamemodes/breach/gamemode/modules/cl_splash.lua
================================================
playing = false
local sequence = 0

surface.CreateFont( "HUDSplashVSmall", {
    font = "Bauhaus",    
	size = 20,
	weight = 100,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
})

surface.CreateFont( "HUDSplashSmall", {
    font = "Bauhaus",    
	size = 32,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
})

surface.CreateFont( "HUDSplashMedium", {
    font = "Bauhaus",    
	size = 64,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
})

surface.CreateFont( "HUDSplashBig", {
    font = "Bauhaus",    
	size = 96,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
})

function PlayIntro( seq )
	gui.EnableScreenClicker( true )
	playing = true
	sequence = seq or 1
end

function Intro()
	if !playing then return end
	if sequence == 1 then
		gui.EnableScreenClicker( false )
		Logo()
	elseif sequence == 2 then
		Settings()
	elseif sequence == 3 then
		gui.EnableScreenClicker( false )
		sequence = 0
		file.Write( "breach/intro.dat", tostring( showupdates ) )
		net.Start( "PlayerReady" )
		net.SendToServer()
		sequence = 4
	elseif sequence == 4 then
		if file.Exists( "breach/version.dat", "DATA" ) then
			local ver = file.Read( "breach/version.dat" )
			if ver != VERSION then
				file.Write( "breach/version.dat", tostring( VERSION ) )
				sequence = 5
				playing = true
			else
				playing = false
				gui.EnableScreenClicker( false )
			end
		else
			file.Write( "breach/version.dat", tostring( VERSION ) )
			sequence = 5
			playing = true
		end
	elseif sequence == 5 then
		Update()
	end
end

hook.Add( "HUDPaint", "Intro", Intro )

local elements = {
	{ 0.348, 0.4, 0.055, 0.14, 255 },
	{ 0.409, 0.4, 0.055, 0.14, 255 },
	{ 0.47, 0.4, 0.06, 0.14, 255 },
	{ 0.545, 0.39, 0.11, 0.163, 255 },
	{ 0.345, 0.555, 0.31, 0.05, 255 },
}

local scplx, scply, scplw, scplh = ScrW() * 0.25, ScrH() * 0.25, ScrW() * 0.5, ScrH() * 0.5
local scaledown = 1
local brla, ka, da, foa = 0, 0, 0, -1000

function Logo()
	local w, h = ScrW(), ScrH()
	surface.SetDrawColor( 0, 0, 0, 255 )
	surface.DrawRect( 0, 0, w, h )
	
	surface.SetMaterial( Material( "materials/breach/logo_scp.png" ) )
	surface.SetDrawColor( 255, 255, 255, 255 )
	surface.DrawTexturedRect( scplx + scplw * (1 - scaledown) / 2 , scply * scaledown, scplw * scaledown, scplh * scaledown )
	
	for k, v in pairs( elements ) do
		surface.SetDrawColor( 0, 0, 0, v[5] )
		surface.DrawRect( w * v[1], h * v[2], w * v[3], h * v[4] )
	end
	
	for k, v in pairs( elements ) do
		if v[5] > 0 then
			v[5] = v[5] - 2
			return
		end
	end
	
	if scaledown > 0.3 then
		scaledown = scaledown - 0.001
		return
	end
	surface.SetMaterial( Material( "materials/breach/logo_breach.png" ) )
	surface.SetDrawColor( 255, 255, 255, brla )
	surface.DrawTexturedRect( w * 0.43, h * 0.3, w * 0.14, h * 0.25 )
	
	if brla < 255 then
		brla = brla + 2
		return
	end
	
	draw.Text( {
		text = clang.credits_orig,
		pos = { w * 0.5, h * 0.55 },
		font = "HUDSplashSmall",
		color = Color( 155, 155, 155, ka ),
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_RIGHT,
	})
	draw.Text( {
		text = "Kanade",
		pos = { w * 0.5, h * 0.58 },
		font = "HUDSplashMedium",
		color = Color( 255, 255, 255, ka ),
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_RIGHT,
	})
	
	if ka < 255 then
		ka = ka + 2
		return
	end
	
	draw.Text( {
		text = clang.credits_edit,
		pos = { w * 0.5, h * 0.68 },
		font = "HUDSplashMedium",
		color = Color( 155, 155, 155, da ),
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_RIGHT,
	})
	draw.Text( {
		text = "danx91",
		pos = { w * 0.5, h * 0.74 },
		font = "HUDSplashBig",
		color = Color( 255, 255, 255, da ),
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_RIGHT,
	})
	draw.Text( {
		text = "[aka ZGFueDkx]",
		pos = { w * 0.5, h * 0.82 },
		font = "HUDSplashSmall",
		color = Color( 255, 255, 255, da ),
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_RIGHT,
	})
	
	if da < 255 then
		da = da + 2
		return
	end
	
	surface.SetDrawColor( 0, 0, 0, foa )
	surface.DrawRect( 0, 0, w, h )
	
	if foa < 255 then
		foa = foa + 2
		return
	end
	sequence = 2
	
end

local sa = 255
local bposx, bvel = 0, 0

showupdates = showupdates or false

if showupdates then
	bposx = ScrW() * 0.04
end

local sfoa = -1
function Settings()
	if !vgui.CursorVisible() then
		gui.EnableScreenClicker( true )
	end
	local w, h = ScrW(), ScrH()
	surface.SetDrawColor( 0, 0, 0, 255 )
	surface.DrawRect( 0, 0, w, h )
	
	draw.Text( {
		text = clang.settings,
		pos = { w * 0.5, h * 0.02 },
		font = "HUDSplashMedium",
		color = Color( 255, 255, 255, 255 ),
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_RIGHT,
	})
	
	surface.SetDrawColor( 100, 100, 100, 255 )
	surface.DrawRect( w * 0.1, h * 0.15, w * 0.08, h * 0.04 )
	
	if showupdates then
		surface.SetDrawColor( 20, 100, 20, 255 )
		if DoButton( w * 0.14 + 1, h * 0.15 + 1, w * 0.04 - 1, h * 0.04 - 2 ) then
			showupdates = false
			bvel = -10
		end
	else
		surface.SetDrawColor( 100, 20, 20, 255 )
		if DoButton( w * 0.10 + 1, h * 0.15 + 1, w * 0.04 - 1, h * 0.04 - 2 ) then
			showupdates = true
			bvel = 10
		end
	end
	
	surface.DrawRect( w * 0.10 + bposx + 1, h * 0.15 + 1, w * 0.04 - 1, h * 0.04 - 2 )
	
	if bvel != 0 then
		bposx = bposx + bvel
		if bposx < 0 then
			bposx = 0
			bvel = 0
		elseif bposx > w * 0.04 then
			bposx = w * 0.04
			bvel = 0
		end
	end
	
	draw.Text( {
		text = clang.updateinfo,
		pos = { w * 0.2, h * 0.17 },
		font = "HUDSplashSmall",
		color = Color( 255, 255, 255, 255 ),
		xalign = TEXT_ALIGN_LEFT,
		yalign = TEXT_ALIGN_CENTER,
	})
	
	surface.SetDrawColor( 80, 80, 100, 255 )
	surface.DrawRect( w * 0.6, h * 0.9, w * 0.3, h * 0.06 )
	
	draw.Text( {
		text = clang.done,
		pos = { w * 0.75, h * 0.93 },
		font = "HUDSplashSmall",
		color = Color( 255, 255, 255, 255 ),
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_CENTER,
	})
	
	if DoButton( w * 0.6, h * 0.9, w * 0.3, h * 0.06 ) then
		sfoa = 0
	end
	
	draw.Text( {
		text = clang.repe,
		pos = { w * 0.01, h * 0.95 },
		font = "HUDSplashSmall",
		color = Color( 255, 255, 255, 255 ),
		xalign = TEXT_ALIGN_LEFT,
		yalign = TEXT_ALIGN_CENTER,
	})
	
	surface.SetDrawColor( 0, 0, 0, sa )
	surface.DrawRect( 0, 0, w, h )
	
	if sa > 0 then
		sa = sa - 2
		return
	end
	
	if sfoa == -1 then return end
	
	surface.SetDrawColor( 0, 0, 0, sfoa )
	surface.DrawRect( 0, 0, w, h )
	
	if sfoa < 255 then
		sfoa = sfoa + 2
		return
	end
	
	sequence = 3
	
end

local info = { version = 0.00 }
if file.Exists( "gamemodes/breach/gamemode/updates/update"..VERSION..".lua", "GAME" ) then
	local raw = file.Read( "gamemodes/breach/gamemode/updates/update"..VERSION..".lua", "GAME" )
	info = util.JSONToTable( raw )
end

//PrintTable( info )

local COLOR_BUFF = Color( 20, 200, 20, 255 )
local COLOR_NERF = Color( 200, 20, 20, 255 )

function Update()
	if !vgui.CursorVisible() then
		gui.EnableScreenClicker( true )
	end
	local w, h = ScrW(), ScrH()
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawRect( h * 0.1, h * 0.1, w - h * 0.2, h * 0.8 )
	
	surface.SetDrawColor( 200, 20, 20, 255 )
	surface.DrawRect( w - h * 0.2, h * 0.13, h * 0.07, h * 0.07 )
	
	surface.SetDrawColor( 255, 255, 255, 255 )
	draw.NoTexture()
	surface.DrawTexturedRectRotated( w - h * 0.165, h * 0.165, 5, 75, 45 )
	surface.DrawTexturedRectRotated( w - h * 0.165, h * 0.165, 5, 75, -45 )
	
	if DoButton( w - h * 0.2, h * 0.13, h * 0.07, h * 0.07 ) then
		sequence = 0
		playing = false
		gui.EnableScreenClicker( false ) 
	end
	
	local num = 3
	
	if clang.updates[1] == "polski" then num = 2 end
	
	draw.Text( {
		text = clang.updates[2].." "..info.version,
		pos = { w * 0.07, h * 0.13 },
		font = "HUDSplashSmall",
		color = Color( 255, 255, 255, 255 ),
		xalign = TEXT_ALIGN_LEFT,
		yalign = TEXT_ALIGN_CENTER,
	})
	
	draw.Text( {
		text = clang.updates[4].." "..VERSION,
		pos = { w * 0.35, h * 0.13 },
		font = "HUDSplashSmall",
		color = Color( 255, 255, 255, 255 ),
		xalign = TEXT_ALIGN_LEFT,
		yalign = TEXT_ALIGN_CENTER,
	})
	
	if info.version != VERSION then
		draw.Text( {
			text = string.format( clang.updates[3], VERSION ),
			pos = { w * 0.1, h * 0.25 },
			font = "HUDSplashMedium",
			color = Color( 255, 255, 255, 255 ),
			xalign = TEXT_ALIGN_LEFT,
			yalign = TEXT_ALIGN_CENTER,
		})
		return
	end
	
	local lastinfo = { [0] = 0, [1] = 0, [2] = 0 }
	local col = 0
	local row = 0
	
	for k, v in pairs( info.update ) do
		local infos = math.floor( #v / 3 )
		local yadd = row > 0 and 60 or 0
		draw.Text( {
			text = k,
			pos = { w * 0.08 + (w - h * 0.2) / 3 * col - 25, h * 0.2 + row * lastinfo[ col ] * 25 + yadd },
			font = "HUDSplashSmall",
			color = Color( 255, 255, 255, 255 ),
			xalign = TEXT_ALIGN_LEFT,
			yalign = TEXT_ALIGN_CENTER,
		})
		for i = 0, infos - 1 do
			local drawcolor = v[1 + i * 3] == "buff" and COLOR_BUFF or v[1 + i * 3] == "nerf" and COLOR_NERF or Color( 200, 200, 200, 255 )
			draw.Text( {
				text = v[num + i * 3],
				pos = { w * 0.08 + (w - h * 0.2) / 3 * col, h * 0.2 + row * lastinfo[ col ] * 25 + 35 + i * 25 + yadd },
				font = "HUDSplashVSmall",
				color = drawcolor,
				xalign = TEXT_ALIGN_LEFT,
				yalign = TEXT_ALIGN_CENTER,
			})
		end
		lastinfo[ col ] = infos
		col = col + 1
		if col > 2 then 
			col = 0
			row = row + 1
		end
		if col > 0 then
			for i = 1, col do
				if i > 2 then break end
				surface.SetDrawColor( Color( 255, 255, 255, 255 ) )
				surface.DrawRect( h * 0.1 + (w - h * 0.2) / 3 * i - 1, h * 0.2, 2, h * 0.65 )
			end
		end
	end
end

function DoButton( x, y, w, h )
	local mx, my = input.GetCursorPos()
	if mx > x and mx < x + w then
		if my > y and my < y + h then
			if input.IsMouseDown( MOUSE_LEFT ) then
				return true
			end
		end
	end
	return false
end


================================================
FILE: gamemodes/breach/gamemode/modules/cl_targetid.lua
================================================

function GM:HUDDrawTargetID()
	local trace = LocalPlayer():GetEyeTrace()
	if !trace.Hit then return end
	if !trace.HitNonWorld then return end
	
	-- If the entity you're looking at is a player using SCP-268 invisibility, don't show TargetID
	if IsValid(trace.Entity) and trace.Entity:IsPlayer() and trace.Entity:GetNWBool("SCP268_Invisible", false) then return end
	
	local text = clang.class_unknown or "Unknown"
	local font = "TargetID"
	local ply =  trace.Entity
	
	local clr = color_white
	local clr2 = color_white
	
	if ply:IsPlayer() then
		if ply:Alive() == false then return end
		if ply:GetPos():Distance(LocalPlayer():GetPos()) > 500 then return end
		if not ply.GetNClass or not ply.GetLastRole then
			player_manager.RunClass( ply, "SetupDataTables" )
		end
		if ply:GTeam() == TEAM_SPEC then return end
		if ply:GetNClass() == ROLES.ROLE_SCP966 then
			local hide = true
			-- Use new NVG toggle system
			if LocalPlayer().NVGActive then
					hide = false
			end
			if (LocalPlayer():GTeam() == TEAM_SCP) then
				hide = false
			end
			if hide == true then return end
		end
		if ply:GetNClass() == ROLES.ROLE_SCP9571 and LocalPlayer():GTeam() != TEAM_SCP then
			text = GetLangRole(ply:GetLastRole())
			clr = gteams.GetColor(ply:GetLastTeam())
			if !text or text == "" then
				text = clang.class_unknown or "Unknown"
			end
		elseif ply:GTeam() == TEAM_SCP then
			text = GetLangRole(ply:GetNClass())
			-- Zabezpieczenie dla SCP0492 (zombie)
			if not text or text == "" then
				text = ply:GetNClass() or "SCP-049-2"
			end
			clr = gteams.GetColor(ply:GTeam())
		else
			for k,v in pairs(SAVEDIDS) do
				if v.pl == ply then
					if v.id != nil then
						if isstring(v.id) then
							text = v.pl.knownrole
							clr = gteams.GetColor(ply:GTeam())
							text = GetLangRole(v.pl.knownrole)
						end
					end
				end
			end
		end
		AddToIDS(ply)
	else
		-- Check if entity has health (func_breakable only)
		if IsValid(trace.Entity) and trace.Entity.Health and trace.Entity:Health() > 0 then
			local ent = trace.Entity
			local entClass = ent:GetClass()
			
			-- Check if it's func_breakable only
			if entClass == "func_breakable" then
				local health = ent:Health()
				local maxHealth = ent:GetMaxHealth()
				
				-- If max health is 0 or unknown, assume current health is max
				if maxHealth <= 0 then
					maxHealth = health
				end
				
				local healthPercent = math.ceil(health * 100 / math.max(1, maxHealth))
				
				-- Determine color based on health percentage
				local healthColor
				if healthPercent >= 75 then
					healthColor = Color(0, 255, 0) -- Green for high health
				elseif healthPercent >= 50 then
					healthColor = Color(255, 255, 0) -- Yellow for medium health
				elseif healthPercent >= 25 then
					healthColor = Color(255, 165, 0) -- Orange for low health
				else
					healthColor = Color(255, 0, 0) -- Red for critical health
				end
				
				local x = ScrW() / 2
				local y = ScrH() / 2 + 30
				
				-- Display object health
				draw.Text( {
					text = "Object (" .. health .. "/" .. maxHealth .. ")",
					pos = { x, y },
					font = "TargetID",
					color = Color(255, 255, 255),
					xalign = TEXT_ALIGN_CENTER,
					yalign = TEXT_ALIGN_CENTER,
				})
				
				draw.Text( {
					text = "Health: " .. healthPercent .. "%",
					pos = { x, y + 16 },
					font = "TargetID",
					color = healthColor,
					xalign = TEXT_ALIGN_CENTER,
					yalign = TEXT_ALIGN_CENTER,
				})
				
				return
			end
		end
		
		
		return
	end
	
	local x = ScrW() / 2
	local y = ScrH() / 2 + 30

	local health = math.ceil( ply:Health() * 100 / math.max( 1, ply:GetMaxHealth() ) )

	-- Determine color based on player health percentage
	local healthColor
	if health >= 75 then
		healthColor = Color(0, 255, 0) -- Green for high health
	elseif health >= 50 then
		healthColor = Color(255, 255, 0) -- Yellow for medium health
	elseif health >= 25 then
		healthColor = Color(255, 165, 0) -- Orange for low health
	else
		healthColor = Color(255, 0, 0) -- Red for critical health
	end

	-- Calculate text widths for proper centering
	surface.SetFont("TargetID")
	local nameText = ply:Nick() .. " ("
	local healthText = health .. "%"
	local endText = ")"
	local fullText = nameText .. healthText .. endText
	
	local nameWidth = surface.GetTextSize(nameText)
	local healthWidth = surface.GetTextSize(healthText)
	local fullWidth = surface.GetTextSize(fullText)
	
	-- Calculate starting position to center the entire text
	local startX = x - fullWidth / 2
	
	-- Draw player name and opening bracket in white
	draw.Text( {
		text = nameText,
		pos = { startX, y },
		font = "TargetID",
		color = color_white,
		xalign = TEXT_ALIGN_LEFT,
		yalign = TEXT_ALIGN_CENTER,
	})
	
	-- Draw health percentage in color
	draw.Text( {
		text = healthText,
		pos = { startX + nameWidth, y },
		font = "TargetID",
		color = healthColor,
		xalign = TEXT_ALIGN_LEFT,
		yalign = TEXT_ALIGN_CENTER,
	})
	
	-- Draw closing bracket in white
	draw.Text( {
		text = endText,
		pos = { startX + nameWidth + healthWidth, y },
		font = "TargetID",
		color = color_white,
		xalign = TEXT_ALIGN_LEFT,
		yalign = TEXT_ALIGN_CENTER,
	})
	
	draw.Text( {
		text = text,
		pos = { x, y + 16 },
		font = "TargetID",
		color = clr,
		xalign = TEXT_ALIGN_CENTER,
		yalign = TEXT_ALIGN_CENTER,
	})
end



================================================
FILE: gamemodes/breach/gamemode/modules/cl_upgrader_menu.lua
================================================
-- SCP UPGRADER - Advanced Client Menu
-- AAA Quality animations and CS2-style interface

if not BR then BR = {} end
if not BR.UpgraderUI then BR.UpgraderUI = {} end

-- UI State Management
local upgraderMenu = nil
local roulettePanel = nil
local currentTheme = nil
local isAnimating = false

-- Animation variables
local wheelRotation = 0
local wheelSpeed = 0
local targetRotation = 0
local glowPulse = 0
local resultDisplayTime = 0

-- Cached materials for performance
local glowMaterial = Material("effects/yellowflare")
local gradientMaterial = Material("gui/gradient_up")

-- Sound precaching
local function PrecacheSounds()
    for _, rarity in ipairs(BR.Upgrader.Rarities) do
        if rarity.soundEffect then
            sound.Add({
                name = "upgrader_" .. rarity.tier,
                channel = CHAN_AUTO,
                volume = 0.8,
                level = 75,
                sound = rarity.soundEffect
            })
        end
    end
    
    -- Additional UI sounds
    sound.Add({
        name = "upgrader_tick",
        channel = CHAN_AUTO,
        volume = 0.3,
        level = 50,
        sound = "buttons/lightswitch2.wav"
    })
    
    sound.Add({
        name = "upgrader_open",
        channel = CHAN_AUTO,
        volume = 0.6,
        level = 75,
        sound = "ambient/machines/keyboard1_clicks.wav"
    })
end

-- Initialize sounds
timer.Simple(1, PrecacheSounds)

-- Easing functions for smooth animations
local function EaseOutCubic(t)
    return 1 - math.pow(1 - t, 3)
end

local function EaseInOutQuad(t)
    return t < 0.5 and 2 * t * t or 1 - math.pow(-2 * t + 2, 2) / 2
end

-- Advanced drawing functions
local function DrawGlowingBox(x, y, w, h, color, glowIntensity)
    glowIntensity = glowIntensity or 1
    
    -- Base box
    draw.RoundedBox(8, x, y, w, h, color)
    
    -- Glow effect layers
    for i = 1, 3 do
        local alpha = math.max(0, (color.a * glowIntensity * (4 - i)) / 3)
        local expandedColor = Color(color.r, color.g, color.b, alpha)
        draw.RoundedBox(8, x - i * 2, y - i * 2, w + i * 4, h + i * 4, expandedColor)
    end
end

local function DrawProgressRing(centerX, centerY, radius, progress, color, thickness)
    thickness = thickness or 8
    local segments = 64
    local angleStep = 360 / segments
    local totalAngle = 360 * progress
    
    surface.SetDrawColor(color.r, color.g, color.b, color.a)
    
    for i = 0, segments do
        local angle = i * angleStep
        if angle <= totalAngle then
            local x1 = centerX + math.cos(math.rad(angle)) * (radius - thickness/2)
            local y1 = centerY + math.sin(math.rad(angle)) * (radius - thickness/2)
            local x2 = centerX + math.cos(math.rad(angle)) * (radius + thickness/2)
            local y2 = centerY + math.sin(math.rad(angle)) * (radius + thickness/2)
            
            surface.DrawLine(x1, y1, x2, y2)
        end
    end
end

local function DrawCustomCircle(x, y, radius, color)
    local segments = 32
    local points = {}
    
    for i = 0, segments do
        local angle = (i / segments) * math.pi * 2
        local px = x + math.cos(angle) * radius
        local py = y + math.sin(angle) * radius
        table.insert(points, {x = px, y = py})
    end
    
    surface.SetDrawColor(color.r, color.g, color.b, color.a)
    surface.DrawPoly(points)
end

-- Main menu creation function
function BR.UpgraderUI:CreateUpgraderMenu(items, rarities, theme, upgrader)
    if IsValid(upgraderMenu) then
        upgraderMenu:Remove()
    end
    
    currentTheme = theme or BR.Upgrader:GetPlayerTheme(LocalPlayer())
    
    upgraderMenu = vgui.Create("DFrame")
    upgraderMenu:SetSize(700, 600)
    upgraderMenu:Center()
    upgraderMenu:SetTitle("")
    upgraderMenu:SetDraggable(false)
    upgraderMenu:ShowCloseButton(false)
    upgraderMenu:MakePopup()
    
    -- Play open sound
    surface.PlaySound("upgrader_open")
    
    -- Custom paint function with theme support
    upgraderMenu.Paint = function(self, w, h)
        -- Animated background
        local pulseAlpha = math.sin(CurTime() * 2) * 20 + 220
        local bgColor = Color(currentTheme.background.r, currentTheme.background.g, currentTheme.background.b, pulseAlpha)
        
        DrawGlowingBox(0, 0, w, h, bgColor, 0.5)
        
        -- Header with gradient
        surface.SetMaterial(gradientMaterial)
        surface.SetDrawColor(currentTheme.primary.r, currentTheme.primary.g, currentTheme.primary.b, 180)
        surface.DrawTexturedRect(0, 0, w, 60)
        
        -- Title with glow effect
        draw.SimpleText("SCP UPGRADER", "DermaLarge", w/2, 30, currentTheme.accent, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText("SCP UPGRADER", "DermaLarge", w/2 + 1, 31, Color(0, 0, 0, 100), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        
        -- Version info
        draw.SimpleText("v2.0 Advanced", "DermaDefault", w - 10, h - 15, Color(150, 150, 150), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
    end
    
    -- Close button with custom styling
    local closeBtn = vgui.Create("DButton", upgraderMenu)
    closeBtn:SetPos(upgraderMenu:GetWide() - 40, 10)
    closeBtn:SetSize(30, 30)
    closeBtn:SetText("")
    closeBtn.Paint = function(self, w, h)
        local color = self:IsHovered() and Color(255, 100, 100) or Color(200, 200, 200)
        DrawGlowingBox(0, 0, w, h, color, self:IsHovered() and 1.2 or 0.8)
        draw.SimpleText("✕", "DermaDefaultBold", w/2, h/2, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    closeBtn.DoClick = function()
        upgraderMenu:Remove()
    end
    
    -- Subtitle
    local subtitle = vgui.Create("DLabel", upgraderMenu)
    subtitle:SetPos(0, 70)
    subtitle:SetSize(700, 25)
    subtitle:SetText("Wybierz przedmiot do ulepszenia • Gwarancja Mil-Spec co 10 rolli")
    subtitle:SetFont("DermaDefaultBold")
    subtitle:SetTextColor(currentTheme.accent)
    subtitle:SetContentAlignment(5)
    
    -- Items scroll panel with custom styling
    local scroll = vgui.Create("DScrollPanel", upgraderMenu)
    scroll:SetPos(20, 105)
    scroll:SetSize(660, 350)
    
    -- Custom scrollbar
    local sbar = scroll:GetVBar()
    sbar:SetWide(12)
    sbar.Paint = function(self, w, h)
        DrawGlowingBox(0, 0, w, h, Color(30, 30, 30, 200), 0.3)
    end
    sbar.btnGrip.Paint = function(self, w, h)
        local color = self:IsHovered() and currentTheme.accent or currentTheme.primary
        DrawGlowingBox(2, 0, w-4, h, color, 0.8)
    end
    sbar.btnUp.Paint = function() end
    sbar.btnDown.Paint = function() end
    
    if #items == 0 then
        local noItems = vgui.Create("DLabel", scroll)
        noItems:SetPos(0, 150)
        noItems:SetSize(660, 40)
        noItems:SetText("🚫 Nie masz kompatybilnych przedmiotów!")
        noItems:SetFont("DermaLarge")
        noItems:SetTextColor(Color(255, 100, 100))
        noItems:SetContentAlignment(5)
    else
        for i, item in ipairs(items) do
            local itemPanel = vgui.Create("DButton", scroll)
            itemPanel:SetPos(10, (i-1) * 70 + 10)
            itemPanel:SetSize(640, 60)
            itemPanel:SetText("")
            
            -- Get item tier info
            local tier = item.tier or 1
            local tierColor = rarities[tier] and rarities[tier].color or Color(150, 150, 150)
            local glowIntensity = rarities[tier] and rarities[tier].glowIntensity or 0.3
            
            itemPanel.Paint = function(self, w, h)
                local baseColor = self:IsHovered() and Color(60, 60, 60, 240) or Color(40, 40, 40, 200)
                local finalGlow = self:IsHovered() and glowIntensity * 1.5 or glowIntensity
                
                DrawGlowingBox(0, 0, w, h, baseColor, 0.5)
                
                -- Tier indicator bar
                DrawGlowingBox(0, 0, 6, h, tierColor, finalGlow)
                
                -- Item name with tier info
                draw.SimpleText(item.name, "DermaDefaultBold", 20, h/2 - 8, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
                
                -- Tier name
                local tierName = rarities[tier] and rarities[tier].name or "Consumer Grade"
                draw.SimpleText("Tier: " .. tierName, "DermaDefault", 20, h/2 + 10, tierColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
                
                -- Action text
                local actionColor = self:IsHovered() and currentTheme.accent or Color(180, 180, 180)
                draw.SimpleText("KLIKNIJ ABY ULEPSZYĆ ►", "DermaDefaultBold", w-20, h/2, actionColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
            end
            
            itemPanel.DoClick = function()
                -- Find the upgrader entity
                local upgrader = nil
                for _, ent in pairs(ents.FindByClass("scp_wall_hole")) do
                    if IsValid(ent) and LocalPlayer():GetPos():Distance(ent:GetPos()) < 150 then
                        upgrader = ent
                        break
                    end
                end
                
                if IsValid(upgrader) then
                    net.Start("UpgradeItem")
                    net.WriteString(item.class)
                    net.WriteEntity(upgrader)
                    net.SendToServer()
                    
                    upgraderMenu:Remove()
                end
            end
        end
    end
    
    -- Rarity info panel with enhanced design
    local rarityPanel = vgui.Create("DPanel", upgraderMenu)
    rarityPanel:SetPos(20, 470)
    rarityPanel:SetSize(660, 120)
    
    rarityPanel.Paint = function(self, w, h)
        DrawGlowingBox(0, 0, w, h, Color(20, 20, 20, 220), 0.6)
        
        draw.SimpleText("🎲 SZANSE NA RZADKOŚĆ", "DermaDefaultBold", 15, 15, currentTheme.accent)
        
        -- Calculate total weight dynamically
        local totalWeight = 0
        for _, r in ipairs(rarities) do totalWeight = totalWeight + r.weight end
        
        -- Draw rarity bars
        local startY = 40
        local barHeight = 12
        local spacing = 12
        
        for i, rarity in ipairs(rarities) do
            local y = startY + (i-1) * spacing
            local percentage = math.Round((rarity.weight / totalWeight) * 100, 1)
            
            -- Background bar
            draw.RoundedBox(4, 15, y, 200, barHeight, Color(30, 30, 30))
            
            -- Filled bar with glow
            local fillWidth = (percentage / 100) * 200
            DrawGlowingBox(15, y, fillWidth, barHeight, rarity.color, rarity.glowIntensity)
            
            -- Text
            draw.SimpleText(rarity.name, "DermaDefault", 225, y + barHeight/2, rarity.color, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
            draw.SimpleText(percentage .. "%", "DermaDefault", w - 15, y + barHeight/2, Color(255, 255, 255), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
        end
    end
end

-- Advanced roulette wheel
function BR.UpgraderUI:CreateRouletteMenu(rewardItem, rarityName, rarityColor, rarities, wasFailSafe)
    if IsValid(roulettePanel) then
        roulettePanel:Remove()
    end
    
    roulettePanel = vgui.Create("DFrame")
    roulettePanel:SetSize(1000, 700)
    roulettePanel:Center()
    roulettePanel:SetTitle("")
    roulettePanel:SetDraggable(false)
    roulettePanel:ShowCloseButton(false)
    roulettePanel:MakePopup()
    
    -- Animation setup
    wheelRotation = 0
    wheelSpeed = 20
    targetRotation = math.random(720, 1080) -- 2-3 full rotations
    isAnimating = true
    glowPulse = 0
    resultDisplayTime = 0
    
    local animationStartTime = CurTime()
    local animationDuration = 4 -- 4 seconds
    local lastSegment = -1
    
    roulettePanel.Paint = function(self, w, h)
        -- Background with particles effect
        draw.RoundedBox(0, 0, 0, w, h, Color(10, 10, 10, 250))
        
        -- Title
        draw.SimpleText("SCP UPGRADER ROULETTE", "DermaLarge", w/2, 50, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        
        if wasFailSafe then
            draw.SimpleText("🎯 GWARANCJA AKTYWNA!", "DermaDefaultBold", w/2, 85, Color(255, 215, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
        
        -- Roulette wheel center
        local centerX, centerY = w/2, h/2 + 50
        local radius = 180
        
        -- Update animation
        if isAnimating then
            local elapsed = CurTime() - animationStartTime
            local progress = math.min(elapsed / animationDuration, 1)
            
            -- Smooth deceleration
            local easedProgress = EaseOutCubic(progress)
            wheelRotation = targetRotation * easedProgress
            
            if progress >= 1 then
                isAnimating = false
                resultDisplayTime = CurTime()
                
                -- Play result sound
                for _, rarity in ipairs(rarities) do
                    if rarity.name == rarityName then
                        surface.PlaySound("upgrader_" .. rarity.tier)
                        break
                    end
                end
            else
                -- Play tick sounds during spin
                local currentSegment = math.floor((wheelRotation % 360) / (360 / #rarities))
                if currentSegment ~= lastSegment then
                    surface.PlaySound("upgrader_tick")
                    lastSegment = currentSegment
                end
            end
        end
        
        -- Draw wheel segments
        local segmentAngle = 360 / #rarities
        for i, rarity in ipairs(rarities) do
            local startAngle = (i-1) * segmentAngle + wheelRotation
            local midAngle = startAngle + segmentAngle/2
            
            -- Calculate segment position
            local segX = centerX + math.cos(math.rad(midAngle)) * radius * 0.6
            local segY = centerY + math.sin(math.rad(midAngle)) * radius * 0.6
            
            -- Enhanced glow for current result
            local glowMult = 1
            if not isAnimating and rarity.name == rarityName then
                glowMult = 2 + math.sin(CurTime() * 8) * 0.5
            end
            
            DrawGlowingBox(segX - 80, segY - 20, 160, 40, rarity.color, rarity.glowIntensity * glowMult)
            draw.SimpleText(rarity.name, "DermaDefaultBold", segX, segY, Color(0, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
        
        -- Wheel border with multiple rings
        for i = 0, 4 do
            DrawCustomCircle(centerX, centerY, radius - i * 2, Color(255, 255, 255, 60 - i * 10))
        end
        
        -- Progress ring during animation
        if isAnimating then
            local elapsed = CurTime() - animationStartTime
            local progress = elapsed / animationDuration
            DrawProgressRing(centerX, centerY, radius + 20, progress, Color(255, 215, 0), 8)
        end
        
        -- Pointer with enhanced design
        surface.SetDrawColor(255, 50, 50)
        local points = {
            {x = centerX, y = centerY - radius - 25},
            {x = centerX - 12, y = centerY - radius - 5},
            {x = centerX + 12, y = centerY - radius - 5}
        }
        surface.DrawPoly(points)
        
        -- Result display with 3D model preview
        if not isAnimating and CurTime() - resultDisplayTime > 0.5 then
            local resultY = h - 150
            
            -- Result background
            DrawGlowingBox(w/2 - 250, resultY - 50, 500, 120, Color(20, 20, 20, 240), 1.0)
            
            -- Result text with pulsing effect
            local pulse = 1 + math.sin(CurTime() * 6) * 0.2
            draw.SimpleText("WYGRAŁEŚ:", "DermaLarge", w/2, resultY - 20, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            
            local scaledColor = Color(rarityColor.r * pulse, rarityColor.g * pulse, rarityColor.b * pulse)
            draw.SimpleText(rewardItem, "DermaLarge", w/2, resultY + 15, scaledColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            
            -- Auto close after 4 seconds
            if CurTime() - resultDisplayTime > 4 then
                roulettePanel:Remove()
            end
        end
        
        -- Skip button
        if isAnimating then
            local skipBtn = "Naciśnij SPACE aby pominąć animację"
            draw.SimpleText(skipBtn, "DermaDefault", w/2, h - 30, Color(180, 180, 180), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end
    
    roulettePanel.OnKeyCodePressed = function(self, key)
        if key == KEY_SPACE and isAnimating then
            isAnimating = false
            wheelRotation = targetRotation
            resultDisplayTime = CurTime()
            
            -- Play result sound immediately
            for _, rarity in ipairs(rarities) do
                if rarity.name == rarityName then
                    surface.PlaySound("upgrader_" .. rarity.tier)
                    break
                end
            end
            
            -- Create the model panel once the animation is skipped/finished
            self:CreateModelPreview(rewardItem)
        end
    end
    
    roulettePanel.CreateModelPreview = function(self, itemClass)
        local wep = weapons.Get(itemClass)
        if not wep or not wep.ViewModel then return end

        local modelPanel = vgui.Create("DModelPanel", self)
        modelPanel:SetSize(100, 100)
        local resultY = self:GetTall() - 150
        modelPanel:SetPos(self:GetWide()/2 - 220, resultY - 25)
        modelPanel:SetModel(wep.ViewModel)
        
        -- Animation and lookat
        modelPanel:SetAnimated(true)
        local sequence = modelPanel.Entity:LookupSequence("idle")
        if sequence and sequence > 0 then
            modelPanel.Entity:SetSequence(sequence)
        end
        
        modelPanel.LayoutEntity = function(ent)
            ent:SetAngles(Angle(0, CurTime() * 50, 0))
        end
    end
    
    -- Override the on-finish logic to create the model panel
    local originalPaint = roulettePanel.Paint
    roulettePanel.Paint = function(self, w, h)
        originalPaint(self, w, h)
        
        if not isAnimating and not self.ModelPanelCreated and CurTime() - resultDisplayTime > 0.5 then
            self:CreateModelPreview(rewardItem)
            self.ModelPanelCreated = true
        end
    end
end

-- Network receivers
net.Receive("OpenUpgraderMenu", function()
    local items = net.ReadTable()
    local rarities = net.ReadTable()
    local upgrader = net.ReadEntity()
    local theme = BR.Upgrader:GetPlayerTheme(LocalPlayer())
    
    BR.UpgraderUI:CreateUpgraderMenu(items, rarities, theme, upgrader)
end)

net.Receive("SpinRoulette", function()
    local rewardItem = net.ReadString()
    local rarityName = net.ReadString()
    local rarityColor = net.ReadColor()
    local rarities = net.ReadTable()
    local wasFailSafe = net.ReadBool()
    
    BR.UpgraderUI:CreateRouletteMenu(rewardItem, rarityName, rarityColor, rarities, wasFailSafe)
end) 


================================================
FILE: gamemodes/breach/gamemode/modules/cl_vest_hud.lua
================================================
-- Client-side vest HUD display
CreateClientConVar("breach_vest_hud_enabled", "1", true, false, "Enable/disable vest HUD display")

local vestInfo = {
    ["armor_security"] = {name = "Security Vest", reduction = "10%", color = Color(100, 100, 200)},
    ["armor_mtfguard"] = {name = "MTF Guard Vest", reduction = "15%", color = Color(50, 100, 200)},
    ["armor_mtfl"] = {name = "MTF-L Vest", reduction = "17%", color = Color(50, 100, 200)},
    ["armor_mtfmedic"] = {name = "MTF Medic Vest", reduction = "15%", color = Color(200, 50, 50)},
    ["armor_csecurity"] = {name = "Security Chief Vest", reduction = "17%", color = Color(150, 150, 200)},
    ["armor_mtfcom"] = {name = "MTF Commander Vest", reduction = "27%", color = Color(200, 200, 50)},
    ["armor_hazmat"] = {name = "Hazmat Suit", reduction = "20%", color = Color(200, 200, 100)},
    ["armor_ntf"] = {name = "NTF Vest", reduction = "25%", color = Color(50, 50, 200)},
    ["armor_chaosins"] = {name = "Chaos Insurgency Vest", reduction = "20%", color = Color(100, 50, 50)},
    ["armor_goc"] = {name = "GOC Vest", reduction = "30%", color = Color(150, 150, 150)},
    ["armor_fireproof"] = {name = "Fireproof Vest", reduction = "75% Fire", color = Color(255, 100, 0)},
    ["armor_electroproof"] = {name = "Electroproof Vest", reduction = "100% Electric", color = Color(100, 200, 255)},
    ["armor_heavysupport"] = {name = "Heavy Support Vest", reduction = "50%", color = Color(80, 80, 80)}
}

-- Create font for vest display
surface.CreateFont("VestHUDFont", {
    font = "Roboto",
    extended = false,
    size = 18,
    weight = 500,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = true,
    additive = false,
    outline = false,
})

surface.CreateFont("VestHUDFontSmall", {
    font = "Roboto",
    extended = false,
    size = 14,
    weight = 400,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = true,
    additive = false,
    outline = false,
})

-- Hook to draw vest info
hook.Add("HUDPaint", "Breach_VestHUD", function()
    if disablehud then return end
    if playing then return end
    
    -- Check if vest HUD is enabled
    if GetConVar("breach_vest_hud_enabled"):GetInt() == 0 then return end
    
    local ply = LocalPlayer()
    if not ply:Alive() then return end
    if ply:GTeam() == TEAM_SPEC then return end
    
    -- Check if player has vest
    if ply.UsingArmor and vestInfo[ply.UsingArmor] then
        local vest = vestInfo[ply.UsingArmor]
        local w, h = ScrW(), ScrH()
        
        -- Position at very bottom
        local yPos = h - 20
        
        -- Simple text display
        draw.SimpleText(vest.name, "VestHUDFont", w / 2, yPos - 20, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText("Damage Reduction: " .. vest.reduction, "VestHUDFontSmall", w / 2, yPos, Color(200, 200, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
end)

-- Network receiver for vest updates
net.Receive("BR_UpdateVest", function()
    local ply = LocalPlayer()
    local vestType = net.ReadString()
    
    if vestType == "" then
        ply.UsingArmor = nil
    else
        ply.UsingArmor = vestType
    end
end)

-- Clear vest info on death
hook.Add("PlayerDeath", "BR_ClearVestOnDeath", function(victim, inflictor, attacker)
    if victim == LocalPlayer() then
        victim.UsingArmor = nil
    end
end)

-- Clear vest info on spawn
hook.Add("PlayerSpawn", "BR_ClearVestOnSpawn", function(ply)
    if ply == LocalPlayer() then
        timer.Simple(0.1, function()
            if IsValid(ply) and not ply.UsingArmor then
                ply.UsingArmor = nil
            end
        end)
    end
end)

-- Clear vest info when selecting a new class
hook.Add("BR_SelectingClass", "BR_ClearVestOnClassSelect", function()
    LocalPlayer().UsingArmor = nil
end)

-- Clear vest info on round restart
hook.Add("BR_RoundRestart", "BR_ClearVestOnRoundRestart", function()
    LocalPlayer().UsingArmor = nil
end)

-- Additional cleanup on respawn
gameevent.Listen("player_spawn")
hook.Add("player_spawn", "BR_ClearVestOnRespawn", function(data)
    local ply = Player(data.userid)
    if ply == LocalPlayer() then
        ply.UsingArmor = nil
    end
end)


================================================
FILE: gamemodes/breach/gamemode/modules/cl_vip_panic.lua
================================================
-- VIP Panic Button System - Client Side
-- Handles key binding, HUD alerts and visual effects

-- VIP panic variables
local VIPPanicCooldown = 0
local VIPPanicAlerts = {}

-- Create font for VIP alerts
surface.CreateFont("VIPPanicFont", {
    font = "Arial",
    extended = false,
    size = 16,
    weight = 700,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = true,
    additive = false,
    outline = false,
})

surface.CreateFont("VIPPanicFontBig", {
    font = "Arial",
    extended = false,
    size = 18,
    weight = 700,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = true,
    additive = false,
    outline = false,
})

-- Function to send panic signal
local function SendVIPPanic()
    local ply = LocalPlayer()
    if not IsValid(ply) or not ply:Alive() then return end
    if ply:GetNClass() != ROLES.ROLE_VIP then return end
    
    -- Send panic signal to server
    net.Start("VIP_PanicButtonPressed")
    net.SendToServer()
end

-- Key binding for VIP panic button
hook.Add("PlayerButtonDown", "VIP_PanicButton", function(ply, button)
    if ply != LocalPlayer() then return end
    if button != KEY_P then return end -- P key for panic button
    if ply:GetNClass() != ROLES.ROLE_VIP then return end
    
    SendVIPPanic()
end)

-- Receive panic alerts from server
net.Receive("VIP_PanicAlert", function()
    local vipName = net.ReadString()
    local vipPos = net.ReadVector()
    local endTime = net.ReadFloat()
    
    -- Store alert data
    table.insert(VIPPanicAlerts, {
        vipName = vipName,
        pos = vipPos,
        endTime = endTime,
        startTime = CurTime()
    })
    
    -- Play alert sound
    surface.PlaySound("ambient/alarms/klaxon1.wav")
    
    -- Show message
    local prefix = "[VIP PANIC] "
    local message = vipName .. " has activated their panic button!"
    if clang and clang.VIP_PANIC then
        prefix = clang.VIP_PANIC.alert_prefix
        message = string.format(clang.VIP_PANIC.alert_message, vipName)
    end
    chat.AddText(Color(255, 100, 100), prefix, Color(255, 255, 255), message)
end)

-- Draw VIP panic alerts on HUD
hook.Add("HUDPaint", "VIP_DrawPanicAlerts", function()
    if disablehud then return end
    
    local ply = LocalPlayer()
    if not IsValid(ply) or not ply:Alive() then return end
    if ply:GTeam() == TEAM_SPEC then return end
    
    -- Only show alerts to MTF and CI Spy
    if not (ply:GTeam() == TEAM_GUARD or (ply:GTeam() == TEAM_CHAOS and ply:GetNClass() == ROLES.ROLE_CHAOSSPY)) then return end
    
    -- Clean up expired alerts
    for i = #VIPPanicAlerts, 1, -1 do
        if CurTime() > VIPPanicAlerts[i].endTime then
            table.remove(VIPPanicAlerts, i)
        end
    end
    
    -- Draw active alerts
    for i, alert in ipairs(VIPPanicAlerts) do
        local timeLeft = math.max(0, alert.endTime - CurTime())
        local alertAge = CurTime() - alert.startTime
        
        -- Convert 3D position to 2D screen position
        local screenPos = alert.pos:ToScreen()
        
        if screenPos.visible then
            -- Calculate blinking alpha for red border
            local blinkSpeed = 3 -- Blinks per second
            local blinkAlpha = math.abs(math.sin(CurTime() * blinkSpeed * math.pi)) * 255
            
            -- Draw yellow circle with red blinking border
            local circleRadius = 25
            local circleX, circleY = screenPos.x, screenPos.y
            
            -- Draw yellow circle with custom function
            draw.NoTexture()
            
            -- Yellow background circle
            surface.SetDrawColor(255, 255, 0, 200)
            local segments = 32
            for i = 0, segments do
                local angle1 = (i / segments) * 360
                local angle2 = ((i + 1) / segments) * 360
                
                local x1 = circleX + math.cos(math.rad(angle1)) * circleRadius
                local y1 = circleY + math.sin(math.rad(angle1)) * circleRadius
                local x2 = circleX + math.cos(math.rad(angle2)) * circleRadius
                local y2 = circleY + math.sin(math.rad(angle2)) * circleRadius
                
                surface.DrawPoly({
                    {x = circleX, y = circleY},
                    {x = x1, y = y1},
                    {x = x2, y = y2}
                })
            end
            
            -- Red blinking border
            surface.SetDrawColor(255, 0, 0, blinkAlpha)
            for thickness = 1, 3 do
                local borderRadius = circleRadius + thickness
                for i = 0, segments do
                    local angle1 = (i / segments) * 360
                    local angle2 = ((i + 1) / segments) * 360
                    
                    local x1 = circleX + math.cos(math.rad(angle1)) * borderRadius
                    local y1 = circleY + math.sin(math.rad(angle1)) * borderRadius
                    local x2 = circleX + math.cos(math.rad(angle2)) * borderRadius
                    local y2 = circleY + math.sin(math.rad(angle2)) * borderRadius
                    
                    surface.DrawLine(x1, y1, x2, y2)
                end
            end
            
            -- Draw "VIP" text in center
            draw.SimpleText("VIP", "VIPPanicFontBig", circleX, circleY, Color(0, 0, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            
            -- Draw VIP name above circle
            draw.SimpleText(alert.vipName, "VIPPanicFont", circleX, circleY - 40, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            
            -- Draw timer below circle
            draw.SimpleText(string.format("%.0fs", timeLeft), "VIPPanicFont", circleX, circleY + 35, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end
    
    -- Draw panic button instruction for VIP
    if ply:GetNClass() == ROLES.ROLE_VIP then
        local instructionText = "Press [P] - VIP Panic Button"
        if VIPPanicCooldown > CurTime() then
            local cooldownLeft = math.ceil(VIPPanicCooldown - CurTime())
            instructionText = "VIP Panic Button - Cooldown: " .. cooldownLeft .. "s"
            if clang and clang.VIP_PANIC then
                instructionText = string.format(clang.VIP_PANIC.cooldown_hint, cooldownLeft)
            end
        else
            if clang and clang.VIP_PANIC then
                instructionText = clang.VIP_PANIC.button_hint
            end
        end
        
        -- Draw at bottom center of screen
        draw.SimpleText(instructionText, "VIPPanicFont", ScrW() / 2, ScrH() - 100, Color(255, 255, 100, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
end)

-- Handle panic button cooldown updates from server
net.Receive("VIP_PanicCooldown", function()
    VIPPanicCooldown = net.ReadFloat()
end)

-- Console command for VIP panic (alternative to key press)
concommand.Add("vip_panic", function()
    SendVIPPanic()
end)

-- Bind suggestion message
hook.Add("Initialize", "VIP_PanicBindSuggestion", function()
    timer.Simple(5, function()
        local ply = LocalPlayer()
        if IsValid(ply) and ply:GetNClass() == ROLES.ROLE_VIP then
            local message = "Press P for panic button or type 'vip_panic' in console!"
            if clang and clang.VIP_PANIC then
                message = clang.VIP_PANIC.bind_suggestion
            end
            chat.AddText(Color(255, 255, 100), "[VIP] ", Color(255, 255, 255), message)
        end
    end)
end) 


================================================
FILE: gamemodes/breach/gamemode/modules/cl_weapon_damage_menu.lua
================================================
-- Weapon Damage Modifiers Menu
-- Client-side GUI with improved layout

local WEAPON_DAMAGE_MODIFIERS = {}
local WeaponDamagePanel = nil
local CurrentWeaponPanel = nil

-- Receive modifiers from server
net.Receive("BR_SyncWeaponModifiers", function()
    WEAPON_DAMAGE_MODIFIERS = net.ReadTable()
    
    -- Update GUI if open
    if IsValid(WeaponDamagePanel) and WeaponDamagePanel.UpdateWeaponList then
        WeaponDamagePanel:UpdateWeaponList()
    end
    
    -- Update current weapon display
    if IsValid(CurrentWeaponPanel) then
        CurrentWeaponPanel:UpdateDisplay()
    end
end)

-- Function to create weapon panel with text inputs
local function CreateWeaponPanel(weaponClass, modifiers, parent)
    local weaponPanel = vgui.Create("DPanel", parent)
    weaponPanel:SetHeight(80)
    weaponPanel:Dock(TOP)
    weaponPanel:DockMargin(0, 0, 0, 5)
    weaponPanel.Paint = function(self, w, h)
        draw.RoundedBox(4, 0, 0, w, h, Color(60, 60, 60, 200))
        
        -- Weapon name
        draw.SimpleText(weaponClass, "DermaDefaultBold", 10, 15, Color(255, 255, 255))
        
        -- Get weapon print name if available
        local wepTable = weapons.Get(weaponClass)
        if wepTable and wepTable.PrintName then
            draw.SimpleText(wepTable.PrintName, "DermaDefault", 10, 35, Color(200, 200, 200))
        end
    end
    
    -- VS SCP controls
    local scpLabel = vgui.Create("DLabel", weaponPanel)
    scpLabel:SetPos(400, 15)
    scpLabel:SetText("VS SCP:")
    scpLabel:SetTextColor(Color(255, 100, 100))
    scpLabel:SizeToContents()
    
    local scpInput = vgui.Create("DTextEntry", weaponPanel)
    scpInput:SetPos(460, 10)
    scpInput:SetSize(60, 25)
    scpInput:SetNumeric(true)
    scpInput:SetValue(string.format("%.2f", modifiers.vs_scp))
    scpInput.OnEnter = function(self)
        local value = tonumber(self:GetValue()) or 1.0
        value = math.Clamp(value, 0, 5)
        self:SetValue(string.format("%.2f", value))
        
        -- Send update to server
        net.Start("BR_UpdateWeaponModifier")
        net.WriteString(weaponClass)
        net.WriteFloat(value)
        net.WriteFloat(modifiers.vs_human)
        net.SendToServer()
        
        modifiers.vs_scp = value
    end
    scpInput.OnLoseFocus = scpInput.OnEnter
    
    -- VS Human controls
    local humanLabel = vgui.Create("DLabel", weaponPanel)
    humanLabel:SetPos(400, 45)
    humanLabel:SetText("VS Human:")
    humanLabel:SetTextColor(Color(100, 200, 100))
    humanLabel:SizeToContents()
    
    local humanInput = vgui.Create("DTextEntry", weaponPanel)
    humanInput:SetPos(460, 40)
    humanInput:SetSize(60, 25)
    humanInput:SetNumeric(true)
    humanInput:SetValue(string.format("%.2f", modifiers.vs_human))
    humanInput.OnEnter = function(self)
        local value = tonumber(self:GetValue()) or 1.0
        value = math.Clamp(value, 0, 5)
        self:SetValue(string.format("%.2f", value))
        
        -- Send update to server
        net.Start("BR_UpdateWeaponModifier")
        net.WriteString(weaponClass)
        net.WriteFloat(modifiers.vs_scp)
        net.WriteFloat(value)
        net.SendToServer()
        
        modifiers.vs_human = value
    end
    humanInput.OnLoseFocus = humanInput.OnEnter
    
    -- Reset button for this weapon
    local resetBtn = vgui.Create("DButton", weaponPanel)
    resetBtn:SetPos(weaponPanel:GetWide() - 80, 25)
    resetBtn:SetSize(70, 30)
    resetBtn:SetText("Reset")
    resetBtn.DoClick = function()
        scpInput:SetValue("1.00")
        humanInput:SetValue("1.00")
        scpInput:OnEnter()
        humanInput:OnEnter()
    end
    resetBtn.Paint = function(self, w, h)
        local color = self:IsHovered() and Color(100, 100, 100) or Color(70, 70, 70)
        draw.RoundedBox(4, 0, 0, w, h, color)
    end
    
    return weaponPanel
end

-- Create current weapon display panel
local function CreateCurrentWeaponPanel(parent)
    CurrentWeaponPanel = vgui.Create("DPanel", parent)
    CurrentWeaponPanel:Dock(RIGHT)
    CurrentWeaponPanel:SetWide(250)
    CurrentWeaponPanel:DockMargin(5, 5, 5, 5)
    CurrentWeaponPanel.Paint = function(self, w, h)
        draw.RoundedBox(8, 0, 0, w, h, Color(40, 40, 40, 250))
        draw.RoundedBox(8, 0, 0, w, 30, Color(20, 20, 20, 255))
        draw.SimpleText("Current Weapon", "DermaDefaultBold", w/2, 15, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    
    CurrentWeaponPanel.UpdateDisplay = function(self)
        -- Clear old display
        for _, child in pairs(self:GetChildren()) do
            if child.IsInfoPanel then
                child:Remove()
            end
        end
        
        local ply = LocalPlayer()
        if not IsValid(ply) then return end
        
        local wep = ply:GetActiveWeapon()
        if not IsValid(wep) then
            local noWepPanel = vgui.Create("DPanel", self)
            noWepPanel:SetPos(10, 40)
            noWepPanel:SetSize(230, 60)
            noWepPanel.IsInfoPanel = true
            noWepPanel.Paint = function(self, w, h)
                draw.SimpleText("No weapon equipped", "DermaDefault", w/2, h/2, Color(150, 150, 150), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            end
            return
        end
        
        local weaponClass = wep:GetClass()
        local modifiers = WEAPON_DAMAGE_MODIFIERS[weaponClass] or { vs_scp = 1.0, vs_human = 1.0 }
        
        -- Weapon info panel
        local infoPanel = vgui.Create("DPanel", self)
        infoPanel:SetPos(10, 40)
        infoPanel:SetSize(230, 150)
        infoPanel.IsInfoPanel = true
        infoPanel.Paint = function(self, w, h)
            -- Weapon class
            draw.SimpleText("Class:", "DermaDefault", 5, 5, Color(200, 200, 200))
            draw.SimpleText(weaponClass, "DermaDefaultBold", 5, 20, Color(255, 255, 255))
            
            -- Weapon print name
            if wep.PrintName then
                draw.SimpleText("Name:", "DermaDefault", 5, 45, Color(200, 200, 200))
                draw.SimpleText(wep.PrintName, "DermaDefaultBold", 5, 60, Color(255, 255, 255))
            end
            
            -- Divider
            surface.SetDrawColor(100, 100, 100, 255)
            surface.DrawLine(5, 85, w-5, 85)
            
            -- Modifiers
            draw.SimpleText("Current Modifiers:", "DermaDefaultBold", 5, 95, Color(255, 200, 0))
            
            -- VS SCP
            local scpColor = modifiers.vs_scp > 1 and Color(255, 100, 100) or 
                           modifiers.vs_scp < 1 and Color(100, 100, 255) or 
                           Color(200, 200, 200)
            draw.SimpleText("VS SCP:", "DermaDefault", 5, 115, Color(255, 100, 100))
            draw.SimpleText(string.format("%.2fx", modifiers.vs_scp), "DermaDefaultBold", 100, 115, scpColor)
            
            -- VS Human
            local humanColor = modifiers.vs_human > 1 and Color(255, 100, 100) or 
                             modifiers.vs_human < 1 and Color(100, 100, 255) or 
                             Color(200, 200, 200)
            draw.SimpleText("VS Human:", "DermaDefault", 5, 135, Color(100, 200, 100))
            draw.SimpleText(string.format("%.2fx", modifiers.vs_human), "DermaDefaultBold", 100, 135, humanColor)
        end
    end
    
    -- Update timer
    timer.Create("UpdateCurrentWeapon", 0.5, 0, function()
        if IsValid(CurrentWeaponPanel) then
            CurrentWeaponPanel:UpdateDisplay()
        else
            timer.Remove("UpdateCurrentWeapon")
        end
    end)
    
    CurrentWeaponPanel:UpdateDisplay()
    
    return CurrentWeaponPanel
end

-- Create the main menu
local function CreateWeaponDamageMenu()
    if IsValid(WeaponDamagePanel) then
        WeaponDamagePanel:Remove()
    end
    
    -- Request latest data from server
    net.Start("BR_RequestWeaponModifiers")
    net.SendToServer()
    
    -- Main frame - larger size
    WeaponDamagePanel = vgui.Create("DFrame")
    WeaponDamagePanel:SetSize(1000, 700)
    WeaponDamagePanel:Center()
    WeaponDamagePanel:SetTitle("Weapon Damage Modifiers")
    WeaponDamagePanel:SetVisible(true)
    WeaponDamagePanel:SetDraggable(true)
    WeaponDamagePanel:ShowCloseButton(true)
    WeaponDamagePanel:MakePopup()
    WeaponDamagePanel.Paint = function(self, w, h)
        draw.RoundedBox(8, 0, 0, w, h, Color(50, 50, 50, 250))
        draw.RoundedBox(8, 0, 0, w, 25, Color(30, 30, 30, 255))
    end
    WeaponDamagePanel.OnClose = function()
        timer.Remove("UpdateCurrentWeapon")
    end
    
    -- Main container
    local mainContainer = vgui.Create("DPanel", WeaponDamagePanel)
    mainContainer:Dock(FILL)
    mainContainer:DockMargin(5, 5, 5, 5)
    mainContainer.Paint = function() end
    
    -- Left panel for weapon list
    local leftPanel = vgui.Create("DPanel", mainContainer)
    leftPanel:Dock(FILL)
    leftPanel:DockMargin(0, 0, 0, 0)
    leftPanel.Paint = function() end
    
    -- Current weapon panel on the right
    CreateCurrentWeaponPanel(mainContainer)
    
    -- Info panel
    local infoPanel = vgui.Create("DPanel", leftPanel)
    infoPanel:Dock(TOP)
    infoPanel:SetHeight(60)
    infoPanel:DockMargin(0, 0, 0, 5)
    infoPanel.Paint = function(self, w, h)
        draw.RoundedBox(4, 0, 0, w, h, Color(30, 30, 30, 200))
        draw.SimpleText("Modify damage multipliers for CW2.0 weapons", "DermaDefault", 10, 10, Color(255, 255, 255))
        draw.SimpleText("Enter values between 0.00 and 5.00 | 1.00 = Normal damage", "DermaDefault", 10, 25, Color(200, 200, 200))
        draw.SimpleText("Changes are saved automatically and applied immediately", "DermaDefault", 10, 40, Color(200, 200, 200))
    end
    
    -- Search bar
    local searchPanel = vgui.Create("DPanel", leftPanel)
    searchPanel:Dock(TOP)
    searchPanel:SetHeight(35)
    searchPanel:DockMargin(0, 0, 0, 5)
    searchPanel.Paint = function(self, w, h)
        draw.RoundedBox(4, 0, 0, w, h, Color(30, 30, 30, 200))
    end
    
    local searchLabel = vgui.Create("DLabel", searchPanel)
    searchLabel:SetPos(10, 8)
    searchLabel:SetText("Search:")
    searchLabel:SetTextColor(Color(255, 255, 255))
    searchLabel:SizeToContents()
    
    local searchBox = vgui.Create("DTextEntry", searchPanel)
    searchBox:SetPos(60, 5)
    searchBox:SetSize(200, 25)
    searchBox:SetText("")
    searchBox.OnChange = function()
        if IsValid(WeaponDamagePanel) then
            WeaponDamagePanel:UpdateWeaponList(searchBox:GetValue())
        end
    end
    
    -- Reset all button
    local resetAllBtn = vgui.Create("DButton", searchPanel)
    resetAllBtn:SetPos(searchPanel:GetWide() - 270, 5)
    resetAllBtn:SetSize(150, 25)
    resetAllBtn:SetText("Reset All to Default")
    resetAllBtn.DoClick = function()
        Derma_Query(
            "Are you sure you want to reset ALL weapon damage modifiers to 1.0?",
            "Confirm Reset",
            "Yes", function()
                RunConsoleCommand("br_reset_weapon_modifiers")
            end,
            "No", function() end
        )
    end
    resetAllBtn.Paint = function(self, w, h)
        local color = self:IsHovered() and Color(200, 50, 50) or Color(150, 50, 50)
        draw.RoundedBox(4, 0, 0, w, h, color)
    end
    
    -- Headers
    local headerPanel = vgui.Create("DPanel", leftPanel)
    headerPanel:Dock(TOP)
    headerPanel:SetHeight(30)
    headerPanel:DockMargin(0, 0, 0, 5)
    headerPanel.Paint = function(self, w, h)
        draw.RoundedBox(4, 0, 0, w, h, Color(40, 40, 40, 200))
        draw.SimpleText("Weapon", "DermaDefaultBold", 10, h/2, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        draw.SimpleText("VS SCP", "DermaDefaultBold", 430, h/2, Color(255, 100, 100), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText("VS Human", "DermaDefaultBold", 490, h/2, Color(100, 200, 100), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText("Actions", "DermaDefaultBold", w - 45, h/2, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    
    -- Weapon list
    local weaponScroll = vgui.Create("DScrollPanel", leftPanel)
    weaponScroll:Dock(FILL)
    weaponScroll:DockMargin(0, 0, 0, 0)
    
    local weaponContainer = vgui.Create("DPanel", weaponScroll)
    weaponContainer:Dock(FILL)
    weaponContainer.Paint = function() end
    
    -- Store weapon panels
    local weaponPanels = {}
    
    -- Function to update weapon list
    WeaponDamagePanel.UpdateWeaponList = function(self, filter)
        -- Clear existing panels
        for _, panel in pairs(weaponPanels) do
            if IsValid(panel) then
                panel:Remove()
            end
        end
        weaponPanels = {}
        
        -- Get all CW weapons
        local allWeapons = {}
        
        -- First add all known modifiers
        for weaponClass, modifiers in pairs(WEAPON_DAMAGE_MODIFIERS) do
            allWeapons[weaponClass] = modifiers
        end
        
        -- Then add any CW weapons from the weapon list that aren't already in modifiers
        for _, wep in pairs(weapons.GetList()) do
            if string.StartWith(wep.ClassName or "", "cw_") then
                if not allWeapons[wep.ClassName] then
                    allWeapons[wep.ClassName] = { vs_scp = 1.0, vs_human = 1.0 }
                end
            end
        end
        
        -- Sort weapons alphabetically
        local sortedWeapons = {}
        for weaponClass, _ in pairs(allWeapons) do
            if not filter or filter == "" or string.find(string.lower(weaponClass), string.lower(filter)) then
                table.insert(sortedWeapons, weaponClass)
            end
        end
        table.sort(sortedWeapons)
        
        -- Create entry for each weapon
        local yPos = 5
        for _, weaponClass in ipairs(sortedWeapons) do
            local modifiers = allWeapons[weaponClass]
            local panel = CreateWeaponPanel(weaponClass, modifiers, weaponContainer)
            panel:SetPos(5, yPos)
            panel:SetWide(weaponContainer:GetWide() - 10)
            table.insert(weaponPanels, panel)
            yPos = yPos + 85
        end
        
        -- Update container height
        weaponContainer:SetTall(yPos)
    end
    
    -- Initial population
    WeaponDamagePanel:UpdateWeaponList()
end

-- Console command to open menu
concommand.Add("br_weapon_damage_menu", function()
    if not LocalPlayer():IsSuperAdmin() then
        chat.AddText(Color(255, 0, 0), "[WEAPON MODIFIERS] ", Color(255, 255, 255), "Only super admins can access this menu!")
        return
    end
    
    CreateWeaponDamageMenu()
end)

-- Add to F4 menu or custom menu
hook.Add("OnSpawnMenuOpen", "BR_WeaponDamageMenuHint", function()
    if LocalPlayer():IsSuperAdmin() then
        -- Show hint once per session
        if not LocalPlayer().WeaponMenuHintShown then
            LocalPlayer().WeaponMenuHintShown = true
            timer.Simple(0.5, function()
                chat.AddText(Color(255, 200, 0), "[TIP] ", Color(255, 255, 255), "Use console command 'br_weapon_damage_menu' to open weapon damage modifiers menu")
            end)
        end
    end
end)

-- Help command
concommand.Add("br_weapon_damage_help", function()
    print("=== Weapon Damage Modifiers System ===")
    print("Commands:")
    print("  br_weapon_damage_menu - Opens the weapon damage modifiers menu (admin only)")
    print("  br_reload_weapon_modifiers - Reloads modifiers from file (admin only)")
    print("  br_reset_weapon_modifiers - Resets all modifiers to 1.0 (admin only)")
    print("  br_weapon_modifiers_hud 0/1 - Toggle HUD display")
    print("")
    print("Multiplier values:")
    print("  1.0 = Normal damage (100%)")
    print("  0.5 = Half damage (50%)")
    print("  2.0 = Double damage (200%)")
    print("  0.0 = No damage")
    print("  5.0 = Maximum allowed (500%)")
end)

-- HUD Display for weapon modifiers
local showModifiersHUD = CreateClientConVar("br_weapon_modifiers_hud", "1", true, false, "Show weapon damage modifiers on HUD")

hook.Add("HUDPaint", "BR_WeaponModifiersHUD", function()
    if not showModifiersHUD:GetBool() then return end
    
    local ply = LocalPlayer()
    if not IsValid(ply) or not ply:Alive() then return end
    
    local wep = ply:GetActiveWeapon()
    if not IsValid(wep) then return end
    
    local weaponClass = wep:GetClass()
    
    -- Only show for CW weapons
    if not string.StartWith(weaponClass, "cw_") then
        return
    end
    
    local modifiers = WEAPON_DAMAGE_MODIFIERS[weaponClass] or { vs_scp = 1.0, vs_human = 1.0 }
    
    -- Get base damage (for CW weapons)
    local baseDamage = 0
    if wep.Damage then
        baseDamage = wep.Damage
    elseif wep.Primary and wep.Primary.Damage then
        baseDamage = wep.Primary.Damage
    end
    
    -- Position on the right side of screen (compact layout)
    local x = ScrW() - 100
    local y = ScrH() / 2 - 50
    
    -- Background
    draw.RoundedBox(6, x - 10, y - 5, 100, 90, Color(0, 0, 0, 200))
    
    -- Title
    draw.SimpleText("DMG MOD", "DermaDefaultBold", x + 35, y + 5, Color(255, 200, 0), TEXT_ALIGN_CENTER)
    
    -- SCP Section
    local scpY = y + 20
    local scpColor = modifiers.vs_scp > 1 and Color(255, 100, 100) or
                   modifiers.vs_scp < 1 and Color(100, 150, 255) or
                   Color(200, 200, 200)
    
    draw.SimpleText("SCP", "DermaDefault", x, scpY, Color(255, 150, 150))
    draw.SimpleText(string.format("%.2fx", modifiers.vs_scp), "DermaDefaultBold", x + 75, scpY, scpColor, TEXT_ALIGN_RIGHT)
    
    if baseDamage > 0 then
        local scpDamage = baseDamage * modifiers.vs_scp
        draw.SimpleText(string.format("%.0f dmg", scpDamage), "DermaDefault", x + 75, scpY + 12, Color(200, 200, 200), TEXT_ALIGN_RIGHT)
    end
    
    -- Human Section
    local humanY = y + 50
    local humanColor = modifiers.vs_human > 1 and Color(255, 100, 100) or
                     modifiers.vs_human < 1 and Color(100, 150, 255) or
                     Color(200, 200, 200)
    
    draw.SimpleText("Human", "DermaDefault", x, humanY, Color(150, 255, 150))
    draw.SimpleText(string.format("%.2fx", modifiers.vs_human), "DermaDefaultBold", x + 75, humanY, humanColor, TEXT_ALIGN_RIGHT)
    
    if baseDamage > 0 then
        local humanDamage = baseDamage * modifiers.vs_human
        draw.SimpleText(string.format("%.0f dmg", humanDamage), "DermaDefault", x + 75, humanY + 12, Color(200, 200, 200), TEXT_ALIGN_RIGHT)
    end
end)


================================================
FILE: gamemodes/breach/gamemode/modules/jarate_example.txt
================================================
-- PRZYKŁAD JAK DODAĆ JARATE DO ROLI W BREACH
-- Ten plik to tylko dokumentacja, nie jest ładowany przez grę

-- 1. DODANIE DO KONKRETNEJ ROLI
-- W pliku gamemodes/breach/gamemode/modules/sh_classes.lua
-- Znajdź definicję roli i dodaj "weapon_jarate" do tablicy weapons

-- Przykład dla roli Cook:
cook = {
    name = "Cook",
    color = Color(115, 69, 69, 255),
    weapons = {"weapon_crowbar", "weapon_doner_knife", "weapon_jarate"}, -- Dodane weapon_jarate
    ammo = {["jarate"] = 2}, -- Opcjonalnie: dodatkowa amunicja
    -- reszta konfiguracji...
}

-- 2. DODANIE DO SPAWNU DLA WSZYSTKICH
-- W pliku gamemodes/breach/gamemode/modules/sv_player.lua
-- W funkcji GM:PlayerSpawn(ply) możesz dodać:
ply:Give("weapon_jarate")
ply:GiveAmmo(1, "jarate", true)

-- 3. DODANIE DO SKLEPU/WYPOSAŻENIA
-- Jeśli masz system sklepu, dodaj item:
SHOP_ITEMS["jarate"] = {
    name = "Jarate",
    price = 100,
    weapon = "weapon_jarate",
    ammo = "jarate",
    ammocount = 1,
}

-- 4. KONFIGURACJA
-- Możesz zmienić ustawienia przez konsolę:
-- blossomJarateDuration 10     - czas trwania efektu (sekundy)
-- blossomJarateStrenght 0.35   - mnożnik obrażeń (0.35 = +35%)
-- blossomJarateRange 150       - zasięg wybuchu
-- blossomJarateThrow 650       - siła rzutu
-- blossomJarateCount 1         - ilość słoików

-- 5. EFEKTY SPECJALNE
-- Jarate automatycznie:
-- - Nakłada żółty overlay na ekran gracza
-- - Zmienia kolor postaci na żółty
-- - Dodaje cząsteczki moczu spadające z postaci
-- - Zwiększa otrzymywane obrażenia o 35%
-- - Można zmyć wodą (gracz musi wejść do wody)
-- - Efekt znika po śmierci lub po upływie czasu

-- 6. TROUBLESHOOTING
-- Jeśli brakuje tekstur/dźwięków:
-- - Upewnij się że masz zainstalowany oryginalny addon Jarate
-- - Lub skopiuj pliki z jarate/materials i jarate/sound do odpowiednich folderów 


================================================
FILE: gamemodes/breach/gamemode/modules/sh_bodycam_sounds.lua
================================================
AddCSLuaFile()

sound.Add( {
    name = "Stalker2.PDAEquip",
    channel = CHAN_WEAPON,
    volume = 1,
    level = 65,
    pitch = {95, 100},
    sound = {
        "weapons/stalker2/pda/SFX_PDA_Equip_01.mp3",
		"weapons/stalker2/pda/SFX_PDA_Equip_02.mp3",
		"weapons/stalker2/pda/SFX_PDA_Equip_03.mp3",
    } 
} )

sound.Add( {
    name = "Stalker2.PDAUnequip",
    channel = CHAN_WEAPON,
    volume = 1,
    level = 65,
    pitch = {95, 100},
    sound = {
        "weapons/stalker2/pda/SFX_PDA_Unequip_01.mp3",
		"weapons/stalker2/pda/SFX_PDA_Unequip_02.mp3",
		"weapons/stalker2/pda/SFX_PDA_Unequip_03.mp3",
    }
} ) 


================================================
FILE: gamemodes/breach/gamemode/modules/sh_class_breach.lua
================================================
DEFINE_BASECLASS( "player_default" )

local PLAYER = {}

function PLAYER:SetupDataTables()
	
	self.Player:NetworkVar( "String", 0, "NClass" )
	self.Player:NetworkVar( "String", 1, "LastRole" )
	self.Player:NetworkVar( "Int", 0, "NEXP" )
	self.Player:NetworkVar( "Int", 1, "NLevel" )
	self.Player:NetworkVar( "Int", 2, "NGTeam" )
	self.Player:NetworkVar( "Int", 3, "LastTeam" )
	self.Player:NetworkVar( "Bool", 0, "NActive" )
	self.Player:NetworkVar( "Bool", 1, "NPremium" )
	
	if SERVER then
		print("Setting up datatables for " .. self.Player:Nick())
		self.Player:SetNClass("Spectator")
		self.Player:SetLastRole( "" )
		self.Player:SetLastTeam( 0 )
		CheckPlayerData( self.Player, "breach_exp" )
		CheckPlayerData( self.Player, "breach_level" )
		self.Player:SetNEXP( tonumber( self.Player:GetPData( "breach_exp", 0 ) ) )
		self.Player:SetNLevel( tonumber( self.Player:GetPData( "breach_level", 0 ) ) )
		self.Player:SetNGTeam(1)
		-- Napraw problem z przezroczystością - ustaw domyślnie true jeśli ActivePlayer nie jest zdefiniowane
		if self.Player.ActivePlayer == nil then
			self.Player.ActivePlayer = true
		end
		self.Player:SetNActive( self.Player.ActivePlayer )
		self.Player:SetNPremium( self.Player.Premium or false )
	end
end

function CheckPlayerData( player, name )
	local pd = player:GetPData( name, 0 )
	if pd == "nil" then
		print( "Damaged playerdata found..." )
		player:RemovePData( name )
		player:SetPData( name, 1 )
	end
end

player_manager.RegisterClass( "class_breach", PLAYER, "player_default" )


================================================
FILE: gamemodes/breach/gamemode/modules/sh_classes.lua
================================================
RESEARCHERMODELS = {
	"models/bmscientistcits/p_female_01.mdl",
	"models/bmscientistcits/p_female_02.mdl",
	"models/bmscientistcits/p_female_03.mdl",
	"models/bmscientistcits/p_female_04.mdl",
	"models/bmscientistcits/p_female_06.mdl",
	"models/bmscientistcits/p_female_07.mdl",
	"models/bmscientistcits/p_male_01.mdl",
	"models/bmscientistcits/p_male_02.mdl",
	"models/bmscientistcits/p_male_03.mdl",
	"models/bmscientistcits/p_male_04.mdl",
	"models/bmscientistcits/p_male_05.mdl",
	"models/bmscientistcits/p_male_06.mdl",
	"models/bmscientistcits/p_male_07.mdl",
	"models/bmscientistcits/p_male_08.mdl",
	"models/bmscientistcits/p_male_09.mdl",
	"models/bmscientistcits/p_male_10.mdl",
	"models/scp/apsci_cohrt.mdl",
	"models/scp/apsci_male_02.mdl",
	"models/scp/apsci_male_03.mdl",
	"models/scp/apsci_male_05.mdl",
	"models/scp/apsci_male_07.mdl",
	"models/scp/apsci_male_08.mdl",
	"models/scp/apsci_male_09.mdl",
}
CHAOSMODELS = {
	/*"models/kerry/merriweather1.mdl",
	"models/kerry/merriweather2.mdl",
	"models/kerry/merriweather3.mdl",
	"models/kerry/merriweather4.mdl",
	"models/kerry/merriweather5.mdl",
	"models/kerry/merriweather6.mdl",
	"models/kerry/merriweather7.mdl",
	"models/kerry/merriweather8.mdl",*/
	"models/kerry/player/merriweather/male_01.mdl",
	"models/kerry/player/merriweather/male_02.mdl",
	"models/kerry/player/merriweather/male_03.mdl",
	"models/kerry/player/merriweather/male_04.mdl",
	"models/kerry/player/merriweather/male_05.mdl",
	"models/kerry/player/merriweather/male_06.mdl",
	"models/kerry/player/merriweather/male_07.mdl",
	"models/kerry/player/merriweather/male_08.mdl",
	"models/kerry/player/merriweather/male_09.mdl",
}
SECURITYMODELS = {
	"models/npc/portal/Male_02_Garde.mdl",
	"models/npc/portal/Male_04_Garde.mdl",
	"models/npc/portal/Male_05_Garde.mdl",
	"models/npc/portal/Male_06_Garde.mdl",
	"models/npc/portal/Male_07_Garde.mdl",
	"models/npc/portal/Male_08_Garde.mdl",
	"models/npc/portal/Male_09_Garde.mdl",
}
CLASSDMODELS = {
	"models/player/kerry/class_d_1.mdl",
	"models/player/kerry/class_d_2.mdl",
	"models/player/kerry/class_d_3.mdl",
	"models/player/kerry/class_d_4.mdl",
	"models/player/kerry/class_d_5.mdl",
	"models/player/kerry/class_d_6.mdl",
	"models/player/kerry/class_d_7.mdl",
}
VETERANMODELS = {
	"models/player/kerry/Class_Jan_2.mdl",
	"models/player/kerry/Class_Jan_3.mdl",
	"models/player/kerry/Class_Jan_4.mdl",
	"models/player/kerry/Class_Jan_5.mdl",
	"models/player/kerry/Class_Jan_6.mdl",
	"models/player/kerry/Class_Jan_7.mdl",
}
SCOUTDMODELS = {
	"models/player/cheddar/class_d/scout/scout_art.mdl",
	"models/player/cheddar/class_d/scout/scout_mike.mdl",
	"models/player/cheddar/class_d/scout/scout_vance.mdl",
}
MEDICMODELS = {
	"models/player/portal/male_01_medic.mdl",
	"models/player/portal/male_02_medic.mdl",
	"models/player/portal/male_03_medic.mdl",
	"models/player/portal/male_04_medic.mdl",
	"models/player/portal/male_05_medic.mdl",
	"models/player/portal/male_06_medic.mdl",
	"models/player/portal/male_07_medic.mdl",
}
CICMODELS = {
	"models/scp/jumpsuitm1.mdl",
	"models/scp/jumpsuitm2.mdl",
	"models/scp/jumpsuitm3.mdl",
	"models/scp/jumpsuitm4.mdl",
	"models/scp/jumpsuitm5.mdl",
	"models/scp/jumpsuitm6.mdl",
	"models/scp/jumpsuitm7.mdl",
	"models/scp/jumpsuitm8.mdl",
	"models/scp/jumpsuitm9.mdl",
}

ALLCLASSES = {
	classds = {
		name = "Class D Personell",
		color = Color(255, 130, 0),
		roles = {
			{name = ROLES.ROLE_CLASSD,
			 team = TEAM_CLASSD,
			 weapons = {"br_holster", "br_id"},
			 showweapons = {},
			 keycard = "",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 1,
			 runspeed = 1,
			 jumppower = 1,
			 vest = nil,
			 models = CLASSDMODELS,
			 showmodel = nil,
			 level = 0,
			 customcheck = nil,
			 flashlight = false,
			 max = 0
			},
			{name = ROLES.ROLE_CLASSD,
			 team = TEAM_CLASSD,
			 weapons = {"br_holster", "br_id"},
			 showweapons = {"Keycard Level 1"},
			 keycard = "safe",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 1,
			 runspeed = 1,
			 jumppower = 1,
			 vest = nil,
			 models = CLASSDMODELS,
			 showmodel = nil,
			 level = 0,
			 customcheck = nil,
			 flashlight = false,
			 max = 0
			},
			{name = ROLES.ROLE_VETERAN,
			 team = TEAM_CLASSD,
			 weapons = {"br_holster", "br_id", "weapon_piss"},
			 showweapons = {"Keycard Level 1", "Jarate (25%)"},
			 keycard = "safe",
			 ammo = {{"weapon_piss", 1}},
			 health = 120,
			 armor = 0,
			 walkspeed = 1.1,
			 runspeed = 1.1,
			 jumppower = 1.1,
			 vest = nil,
			 models = CLASSDMODELS,
			 showmodel = nil,
			 flashlight = true,
			 level = 6,
			 max = 2
			},
			{name = ROLES.ROLE_SCOUT_D,
			 team = TEAM_CLASSD,
			 		weapons = {"br_holster", "br_id", "item_radio", "weapon_pocket_knife"},
			 showweapons = {"Keycard Level 2", "Radio (50%)", "Pocket Knife (25%)"},
			 keycard = "euclid",
			 ammo = {},
			 health = 110,
			 armor = 0,
			 walkspeed = 1.2,
			 runspeed = 1.2,
			 jumppower = 1.2,
			 vest = nil,
			 models = SCOUTDMODELS,
			 showmodel = nil,
			 flashlight = true,
			 level = 4,
			 max = 2
			},
					{name = ROLES.ROLE_FAT_D,
		 team = TEAM_CLASSD,
		 weapons = {"br_holster", "br_id"},
		 showweapons = {"Keycard Level 1"},
		 keycard = "safe",
		 ammo = {},
		 health = 150,
		 armor = 0,
		 walkspeed = 0.8,
		 runspeed = 0.9,
		 jumppower = 0.7,
		 vest = nil,
		 models = CLASSDMODELS,
		 showmodel = nil,
		 flashlight = true,
		 level = 2,
		 max = 2,
		 fatbelly = true
		},
		{name = ROLES.ROLE_SKINNY_D,
		 team = TEAM_CLASSD,
		 weapons = {"br_holster", "br_id"},
		 showweapons = {"Keycard Level 1"},
		 keycard = "safe",
		 ammo = {},
		 health = 80,
		 armor = 0,
		 walkspeed = 1.3,
		 runspeed = 1.4,
		 jumppower = 1.3,
		 vest = nil,
		 models = CLASSDMODELS,
		 showmodel = nil,
		 flashlight = true,
		 level = 1,
		 max = 1,
		 skinnybody = true
		},

		{name = ROLES.ROLE_SCP527,
		 team = TEAM_CLASSD,
		 weapons = {"br_holster", "br_id"},
		 showweapons = {"No Keycard"},
		 keycard = "",
		 ammo = {},
		 health = 100,
		 armor = 0,
		 walkspeed = 1.0,
		 runspeed = 1.0,
		 jumppower = 1.0,
		 vest = nil,
		 models = {"models/scp_527/scp_527.mdl"},
		 showmodel = "models/scp_527/scp_527.mdl",
		 flashlight = true,
		 level = 3,
		 max = 1
		},
			{name = ROLES.ROLE_CIC,
			 team = TEAM_CHAOS,
			 weapons = {"br_holster", "br_id", "weapon_zeus"},
			 showweapons = {"Keycard Level 1", "Taser"},
			 keycard = "safe",
			 ammo = {{"weapon_zeus", 1}},
			 health = 120,
			 armor = 0,
			 walkspeed = 1.1,
			 runspeed = 1.1,
			 jumppower = 1.1,
			 vest = nil,
			 models = CLASSDMODELS,
			 showmodel = nil,
			 flashlight = true,
			 level = 9,
			 max = 1
			},
					{name = ROLES.ROLE_DCLASS_INFECTED,
		 team = TEAM_CLASSD,
		 weapons = {"br_holster", "br_id"},
		 showweapons = {"No Keycard", "Viral Infection"},
		 keycard = "",
		 ammo = {},
		 health = 80,
		 armor = 0,
		 walkspeed = 0.9,
		 runspeed = 0.9,
		 jumppower = 1,
		 vest = nil,
		 models = {"models/snood_17/citizen_17_snood_pm.mdl"},
		 showmodel = "models/snood_17/citizen_17_snood_pm.mdl",
		 flashlight = false,
		 level = 1,
		 max = 1
		},
		{name = ROLES.ROLE_THIEF_D,
		 team = TEAM_CLASSD,
		 weapons = {"br_holster", "br_id"},
		 showweapons = {"Keycard Level 1", "Weapon Theft (Passive)"},
		 keycard = "safe",
		 ammo = {},
		 health = 90,
		 armor = 0,
		 walkspeed = 1.1,
		 runspeed = 1.1,
		 jumppower = 1.0,
		 vest = nil,
		 models = CLASSDMODELS,
		 showmodel = nil,
		 flashlight = true,
		 level = 2,
			 max = 1
			}
		}
	},
	researchers = {
		name = "Unarmed Site Staff",
		color = Color(66, 188, 244),
		roles = {
			{name = ROLES.ROLE_RES,
			 team = TEAM_SCI,
			 weapons = {"br_holster", "br_id"},
			 showweapons = {"Keycard Level 1"},
			 keycard = "res",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 1,
			 runspeed = 1,
			 jumppower = 1,
			 vest = nil,
			 models = RESEARCHERMODELS,
			 showmodel = nil,
			 flashlight = true,
			 level = 0,
			 max = 0
			},
			{name = ROLES.ROLE_MEDIC,
			 team = TEAM_SCI,
			 weapons = {"br_holster", "br_id", "item_ultramedkit"},
			 showweapons = {"Researcher Keycard", "Med Kit"},
			 keycard = "res",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 1,
			 runspeed = 1,
			 jumppower = 1,
			 vest = nil,
			 models = MEDICMODELS,
			 showmodel = nil,
			 flashlight = true,
			 level = 1,
			 max = 2
			},
			{name = ROLES.ROLE_NO3,
			 team = TEAM_SCI,
			 weapons = {"br_holster", "br_id", "item_radio", "item_nvg"},
			 showweapons = {"Radio", "NVG", "Researcher Keycard"},
			 keycard = "res",
			 ammo = {},
			 health = 150,
			 armor = 0,
			 walkspeed = 1.05,
			 runspeed = 1.05,
			 jumppower = 1.05,
			 vest = nil,
			 models = RESEARCHERMODELS,
			 showmodel = nil,
			 flashlight = true,
			 level = 8,
			 max = 1
			},
			{name = ROLES.ROLE_JANITOR,
			 team = TEAM_SCI,
			 weapons = {"br_holster", "br_id", "weapon_broom"},
			 showweapons = {"Keycard Level 1", "Broom"},
			 keycard = "safe",
			 ammo = {},
			 health = 90,
			 armor = 0,
			 walkspeed = 1.0,
			 runspeed = 1.0,
			 jumppower = 1.0,
			 vest = nil,
			 models = VETERANMODELS,
			 showmodel = nil,
			 flashlight = true,
			 level = 1,
			 max = 1
			},
			{name = ROLES.ROLE_VIP,
			 team = TEAM_SCI,
			 weapons = {"br_holster", "br_id", "item_radio", "weapon_pocket_knife"},
			 showweapons = {"Checkpoint Security Keycard", "Radio", "Pocket Knife (25%)"},
			 keycard = "cps",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 1.0,
			 runspeed = 1.0,
			 jumppower = 1.0,
			 vest = nil,
			 models = {"models/male_09_vip/vip_player/male_09_vip_player.mdl"},
			 showmodel = nil,
			 flashlight = true,
			 level = 3,
			 max = 1,
			 bodygroups = {{0, 2}, {1, 2}, {2, 1}}
			},
			{name = ROLES.ROLE_CLEARANCE_TECH,
			 team = TEAM_SCI,
			 				 		weapons = {"br_holster", "br_id", "item_radio", "weapon_doorcontrol"},
		 showweapons = {"Researcher Keycard", "Radio", "Door Controller"},
			 keycard = "res",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 1.0,
			 runspeed = 1.0,
			 jumppower = 1.0,
			 vest = nil,
			 models = {"models/player/cheddar/bms/bms_technician.mdl"},
			 showmodel = nil,
			 flashlight = true,
			 level = 2,
			 max = 1,
			 bodygroups_random = {{0, {0, 14}}, {1, {1, 1}}, {2, {0, 3}}}
			},
			{name = ROLES.ROLE_ENGINEER,
			 team = TEAM_SCI,
			 weapons = {"br_holster", "br_id", "item_radio", "weapon_crowbar"},
			 showweapons = {"Researcher Keycard", "Radio", "Crowbar"},
			 keycard = "res",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 1.0,
			 runspeed = 1.0,
			 jumppower = 1.0,
			 vest = nil,
			 models = {"models/worker_04/worker_04.mdl"},
			 showmodel = nil,
			 flashlight = true,
			 level = 2,
			 max = 1,
			},
			{name = ROLES.ROLE_COOK,
			 team = TEAM_SCI,
			 		weapons = {"br_holster", "br_id", "weapon_doner_knife"},
			 showweapons = {"Researcher Keycard", "Doner Knife", "Kebab Stand Spawner"},
			 keycard = "res",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 1.0,
			 runspeed = 1.0,
			 jumppower = 1.0,
			 vest = nil,
			 models = {"models/fearless/chef1.mdl"},
			 showmodel = nil,
			 flashlight = true,
			 level = 1,
			 max = 1
			},
			{name = ROLES.ROLE_DRHOUSE,
			 team = TEAM_SCI,
			 weapons = {"br_holster", "br_id", "weapon_breach_syringe", "weapon_house_canebar"},
			 showweapons = {"Researcher Keycard", "Medical Syringe", "House Canebar"},
			 keycard = "res",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 1.0,
			 runspeed = 1.0,
			 jumppower = 1.0,
			 vest = nil,
			 models = {"models/bunny/doctor_house/doctor_house.mdl"},
			 showmodel = nil,
			 flashlight = true,
			 level = 2,
			 max = 1
			},
			{name = ROLES.ROLE_PSYCHOLOGIST,
			 team = TEAM_SCI,
			 weapons = {"br_holster", "br_id", "item_radio", "weapon_pencil"},
			 showweapons = {"Researcher Keycard", "Radio", "Therapeutic Pencil"},
			 keycard = "res",
			 ammo = {},
			 health = 110,
			 armor = 0,
			 walkspeed = 1.0,
			 runspeed = 1.0,
			 jumppower = 1.0,
			 vest = nil,
			 models = {"models/player/dr_schwaiger.mdl"},
			 showmodel = nil,
			 flashlight = true,
			 level = 2,
			 max = 1
			},
		}
	},
	security = {
		name = "Armed Site Security",
		color = Color(0, 100, 255),
		roles = {
			{name = ROLES.ROLE_SECURITY, 
			 team = TEAM_GUARD,
			 weapons = {"br_holster", "br_id", "item_radio", "weapon_stunstick", "cw_mp5"},
			 showweapons = {"MTF Keycard", "Radio", "Stunstick", "MP5"},
			 keycard = "mtf",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 0.9,
			 runspeed = 0.95,
			 jumppower = 0.9,
			 vest = "armor_security",
			 models = SECURITYMODELS,
			 showmodel = "models/scp/guard_sci.mdl",
			 pmcolor = nil,
			 flashlight = true,
			 level = 0,
			 max = 0,
			},
			{name = ROLES.ROLE_MTFGUARD, 
			 team = TEAM_GUARD,
			 weapons = {"br_holster", "br_id", "item_radio", "weapon_stunstick", "cw_mp5"},
			 showweapons = {"MTF Keycard", "Radio", "Stunstick", "MP5"},
			 keycard = "mtf",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 0.85,
			 runspeed = 0.92,
			 jumppower = 0.87,
			 vest = "armor_mtfguard",
			 models = SECURITYMODELS,
			 showmodel = "models/scp/guard_noob.mdl",
			 pmcolor = nil,
			 flashlight = true,
			 level = 2,
			 max = 10,
			},
			{name = ROLES.ROLE_MTF_HEAVY_SUPPORT, 
			 team = TEAM_GUARD,
			 weapons = {"br_holster", "br_id", "item_radio", "weapon_stunstick", "cw_rinic_spas12"},
			 showweapons = {"MTF Keycard", "Radio", "Stunstick", "SPAS-12"},
			 keycard = "mtf",
			 ammo = {},
			 health = 170,
			 armor = 0,
			 walkspeed = 0.75,
			 runspeed = 0.85,
			 jumppower = 0.8,
			 vest = "armor_heavysupport",
			 models = SECURITYMODELS,
			 showmodel = "models/scp_mtf_russian/mtf_rus_02.mdl",
			 pmcolor = nil,
			 flashlight = true,
			 level = 3,
			 max = 1,
			},
			{name = ROLES.ROLE_SECURITY_DROID, 
			 team = TEAM_GUARD,
			 weapons = {"br_holster", "br_id", "item_radio", "weapon_stunstick", "cw_mp5"},
			 showweapons = {"MTF Keycard", "Radio", "Stunstick", "MP5"},
			 keycard = "mtf",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 0.85,
			 runspeed = 0.92,
			 jumppower = 0.87,
			 vest = nil,
			 models = {"models/mass effect 2/player/player/loki_mech.mdl"},
			 showmodel = "models/mass effect 2/player/player/loki_mech.mdl",
			 pmcolor = nil,
			 flashlight = true,
			 level = 2,
			 max = 2,
			},

			{name = ROLES.ROLE_CHAOSSPY, 
			 team = TEAM_CHAOS,
			 weapons = {"br_holster", "br_id", "item_radio", "weapon_stunstick", "cw_mp5"},
			 showweapons = {"MTF Keycard", "Radio", "Stunstick", "MP5"},
			 keycard = "mtf",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 0.85,
			 runspeed = 0.92,
			 jumppower = 0.87,
			 vest = "armor_mtfguard",
			 models = SECURITYMODELS,
			 showmodel = "models/scp/guard_noob.mdl",
			 pmcolor = nil,
			 flashlight = true,
			 level = 3,
			 max = 2,
			},
			{name = ROLES.ROLE_MTFL, 
			 team = TEAM_GUARD,
			 weapons = {"br_holster", "br_id", "item_radio", "item_nvg", "item_cameraview", "weapon_stunstick", "cw_ump45"},
			 showweapons = {"MTF Keycard", "Radio", "NVG", "Camera View", "Stunstick", "UMP .45"},
			 keycard = "mtf",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 0.87,
			 runspeed = 0.94,
			 jumppower = 0.9,
			 vest = "armor_mtfl",
			 models = SECURITYMODELS,
			 showmodel = "models/scp/guard_left.mdl",
			 pmcolor = nil,
			 flashlight = true,
			 level = 3,
			 max = 2,
			},
			{name = ROLES.ROLE_CSECURITY,
			 team = TEAM_GUARD,
			 weapons = {"br_holster", "br_id", "item_radio", "item_cameraview", "weapon_stunstick", "cw_g36c"},
			 showweapons = {"MTF Keycard", "Radio", "Camera View", "Stunstick", "G36C"},
			 keycard = "mtf",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 0.9,
			 runspeed = 0.95,
			 jumppower = 0.9,
			 vest = "armor_csecurity",
			 models = SECURITYMODELS,
			 showmodel = "models/scp/soldier_1.mdl",
			 pmcolor = nil,
			 flashlight = true,
			 level = 4,
			 max = 1,
			},
			{name = ROLES.ROLE_MTFMEDIC, 
			 team = TEAM_GUARD,
			 weapons = {"br_holster", "br_id", "item_radio", "item_ultramedkit", "weapon_stunstick", "cw_scarh"},
			 showweapons = {"MTF Keycard", "Radio", "Medkit", "Stunstick", "SCAR-H"},
			 keycard = "mtf",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 0.85,
			 runspeed = 0.92,
			 jumppower = 0.87,
			 vest = "armor_mtfmedic",
			 models = SECURITYMODELS,
			 showmodel = "models/scp/guard_med.mdl",
			 pmcolor = nil,
			 flashlight = true,
			 level = 5,
			 max = 1,
			},
			{name = ROLES.ROLE_MTFCOM, 
			 team = TEAM_GUARD,
			 weapons = {"br_holster", "br_id", "item_radio", "item_nvg", "item_cameraview", "weapon_bodycam_tablet", "weapon_stunstick", "cw_ar15"},
			 showweapons = {"Commander Keycard", "Radio", "NVG", "Camera View", "Bodycam Tablet", "Stunstick", "AR-15"},
			 keycard = "com",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 0.9,
			 runspeed = 0.94,
			 jumppower = 0.9,
			 vest = "armor_mtfcom",
			 models = SECURITYMODELS,
			 showmodel = "models/scp/captain.mdl",
			 pmcolor = nil,
			 flashlight = true,
			 level = 6,
			 max = 1,
			},
			{name = ROLES.ROLE_SD, 
			 team = TEAM_GUARD,
			 weapons = {"br_holster", "br_id", "item_radio", "item_cameraview", "weapon_stunstick", "cw_fiveseven"},
			 showweapons = {"Keycard Level OMNI", "Radio", "Camera View", "Stunstick", "Fiveseven"},
			 keycard = "omni",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 1,
			 runspeed = 1,
			 jumppower = 1,
			 vest = nil,
			 models = {"models/player/breen.mdl"},
			 showmodel = "models/player/breen.mdl",
			 pmcolor = Color(0,0,0),
			 flashlight = true,
			 level = 6,
			 max = 1,
			},
			{name = ROLES.ROLE_HAZMAT, 
			 team = TEAM_GUARD,
			 weapons = {"br_holster", "br_id", "item_radio", "item_nvg", "weapon_stunstick", "cw_m14"},
			 showweapons = {"MTF Keycard", "Radio", "NVG", "Stunstick", "M14 EBR"},
			 keycard = "mtf",
			 ammo = {},
			 health = 125,
			 armor = 50,
			 walkspeed = 0.93,
			 runspeed = 0.98,
			 jumppower = 0.92,
			 vest = "armor_hazmat",
			 models = SECURITYMODELS,
			 showmodel = "models/che_pm.mdl",
			 pmcolor = nil,
			 flashlight = true,
			 level = 8,
			 max = 1,
			},
			{name = ROLES.ROLE_O5, 
			 team = TEAM_GUARD,
			 weapons = {"br_holster", "br_id", "item_radio", "item_cameraview", "weapon_stunstick", "cw_deagle", "weapon_zeus"},
			 showweapons = {"Keycard Level OMNI", "Radio", "Camera View", "Stunstick", "Desert Eagle", "Taser"},
			 keycard = "omni",
			 ammo = {{"weapon_zeus", 3}},
			 health = 200,
			 armor = 0,
			 walkspeed = 1.15,
			 runspeed = 1.15,
			 jumppower = 1.15,
			 vest = nil,
			 models = {"models/player/gman_high.mdl"},
			 showmodel = "models/player/gman_high.mdl",
			 pmcolor = Color(0,0,0),
			 flashlight = true,
			 level = 10,
			 max = 1,
			},
		}
	},
	support = {
		name = "Armed Site Support",
		color = Color(29, 81, 56),
		roles = {
			{name = ROLES.ROLE_MTFNTF, 
			 team = TEAM_GUARD,
			 weapons = {"br_holster", "br_id", "item_radio", "item_nvg", "weapon_stunstick", "cw_ar15"},
			 showweapons = {"MTF Keycard", "Radio", "NVG", "Stunstick", "AR-15"},
			 keycard = "mtf",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 0.86,
			 runspeed = 0.93,
			 jumppower = 0.85,
			 vest = "armor_ntf",
			 models = SECURITYMODELS,
			 showmodel = "models/balkandude.mdl",
			 pmcolor = nil,
			 flashlight = true,
			 level = 0,
			 max = 5
			},
			{name = ROLES.ROLE_CHAOS, 
			 team = TEAM_CHAOS,
			 weapons = {"br_holster", "br_id", "item_radio", "weapon_stunstick", "cw_ak74"},
			 showweapons = {"Hacked CI Keycard", "Radio", "Stunstick", "AK-74"},
			 keycard = "ci",
			 ammo = {},
			 health = 100,
			 armor = 0,
			 walkspeed = 0.86,
			 runspeed = 0.93,
			 jumppower = 0.85,
			 vest = "armor_chaosins",
			 models = CHAOSMODELS,
			 showmodel = "models/chaos_insurgency_trooper/chaos_insurgency_trooper.mdl",
			 pmcolor = nil,
			 flashlight = true,
			 level = 0,
			 max = 5
			},
			{name = ROLES.ROLE_CHAOS_JUGGERNAUT,
			 team = TEAM_CHAOS,
			 weapons = {"br_holster", "br_id", "item_radio", "cw_gau_minigun"},
			 showweapons = {"Hacked CI Keycard", "Radio", "Minigun"},
			 keycard = "ci",
			 ammo = {},
			 health = 200,
			 armor = 0,
			 walkspeed = 0.25,
			 runspeed = 0.25,
			 jumppower = 0.25,
			 vest = "armor_chaosjugg",
			 models = CHAOSMODELS,
			 showmodel = "models/arty/codmw2022/mp/dmz/alqatala/juggernaut/juggernaut_pm.mdl",
			 pmcolor = nil,
			 flashlight = true,
			 level = 10,
			 max = 1
			}
		}
	},
	goc = {
		name = "Global Occult Coalition",
		color = Color(255, 255, 0),
		roles = {
			{name = ROLES.ROLE_GOC_SOLDIER,
			 team = TEAM_GOC,
			 weapons = {"br_holster", "br_id", "item_radio", "item_medkit", "weapon_stunstick", "cw_g36c"},
			 showweapons = {"GOC Keycard", "Radio", "Medkit", "Stunstick", "G36C"},
			 keycard = "omni",
			 ammo = {},
			 health = 120,
			 armor = 0,
			 walkspeed = 0.9,
			 runspeed = 0.95,
			 jumppower = 0.9,
			 vest = "armor_goc",
			 models = {"models/player/cheddar/goc/goc_soldier2.mdl"},
			 showmodel = "models/player/cheddar/goc/goc_soldier2.mdl",
			 pmcolor = Color(255, 255, 0),
			 flashlight = true,
			 level = 10,
			 max = 8
			},
			{name = ROLES.ROLE_GOC_OPERATIVE,
			 team = TEAM_GOC,
			 weapons = {"br_holster", "br_id", "item_radio", "item_nvg", "item_medkit", "weapon_stunstick", "cw_ar15"},
			 showweapons = {"GOC Keycard", "Radio", "NVG", "Medkit", "Stunstick", "AR-15"},
			 keycard = "omni",
			 ammo = {},
			 health = 130,
			 armor = 0,
			 walkspeed = 0.92,
			 runspeed = 0.97,
			 jumppower = 0.92,
			 vest = "armor_goc",
			 models = {"models/player/cheddar/goc/goc_soldier2.mdl"},
			 showmodel = "models/player/cheddar/goc/goc_soldier2.mdl",
			 pmcolor = Color(255, 255, 0),
			 flashlight = true,
			 level = 12,
			 max = 3
			},
			{name = ROLES.ROLE_GOC_COMMANDER,
			 team = TEAM_GOC,
			 weapons = {"br_holster", "br_id", "item_radio", "item_nvg", "item_cameraview", "weapon_stunstick", "cw_scarh"},
			 showweapons = {"GOC Commander Keycard", "Radio", "NVG", "Camera View", "Ultra Medkit", "Stunstick", "SCAR-H"},
			 keycard = "omni",
			 ammo = {},
			 health = 150,
			 armor = 0,
			 walkspeed = 0.95,
			 runspeed = 1.0,
			 jumppower = 0.95,
			 vest = "armor_goc",
			 models = {"models/player/cheddar/goc/goc_soldier2.mdl"},
			 showmodel = "models/player/cheddar/goc/goc_soldier2.mdl",
			 pmcolor = Color(255, 255, 0),
			 flashlight = true,
			 level = 15,
			 max = 1
			}
		}
	}
}



================================================
FILE: gamemodes/breach/gamemode/modules/sh_ezquadcopter_loader.lua
================================================
--[[
    EZ QUADCOPTER LOADER FOR SCP BREACH
    DISABLED - Using direct loading in sh_ezquadcopter_integration.lua instead
]]

-- This file is disabled - all loading is done in sh_ezquadcopter_integration.lua
return






================================================
FILE: gamemodes/breach/gamemode/modules/sh_gteams.lua
================================================

gteams = {}
gteams.Teams = {}

function gteams.SetUp(index, name, color)
	if isnumber(index) and isstring(name) and IsColor(color) then
		table.ForceInsert(gteams.Teams, {
			index = index,
			name = name,
			color = color,
			points
		})
	else
		ErrorNoHalt( "GTEAMS [ERROR] tried to setup invalid team!" )
		print(debug.traceback())
	end
end

function gteams.GetColor(input)
	if isnumber(input) then
		for k,v in pairs(gteams.Teams) do
			if v.index == input then
				return v.color
			end
		end
	elseif isstring(input) then
		for k,v in pairs(gteams.Teams) do
			if v.name == input then
				return v.color
			end
		end
	elseif IsColor(input) then
		for k,v in pairs(gteams.Teams) do
			if v.color == input then
				return v.color
			end
		end
	end
end

function gteams.GetScore(input)
	if isnumber(input) then
		for k,v in pairs(gteams.Teams) do
			if v.index == input then
				return v.points
			end
		end
	elseif isstring(input) then
		for k,v in pairs(gteams.Teams) do
			if v.name == input then
				return v.points
			end
		end
	elseif IsColor(input) then
		for k,v in pairs(gteams.Teams) do
			if v.color == input then
				return v.points
			end
		end
	end
end

function gteams.SetScore(input, amount)
	if isnumber(input) then
		for k,v in pairs(gteams.Teams) do
			if v.index == input then
				v.points = amount
				return
			end
		end
	elseif isstring(input) then
		for k,v in pairs(gteams.Teams) do
			if v.name == input then
				v.points = amount
				return
			end
		end
	elseif IsColor(input) then
		for k,v in pairs(gteams.Teams) do
			if v.color == input then
				v.points = amount
				return
			end
		end
	end
end

function gteams.AddScore(input, amount)
	if isnumber(input) then
		for k,v in pairs(gteams.Teams) do
			if v.index == input then
				v.points = v.points + amount
				return
			end
		end
	elseif isstring(input) then
		for k,v in pairs(gteams.Teams) do
			if v.name == input then
				v.points = v.points + amount
				return
			end
		end
	elseif IsColor(input) then
		for k,v in pairs(gteams.Teams) do
			if v.color == input then
				v.points = v.points + amount
				return
			end
		end
	end
end

function gteams.Valid(input)
	if isnumber(input) then
		for k,v in pairs(gteams.Teams) do
			if v.index == input then
				return true
			end
		end
	elseif isstring(input) then
		for k,v in pairs(gteams.Teams) do
			if v.name == input then
				return true
			end
		end
	elseif IsColor(input) then
		for k,v in pairs(gteams.Teams) do
			if v.color == input then
				return true
			end
		end
	end
	return false
end

local mply = FindMetaTable( "Player" )

function mply:GTeam()
    if !IsValid(self) then return TEAM_SPEC end
    if not self.GetNGTeam then
        player_manager.RunClass( self, "SetupDataTables" )
    end
    if not self.GetNGTeam then return TEAM_SPEC end
    return self:GetNGTeam()
end

function mply:GetGTeam()
    return self:GTeam()
end

function mply:SetGTeam(input)
	if not self.SetNGTeam then
		player_manager.RunClass( self, "SetupDataTables" )
	end
	if isnumber(input) then
		for k,v in pairs(gteams.Teams) do
			if v.index == input then
				//if self.SetNGTeam
				self:SetNGTeam(v.index)
				return
			end
		end
	elseif isstring(input) then
		for k,v in pairs(gteams.Teams) do
			if v.name == input then
				self:SetNGTeam(v.index)
				return
			end
		end
	elseif IsColor(input) then
		for k,v in pairs(gteams.Teams) do
			if v.color == input then
				self:SetNGTeam(v.index)
				return
			end
		end
	end
	ErrorNoHalt( "GTEAMS [ERROR] Tried to set an invalid team!" )
	print(debug.traceback())
end

function gteams.CheckTeams()
	print("GTEAMS: List")
	for k,v in pairs(gteams.Teams) do
		print(k .. " - " .. v.name .. "  index: " .. v.index .. "  color: rgb(" .. v.color.r .. "," .. v.color.g .. "," .. v.color.b .. ")")
	end
end

function gteams.CheckPlayers()
	print("GTEAMS: Players")
	for k,v in pairs(player.GetAll()) do
		local tname = v:GTeam()
		print(v:Nick() .. " - " .. tostring(tname))
	end
end

function gteams.GetPlayers( input )
	local tab = {}
	if isnumber(input) then
		for k,v in pairs(player.GetAll()) do
			if v:GTeam() == input then
				table.ForceInsert(tab, v)
			end
		end
	else
		ErrorNoHalt( "GTEAMS [ERROR] Tried to get list of players not using an index!" )
		print(debug.traceback())
	end
	return tab
end

function gteams.NumPlayers( input )
	local tab = {}
	if isnumber(input) then
		for k,v in pairs(player.GetAll()) do
			if v:GTeam() == input then
				table.ForceInsert(tab, v)
			end
		end
	else
		ErrorNoHalt( "GTEAMS [ERROR] Tried to get number of players not using an index!" )
		print(debug.traceback())
	end
	return #tab
end

gteams.SetUp( 0, "Not Set", Color(255,255,255) )
gteams.SetUp( TEAM_SCP, "SCPs", Color(237, 28, 63) )
gteams.SetUp( TEAM_GUARD, "MTF Guards", Color(0, 100, 255) )
gteams.SetUp( TEAM_CLASSD, "Class Ds", Color(255, 130, 0) )
gteams.SetUp( TEAM_SPEC, "Spectators", Color(141, 186, 160) )
gteams.SetUp( TEAM_SCI, "Scientists", Color(66, 188, 244) )
gteams.SetUp( TEAM_CHAOS, "Chaos Insurgency", Color(0, 100, 255) )
gteams.SetUp( TEAM_GOC, "GOC", Color(255, 255, 0) )






================================================
FILE: gamemodes/breach/gamemode/modules/sh_jailbird_sounds.lua
================================================
AddCSLuaFile()

--[[
-----------------------------------------------------------------------------------------------------
Jailbird Sound System for Breach
Adapted from SCP: Secret Laboratory Jailbird
-----------------------------------------------------------------------------------------------------
]]

-- Particle Cache (if available)
if CLIENT then
    -- Try to load Jailbird particles if they exist
    if file.Exists("particles/jailbird_effects.pcf", "GAME") then
        game.AddParticles("particles/jailbird_effects.pcf")
        
        PrecacheParticleSystem("jailbird_smoke")
        PrecacheParticleSystem("jailbird_elc_low_dmg")
        PrecacheParticleSystem("jailbird_elc_low")
        PrecacheParticleSystem("jailbird_elc_high")
        
        print("[Breach] Jailbird particles loaded successfully!")
    end
end

-- Ammo type for Jailbird durability
game.AddAmmoType( {
    name = "JailbirdDurability",
} )

-- Jailbird Sound Definitions
sound.Add( {
    name = "swep_scpsl_jailbird_0",
    channel = CHAN_WEAPON,
    volume = 1,
    level = 55,
    pitch = {95, 100},
    sound = {
        "weapons/scpsl/jailbird/Inspect 0.wav",
    }
} )

sound.Add( {
    name = "swep_scpsl_jailbird_1",
    channel = CHAN_WEAPON,
    volume = 1,
    level = 55,
    pitch = {95, 100},
    sound = {
        "weapons/scpsl/jailbird/Inspect 1.wav",
    }
} )

sound.Add( {
    name = "swep_scpsl_jailbird_2",
    channel = CHAN_WEAPON,
    volume = 1,
    level = 55,
    pitch = {95, 100},
    sound = {
        "weapons/scpsl/jailbird/Inspect 2.wav",
    }
} )

sound.Add( {
    name = "swep_scpsl_jailbird_3",
    channel = CHAN_WEAPON,
    volume = 1,
    level = 55,
    pitch = {95, 100},
    sound = {
        "weapons/scpsl/jailbird/Inspect 3.wav",
    }
} )

sound.Add( {
    name = "swep_scpsl_jailbird_4",
    channel = CHAN_WEAPON,
    volume = 1,
    level = 55,
    pitch = {95, 100},
    sound = {
        "weapons/scpsl/jailbird/Inspect 4.wav",
    }
} )

sound.Add( {
    name = "swep_scpsl_equip",
    channel = CHAN_WEAPON,
    volume = 1,
    level = 55,
    pitch = {95, 100},
    sound = {
        "weapons/scpsl/jailbird/Equip_Fast.wav",
		"weapons/scpsl/jailbird/Equip_Fast.wav",
		"weapons/scpsl/jailbird/Equip_Fast.wav",
		"weapons/scpsl/jailbird/Equip_Fast_Yo.wav",
    }
} )

sound.Add( {
    name = "swep_scpsl_ready",
    channel = CHAN_WEAPON,
    volume = 1,
    level = 55,
    pitch = {95, 100},
    sound = {
        "weapons/scpsl/jailbird/Equip_Slow_fixed.wav",
    }
} )

sound.Add( {
    name = "swep_scpsl_swingr",
    channel = CHAN_WEAPON,
    volume = 1,
    level = 60,
    pitch = {90, 105},
    sound = {
        "weapons/scpsl/jailbird/Normal_Swing.wav",
    }
} )

sound.Add( {
    name = "swep_scpsl_swingl",
    channel = CHAN_WEAPON,
    volume = 1,
    level = 60,
    pitch = {90, 105},
    sound = {
        "weapons/scpsl/jailbird/Normal_Swing_invert.wav",
    }
} )

sound.Add( {
    name = "swep_scpsl_hit",
    channel = CHAN_STATIC,
    volume = 0.35,
    level = 60,
    pitch = {95, 100},
    sound = {
        "weapons/scpsl/jailbird/Normal Hit.wav",
    }
} )

sound.Add( {
    name = "swep_scpsl_discard",
    channel = CHAN_WEAPON,
    volume = 1,
    level = 55,
    pitch = {95, 100},
    sound = {
        "weapons/scpsl/jailbird/Charged_Discard.wav",
    }
} )

sound.Add( {
    name = "swep_scpsl_chargeswing",
    channel = CHAN_WEAPON,
    volume = 1,
    level = 65,
    pitch = {95, 100},
    sound = {
        "weapons/scpsl/jailbird/Charge_Swing_fixed.wav",
    }
} )

sound.Add( {
    name = "swep_scpsl_chargestart",
    channel = CHAN_WEAPON,
    volume = 1,
    level = 55,
    pitch = {95, 100},
    sound = {
        "weapons/scpsl/jailbird/Charge_Start_fixed_real.wav",
    }
} )

sound.Add( {
    name = "swep_scpsl_charge",
    channel = CHAN_WEAPON,
    volume = 1,
    level = 75,
    pitch = {98, 102},
    sound = {
        "weapons/scpsl/jailbird/Charge_Run_fixed.wav",
    }
} )

-- Log successful loading
if SERVER then
    print("[Breach] Jailbird sound system loaded successfully!")
end 


================================================
FILE: gamemodes/breach/gamemode/modules/sh_jarate.lua
================================================
-- Jarate system for Breach gamemode
-- Original by orange_blossom, integrated for Breach

-- ConVars for configuration
CreateConVar("blossomJarateDuration", 10, {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Duration of Jarate effect in seconds")
CreateConVar("blossomJarateStrenght", 0.35, {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Bonus damage multiplier, 0.01 = 1%")
CreateConVar("blossomJarateRange", 150, {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Range of the Jarate explosion")
CreateConVar("blossomJarateThrow", 650, {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Throwing strength")
CreateConVar("blossomJarateCount", 1, {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Number of jars given")

-- Add jarate ammo type
if !game.GetAmmoID("jarate") or game.GetAmmoID("jarate") == -1 then
    game.AddAmmoType({
        name = "jarate",
        dmgtype = DMG_GENERIC,
        tracer = TRACER_NONE,
        plydmg = 0,
        npcdmg = 0,
        force = 500,
        minsplash = 4,
        maxsplash = 8,
        maxcarry = 20,
    })
end

-- Jarate damage hook
hook.Add("EntityTakeDamage", "Breach_Jarate_DamageHook", function(target, dmginfo)
    if IsValid(target) and target.orange_blossom_pissed ~= nil and target.orange_blossom_pissed > CurTime() then
        -- Add bonus damage based on ConVar
        local bonus = dmginfo:GetDamage() * GetConVar("blossomJarateStrenght"):GetFloat()
        dmginfo:AddDamage(bonus)
        
        -- Play mini-crit sound effect if file exists
        if SERVER then
            local soundFile = "orange_blossom/piss/crit_hit_mini" .. tostring(math.random(1, 5)) .. ".wav"
            if file.Exists("sound/" .. soundFile, "GAME") then
                sound.Play(soundFile, target:GetPos(), 75, 100, 1)
            else
                -- Fallback sound
                target:EmitSound("player/crit_hit2.wav", 75, math.random(90, 110))
            end
        end
    end
end)

-- Admin menu for Breach (optional)
if SERVER then
    hook.Add("PopulateToolMenu", "Breach_Jarate_AdminMenu", function()
        spawnmenu.AddToolMenuOption("Utilities", "Breach Admin", "JarateSettings", "Jarate Settings", "", "", function(panel)
            panel:ClearControls()
            
            panel:AddControl("Label", {
                Text = "Configure Jarate settings for Breach gamemode"
            })
            
            panel:NumSlider("Effect Duration", "blossomJarateDuration", 1, 60, 0)
            panel:NumSlider("Bonus Damage %", "blossomJarateStrenght", 0, 2, 2)
            panel:NumSlider("Explosion Range", "blossomJarateRange", 10, 300, 0)
            panel:NumSlider("Throw Strength", "blossomJarateThrow", 100, 1500, 0)
            panel:NumSlider("Jars Amount", "blossomJarateCount", 1, 20, 0)
            
            local button = panel:Button("Reset to Default")
            button.DoClick = function()
                RunConsoleCommand("blossomJarateDuration", "10")
                RunConsoleCommand("blossomJarateStrenght", "0.35")
                RunConsoleCommand("blossomJarateRange", "150")
                RunConsoleCommand("blossomJarateThrow", "650")
                RunConsoleCommand("blossomJarateCount", "1")
            end
        end)
    end)
end

-- Cleanup on player spawn/death
hook.Add("PlayerSpawn", "Breach_Jarate_CleanupSpawn", function(ply)
    -- Clean up jarate effect on respawn
    if ply.orange_blossom_pissed then
        ply.orange_blossom_pissed = nil
        ply:SetColor(Color(255, 255, 255))
    end
end)

hook.Add("PostPlayerDeath", "Breach_Jarate_CleanupDeath", function(ply)
    -- Clean up jarate effect on death
    if ply.orange_blossom_pissed then
        ply.orange_blossom_pissed = nil
        ply:SetColor(Color(255, 255, 255))
    end
end) 


================================================
FILE: gamemodes/breach/gamemode/modules/sh_kapkan_config.lua
================================================
KAPKAN_CONFIG = KAPKAN_CONFIG or {
    MaxPlaceDistance = 150,
    MaxUses = 4,
    ExplosionDamage = 95,
    ExplosionDelay = 0.5,
    AllowUndo = true,
    LaserLength = 80,
    MineHealth = 10,
    PlacementDelay = 0.9,
    PlayerCollisions = false
}

local DEFAULT_CONFIG = table.Copy(KAPKAN_CONFIG)

if SERVER then
    AddCSLuaFile()
    
    util.AddNetworkString("UpdateKapkanConfig")
    function UpdateKapkanConfig(ply)
        net.Start("UpdateKapkanConfig")
            net.WriteTable(KAPKAN_CONFIG)
        if ply then net.Send(ply) else net.Broadcast() end
    end
    
    net.Receive("UpdateKapkanConfig", function(len, ply)
        if ply:IsAdmin() then
            KAPKAN_CONFIG = net.ReadTable()
            UpdateKapkanConfig()
            print("[Kapkan] Config updated by "..ply:Name())
        end
    end)
else
    net.Receive("UpdateKapkanConfig", function()
        KAPKAN_CONFIG = net.ReadTable()
    end)
end

hook.Add("PlayerInitialSpawn", "SendKapkanConfig", function(ply)
    if SERVER then
        timer.Simple(5, function()
            if IsValid(ply) then
                UpdateKapkanConfig(ply)
            end
        end)
    end
end) 


================================================
FILE: gamemodes/breach/gamemode/modules/sh_module.lua
================================================
// Shared file
GM.Name 	= "Breach"
GM.Author 	= "Kanade, edited by danx91"
GM.Email 	= ""
GM.Website 	= ""

VERSION = "0.32"
DATE = "19/04/2019"

function GM:Initialize()
	self.BaseClass.Initialize( self )
end

TEAM_SCP = 1
TEAM_GUARD = 2
TEAM_CLASSD = 3
TEAM_SPEC = 4
TEAM_SCI = 5
TEAM_CHAOS = 6
TEAM_GOC = 7

MINPLAYERS = 2

// Team setup
team.SetUp( 1, "Default", Color(255, 255, 0) )
/* Replaced with GTeams
team.SetUp( TEAM_SCP, "SCPs", Color(237, 28, 63) )
team.SetUp( TEAM_GUARD, "MTF Guards", Color(0, 100, 255) )
team.SetUp( TEAM_CLASSD, "Class Ds", Color(255, 130, 0) )
team.SetUp( TEAM_SPEC, "Spectators", Color(141, 186, 160) )
team.SetUp( TEAM_SCI, "Scientists", Color(66, 188, 244) )
team.SetUp( TEAM_CHAOS, "Chaos Insurgency", Color(0, 100, 255) )
*/

game.AddDecal( "Decal106", "decals/decal106" )

function GetLangRole(rl)
	if clang == nil then return rl end
	local rolef = nil
	for k,v in pairs(ROLES) do
		if rl == v then
			rolef = k
		end
	end
	if rolef != nil then
		if clang.ROLES and clang.ROLES[rolef] then
			return clang.ROLES[rolef]
		else
			return rl -- Zwróć oryginalną nazwę jeśli nie ma tłumaczenia
		end
	else
		return rl or "Unknown" -- Zabezpieczenie przed nil
	end
end

SCPS = {}

ROLES = {}
ROLES.ROLE_SCP0082 = "SCP0082"

ROLES.ADMIN = "ADMIN MODE"

// Researchers
ROLES.ROLE_RES = "Researcher"
ROLES.ROLE_MEDIC = "Medic"
ROLES.ROLE_NO3 = "Level 3 Researcher"
ROLES.ROLE_JANITOR = "Janitor"
ROLES.ROLE_VIP = "VIP"
ROLES.ROLE_CLEARANCE_TECH = "Clearance Technician"
ROLES.ROLE_ENGINEER = "Engineer"
ROLES.ROLE_COOK = "Cook"
ROLES.ROLE_DRHOUSE = "Dr. House"
ROLES.ROLE_PSYCHOLOGIST = "Site Psychologist"
-- ROLES.ROLE_MEDIC_DROID = "Medic Droid" -- Usunięto klasę Medic Droid

// Class D Personell
ROLES.ROLE_CLASSD = "Class D Personell"
ROLES.ROLE_VETERAN = "Veteran"
ROLES.ROLE_SCOUT_D = "Scout D"
ROLES.ROLE_FAT_D = "Fat D"
ROLES.ROLE_SKINNY_D = "Skinny D"
ROLES.ROLE_DCLASS_INFECTED = "D-Class Infected"
ROLES.ROLE_THIEF_D = "Thief D"

ROLES.ROLE_SCP527 = "SCP-527"
ROLES.ROLE_CIC = "CI Agent"

// Security
ROLES.ROLE_SECURITY = "Security Officer"
ROLES.ROLE_MTFGUARD = "MTF Guard"
ROLES.ROLE_MTF_HEAVY_SUPPORT = "MTF Heavy Support"
ROLES.ROLE_MTFMEDIC = "MTF Medic"
ROLES.ROLE_MTFL = "MTF Lieutenant"
ROLES.ROLE_HAZMAT = "MTF SCU"
ROLES.ROLE_MTFNTF = "MTF Nine Tailed Fox"
ROLES.ROLE_CSECURITY = "Security Chief"
ROLES.ROLE_MTFCOM = "MTF Commander"
ROLES.ROLE_SD = "Site Director"
ROLES.ROLE_O5 = "O5 Council Member"
ROLES.ROLE_SECURITY_DROID = "Security Droid"

// Infect round
ROLES.ROLE_INFECTD = "Class D Presonnel"
ROLES.ROLE_INFECTMTF = "MTF"

// Chaos Insurgency
ROLES.ROLE_CHAOSSPY = "Chaos Insurgency Spy"
ROLES.ROLE_CHAOS = "Chaos Insurgency"
ROLES.ROLE_CHAOSCOM = "CI Commander"

// GOC (Global Occult Coalition)
ROLES.ROLE_GOC_SOLDIER = "GOC Soldier"
ROLES.ROLE_GOC_OPERATIVE = "GOC Operative"
ROLES.ROLE_GOC_COMMANDER = "GOC Commander"

// Other
ROLES.ROLE_SPEC = "Spectator"

// SCPs (missing definitions)
ROLES.ROLE_SCP173 = "SCP173"
ROLES.ROLE_SCP106 = "SCP106"
ROLES.ROLE_SCP049 = "SCP049"
ROLES.ROLE_SCP457 = "SCP457"
ROLES.ROLE_SCP966 = "SCP966"
ROLES.ROLE_SCP096 = "SCP096"
ROLES.ROLE_SCP066 = "SCP066"
ROLES.ROLE_SCP689 = "SCP689"
ROLES.ROLE_SCP682 = "SCP682"
ROLES.ROLE_SCP082 = "SCP082"
ROLES.ROLE_SCP939 = "SCP939"
ROLES.ROLE_SCP999 = "SCP999"
ROLES.ROLE_SCP023 = "SCP023"
ROLES.ROLE_SCP076 = "SCP076"
ROLES.ROLE_SCP1471 = "SCP1471"
ROLES.ROLE_SCP8602 = "SCP8602"
ROLES.ROLE_SCP1048A = "SCP1048A"
ROLES.ROLE_SCP1048B = "SCP1048B"
ROLES.ROLE_SCP0492 = "SCP0492"
ROLES.ROLE_SCP035 = "SCP035"
ROLES.ROLE_SCP957 = "SCP957"
ROLES.ROLE_SCP9571 = "SCP9571"
ROLES.ROLE_SCP069 = "SCP069"
ROLES.ROLE_SCP054 = "SCP054"
ROLES.ROLE_SCP2521 = "SCP2521"
ROLES.ROLE_SCP239 = "SCP239"
ROLES.ROLE_SCP3166 = "SCP3166"
ROLES.ROLE_SCPTTT_SAHUR = "SCPTTT_SAHUR"
ROLES.ROLE_SCP1316 = "SCP1316"
ROLES.ROLE_SCP2137J = "SCP2137J"
ROLES.ROLE_SCPSTEVEJ = "SCPSTEVEJ"
ROLES.ROLE_SCPDOOMGUYJ = "SCPDOOMGUYJ"
ROLES.ROLE_SCPIMPOSTORJ = "SCPIMPOSTORJ"

--Keycard access help
ACCESS_SAFE = bit.lshift( 1, 0 )
ACCESS_EUCLID = bit.lshift( 1, 1 )
ACCESS_KETER = bit.lshift( 1, 2 )
ACCESS_CHECKPOINT = bit.lshift( 1, 3 )
ACCESS_OMEGA = bit.lshift( 1, 4 )
ACCESS_GENERAL = bit.lshift( 1, 5 )
ACCESS_GATEA = bit.lshift( 1, 6 )
ACCESS_GATEB = bit.lshift( 1, 7 )
ACCESS_ARMORY = bit.lshift( 1, 8 )
ACCESS_FEMUR = bit.lshift( 1, 9 )
ACCESS_EC = bit.lshift( 1, 10 )

--include( "sh_playersetups.lua" )

if !ConVarExists("br_roundrestart") then CreateConVar( "br_roundrestart", "0", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Restart the round" ) end
if !ConVarExists("br_time_preparing") then CreateConVar( "br_time_preparing", "40", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Set preparing time" ) end
if !ConVarExists("br_time_round") then CreateConVar( "br_time_round", "780", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Set round time" ) end
if !ConVarExists("br_time_postround") then CreateConVar( "br_time_postround", "30", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Set postround time" ) end
if !ConVarExists("br_time_ntfenter") then CreateConVar( "br_time_ntfenter", "360", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Time that NTF units will enter the facility" ) end
if !ConVarExists("br_time_blink") then CreateConVar( "br_time_blink", "0.25", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Blink timer" ) end
if !ConVarExists("br_time_blinkdelay") then CreateConVar( "br_time_blinkdelay", "5", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Delay between blinks" ) end
if !ConVarExists("br_spawnzombies") then CreateConVar( "br_spawnzombies", "0", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Do you want zombies?" ) end
if !ConVarExists("br_scoreboardranks") then CreateConVar( "br_scoreboardranks", "0", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_REPLICATED}, "" ) end
if !ConVarExists("br_defaultlanguage") then CreateConVar( "br_defaultlanguage", "english", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "" ) end
if !ConVarExists("br_expscale") then CreateConVar( "br_expscale", "1", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "" ) end
if !ConVarExists("br_scp_cars") then CreateConVar( "br_scp_cars", "0", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Allow SCPs to drive cars?" ) end
if !ConVarExists("br_allow_vehicle") then CreateConVar( "br_allow_vehicle", "1", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Allow vehicle spawn?" ) end
if !ConVarExists("br_dclass_keycards") then CreateConVar( "br_dclass_keycards", "0", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Is D class supposed to have keycards? (D Class Weterans have keycard anyway)" ) end
if !ConVarExists("br_time_explode") then CreateConVar( "br_time_explode", "30", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Time from call br_destroygatea to explode" ) end
if !ConVarExists("br_ci_percentage") then CreateConVar("br_ci_percentage", "25", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Percentage of CI spawn" ) end
if !ConVarExists("br_i4_min_mtf") then CreateConVar("br_i4_min_mtf", "4", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Percentage of CI spawn" ) end
if !ConVarExists("br_cars_oldmodels") then CreateConVar("br_cars_oldmodels", "0", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Use old cars models?" ) end
if !ConVarExists("br_premium_url") then CreateConVar("br_premium_url", "", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE}, "Link to premium members list" ) end
if !ConVarExists("br_premium_mult") then CreateConVar("br_premium_mult", "1.25", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE}, "Premium members exp multiplier" ) end
if !ConVarExists("br_premium_display") then CreateConVar("br_premium_display", "Premium player %s has joined!", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE}, "Text shown to all players when premium member joins" ) end
if !ConVarExists("br_rounds") then CreateConVar("br_rounds", "0", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE}, "How many round before map restart? 0 - dont restart" ) end
if !ConVarExists("br_min_players") then CreateConVar("br_min_players", "2", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Minimum players to start round" ) end
if !ConVarExists("br_firstround_debug") then CreateConVar("br_firstround_debug", "1", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE}, "Skip first round" ) end
if !ConVarExists("br_force_specialround") then CreateConVar("br_force_specialround", "", {FCVAR_SERVER_CAN_EXECUTE}, "Available special rounds [ infect, multi, ttt, bomber, swapper, moveordie ]" ) end
if !ConVarExists("br_specialround_pct") then CreateConVar("br_specialround_pct", "10", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Skip first round" ) end
if !ConVarExists("br_punishvote_time") then CreateConVar("br_punishvote_time", "30", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "How much time players have to vote" ) end
if !ConVarExists("br_allow_punish") then CreateConVar("br_allow_punish", "1", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Is punish system allowed?" ) end
if !ConVarExists("br_cars_ammount") then CreateConVar("br_cars_ammount", "12", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "How many cars should spawn?" ) end
if !ConVarExists("br_dropvestondeath") then CreateConVar("br_dropvestondeath", "1", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Do players drop vests on death?" ) end
if !ConVarExists("br_force_showupdates") then CreateConVar("br_force_showupdates", "0", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE}, "Should players see update logs any time they join to server?" ) end
if !ConVarExists("br_allow_scptovoicechat") then CreateConVar("br_allow_scptovoicechat", "0", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Can SCPs talk with humans?" ) end
if !ConVarExists("br_ulx_premiumgroup_name") then CreateConVar("br_ulx_premiumgroup_name", "", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE}, "Name of ULX premium group" ) end
if !ConVarExists("br_experimental_bulletdamage_system") then CreateConVar("br_experimental_bulletdamage_system", "0", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE}, "Turn it off when you see any problems with bullets" ) end
if !ConVarExists("br_experimental_antiknockback_force") then CreateConVar("br_experimental_antiknockback_force", "5", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE}, "Turn it off when you see any problems with bullets" ) end
if !ConVarExists("br_allow_ineye_spectate") then CreateConVar("br_allow_ineye_spectate", "0", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "" ) end
if !ConVarExists("br_allow_roaming_spectate") then CreateConVar("br_allow_roaming_spectate", "1", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "" ) end
if !ConVarExists("br_scale_bullet_damage") then CreateConVar("br_scale_bullet_damage", "1", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE}, "Bullet damage scale" ) end
if !ConVarExists("br_new_eq") then CreateConVar("br_new_eq", "0", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Enables new EQ" ) end
if !ConVarExists("br_enable_warhead") then CreateConVar("br_enable_warhead", "1", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE }, "Enables OMEGA Warhead" ) end
if !ConVarExists("br_scale_human_damage") then CreateConVar("br_scale_human_damage", "1", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE }, "Scales damage dealt by humans" ) end
if !ConVarExists("br_scale_scp_damage") then CreateConVar("br_scale_scp_damage", "1", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE }, "Scales damage dealt by SCP" ) end
if !ConVarExists("br_scp_penalty") then CreateConVar("br_scp_penalty", "3", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE }, "" ) end
if !ConVarExists("br_premium_penalty") then CreateConVar("br_premium_penalty", "0", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE }, "" ) end

-- OPTYMALIZACJA: ConVary dla systemu optymalizacji wydajności
if !ConVarExists("br_optimization_enabled") then CreateConVar("br_optimization_enabled", "1", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE}, "Enable performance optimizations") end
if !ConVarExists("br_cache_update_interval") then CreateConVar("br_cache_update_interval", "1", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE}, "Player cache update interval") end
if !ConVarExists("br_entity_cache_time") then CreateConVar("br_entity_cache_time", "0.5", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE}, "Entity search cache time") end
if !ConVarExists("br_timer_group_interval") then CreateConVar("br_timer_group_interval", "0.1", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE}, "Timer group update interval") end

MINPLAYERS = GetConVar("br_min_players"):GetInt()

-- Removed br_debug_armor command

function GetPrepTime()
	return GetConVar("br_time_preparing"):GetInt()
end

function GetRoundTime()
	return GetConVar("br_time_round"):GetInt()
end

function GetPostTime()
	return GetConVar("br_time_postround"):GetInt()
end

function GetGateOpenTime()
	return GetConVar("br_time_gateopen"):GetInt()
end

function GetNTFEnterTime()
	return GetConVar("br_time_ntfenter"):GetInt()
end

function GM:EntityFireBullets( ent, data )
	if GetConVar( "br_experimental_bulletdamage_system" ):GetInt() != 0 then
		local damage = data.Damage
		data.Damage = 0
		data.Callback = function( ent, tr, info )
			if !SERVER then return end
			local vic = tr.Entity
			if IsValid( vic ) then
				if vic:IsPlayer() then
					info:SetDamage( damage )
					gamemode.Call( "ScalePlayerDamage", vic, nil, info )
					local scaleddamge = info:GetDamage()
					local force = info:GetDamageForce():GetNormalized()
					local antiforce = GetConVar( "br_experimental_antiknockback_force" ):GetInt() * -1
					info:SetDamage( 0 )
					info:SetDamageForce( Vector( 0 ) )
					vic:TakeDamage( scaleddamge, ent, ent )
					vic:SetVelocity( force * scaleddamge * antiforce )
				else
					vic:TakeDamage( info:GetDamage(), ent, ent )
				end
			end
		end
		return true
	end
end

function GM:PlayerFootstep( ply, pos, foot, sound, volume, rf )
	if not ply.GetNClass then
		player_manager.RunClass( ply, "SetupDataTables" )
	end
	if not ply.GetNClass then return end
	if ply:GetNClass() == ROLE_SCP173 then
		if ply.steps == nil then ply.steps = 0 end
		ply.steps = ply.steps + 1
		if ply.steps > 6 then
			ply.steps = 1
			if SERVER then
				ply:EmitSound( "173sound"..math.random(1,3)..".ogg", 300, 100, 1 )
			end
		end
		return true
	end
	return false
end

function GM:ShouldCollide( ent1, ent2 )
	/*local ply = ent1:IsPlayer() and ent1 or ent2:IsPlayer() and ent2
	local ent
	if ply then
		if ent1 == ply then
			ent = ent2
		else
			ent = ent1
		end
		if ply:GetNClass() == ROLES.ROLE_SCP106 then
			if ent.ignorecollide106 then
				return false
			end
		end
	end*/
	-- SCP-106 door passing
if ent1:IsPlayer() and ent1:GetNClass() == ROLES.ROLE_SCP106 or ent2:IsPlayer() and ent2:GetNClass() == ROLES.ROLE_SCP106 then
	if ent1.ignorecollide106 or ent2.ignorecollide106 then
		return false
	end
end

-- SCP-054 door passing (używa tego samego systemu co SCP-106)
if ent1:IsPlayer() and ent1:GetNClass() == ROLES.ROLE_SCP054 or ent2:IsPlayer() and ent2:GetNClass() == ROLES.ROLE_SCP054 then
	if ent1.ignorecollide106 or ent2.ignorecollide106 then
		return false
	end
end
	
	-- SCP-999 door passing (używa tego samego systemu co SCP-106)
	if ent1:IsPlayer() and ent1:GetNClass() == ROLES.ROLE_SCP999 and ent1.SCP999Active or ent2:IsPlayer() and ent2:GetNClass() == ROLES.ROLE_SCP999 and ent2.SCP999Active then
		if ent1.ignorecollide999 or ent2.ignorecollide999 then
			return false
		end
	end
	
	-- SCP-X01-J plasma projectile collision
	if ent1:GetClass() == "scp_x01j_plasma_projectile" or ent2:GetClass() == "scp_x01j_plasma_projectile" then
		local projectile = ent1:GetClass() == "scp_x01j_plasma_projectile" and ent1 or ent2
		local other = ent1 == projectile and ent2 or ent1
		
		if IsValid(other) and other:IsPlayer() then
			local owner = projectile:GetOwner()
			if IsValid(owner) and owner:GTeam() == TEAM_SCP and other:GTeam() == TEAM_SCP then
				-- Projectile nie koliduje z innymi SCP
				return false
			end
		end
	end
		
	return true
end

/*
function GM:PlayerShouldTakeDamage( ply, attacker ) 
	if attacker:IsVehicle() then
	
	end
	
end
*/

function GM:PlayerButtonDown( ply, button )
	if CLIENT and IsFirstTimePredicted() then
		//local bind = _G[ "KEY_"..string.upper( input.LookupBinding( "+menu" ) or "q" ) ] or 
		local key = input.LookupBinding( "+menu" )

		if key then
			if input.GetKeyCode( key ) == button then
				if CanShowEQ() then
					ShowEQ()
				end
			end
		end
	end
end

function GM:PlayerButtonUp( ply, button )
	if CLIENT and IsFirstTimePredicted() then
		//local bind = _G[ "KEY_"..string.upper( input.LookupBinding( "+menu" ) ) ] or KEY_Q
		local key = input.LookupBinding( "+menu" )

		if key then
			if input.GetKeyCode( key ) == button and IsEQVisible() then
				HideEQ()
			end
		end
	end
end

-- Hook z wyższym priorytetem dla kamizelek
hook.Add("EntityTakeDamage", "BR_VestProtection", function(target, dmginfo)
	if not target:IsPlayer() or not target:Alive() then return end
	
	local dmgtype = dmginfo:GetDamageType()
	
	-- Debug dla wszystkich obrażeń na graczach z vestem
	if SERVER and target.UsingArmor then
		print("[VEST DEBUG] " .. target:Nick() .. " taking damage. Type: " .. dmgtype .. ", Amount: " .. dmginfo:GetDamage() .. ", Vest: " .. tostring(target.UsingArmor))
	end
	
	-- Fireproof vest protection
	if target.UsingArmor == "armor_fireproof" then
		if dmgtype == DMG_BURN or dmgtype == 268435464 or bit.band(dmgtype, DMG_BURN) > 0 then
			local originalDmg = dmginfo:GetDamage()
			dmginfo:ScaleDamage(0.25)
			
			if SERVER then
				print("[FIREPROOF VEST] ACTIVATED! Reduced damage from " .. originalDmg .. " to " .. dmginfo:GetDamage())
			end
			return
		end
	end
	
	-- Electroproof vest protection
	if target.UsingArmor == "armor_electroproof" then
		if dmgtype == DMG_SHOCK or dmgtype == DMG_ENERGYBEAM then
			dmginfo:SetDamage(0)
			if SERVER then
				print("[ELECTROPROOF VEST] Blocked all electric damage!")
			end
			return
		end
	end
end, HOOK_HIGH)

function GM:EntityTakeDamage( target, dmginfo )
	local at = dmginfo:GetAttacker()
	
	-- MEGA DEBUG dla wszystkich obrażeń między graczami
	if SERVER and target:IsPlayer() and IsValid(at) and at:IsPlayer() then
		local inflictor = dmginfo:GetInflictor()
		print("[DAMAGE DEBUG] Damage event:")
		print("  Target: " .. target:Nick() .. " (Team: " .. target:GTeam() .. ", Class: " .. tostring(target:GetNClass()))
		print("  Attacker: " .. at:Nick() .. " (Team: " .. at:GTeam() .. ", Class: " .. tostring(at:GetNClass()))
		print("  Damage: " .. dmginfo:GetDamage())
		print("  Inflictor: " .. tostring(inflictor) .. " (" .. (IsValid(inflictor) and inflictor:GetClass() or "invalid") .. ")")
		if IsValid(at) and at.GetActiveWeapon and IsValid(at:GetActiveWeapon()) then
			print("  Weapon: " .. at:GetActiveWeapon():GetClass())
		end
	end
	
	-- SCP-239 Immortality System - HIGHEST PRIORITY
	if target:IsPlayer() and target:GetNClass() == ROLES.ROLE_SCP239 then
		-- Check if SCP-239 is in vulnerability window
		local isVulnerable = target:GetNWBool("SCP239_Vulnerable", false)
		if SERVER then
			print("[SCP-239 DEBUG] Damage to SCP-239:", dmginfo:GetDamage(), "Vulnerable:", isVulnerable, "Attacker:", tostring(at))
		end
		if !isVulnerable then
			-- Block all damage when not vulnerable - COMPLETE IMMUNITY
			dmginfo:SetDamage( 0 )
			dmginfo:ScaleDamage( 0 )
			if SERVER then
				print("[SCP-239 DEBUG] BLOCKED ALL DAMAGE - SCP-239 is immortal")
			end
			return true -- Stop processing other damage hooks
		else
			if SERVER then
				print("[SCP-239 DEBUG] Allowing damage - SCP-239 is vulnerable")
			end
		end
	end
	
	-- Blokuj friendly fire między SCPkami (oprócz SCP-035)
	if target:IsPlayer() and at:IsPlayer() then
		if target:GTeam() == TEAM_SCP and at:GTeam() == TEAM_SCP then
			-- SCP-035 może atakować inne SCP
			if at:GetNClass() == ROLES.ROLE_SCP035 then
				print("[SCP-035 DAMAGE DEBUG] SCP-035 attacking SCP - ALLOWING DAMAGE")
				print("  Attacker: " .. at:Nick() .. " (Class: " .. tostring(at:GetNClass()) .. ")")
				print("  Target: " .. target:Nick() .. " (Class: " .. tostring(target:GetNClass()) .. ")")
				print("  Damage: " .. dmginfo:GetDamage())
				-- SCP-035 może zabijać wszystkich, nawet SCP
				return false -- Pozwól na obrażenia
			end
			
			-- Inne SCP mogą atakować SCP-035
			if target:GetNClass() == ROLES.ROLE_SCP035 then
				print("[SCP-035 DAMAGE DEBUG] SCP attacking SCP-035 - ALLOWING DAMAGE")
				print("  Attacker: " .. at:Nick() .. " (Class: " .. tostring(at:GetNClass()) .. ")")
				print("  Target: " .. target:Nick() .. " (Class: " .. tostring(target:GetNClass()) .. ")")
				print("  Damage: " .. dmginfo:GetDamage())
				-- SCP-035 może być atakowany przez inne SCP
				return false -- Pozwól na obrażenia
			end
			
			print("[EntityTakeDamage] BLOCKING SCP friendly fire")
			print("  Attacker: " .. at:Nick() .. " (Class: " .. tostring(at:GetNClass()) .. ")")
			print("  Target: " .. target:Nick() .. " (Class: " .. tostring(target:GetNClass()) .. ")")
			dmginfo:SetDamage( 0 )
			return true
		end
	end
	
	-- Specjalne zabezpieczenie dla projectiles SCP
	if target:IsPlayer() and IsValid(at) then
		local inflictor = dmginfo:GetInflictor()
		if IsValid(inflictor) and inflictor:GetClass() == "scp_x01j_plasma_projectile" then
			local owner = inflictor:GetOwner()
			if IsValid(owner) and owner:IsPlayer() and owner:GTeam() == TEAM_SCP and target:GTeam() == TEAM_SCP then
				print("[EntityTakeDamage] Blocked SCP projectile friendly fire")
				dmginfo:SetDamage( 0 )
				return true
			end
		end
	end
	
	if at:IsVehicle() or ( at:IsPlayer() and at:InVehicle() ) then
		dmginfo:SetDamage( 0 )
	end

	if target:IsPlayer() then
		if target:Alive() then
			local dmgtype = dmginfo:GetDamageType()
			
			-- SCP fire immunity
			if dmgtype == DMG_BURN or dmgtype == 268435464 or bit.band(dmgtype, DMG_BURN) > 0 then
				if target:GTeam() == TEAM_SCP then
					dmginfo:SetDamage( 0 )
					return true
				end
			end

			if dmgtype == DMG_VEHICLE then
				dmginfo:SetDamage( 0 )
			end
		end
	end

	if at:IsPlayer() and target:IsPlayer() and at:GetNClass() == ROLES.ROLE_SCP9571 and target:GTeam() == TEAM_SCP and target:GetNClass() != ROLES.ROLE_SCP035 then
		return true
	end

	if at:IsPlayer() and ply:IsPlayer() then
		if at.GetActiveWeapon then
			local wep = at:GetActiveWeapon()
			if IsValid(wep) then
				if wep:GetClass() == "weapon_crowbar" then
					dmginfo:ScaleDamage(0.3)
				elseif wep:GetClass() == "weapon_stunstick" then
					dmginfo:ScaleDamage(0.5)
				end
			end
		end

		if SERVER then
		end
	end
end

-- Priority hook for SCP-500 auto-use before death (must be highest priority)
hook.Add("EntityTakeDamage", "SCP500_AutoUse", function(target, dmginfo)
	if not SERVER then return end
	if not IsValid(target) or not target:IsPlayer() then return end
	if preparing or postround then return end
	
	-- SCP-500 automatic use when about to die
	if target:HasWeapon("item_scp_500") then
		if target:Health() <= dmginfo:GetDamage() then
			target:GetWeapon("item_scp_500"):OnUse()
			target:PrintMessage(HUD_PRINTTALK, "Using SCP 500")
		end
	end
end, HOOK_MONITOR_HIGHEST)

-- Additional SCP-239 immortality hook with highest priority
hook.Add("EntityTakeDamage", "SCP239_ImmunitySystem", function(target, dmginfo)
	if not SERVER then return end
	if not IsValid(target) or not target:IsPlayer() then return end
	if target:GetNClass() != ROLES.ROLE_SCP239 then return end
	
	local isVulnerable = target:GetNWBool("SCP239_Vulnerable", false)
	print("[SCP-239 HOOK] Direct hook - Vulnerable:", isVulnerable, "Damage:", dmginfo:GetDamage())
	
	if not isVulnerable then
		-- Complete damage immunity
		dmginfo:SetDamage(0)
		dmginfo:ScaleDamage(0)
		print("[SCP-239 HOOK] BLOCKED via direct hook")
		return true
	end
end, HOOK_HIGH)

function GM:ScalePlayerDamage( ply, hitgroup, dmginfo )
	/*
	if SERVER then
		local at = dmginfo:Getat()
		if ply:GTeam() == at:GTeam() then
			at:TakeDamage( 25, at, at )
		end
	end
	*/
	local at = dmginfo:GetAttacker()

	local mul = 1
	local armormul = 1

	if at:IsPlayer() then
		if at:GTeam() == TEAM_SCP then
			local scale = GetConVar( "br_scale_scp_damage" ):GetFloat()
			if scale == 0 then scale = 1 end
			scale = math.Clamp( scale, 0.1, 5 )
			dmginfo:ScaleDamage( scale )
		elseif at:GTeam() != TEAM_SPEC then
			local scale = GetConVar( "br_scale_human_damage" ):GetFloat()
			if scale == 0 then scale = 1 end
			scale = math.Clamp( scale, 0.1, 5 )
			dmginfo:ScaleDamage( scale )
		end

		if at.GetActiveWeapon then
			local wep = at:GetActiveWeapon()
			if IsValid(wep) then
				-- Engineer crowbar healing for Security Droids
				if wep:GetClass() == "weapon_crowbar" and at:GetNClass() == ROLES.ROLE_ENGINEER and ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
					if SERVER then
						-- Prevent damage and heal instead
						dmginfo:SetDamage(0)
						
						-- Initialize heal cooldown
						if not at.EngineerHealCooldown then
							at.EngineerHealCooldown = 0
						end
						
						-- Check cooldown (2 seconds)
						if CurTime() >= at.EngineerHealCooldown then
							at.EngineerHealCooldown = CurTime() + 2.0
							
							-- Heal the droid
							local healAmount = 30
							local newHealth = math.min(ply:Health() + healAmount, ply:GetMaxHealth())
							ply:SetHealth(newHealth)
							
							-- Special effects
							at:EmitSound("ambient/energy/newspark0" .. math.random(1, 9) .. ".wav")
							ply:EmitSound("ambient/energy/newspark0" .. math.random(1, 9) .. ".wav")
							
							-- Visual effect
							local effectdata = EffectData()
							effectdata:SetOrigin(ply:GetPos() + Vector(0, 0, 40))
							effectdata:SetEntity(ply)
							effectdata:SetMagnitude(8)
							effectdata:SetScale(2)
							util.Effect("ElectricSpark", effectdata)
							
							-- Clear overheat status if droid is overheated
							if ply.SecurityDroidOverheated then
								ply:SetWalkSpeed(ply.SecurityDroidOriginalSpeeds.walk)
								ply:SetRunSpeed(ply.SecurityDroidOriginalSpeeds.run)
								ply:SetJumpPower(ply.SecurityDroidOriginalSpeeds.jump)
								ply.SecurityDroidOverheated = false
								ply.SecurityDroidStunHits = 0
								
								-- Remove overheat timer
								timer.Remove("SecurityDroid_Overheat_" .. ply:EntIndex())
								
								ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] Emergency repair complete. Systems restored by Engineer.")
								at:PrintMessage(HUD_PRINTTALK, "[REPAIR] Security Droid systems repaired successfully!")
							else
								ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] Maintenance repair: +" .. healAmount .. " HP")
								at:PrintMessage(HUD_PRINTTALK, "[REPAIR] Security Droid repaired: +" .. healAmount .. " HP")
							end
						else
							-- Cooldown message
							at:PrintMessage(HUD_PRINTTALK, "[REPAIR] Cooldown: " .. math.ceil(at.EngineerHealCooldown - CurTime()) .. "s")
						end
					end
					return -- Stop processing damage
				elseif wep:GetClass() == "weapon_crowbar" then
					dmginfo:ScaleDamage(0.3)
				elseif wep:GetClass() == "weapon_stunstick" then
					dmginfo:ScaleDamage(0.5)
				end
			end
		end

		if SERVER then
		end
	end
	
	/*
	if SERVER then
		print("DMG to "..ply:GetName().."["..ply:GetClass().."]", "DMG: "..dmginfo:GetDamage(), "TYPE: "..dmginfo:GetDamageType())
	end
	*/
	
	-- Debug: pokaż początkowe obrażenia
	local originalDmg = dmginfo:GetDamage()
	local debugInfo = {}
	
	if SERVER and ply.UsingArmor then
		debugInfo.original = originalDmg
		debugInfo.vest = ply.UsingArmor
		debugInfo.hitgroup = hitgroup
	end
	
	if hitgroup == HITGROUP_HEAD then
		mul = 1.5
	elseif hitgroup == HITGROUP_CHEST then
		mul = 1
	elseif hitgroup == HITGROUP_STOMACH then
		mul = 1
	elseif hitgroup == HITGROUP_LEFTARM or hitgroup == HITGROUP_RIGHTARM then
		mul = 0.9
	elseif hitgroup == HITGROUP_LEFTLEG or hitgroup == HITGROUP_RIGHTLEG then
		mul = 0.8
	end

	if SERVER then
		-- Debug: zapisz mnożnik hitgroup
		if ply.UsingArmor then
			debugInfo.hitgroupMul = mul
		end
		
		-- Redukcja obrażeń od pocisków dla vestów (CW 2.0 compatibility)
		if ply.UsingArmor and at:IsPlayer() then
			local armorProtection = {
				["armor_security"] = 0.90,      -- 10% redukcja
				["armor_mtfguard"] = 0.85,      -- 15% redukcja
				["armor_mtfl"] = 0.83,          -- 17% redukcja
				["armor_mtfmedic"] = 0.85,      -- 15% redukcja
				["armor_csecurity"] = 0.83,     -- 17% redukcja
				["armor_mtfcom"] = 0.73,        -- 27% redukcja
				["armor_hazmat"] = 0.80,        -- 20% redukcja
				["armor_ntf"] = 0.75,           -- 25% redukcja
				["armor_chaosins"] = 0.80,      -- 20% redukcja
				["armor_goc"] = 0.70,           -- 30% redukcja
				["armor_heavysupport"] = 0.50,  -- 50% redukcja (najlepszy vest!)
				["armor_fireproof"] = 1.0,      -- 0% redukcja (tylko ogień)
				["armor_electroproof"] = 1.0    -- 0% redukcja (tylko elektryczność)
			}
			
			if armorProtection[ply.UsingArmor] then
				armormul = armormul * armorProtection[ply.UsingArmor]
				debugInfo.armorMul = armorProtection[ply.UsingArmor]
			end
		end
		
		mul = mul * armormul
		dmginfo:ScaleDamage(mul)
		
		-- Debug: pokaż finalne obrażenia
		if ply.UsingArmor then
			debugInfo.finalMul = mul
			debugInfo.finalDmg = dmginfo:GetDamage()
			print("[VEST DEBUG DETAILED] " .. ply:Nick() .. " | Vest: " .. ply.UsingArmor)
			print("  Original DMG: " .. debugInfo.original)
			print("  Hitgroup: " .. debugInfo.hitgroup .. " (mul: " .. debugInfo.hitgroupMul .. ")")
			print("  Armor reduction: " .. (debugInfo.armorMul or 1))
			print("  Final multiplier: " .. debugInfo.finalMul)
			print("  Final DMG: " .. debugInfo.finalDmg)
			print("  ----")
		end
		if ply:GTeam() == TEAM_SCP and OUTSIDE_BUFF( ply:GetPos() ) then
			dmginfo:ScaleDamage( 0.75 )
		end
		local scale = math.Clamp( GetConVar( "br_scale_bullet_damage" ):GetFloat(), 0.1, 2 )
		dmginfo:ScaleDamage( scale )

		if ply:GetNClass() == ROLES.ROLE_SCP957 then
			local wep = ply:GetActiveWeapon()
			if wep and wep:BuffEnabled() then
				dmginfo:ScaleDamage( 0.1 )
			end
		end

		-- Security Droid: 50% redukcja obrażeń od pocisków
		if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID and at:IsPlayer() then
			local wep = at:GetActiveWeapon()
			if IsValid(wep) and wep:GetClass():find("cw_") then
				dmginfo:ScaleDamage(0.5) -- 50% redukcja od pocisków
			end
		end

		-- Security Droid: system przegrzania od stunstick
		if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID and at:IsPlayer() then
			local wep = at:GetActiveWeapon()
			if IsValid(wep) and wep:GetClass() == "weapon_stunstick" then
				-- Inicjalizuj licznik uderzeń stunstick
				if not ply.SecurityDroidStunHits then
					ply.SecurityDroidStunHits = 0
				end
				
				ply.SecurityDroidStunHits = ply.SecurityDroidStunHits + 1
				
				-- Po 2 uderzeniach - przegrzanie (90% spowolnienie)
				if ply.SecurityDroidStunHits >= 2 then
					-- Efekt przegrzania - dźwięki
					ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 100, math.random(80, 120))
					ply:EmitSound("ambient/energy/zap" .. math.random(1, 9) .. ".wav", 100, math.random(90, 110))
					
					-- Efekt wizualny iskier
					local effectdata = EffectData()
					effectdata:SetOrigin(ply:GetPos() + Vector(0, 0, 40))
					effectdata:SetEntity(ply)
					effectdata:SetMagnitude(8)
					effectdata:SetScale(2)
					util.Effect("ElectricSpark", effectdata)
					
					-- Dodatkowe iskry wokół gracza
					for i = 1, 5 do
						timer.Simple(i * 0.2, function()
							if IsValid(ply) and ply.SecurityDroidOverheated then
								local sparkPos = ply:GetPos() + Vector(math.random(-20, 20), math.random(-20, 20), math.random(20, 60))
								local sparkData = EffectData()
								sparkData:SetOrigin(sparkPos)
								sparkData:SetMagnitude(6)
								sparkData:SetScale(1.5)
								util.Effect("ElectricSpark", sparkData)
								ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 60, math.random(80, 120))
							end
						end)
					end
					
					-- Komunikat
					ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] CRITICAL ERROR: OVERHEATING! Systems slowed!")
					
					-- Zapisz oryginalne prędkości jeśli jeszcze nie zapisane
					if not ply.SecurityDroidOriginalSpeeds then
						ply.SecurityDroidOriginalSpeeds = {
							walk = ply:GetWalkSpeed(),
							run = ply:GetRunSpeed(),
							jump = ply:GetJumpPower()
						}
					end
					
					-- Zastosuj 90% spowolnienie (zostaje 10% prędkości)
					ply:SetWalkSpeed(ply.SecurityDroidOriginalSpeeds.walk * 0.1)
					ply:SetRunSpeed(ply.SecurityDroidOriginalSpeeds.run * 0.1)
					ply:SetJumpPower(ply.SecurityDroidOriginalSpeeds.jump * 0.1)
					
					-- Flaga przegrzania
					ply.SecurityDroidOverheated = true
					
					-- Przywróć prędkości po 8 sekundach
					timer.Create("SecurityDroid_Overheat_" .. ply:EntIndex(), 8, 1, function()
						if IsValid(ply) and ply.SecurityDroidOverheated then
							ply:SetWalkSpeed(ply.SecurityDroidOriginalSpeeds.walk)
							ply:SetRunSpeed(ply.SecurityDroidOriginalSpeeds.run)
							ply:SetJumpPower(ply.SecurityDroidOriginalSpeeds.jump)
							ply.SecurityDroidOverheated = false
							ply.SecurityDroidStunHits = 0 -- Reset licznika
							ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] Cooling complete. Systems restored.")
							ply:EmitSound("ambient/energy/newspark" .. math.random(1, 9) .. ".wav", 75, 100)
						end
					end)
				else
					-- Pierwszy hit - ostrzeżenie
					ply:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
					
					-- Efekt wizualny iskier przy pierwszym uderzeniu
					local effectdata = EffectData()
					effectdata:SetOrigin(ply:GetPos() + Vector(0, 0, 40))
					effectdata:SetEntity(ply)
					effectdata:SetMagnitude(4)
					effectdata:SetScale(1)
					util.Effect("ElectricSpark", effectdata)
					
					ply:PrintMessage(HUD_PRINTTALK, "[SYSTEM] WARNING: Electrical interference detected! (" .. ply.SecurityDroidStunHits .. "/2)")
				end
			end
		end

		-- Nie zmniejszaj obrażeń zadawanych przez SCP-957-1 i SCP-035.
		if at:IsPlayer() then
			if at:GetNClass() == ROLES.ROLE_SCP9571 and ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP035 then
				-- Nadal blokuj friendly-fire na innych SCP (oprócz SCP-035)
				return true
			end
			
			-- SCP-035 może atakować wszystkich, nawet SCP
			if at:GetNClass() == ROLES.ROLE_SCP035 then
				return false -- Pozwól na normalne obrażenia
			end
		end
	end
end

function GM:Move( ply, mv )
	if ply:GTeam() == TEAM_SCP and OUTSIDE_BUFF( ply:GetPos() ) then
		local speed = 0.0025
		local ang = mv:GetMoveAngles()
		local vel = mv:GetVelocity()
		if vel.z == 0 then 
			vel = vel + ang:Forward() * mv:GetForwardSpeed() * speed
			vel = vel + ang:Right() * mv:GetSideSpeed() * speed
			vel.z = 0
		end

		mv:SetVelocity( vel )
	end
end

-- Entity names display system (SUPERADMIN ONLY)
if CLIENT then
	local showEntityNames = CreateClientConVar("br_show_entity_names", "0", true, false, "Show entity names above all entities (SuperAdmin only)")
	
	hook.Add("HUDPaint", "BR_EntityNames", function()
		-- Check if player is superadmin
		if not LocalPlayer():IsSuperAdmin() then
			if showEntityNames:GetBool() then
				showEntityNames:SetBool(false)
			end
			return
		end
		
		if not showEntityNames:GetBool() then return end
		
		local tr = LocalPlayer():GetEyeTrace()
		local maxDist = 2000
		
		for _, ent in pairs(ents.GetAll()) do
			if not IsValid(ent) then continue end
			if ent == LocalPlayer() then continue end
			
			local pos = ent:GetPos()
			local distance = pos:Distance(LocalPlayer():GetPos())
			
			if distance > maxDist then continue end
			
			-- Add offset based on entity type
			local offset = Vector(0, 0, 10)
			if ent:IsPlayer() then
				offset = Vector(0, 0, 80)
			elseif ent:IsNPC() then
				offset = Vector(0, 0, 70)
			elseif ent:IsVehicle() then
				offset = Vector(0, 0, 50)
			end
			
			local screenPos = (pos + offset):ToScreen()
			
			if screenPos.visible then
				local alpha = math.Clamp(255 - (distance / maxDist * 255), 0, 255)
				local size = math.Clamp(20 - (distance / maxDist * 10), 10, 20)
				
				-- Entity class name
				draw.SimpleTextOutlined(
					ent:GetClass(),
					"DermaDefaultBold",
					screenPos.x,
					screenPos.y,
					Color(255, 255, 255, alpha),
					TEXT_ALIGN_CENTER,
					TEXT_ALIGN_BOTTOM,
					1,
					Color(0, 0, 0, alpha)
				)
				
				-- Additional info for certain entities
				local extraInfo = ""
				if ent:IsPlayer() then
					extraInfo = ent:Nick() .. " [" .. ent:Health() .. " HP]"
				elseif ent:IsNPC() then
					extraInfo = "NPC [" .. ent:Health() .. " HP]"
				elseif ent:IsWeapon() then
					extraInfo = "Weapon"
				elseif ent:GetClass():find("item_") then
					extraInfo = "Item"
				end
				
				if extraInfo != "" then
					draw.SimpleTextOutlined(
						extraInfo,
						"DermaDefaultBold",
						screenPos.x,
						screenPos.y + 15,
						Color(200, 200, 200, alpha),
						TEXT_ALIGN_CENTER,
						TEXT_ALIGN_BOTTOM,
						1,
						Color(0, 0, 0, alpha)
					)
				end
				
				-- Highlight entity under crosshair
				if tr.Entity == ent then
					draw.SimpleTextOutlined(
						"[TARGETED]",
						"DermaDefaultBold",
						screenPos.x,
						screenPos.y - 15,
						Color(255, 0, 0, alpha),
						TEXT_ALIGN_CENTER,
						TEXT_ALIGN_BOTTOM,
						1,
						Color(0, 0, 0, alpha)
					)
				end
			end
		end
	end)
	
	-- Console command override to check permissions
	cvars.AddChangeCallback("br_show_entity_names", function(name, oldVal, newVal)
		if not LocalPlayer():IsSuperAdmin() and newVal == "1" then
			GetConVar("br_show_entity_names"):SetBool(false)
			chat.AddText(Color(255, 0, 0), "[BREACH] ", Color(255, 255, 255), "Ta komenda jest dostępna tylko dla SuperAdminów!")
		end
	end, "br_entity_names_permission_check")
	
	-- Console command help
	concommand.Add("br_show_entity_names_help", function()
		print("=== Entity Names Display (SUPERADMIN ONLY) ===")
		if LocalPlayer():IsSuperAdmin() then
			print("Use 'br_show_entity_names 1' to enable")
			print("Use 'br_show_entity_names 0' to disable")
			print("Shows class names of all entities within 2000 units")
			print("Additional info shown for players, NPCs, weapons and items")
		else
			print("Ta komenda jest dostępna tylko dla SuperAdminów!")
		end
	end)
end

-- Jarate damage bonus hook
if SERVER then
	hook.Add("EntityTakeDamage", "Breach_JarateDamageBonus", function(target, dmginfo)
		if not IsValid(target) or not target:IsPlayer() then return end
		
		-- Check if target is covered in jarate
		if target.breach_jarate_pissed and target.breach_jarate_pissed > CurTime() then
			local originalDamage = dmginfo:GetDamage()
			local bonusDamage = originalDamage * 0.35 -- 35% bonus damage
			dmginfo:AddDamage(bonusDamage)
			
			-- Play crit sound effect
			sound.Play("orange_blossom/piss/crit_hit_mini" .. tostring(math.random(1, 5)) .. ".wav", target:GetPos(), 75, 100, 1)
		end
	end)
end


================================================
FILE: gamemodes/breach/gamemode/modules/sh_module_debug.lua
================================================
-- Debug dla SCP-999 door passing
hook.Add("ShouldCollide", "SCP999_Debug", function(ent1, ent2)
	-- Sprawdź tylko dla graczy
	local ply, other
	if ent1:IsPlayer() then
		ply = ent1
		other = ent2
	elseif ent2:IsPlayer() then
		ply = ent2
		other = ent1
	else
		return
	end
	
	-- Jeśli gracz ma flagę SCP999Active
	if ply.SCP999Active then
		-- print("[SCP-999 DEBUG] Player " .. ply:Nick() .. " has SCP999Active flag")
		-- print("[SCP-999 DEBUG] Colliding with: " .. other:GetClass())
		
		-- Sprawdź czy obiekt ma flagę ignorecollide999
		if other.ignorecollide999 then
			-- print("[SCP-999 DEBUG] Entity has ignorecollide999 = true - WILL PASS THROUGH")
		else
			-- print("[SCP-999 DEBUG] Entity has ignorecollide999 = " .. tostring(other.ignorecollide999) .. " - WILL COLLIDE")
		end
		
		-- Dodatkowe info o typie obiektu
		local isDoor = other:GetClass() == "func_door" or
		               other:GetClass() == "func_door_rotating" or
		               other:GetClass() == "prop_door_rotating"
		local isPropDynamic = other:GetClass() == "prop_dynamic"
		
		if isDoor then
			-- print("[SCP-999 DEBUG] This is a door entity")
		elseif isPropDynamic then
			-- print("[SCP-999 DEBUG] This is a prop_dynamic (might be part of a door)")
		end
	end
end)

-- Debug dla sprawdzenia flagi
if SERVER then
	hook.Add("Think", "SCP999_FlagCheck", function()
		for _, ply in pairs(player.GetAll()) do
			if ply.SCP999Active then
				-- Wyświetl nad głową gracza
				debugoverlay.Text(ply:GetPos() + Vector(0, 0, 80), "SCP-999 ACTIVE", 0.1, false)
			end
		end
	end)
end


================================================
FILE: gamemodes/breach/gamemode/modules/sh_player.lua
================================================
local mply = FindMetaTable( "Player" )

/*function mply:CLevelGlobal()
	local biggest = 1
	for k,wep in pairs(self:GetWeapons()) do
		if IsValid(wep) then
			if wep.clevel then
				if wep.clevel > biggest then
					biggest =  wep.clevel
				end
			end
		end
	end
	return biggest
end 

function mply:CLevel()
	local wep = self:GetActiveWeapon()
	if IsValid(wep) then
		if wep.clevel then
			return wep.clevel
		end
	end
	return 1
end*/

function mply:GetExp()
	if not self.GetNEXP then
		player_manager.RunClass( self, "SetupDataTables" )
	end
	if self.GetNEXP and self.SetNEXP then
		return self:GetNEXP()
	else
		ErrorNoHalt( "Cannot get the exp, GetNEXP invalid" )
		return 0
	end
end

function mply:GetLevel()
	if not self.GetNLevel then
		player_manager.RunClass( self, "SetupDataTables" )
	end
	if self.GetNLevel and self.SetNLevel then
		return self:GetNLevel()
	else
		ErrorNoHalt( "Cannot get the exp, GetNLevel invalid" )
		return 0
	end
end

function Sprint( ply )

end

if CLIENT then
	function mply:DropWeapon( class )
		net.Start( "DropWeapon" )
			net.WriteString( class )
		net.SendToServer()
	end

	function mply:SelectWeapon( class )
		if ( !self:HasWeapon( class ) ) then return end
		self.DoWeaponSwitch = self:GetWeapon( class )
	end
	
	hook.Add( "CreateMove", "WeaponSwitch", function( cmd )
		if !IsValid( LocalPlayer().DoWeaponSwitch ) then return end

		cmd:SelectWeapon( LocalPlayer().DoWeaponSwitch )

		if LocalPlayer():GetActiveWeapon() == LocalPlayer().DoWeaponSwitch then
			LocalPlayer().DoWeaponSwitch = nil
		end
	end )
end

function OnTick()
	if CLIENT then
		Sprint( LocalPlayer() )
	elseif SERVER then
		for k, v in pairs( player.GetAll() ) do
			Sprint( v )
		end
	end
end



================================================
FILE: gamemodes/breach/gamemode/modules/sh_rules.lua
================================================
-- Shared file for rules system
if SERVER then
	util.AddNetworkString("BR_OpenRulesMenu")
	util.AddNetworkString("BR_UpdateRules")
	util.AddNetworkString("BR_SendRules")
	
	-- Pliki z regulaminami
	local rulesFilePL = "breach/rules_pl.txt"
	local rulesFileEN = "breach/rules_en.txt"
	local rulesTextPL = ""
	local rulesTextEN = ""
	
	-- Wczytaj regulaminy z plików
	local function LoadRules()
		-- Polski regulamin
		if file.Exists(rulesFilePL, "DATA") then
			rulesTextPL = file.Read(rulesFilePL, "DATA")
		else
			rulesTextPL = "Regulamin serwera:\n\n1. Szanuj innych graczy\n2. Nie używaj cheatów\n3. Nie spamuj\n4. Graj zgodnie z rolą\n5. Słuchaj administracji"
			file.CreateDir("breach")
			file.Write(rulesFilePL, rulesTextPL)
		end
		
		-- Angielski regulamin
		if file.Exists(rulesFileEN, "DATA") then
			rulesTextEN = file.Read(rulesFileEN, "DATA")
		else
			rulesTextEN = "Server Rules:\n\n1. Respect other players\n2. Don't use cheats\n3. Don't spam\n4. Play according to your role\n5. Listen to administration"
			file.Write(rulesFileEN, rulesTextEN)
		end
	end
	
	-- Zapisz regulamin do pliku
	local function SaveRules(text, lang)
		if lang == "pl" then
			rulesTextPL = text
			file.Write(rulesFilePL, rulesTextPL)
		else
			rulesTextEN = text
			file.Write(rulesFileEN, rulesTextEN)
		end
	end
	
	-- Inicjalizacja
	LoadRules()
	
	-- Hook na komendy czatu
	hook.Add("PlayerSay", "BR_RulesCommand", function(ply, text, public)
		text = string.lower(text)
		
		if text == "!regulamin" or text == "!rules" or text == "/regulamin" or text == "/rules" then
			net.Start("BR_OpenRulesMenu")
				net.WriteString(rulesTextPL)
				net.WriteString(rulesTextEN)
				net.WriteBool(ply:IsSuperAdmin())
			net.Send(ply)
			
			return ""
		end
	end)
	
	-- Odbieranie aktualizacji regulaminu
	net.Receive("BR_UpdateRules", function(len, ply)
		if not ply:IsSuperAdmin() then return end
		
		local newRulesPL = net.ReadString()
		local newRulesEN = net.ReadString()
		
		SaveRules(newRulesPL, "pl")
		SaveRules(newRulesEN, "en")
		
		-- Powiadom wszystkich graczy
		for _, p in pairs(player.GetAll()) do
			p:PrintMessage(HUD_PRINTTALK, "[RULES] Rules have been updated by " .. ply:Nick())
		end
	end)
	
	-- Żądanie regulaminu
	net.Receive("BR_SendRules", function(len, ply)
		net.Start("BR_OpenRulesMenu")
			net.WriteString(rulesTextPL)
			net.WriteString(rulesTextEN)
			net.WriteBool(ply:IsSuperAdmin())
		net.Send(ply)
	end)
end

if CLIENT then
	local rulesFrame = nil
	
	net.Receive("BR_OpenRulesMenu", function()
		local rulesTextPL = net.ReadString()
		local rulesTextEN = net.ReadString()
		local canEdit = net.ReadBool()
		
		-- Zamknij poprzednie okno jeśli istnieje
		if IsValid(rulesFrame) then
			rulesFrame:Remove()
		end
		
		-- Główne okno
		rulesFrame = vgui.Create("DFrame")
		rulesFrame:SetSize(800, 600)
		rulesFrame:Center()
		rulesFrame:SetTitle("Regulamin Serwera / Server Rules")
		rulesFrame:SetDraggable(true)
		rulesFrame:ShowCloseButton(true)
		rulesFrame:MakePopup()
		
		-- Panel tła
		rulesFrame.Paint = function(self, w, h)
			draw.RoundedBox(8, 0, 0, w, h, Color(30, 30, 30, 250))
			draw.RoundedBoxEx(8, 0, 0, w, 24, Color(50, 50, 50, 255), true, true, false, false)
		end
		
		-- Przycisk odśwież na dole na środku
		local refreshBtn = vgui.Create("DButton", rulesFrame)
		refreshBtn:SetText("Odśwież / Refresh")
		refreshBtn:SetSize(150, 30)
		refreshBtn:SetPos(rulesFrame:GetWide() / 2 - 75, rulesFrame:GetTall() - 40)
		refreshBtn.DoClick = function()
			net.Start("BR_SendRules")
			net.SendToServer()
			surface.PlaySound("buttons/button15.wav")
		end
		
		refreshBtn.Paint = function(self, w, h)
			local col = Color(70, 70, 70)
			if self:IsHovered() then
				col = Color(90, 90, 90)
			end
			draw.RoundedBox(4, 0, 0, w, h, col)
		end
		
		-- Panel z zakładkami
		local sheet = vgui.Create("DPropertySheet", rulesFrame)
		sheet:Dock(FILL)
		sheet:DockMargin(10, 10, 10, 50)
		
		if canEdit then
			-- Tryb edycji dla superadminów
			
			-- Panel polski
			local panelPL = vgui.Create("DPanel", sheet)
			panelPL.Paint = function(self, w, h)
				draw.RoundedBox(4, 0, 0, w, h, Color(35, 35, 35, 255))
			end
			
			local textEntryPL = vgui.Create("DTextEntry", panelPL)
			textEntryPL:Dock(FILL)
			textEntryPL:DockMargin(5, 5, 5, 5)
			textEntryPL:SetMultiline(true)
			textEntryPL:SetText(rulesTextPL)
			textEntryPL:SetFont("DermaDefault")
			textEntryPL:SetTextColor(Color(255, 255, 255))
			textEntryPL:SetPaintBackground(false)
			
			textEntryPL.Paint = function(self, w, h)
				draw.RoundedBox(4, 0, 0, w, h, Color(40, 40, 40, 255))
				self:DrawTextEntryText(Color(255, 255, 255), Color(100, 100, 255), Color(255, 255, 255))
			end
			
			-- Panel angielski
			local panelEN = vgui.Create("DPanel", sheet)
			panelEN.Paint = function(self, w, h)
				draw.RoundedBox(4, 0, 0, w, h, Color(35, 35, 35, 255))
			end
			
			local textEntryEN = vgui.Create("DTextEntry", panelEN)
			textEntryEN:Dock(FILL)
			textEntryEN:DockMargin(5, 5, 5, 5)
			textEntryEN:SetMultiline(true)
			textEntryEN:SetText(rulesTextEN)
			textEntryEN:SetFont("DermaDefault")
			textEntryEN:SetTextColor(Color(255, 255, 255))
			textEntryEN:SetPaintBackground(false)
			
			textEntryEN.Paint = function(self, w, h)
				draw.RoundedBox(4, 0, 0, w, h, Color(40, 40, 40, 255))
				self:DrawTextEntryText(Color(255, 255, 255), Color(100, 100, 255), Color(255, 255, 255))
			end
			
			-- Dodaj zakładki
			sheet:AddSheet("Polski", panelPL, "icon16/flag_red.png")
			sheet:AddSheet("English", panelEN, "icon16/flag_blue.png")
			
			-- Przycisk zapisz
			local saveBtn = vgui.Create("DButton", rulesFrame)
			saveBtn:SetText("Zapisz zmiany / Save changes")
			saveBtn:SetSize(200, 30)
			saveBtn:SetPos(rulesFrame:GetWide() - 220, rulesFrame:GetTall() - 40)
			saveBtn.DoClick = function()
				net.Start("BR_UpdateRules")
					net.WriteString(textEntryPL:GetText())
					net.WriteString(textEntryEN:GetText())
				net.SendToServer()
				
				rulesFrame:Close()
				surface.PlaySound("buttons/button15.wav")
			end
			
			saveBtn.Paint = function(self, w, h)
				local col = Color(100, 200, 100)
				if self:IsHovered() then
					col = Color(120, 220, 120)
				end
				draw.RoundedBox(4, 0, 0, w, h, col)
			end
			
			-- Info o edycji
			local infoLabel = vgui.Create("DLabel", rulesFrame)
			infoLabel:SetText("TRYB EDYCJI / EDIT MODE")
			infoLabel:SetFont("DermaDefaultBold")
			infoLabel:SetTextColor(Color(255, 200, 0))
			infoLabel:SizeToContents()
			infoLabel:SetPos(10, rulesFrame:GetTall() - 35)
		else
			-- Tryb tylko do odczytu
			
			-- Panel polski
			local panelPL = vgui.Create("DPanel", sheet)
			panelPL.Paint = function(self, w, h)
				draw.RoundedBox(4, 0, 0, w, h, Color(35, 35, 35, 255))
			end
			
			local richTextPL = vgui.Create("RichText", panelPL)
			richTextPL:Dock(FILL)
			richTextPL:DockMargin(10, 10, 10, 10)
			richTextPL:SetFontInternal("DermaLarge")
			
			-- Formatowanie tekstu polskiego
			local linesPL = string.Explode("\n", rulesTextPL)
			for _, line in ipairs(linesPL) do
				if string.find(line, "^%d+%.") or string.find(line, "^-") or string.find(line, "^•") then
					richTextPL:InsertColorChange(255, 255, 255, 255)
					richTextPL:AppendText(line .. "\n")
				elseif string.len(string.Trim(line)) > 0 then
					richTextPL:InsertColorChange(255, 200, 0, 255)
					richTextPL:AppendText(line .. "\n")
					richTextPL:InsertColorChange(255, 255, 255, 255)
				else
					richTextPL:AppendText("\n")
				end
			end
			
			-- Panel angielski
			local panelEN = vgui.Create("DPanel", sheet)
			panelEN.Paint = function(self, w, h)
				draw.RoundedBox(4, 0, 0, w, h, Color(35, 35, 35, 255))
			end
			
			local richTextEN = vgui.Create("RichText", panelEN)
			richTextEN:Dock(FILL)
			richTextEN:DockMargin(10, 10, 10, 10)
			richTextEN:SetFontInternal("DermaLarge")
			
			-- Formatowanie tekstu angielskiego
			local linesEN = string.Explode("\n", rulesTextEN)
			for _, line in ipairs(linesEN) do
				if string.find(line, "^%d+%.") or string.find(line, "^-") or string.find(line, "^•") then
					richTextEN:InsertColorChange(255, 255, 255, 255)
					richTextEN:AppendText(line .. "\n")
				elseif string.len(string.Trim(line)) > 0 then
					richTextEN:InsertColorChange(255, 200, 0, 255)
					richTextEN:AppendText(line .. "\n")
					richTextEN:InsertColorChange(255, 255, 255, 255)
				else
					richTextEN:AppendText("\n")
				end
			end
			
			-- Dodaj zakładki
			sheet:AddSheet("Polski", panelPL, "icon16/flag_red.png")
			sheet:AddSheet("English", panelEN, "icon16/flag_blue.png")
		end
	end)
end


================================================
FILE: gamemodes/breach/gamemode/modules/sh_sam_breach.lua
================================================
-- SAM Breach Integration
-- Ten plik powinien być umieszczony w folderze modułów gamemode'u Breach
-- aby załadować się po wszystkich funkcjach Breach

if not sam or not sam.command then
	print("[SAM Breach] SAM not found, skipping Breach integration")
	return
end

local sam, command, language = sam, sam.command, sam.language

print("[SAM Breach] Loading Breach integration for SAM...")

-- Sprawdź czy dane Breach są dostępne
if not ALLCLASSES or not SCPS then
	print("[SAM Breach] Breach data not available")
	return
end

command.set_category("SCP: Breach")

-- Definiuj niestandardowe argumenty
command.new_argument("breach_class")
	:OnExecute(function(arg, input, ply, _, result)
		if not ALLCLASSES then
			ply:sam_send_message("breach_classes_not_loaded")
			return false
		end
		
		-- Sprawdź czy klasa istnieje
		local found = false
		for _, group in pairs(ALLCLASSES) do
			for k, class in pairs(group.roles) do
				if class.name == input or class.name == ROLES["ROLE_"..input] then
					found = true
					break
				end
			end
			if found then break end
		end
		
		if not found then
			ply:sam_send_message("breach_invalid_class", {V = input})
			return false
		end
		
		table.insert(result, input)
	end)
	
	:Menu(function(set_result, body, buttons, arg)
		local default = arg.hint or "Select Class"
		
		local cbo = buttons:Add("SAM.ComboBox")
		cbo:SetValue(default)
		cbo:SetTall(25)
		
		function cbo:OnSelect(_, value)
			set_result(value)
			default = value
		end
		
		function cbo:DoClick()
			if self:IsMenuOpen() then
				return self:CloseMenu()
			end
			
			self:Clear()
			self:SetValue(default)
			
			if not ALLCLASSES then
				LocalPlayer():sam_send_message("breach_classes_not_loaded")
				return
			end
			
			-- Dodaj wszystkie klasy do dropdown w uporządkowany sposób
			local class_list = {}
			for _, group in pairs(ALLCLASSES) do
				for k, class in pairs(group.roles) do
					table.insert(class_list, class.name)
				end
			end
			
			table.sort(class_list)
			
			for _, class_name in pairs(class_list) do
				self:AddChoice(class_name)
			end
			
			self:OpenMenu()
		end
		
		return cbo
	end)
	
	:AutoComplete(function(arg, result, name)
		if not ALLCLASSES then return end
		
		name = name:lower()
		for _, group in pairs(ALLCLASSES) do
			for k, class in pairs(group.roles) do
				if class.name:lower():find(name, 1, true) then
					table.insert(result, class.name)
				end
			end
		end
	end)
:End()

command.new_argument("breach_scp")
	:OnExecute(function(arg, input, ply, _, result)
		if not SCPS then
			ply:sam_send_message("breach_scps_not_loaded")
			return false
		end
		
		-- Sprawdź czy SCP istnieje
		local found = false
		for _, scp_name in pairs(SCPS) do
			if scp_name == input then
				found = true
				break
			end
		end
		
		if not found then
			ply:sam_send_message("breach_invalid_scp", {V = input})
			return false
		end
		
		table.insert(result, input)
	end)
	
	:Menu(function(set_result, body, buttons, arg)
		local default = arg.hint or "Select SCP"
		
		local cbo = buttons:Add("SAM.ComboBox")
		cbo:SetValue(default)
		cbo:SetTall(25)
		
		function cbo:OnSelect(_, value)
			set_result(value)
			default = value
		end
		
		function cbo:DoClick()
			if self:IsMenuOpen() then
				return self:CloseMenu()
			end
			
			self:Clear()
			self:SetValue(default)
			
			if not SCPS then
				LocalPlayer():sam_send_message("breach_scps_not_loaded")
				return
			end
			
			-- Dodaj wszystkie SCP do dropdown w uporządkowany sposób
			local scp_list = table.Copy(SCPS)
			table.sort(scp_list)
			
			for _, scp_name in pairs(scp_list) do
				self:AddChoice(scp_name)
			end
			
			self:OpenMenu()
		end
		
		return cbo
	end)
	
	:AutoComplete(function(arg, result, name)
		if not SCPS then return end
		
		name = name:lower()
		for _, scp_name in pairs(SCPS) do
			if scp_name:lower():find(name, 1, true) then
				table.insert(result, scp_name)
			end
		end
	end)
:End()

-- Komenda force_spawn - Wymusza spawn gracza jako określona klasa
command.new("force_spawn")
	:SetPermission("breach_force_spawn", "superadmin")
	
	:AddArg("player")
	:AddArg("breach_class", {hint = "class name"})
	
	:Help("Forces player(s) to spawn as specific class")
	
	:OnExecute(function(ply, targets, class_name)
		if not class_name then return end
		
		-- Znajdź klasę w ALLCLASSES
		local cl, gr
		for _, group in pairs(ALLCLASSES) do
			gr = group.name
			for k, clas in pairs(group.roles) do
				if clas.name == class_name or clas.name == ROLES["ROLE_"..class_name] then
					cl = clas
					break
				end
			end
			if cl then break end
		end
		
		if cl and gr then
			local pos
			if gr == "Armed Site Support" then
				pos = SPAWN_OUTSIDE
			elseif gr == "Armed Site Security" then
				pos = SPAWN_GUARD
			elseif gr == "Unarmed Site Staff" then
				-- Special handling for Cook role
				if cl.name == ROLES.ROLE_COOK and SPAWN_COOK and #SPAWN_COOK > 0 then
					pos = SPAWN_COOK
				-- Special handling for Dr. House role
				elseif cl.name == ROLES.ROLE_DRHOUSE and SPAWN_DRHOUSE and #SPAWN_DRHOUSE > 0 then
					pos = SPAWN_DRHOUSE
				-- Special handling for Psychologist role
				elseif cl.name == ROLES.ROLE_PSYCHOLOGIST and SPAWN_PSYCHOLOGIST and #SPAWN_PSYCHOLOGIST > 0 then
					pos = SPAWN_PSYCHOLOGIST
				else
					pos = SPAWN_SCIENT
				end
			elseif gr == "Class D Personell" then
				pos = SPAWN_CLASSD
			end
			
			for k, v in pairs(targets) do
				-- Sprawdź czy gracz jest prawidłowy i aktywny
				if IsValid(v) and v:IsPlayer() then
					-- Sprawdź czy ma funkcję GetNActive (specyficzną dla Breach)
					local isActive = true
					if v.GetNActive then
						isActive = v:GetNActive()
					end
					
					if isActive then
						-- Sprawdź czy ma funkcje Breach
						if v.SetupNormal and v.ApplyRoleStats then
							v:SetupNormal()
							v:ApplyRoleStats(cl)
							if pos and #pos > 0 then
								v:SetPos(table.Random(pos))
							end
						else
							-- Fallback - podstawowy spawn
							v:Spawn()
							if pos and #pos > 0 then
								v:SetPos(table.Random(pos))
							end
						end
					else
						sam.player.send_message(ply, "breach_player_inactive", {
							T = v:Name()
						})
					end
				else
					sam.player.send_message(ply, "breach_invalid_target")
				end
			end
			
			sam.player.send_message(nil, "breach_force_spawn", {
				A = ply, T = targets, V = cl.name
			})
		else
			sam.player.send_message(ply, "breach_invalid_class", {
				V = class_name
			})
		end
	end)
:End()

-- Komenda force_scp - Wymusza spawn gracza jako SCP
command.new("force_scp")
	:SetPermission("breach_force_scp", "superadmin")
	
	:AddArg("player", {single_target = true})
	:AddArg("breach_scp", {hint = "SCP name"})
	
	:Help("Forces player to spawn as specific SCP")
	
	:OnExecute(function(ply, targets, scp_name)
		local target = targets[1]
		
		-- Sprawdź czy gracz jest prawidłowy
		if not IsValid(target) or not target:IsPlayer() then
			sam.player.send_message(ply, "breach_invalid_target")
			return
		end
		
		-- Sprawdź czy gracz jest aktywny (jeśli ma funkcję GetNActive)
		local isActive = true
		if target.GetNActive then
			isActive = target:GetNActive()
		end
		
		if not isActive then
			sam.player.send_message(ply, "breach_player_inactive", {
				T = target:Name()
			})
			return
		end
		
		-- Sprawdź czy funkcja GetSCP istnieje
		if not GetSCP then
			sam.player.send_message(ply, "breach_scps_not_loaded")
			return
		end
		
		local scp_obj = GetSCP(scp_name)
		if scp_obj and scp_obj.SetupPlayer then
			scp_obj:SetupPlayer(target)
			
			sam.player.send_message(nil, "breach_force_scp", {
				A = ply, T = target:Name(), V = scp_name
			})
		else
			sam.player.send_message(ply, "breach_invalid_scp", {
				V = scp_name
			})
		end
	end)
:End()

-- Komenda restart_round - Restartuje rundę
command.new("restart_round")
	:SetPermission("breach_restart_round", "superadmin")
	
	:Help("Restarts current round")
	
	:OnExecute(function(ply)
		if not RoundRestart then
			sam.player.send_message(ply, "breach_function_not_available", {
				V = "RoundRestart"
			})
			return
		end
		
		RoundRestart()
		
		sam.player.send_message(nil, "breach_restart_round", {
			A = ply
		})
	end)
:End()

-- Komenda admin_mode - Przełącza tryb administratora
command.new("admin_mode")
	:SetPermission("breach_admin_mode", "admin")
	
	:Help("Toggles admin mode for next round")
	
	:OnExecute(function(ply)
		if not ply.ToggleAdminModePref then
			sam.player.send_message(ply, "breach_function_not_available", {
				V = "ToggleAdminModePref"
			})
			return
		end
		
		ply:ToggleAdminModePref()
		
		if ply.admpref then
			if ply.AdminMode then
				sam.player.send_message(nil, "breach_admin_mode_entered", {
					A = ply
				})
			else
				sam.player.send_message(nil, "breach_admin_mode_next", {
					A = ply
				})
			end
		else
			sam.player.send_message(nil, "breach_admin_mode_disabled", {
				A = ply
			})
		end
	end)
:End()

-- Komenda request_ntf - Spawnuje jednostki wsparcia
command.new("request_ntf")
	:SetPermission("breach_request_ntf", "superadmin")
	
	:Help("Spawns support units (NTF/GOC/Chaos)")
	
	:OnExecute(function(ply)
		-- Sprawdź czy funkcje spawn istnieją
		if not SpawnNTFS then
			sam.player.send_message(ply, "breach_function_not_available", {
				V = "SpawnNTFS"
			})
			return
		end
		
		-- Losowanie z właściwymi proporcjami: NTF 50%, GOC 10%, Chaos 40%
		local rand = math.random(1, 100)
		if rand <= 50 then
			-- 50% szans dla NTF
			SpawnNTFS()
		elseif rand <= 60 and SpawnGOC then
			-- 10% szans dla GOC (51-60)
			SpawnGOC()
		else
			-- 40% szans dla Chaos (61-100)
			SpawnNTFS(true) -- Wymusza spawn Chaos
		end
		
		sam.player.send_message(nil, "breach_request_ntf", {
			A = ply
		})
	end)
:End()

-- Komenda tsay - Wyświetla kolorową wiadomość wszystkim graczom
command.new("tsay")
	:SetPermission("breach_tsay", "admin")
	
	:AddArg("text", {hint = "message"})
	
	:GetRestArgs()
	:Help("Displays a colored message to all players")
	
	:OnExecute(function(ply, message)
		-- Wyślij tylko kolorową wiadomość (bez standardowej)
		if sam.netstream then
			sam.netstream.Start(nil, "breach_tsay_display", {
				message = message,
				admin = ply:Name()
			})
		else
			-- Fallback jeśli netstream nie działa
			for _, v in pairs(player.GetAll()) do
				if IsValid(v) then
					v:PrintMessage(HUD_PRINTCENTER, "[ADMIN] " .. message)
				end
			end
		end
		
		sam.player.send_message(nil, "breach_tsay", {
			A = ply, V = message
		})
	end)
:End()

-- Komenda getpos - Pobiera pozycję gracza
command.new("getpos")
	:SetPermission("breach_getpos", "admin")
	
	:AddArg("player", {single_target = true, optional = true})
	
	:Help("Gets player position coordinates")
	
	:OnExecute(function(ply, targets)
		local target = targets and targets[1] or ply
		
		if not IsValid(target) then
			sam.player.send_message(ply, "breach_invalid_target")
			return
		end
		
		local pos = target:GetPos()
		local ang = target:GetAngles()
		
		local posString = string.format("%.2f %.2f %.2f", pos.x, pos.y, pos.z)
		local angString = string.format("%.2f %.2f %.2f", ang.p, ang.y, ang.r)
		
		sam.player.send_message(ply, "breach_getpos", {
			T = target:Name(), V = posString, V_2 = angString
		})
	end)
:End()

-- Komenda bot - Dodaje boty do serwera
command.new("bot")
	:SetPermission("breach_bot", "admin")
	
	:AddArg("number", {hint = "amount", min = 1, max = 32, default = 1})
	
	:Help("Adds bots to the server")
	
	:OnExecute(function(ply, amount)
		amount = math.Clamp(amount, 1, 32)
		
		for i = 1, amount do
			RunConsoleCommand("bot")
		end
		
		sam.player.send_message(nil, "breach_bot_add", {
			A = ply, V = amount
		})
	end)
:End()

-- Komenda kickbot - Usuwa wszystkie boty
command.new("kickbot")
	:SetPermission("breach_kickbot", "admin")
	
	:Help("Kicks all bots from the server")
	
	:OnExecute(function(ply)
		local botCount = 0
		for _, v in pairs(player.GetAll()) do
			if v:IsBot() then
				v:Kick("Kicked by admin")
				botCount = botCount + 1
			end
		end
		
		sam.player.send_message(nil, "breach_kickbot", {
			A = ply, V = botCount
		})
	end)
:End()

-- Komenda recheck_premium - Przeładowuje status premium graczy
command.new("recheck_premium")
	:SetPermission("breach_recheck_premium", "admin")
	
	:Help("Reloads all players premium status")
	
	:OnExecute(function(ply)
		-- Sprawdź czy funkcja IsPremium istnieje
		if not IsPremium then
			sam.player.send_message(ply, "breach_function_not_available", {
				V = "IsPremium"
			})
			return
		end
		
		for k, v in pairs(player.GetAll()) do
			if IsValid(v) and v:IsPlayer() then
				IsPremium(v, true)
			end
		end
		
		sam.player.send_message(nil, "breach_recheck_premium", {
			A = ply
		})
	end)
:End()

-- Komenda punish_cancel - Anuluje ostatnie głosowanie karania
command.new("punish_cancel")
	:SetPermission("breach_punish_cancel", "admin")
	
	:Help("Cancels last punish vote")
	
	:OnExecute(function(ply)
		-- Sprawdź czy funkcja CancelVote istnieje
		if not CancelVote then
			sam.player.send_message(ply, "breach_function_not_available", {
				V = "CancelVote"
			})
			return
		end
		
		CancelVote()
		
		sam.player.send_message(nil, "breach_punish_cancel", {
			A = ply
		})
	end)
:End()

-- Komenda clear_stats - Czyści statystyki gracza
command.new("clear_stats")
	:SetPermission("breach_clear_stats", "superadmin")
	
	:AddArg("player", {single_target = true})
	:AddArg("text", {hint = "SteamID64", optional = true})
	
	:Help("Clears player data by name or SteamID64")
	
	:OnExecute(function(ply, targets, steamid)
		local target = targets[1]
		
		if ply == target and steamid and steamid ~= "" then
			if steamid == "&ALL" then
				sam.player.send_message(ply, "breach_clear_all_error")
				return
			end
			
			if IsValidSteamID and IsValidSteamID(steamid) then
				if clearDataID then
					clearDataID(steamid)
					sam.player.send_message(nil, "breach_clear_stats_id", {
						A = ply, V = steamid
					})
				else
					sam.player.send_message(ply, "breach_function_not_available", {
						V = "clearDataID"
					})
				end
			else
				sam.player.send_message(ply, "breach_invalid_steamid")
			end
			return
		end
		
		if clearData then
			clearData(target)
			sam.player.send_message(nil, "breach_clear_stats", {
				A = ply, T = target:Name()
			})
		else
			sam.player.send_message(ply, "breach_function_not_available", {
				V = "clearData"
			})
		end
	end)
:End()

-- Komenda restart_game - Restartuje grę
command.new("restart_game")
	:SetPermission("breach_restart_game", "superadmin")
	
	:Help("Restarts the game")
	
	:OnExecute(function(ply)
		if not RestartGame then
			sam.player.send_message(ply, "breach_function_not_available", {
				V = "RestartGame"
			})
			return
		end
		
		RestartGame()
		
		sam.player.send_message(nil, "breach_restart_game", {
			A = ply
		})
	end)
:End()

-- Komenda destroy_gate_a - Niszczy Bramę A
command.new("destroy_gate_a")
	:SetPermission("breach_destroy_gate_a", "admin")
	
	:Help("Destroys Gate A")
	
	:OnExecute(function(ply)
		if not explodeGateA then
			sam.player.send_message(ply, "breach_function_not_available", {
				V = "explodeGateA"
			})
			return
		end
		
		explodeGateA()
		
		sam.player.send_message(nil, "breach_destroy_gate_a", {
			A = ply
		})
	end)
:End()

-- Komenda setlvl - Ustawia poziom gracza
command.new("setlvl")
	:SetPermission("breach_setlvl", "superadmin")
	
	:AddArg("player", {single_target = true})
	:AddArg("number", {hint = "level", min = 0, max = 100})
	
	:Help("Sets player level")
	
	:OnExecute(function(ply, targets, level)
		local target = targets[1]
		
		if not IsValid(target) then
			sam.player.send_message(ply, "breach_invalid_target")
			return
		end
		
		-- Sprawdź czy gracz ma funkcje poziomu
		if not target.SetNLevel then
			sam.player.send_message(ply, "breach_level_not_supported")
			return
		end
		
		level = math.Clamp(level, 0, 100)
		
		target:SetNLevel(level)
		if target.SetPData then
			target:SetPData("breach_level", level)
		end
		if target.SaveLevel then
			target:SaveLevel()
		end
		
		sam.player.send_message(nil, "breach_setlvl", {
			A = ply, T = target:Name(), V = level
		})
	end)
:End()

-- Komenda addlvl - Dodaje poziomy graczowi
command.new("addlvl")
	:SetPermission("breach_addlvl", "superadmin")
	
	:AddArg("player", {single_target = true})
	:AddArg("number", {hint = "levels", min = 1, max = 50})
	
	:Help("Adds levels to player")
	
	:OnExecute(function(ply, targets, levels)
		local target = targets[1]
		
		if not IsValid(target) then
			sam.player.send_message(ply, "breach_invalid_target")
			return
		end
		
		-- Sprawdź czy gracz ma funkcje poziomu
		if not target.GetLevel or not target.SetNLevel then
			sam.player.send_message(ply, "breach_level_not_supported")
			return
		end
		
		levels = math.Clamp(levels, 1, 50)
		local currentLevel = target:GetLevel()
		local newLevel = math.Clamp(currentLevel + levels, 0, 100)
		
		target:SetNLevel(newLevel)
		if target.SetPData then
			target:SetPData("breach_level", newLevel)
		end
		if target.SaveLevel then
			target:SaveLevel()
		end
		
		sam.player.send_message(nil, "breach_addlvl", {
			A = ply, T = target:Name(), V = levels, V_2 = newLevel
		})
	end)
:End()

-- Komenda addexp - Dodaje doświadczenie graczowi
command.new("addexp")
	:SetPermission("breach_addexp", "admin")
	
	:AddArg("player", {single_target = true})
	:AddArg("number", {hint = "experience", min = 1, max = 10000})
	
	:Help("Adds experience to player")
	
	:OnExecute(function(ply, targets, exp)
		local target = targets[1]
		
		if not IsValid(target) then
			sam.player.send_message(ply, "breach_invalid_target")
			return
		end
		
		-- Sprawdź czy gracz ma funkcje doświadczenia
		if not target.AddExp then
			sam.player.send_message(ply, "breach_exp_not_supported")
			return
		end
		
		exp = math.Clamp(exp, 1, 10000)
		
		target:AddExp(exp, true)
		
		sam.player.send_message(nil, "breach_addexp", {
			A = ply, T = target:Name(), V = exp
		})
	end)
:End()

print("[SAM Breach] Successfully loaded " .. 18 .. " commands")


================================================
FILE: gamemodes/breach/gamemode/modules/sh_ulx.lua
================================================
function InitializeBreachULX()
	if !ulx or !ULib then 
		print( "ULX or ULib not found" )
		return
	end

	if !ALLCLASSES then
		print( "ALLCLASSES not loaded yet, skipping ULX initialization" )
		return
	end

	local class_names = {}
	for _, group in pairs( ALLCLASSES ) do
		for k, class in pairs( group.roles ) do
			table.insert( class_names, class.name )
		end
	end

	/*local scp_names = {}
	for _, scp in pairs( SPCS ) do
		table.insert( scp_names, scp.name )
	end*/

	function ulx.forcespawn( ply, plys, class, silent )
		if !class then return end
		local cl, gr
		for _, group in pairs( ALLCLASSES ) do
			gr = group.name
			for k, clas in pairs( group.roles ) do
				if clas.name == class or clas.name == ROLES["ROLE_"..class] then
					cl = clas
				end
				if cl then break end
			end
			if cl then break end
		end
		if cl and gr then
			local pos
			if gr == "Armed Site Support" then
				pos = SPAWN_OUTSIDE
			elseif gr == "Armed Site Security" then
				pos = SPAWN_GUARD
			elseif gr == "Unarmed Site Staff" then
				-- Special handling for Cook role
				if cl.name == ROLES.ROLE_COOK and SPAWN_COOK and #SPAWN_COOK > 0 then
					pos = SPAWN_COOK
							-- Special handling for Dr. House role
			elseif cl.name == ROLES.ROLE_DRHOUSE and SPAWN_DRHOUSE and #SPAWN_DRHOUSE > 0 then
				pos = SPAWN_DRHOUSE
			-- Special handling for Psychologist role
			elseif cl.name == ROLES.ROLE_PSYCHOLOGIST and SPAWN_PSYCHOLOGIST and #SPAWN_PSYCHOLOGIST > 0 then
				pos = SPAWN_PSYCHOLOGIST
				else
					pos = SPAWN_SCIENT
				end
			elseif  gr == "Class D Personell" then
				pos = SPAWN_CLASSD
			end
			for k, v in pairs( plys ) do
				if v:GetNActive() then
					v:SetupNormal()
					v:ApplyRoleStats( cl )
					if pos then
						v:SetPos( table.Random( pos ) )
					end
				else
					ULib.tsayError( plyc, "Player "..v:GetName().." is inactive! Forced spawn failed", true )
				end
			end
			if silent then
				ulx.fancyLogAdmin( ply, true, "#A force spawned #T as "..cl.name, plys )
			else
				ulx.fancyLogAdmin( ply, "#A force spawned #T as "..cl.name, plys )
			end
		end
	end

	local forcespawn = ulx.command( "Breach Admin", "ulx force_spawn", ulx.forcespawn, "!forcespawn" )
	forcespawn:addParam{ type = ULib.cmds.PlayersArg }
	forcespawn:addParam{ type = ULib.cmds.StringArg, hint = "class name", completes = class_names, ULib.cmds.takeRestOfLine }
	forcespawn:addParam{ type = ULib.cmds.BoolArg, invisible = true }
	forcespawn:setOpposite( "ulx silent force_spawn", { _, _, _, true }, "!sforcespawn" )
	forcespawn:defaultAccess( ULib.ACCESS_SUPERADMIN )
	forcespawn:help( "Sets player(s) to specific class and spawns him" )



	function ulx.recheckpremium( ply, silent )
		for k, v in pairs( player.GetAll() ) do
			IsPremium( v, true )
		end
		if silent then
			ulx.fancyLogAdmin( ply, true, "#A reloaded premium status of players" )
		else
			ulx.fancyLogAdmin( ply, "#A reloaded premium status of players" )
		end
	end

	local recheckpremium = ulx.command( "Breach Admin", "ulx recheck_premium", ulx.recheckpremium, "!recheckpremium" )
	recheckpremium:defaultAccess( ULib.ACCESS_ADMIN )
	recheckpremium:help( "Reloads player's premium status" )

	function ulx.punishcancel( ply, silent )
		CancelVote()
		if silent then
			ulx.fancyLogAdmin( ply, true, "#A canceled last punish vote" )
		else
			ulx.fancyLogAdmin( ply, "#A canceled last punish vote" )
		end
	end

	local punishcancel = ulx.command( "Breach Admin", "ulx punish_cancel", ulx.punishcancel, "!punishcancel" )
	punishcancel:addParam{ type = ULib.cmds.BoolArg, invisible = true }
	punishcancel:setOpposite( "ulx silent recheck_premium", { _, true }, "!spunishcancel" )
	punishcancel:defaultAccess( ULib.ACCESS_ADMIN )
	punishcancel:help( "Cancels last punish vote" )

	function ulx.clearstats( plyc, plyt, id, silent )
		if plyc == plyt and id != "" then
			if id == "&ALL" then
				ULib.tsayError( plyc, "To clear data of every online player use br_clear_stats instead!", true )
				return
			end
			if IsValidSteamID( id ) then
				clearDataID( id )
			end
			if silent then
				ulx.fancyLogAdmin( plyc, true, "#A cleared data of player with SteamID64: "..id )
			else
				ulx.fancyLogAdmin( plyc, "#A cleared data of player with SteamID64: "..id )
			end
			return
		end
		clearData( plyt )
		if silent then
			ulx.fancyLogAdmin( plyc, true, "#A cleared data of #T", plyt )
		else
			ulx.fancyLogAdmin( plyc, "#A cleared data of #T", plyt )
		end
	end

	local clearstats = ulx.command( "Breach Admin", "ulx clear_stats", ulx.clearstats, "!clearstats" )
	clearstats:addParam{ type = ULib.cmds.PlayerArg }
	clearstats:addParam{ type = ULib.cmds.StringArg, hint = "SteamID64", ULib.cmds.takeRestOfLine, ULib.cmds.optional }
	clearstats:addParam{ type = ULib.cmds.BoolArg, invisible = true }
	clearstats:setOpposite( "ulx silent clear_stats", { _, _, _, true }, "!sclearstats" )
	clearstats:defaultAccess( ULib.ACCESS_SUPERADMIN )
	clearstats:help( "Clears player data by name or SteamID64(to use SteamID64 select yourself as target)" )

	function ulx.restartgame( ply, silent )
		RestartGame()
		if silent then
			ulx.fancyLogAdmin( ply, true, "#A restarted game" )
		else
			ulx.fancyLogAdmin( ply, "#A restarted game" )
		end
	end

	local restartgame = ulx.command( "Breach Admin", "ulx restart_game", ulx.restartgame, "!restartgame" )
	restartgame:addParam{ type = ULib.cmds.BoolArg, invisible = true }
	restartgame:setOpposite( "ulx silent restart_game", { _, true }, "!srestartgame" )
	restartgame:defaultAccess( ULib.ACCESS_SUPERADMIN )
	restartgame:help( "Restarts game" )

	function ulx.adminmode( ply, silent )
		ply:ToggleAdminModePref()
		if ply.admpref then
			if ply.AdminMode then
				if silent then
					ulx.fancyLogAdmin( ply, true, "#A entered admin mode" )
				else
					ulx.fancyLogAdmin( ply, "#A entered admin mode" )
				end
			else
				if silent then
					ulx.fancyLogAdmin( ply, true, "#A will enter admin mode in next round" )
				else
					ulx.fancyLogAdmin( ply, "#A will enter admin mode in next round" )
				end
			end
		else
			if silent then
				ulx.fancyLogAdmin( ply, "#A will no longer be in admin mode" )
			else
				ulx.fancyLogAdmin( ply, "#A will no longer be in admin mode" )
			end
		end
	end

	local adminmode = ulx.command( "Breach Admin", "ulx admin_mode", ulx.adminmode, "!adminmode" )
	adminmode:addParam{ type = ULib.cmds.BoolArg, invisible = true }
	adminmode:setOpposite( "ulx silent admin_mode", { _, true }, "!sadminmode" )
	adminmode:defaultAccess( ULib.ACCESS_ADMIN )
	adminmode:help( "Toggles admin mode" )

	function ulx.requestntf( ply, silent )
		-- Losowanie z właściwymi proporcjami: NTF 50%, GOC 10%, Chaos 40%
		local rand = math.random(1, 100)
		if rand <= 50 then
			-- 50% szans dla NTF
			SpawnNTFS()
		elseif rand <= 60 then
			-- 10% szans dla GOC (51-60)
			SpawnGOC()
		else
			-- 40% szans dla Chaos (61-100)
			SpawnNTFS(true) -- Wymusza spawn Chaos
		end
		
		if silent then
			ulx.fancyLogAdmin( ply, true, "#A spawned support units" )
		else
			ulx.fancyLogAdmin( ply, "#A spawned support units" )
		end
	end

	local requestntf = ulx.command( "Breach Admin", "ulx request_ntf", ulx.requestntf, "!ntf" )
	requestntf:addParam{ type = ULib.cmds.BoolArg, invisible = true }
	requestntf:setOpposite( "ulx silent request_ntf", { _, true }, "!sntf" )
	requestntf:defaultAccess( ULib.ACCESS_SUPERADMIN )
	requestntf:help( "Spawns support units" )

	function ulx.destroygatea( ply, silent )
		explodeGateA()
		if silent then
			ulx.fancyLogAdmin( ply, true, "#A triggered Gate A destroy" )
		else
			ulx.fancyLogAdmin( ply, "#A triggered Gate A destroy" )
		end
	end

	local destroygatea = ulx.command( "Breach Admin", "ulx destroy_gate_a", ulx.destroygatea, "!destroygatea" )
	destroygatea:addParam{ type = ULib.cmds.BoolArg, invisible = true }
	destroygatea:setOpposite( "ulx silent destroy_gate_a", { _, true }, "!sdestroygatea" )
	destroygatea:defaultAccess( ULib.ACCESS_ADMIN )
	destroygatea:help( "Destroys Gate A" )

	function ulx.restartround( ply, silent )
		RoundRestart()
		if silent then
			ulx.fancyLogAdmin( ply, true, "#A restarted round" )
		else
			ulx.fancyLogAdmin( ply, "#A restarted round" )
		end
	end

	local restartround = ulx.command( "Breach Admin", "ulx restart_round", ulx.restartround, "!restart" )
	restartround:addParam{ type = ULib.cmds.BoolArg, invisible = true }
	restartround:setOpposite( "ulx silent restart_round", { _, true }, "!srestart" )
	restartround:defaultAccess( ULib.ACCESS_SUPERADMIN )
	restartround:help( "Restarts round" )
end

function SetupForceSCP()
	if !ulx or !ULib then 
		print( "ULX or ULib not found" )
		return
	end
	
	function ulx.forcescp( plyc, plyt, scp, silent )
		if !scp then return end
		if !plyt:GetNActive() then
			ULib.tsayError( plyc, "Player "..plyt:GetName().." is inactive! Forced spawn failed", true )
			return
		end
		--for k, v in pairs( SPCS ) do
			--if v.name == scp then
				--v.func( plyt )
		local scp_obj = GetSCP( scp )
		if scp_obj then
			scp_obj:SetupPlayer( plyt )

			if silent then
				ulx.fancyLogAdmin( plyc, true, "#A force spawned #T as "..scp, plyt )
			else
				ulx.fancyLogAdmin( plyc, "#A force spawned #T as "..scp, plyt )
			end
				--break
			--end
		else
			ULib.tsayError( plyc, "Invalid SCP "..scp.."!", true )
		end
	end

	local forcescp = ulx.command( "Breach Admin", "ulx force_scp", ulx.forcescp, "!forcescp" )
	forcescp:addParam{ type = ULib.cmds.PlayerArg }
	forcescp:addParam{ type = ULib.cmds.StringArg, hint = "SCP name", completes = SCPS, ULib.cmds.takeRestOfLine }
	forcescp:addParam{ type = ULib.cmds.BoolArg, invisible = true }
	forcescp:setOpposite( "ulx silent force_scp", { _, _, _, true }, "!sforcescp" )
	forcescp:defaultAccess( ULib.ACCESS_SUPERADMIN )
	forcescp:help( "Sets player to specific SCP and spawns him" )
end

-- Inicjalizuj ULX po załadowaniu wszystkich modułów
InitializeBreachULX()
SetupForceSCP()


================================================
FILE: gamemodes/breach/gamemode/modules/sh_upgrader_config.lua
================================================
-- SCP UPGRADER - Shared Configuration
-- Advanced rarity system with weights and enhanced features

if not BR then BR = {} end
if not BR.Upgrader then BR.Upgrader = {} end

-- Enhanced 7-tier rarity system with weights
BR.Upgrader.Rarities = {
    {
        name = "Consumer Grade",
        color = Color(176, 195, 217), -- Light gray-blue
        weight = 100,
        glowIntensity = 0.2,
        soundEffect = "buttons/button15.wav",
        tier = 1
    },
    {
        name = "Industrial Grade", 
        color = Color(94, 152, 217), -- Light blue
        weight = 60,
        glowIntensity = 0.4,
        soundEffect = "buttons/button9.wav",
        tier = 2
    },
    {
        name = "Mil-Spec Grade",
        color = Color(75, 105, 255), -- Blue
        weight = 30,
        glowIntensity = 0.6,
        soundEffect = "buttons/button3.wav",
        tier = 3
    },
    {
        name = "Restricted",
        color = Color(136, 71, 255), -- Purple
        weight = 15,
        glowIntensity = 0.8,
        soundEffect = "ambient/levels/labs/electric_explosion1.wav",
        tier = 4
    },
    {
        name = "Classified", 
        color = Color(211, 44, 230), -- Pink-purple
        weight = 6,
        glowIntensity = 1.0,
        soundEffect = "ambient/energy/zap1.wav",
        tier = 5
    },
    {
        name = "Covert",
        color = Color(235, 75, 75), -- Red
        weight = 2,
        glowIntensity = 1.2,
        soundEffect = "ambient/alarms/klaxon1.wav",
        tier = 6
    },
    {
        name = "Extraordinary",
        color = Color(255, 215, 0), -- Gold
        weight = 1,
        glowIntensity = 1.5,
        soundEffect = "vo/npc/male01/fantastic01.wav",
        tier = 7
    }
}

-- Enhanced item pools with tier progression
BR.Upgrader.ItemPools = {
    ["Consumer Grade"] = {
        "item_medkit", "item_radio", "weapon_pocket_knife", "br_keycard", "weapon_crowbar"
    },
    ["Industrial Grade"] = {
        "item_nvg", "item_eyedrops", "item_cameraview", "item_snav_300", "item_cctv"
    },
    ["Mil-Spec Grade"] = {
        "item_ultramedkit", "cw_deagle", "weapon_zeus", "item_snav_ultimate"
    },
    ["Restricted"] = {
        "cw_mp5", "cw_ar15", "item_scp_420j"
    },
    ["Classified"] = {
        "cw_ak74", "cw_l115", "item_scp_714"
    },
    ["Covert"] = {
        "weapon_scp_500", "weapon_scp_1499", "weapon_scp_018"
    },
    ["Extraordinary"] = {
        "weapon_scp_500", "weapon_scp_1499", "item_scp_714" -- Premium duplicates with higher chance
    }
}

-- All upgradeable items (any item that has value)
BR.Upgrader.UpgradeableItems = {
    "item_medkit", "item_radio", "weapon_pocket_knife", "br_keycard", "weapon_crowbar",
    "item_nvg", "item_eyedrops", "item_cameraview", "item_snav_300", "item_ultramedkit",
    "cw_deagle", "weapon_zeus", "cw_mp5", "item_snav_ultimate", "item_cctv",
    "cw_ar15", "cw_ak74", "cw_l115",
    "weapon_scp_500", "weapon_scp_1499", "item_scp_714", "item_scp_420j", "weapon_scp_018"
}

-- UI Themes for different factions
BR.Upgrader.Themes = {
    ["MTF"] = {
        primary = Color(30, 144, 255),
        secondary = Color(0, 100, 200),
        accent = Color(100, 200, 255),
        background = Color(20, 30, 50, 240)
    },
    ["CI"] = {
        primary = Color(34, 139, 34),
        secondary = Color(0, 100, 0),
        accent = Color(144, 238, 144),
        background = Color(20, 40, 20, 240)
    },
    ["Class-D"] = {
        primary = Color(255, 140, 0),
        secondary = Color(200, 100, 0),
        accent = Color(255, 215, 0),
        background = Color(50, 30, 10, 240)
    },
    ["Default"] = {
        primary = Color(163, 53, 238),
        secondary = Color(100, 30, 180),
        accent = Color(255, 215, 0),
        background = Color(40, 40, 40, 240)
    }
}

-- Fail-safe system configuration
BR.Upgrader.FailSafe = {
    enabled = true,
    guaranteedTier = 3, -- Mil-Spec Grade
    rollsRequired = 10, -- After 10 rolls without tier 3+
    message = "Gwarancja! Otrzymujesz Mil-Spec lub lepszy!"
}

-- API Functions
function BR.Upgrader:GetCompatibleItems(ply)
    if not IsValid(ply) or not ply:IsPlayer() then return {} end
    
    local compatibleItems = {}
    
    for _, weapon in pairs(ply:GetWeapons()) do
        local weaponClass = weapon:GetClass()
        if table.HasValue(self.UpgradeableItems, weaponClass) then
            table.insert(compatibleItems, {
                class = weaponClass,
                name = weapon.PrintName or weaponClass,
                tier = self:GetItemTier(weaponClass)
            })
        end
    end
    
    return compatibleItems
end

function BR.Upgrader:GetItemTier(itemClass)
    for tierName, items in pairs(self.ItemPools) do
        if table.HasValue(items, itemClass) then
            for _, rarity in ipairs(self.Rarities) do
                if rarity.name == tierName then
                    return rarity.tier
                end
            end
        end
    end
    return 1 -- Default to Consumer Grade
end

function BR.Upgrader:Roll(playerFailSafeCount)
    playerFailSafeCount = playerFailSafeCount or 0
    
    -- Check fail-safe
    if self.FailSafe.enabled and playerFailSafeCount >= self.FailSafe.rollsRequired then
        -- Force at least Mil-Spec Grade
        local availableRarities = {}
        for _, rarity in ipairs(self.Rarities) do
            if rarity.tier >= self.FailSafe.guaranteedTier then
                table.insert(availableRarities, rarity)
            end
        end
        
        local selectedRarity = table.Random(availableRarities)
        local pool = self.ItemPools[selectedRarity.name]
        local item = table.Random(pool)
        
        return item, selectedRarity, true -- true = was fail-safe
    end
    
    -- Normal weighted roll
    local totalWeight = 0
    for _, rarity in ipairs(self.Rarities) do
        totalWeight = totalWeight + rarity.weight
    end
    
    local rand = math.random(1, totalWeight)
    local cumulative = 0
    
    for _, rarity in ipairs(self.Rarities) do
        cumulative = cumulative + rarity.weight
        if rand <= cumulative then
            local pool = self.ItemPools[rarity.name]
            local item = table.Random(pool)
            return item, rarity, false -- false = normal roll
        end
    end
    
    -- Fallback to Consumer Grade
    local pool = self.ItemPools["Consumer Grade"]
    return table.Random(pool), self.Rarities[1], false
end

function BR.Upgrader:GetPlayerTheme(ply)
    if not IsValid(ply) then return self.Themes["Default"] end
    
    local team = ply:GTeam()
    if team == TEAM_GUARD then
        return self.Themes["MTF"]
    elseif team == TEAM_CHAOS then
        return self.Themes["CI"]
    elseif team == TEAM_CLASSD then
        return self.Themes["Class-D"]
    else
        return self.Themes["Default"]
    end
end

-- Pre-calculate item tier map for performance
function BR.Upgrader:InitializeTierMap()
    self.ItemTierMap = self.ItemTierMap or {}
    
    for tierName, items in pairs(self.ItemPools) do
        local tier = 1
        for _, rarity in ipairs(self.Rarities) do
            if rarity.name == tierName then
                tier = rarity.tier
                break
            end
        end
        
        for _, itemClass in ipairs(items) do
            self.ItemTierMap[itemClass] = tier
        end
    end
    
    -- Override the GetItemTier function with a faster one
    self.GetItemTier = function(self, itemClass)
        return self.ItemTierMap[itemClass] or 1
    end
    
    print("[SCP-UPGRADER] Item Tier Map initialized for fast lookups.")
end

-- Initialize the map on load
BR.Upgrader:InitializeTierMap()

-- Hooks for addons
hook.Add("UpgraderPreRoll", "BR_Upgrader_PreRoll", function(ply, itemClass)
    -- Other addons can modify roll chances here
end)

hook.Add("UpgraderPostRoll", "BR_Upgrader_PostRoll", function(ply, itemClass, rewardItem, rarity, wasFailSafe)
    -- Other addons can react to rolls here
    if wasFailSafe then
        ply:PrintMessage(HUD_PRINTTALK, BR.Upgrader.FailSafe.message)
    end
end) 


================================================
FILE: gamemodes/breach/gamemode/modules/sh_utils.lua
================================================
surface = surface or  {}
math = math or {}

local vec = FindMetaTable( "Vector" )
function vec:Copy()
	return Vector( self.x, self.y, self.z )
end

function math.TimedSinWave( freq, min, max )
	min = ( min + max ) / 2
	local wave = math.SinWave( RealTime(), freq, min - max, min )
	return wave
end

--based on wikipedia: f(x) = sin( angular frequency(in Hz) * x ) * amplitude + offset
function math.SinWave( x, freq, amp, offset )
	local wave = math.sin( 2 * math.pi * freq * x ) * amp + offset
	return wave
end

function surface.DrawRing( x, y, radius, thick, angle, segments, fill, rotation )
	angle = math.Clamp( angle or 360, 1, 360 )
	fill = math.Clamp( fill or 1, 0, 1 )
	rotation = rotation or 0

	local segmentstodraw = {}
	local segang = angle / segments
	local bigradius = radius + thick

	for i = 1, math.Round( segments * fill ) do
		local ang1 = math.rad( rotation + ( i - 1 ) * segang )
		local ang2 = math.rad( rotation + i * segang )

		local sin1 = math.sin( ang1 )
		local cos1 = -math.cos( ang1 )

		local sin2 = math.sin( ang2 )
		local cos2 = -math.cos( ang2 )

		surface.DrawPoly( {
			{ x = x + sin1 * radius, y = y + cos1 * radius },
			{ x = x + sin1 * bigradius, y = y + cos1 * bigradius },
			{ x = x + sin2 * bigradius, y = y + cos2 * bigradius },
			{ x = x + sin2 * radius, y = y + cos2 * radius }
		} )

	end
end

function AddTables( tab1, tab2 )
	for k, v in pairs( tab2 ) do
		if tab1[k] and istable( v ) then
			AddTables( tab1[k], v )
		else
			tab1[k] = v
		end
	end
end

INI_LOADER_VERSION = "GMOD 1.0"

local function WriteSections( f, tab )
	local d = file.Open( f, "w", "DATA" )
	if !d then 
		error( "Failed to open "..f )
	end

	d:Write( "# INI library by danx91 version: "..INI_LOADER_VERSION )

	for k, v in pairs( tab ) do
		d:Write( "\n\n"..string.format( "[%s]", k ) )
		for _k, _v in pairs( v ) do
			d:Write( "\n"..string.format( "%s = %s", _k, _v ) )
		end
	end

	d:Close()
end

local function CreateSections( tab, name, prefix, sections, char )
	local n = prefix..char..name
	sections[n] = {}
	for k, v in pairs( tab ) do
		if type( v ) == "table" then
			CreateSections( v, k, n, sections, char )
		elseif type( v ) != "function" and type( v ) != "userdata" then
			sections[n][k] = v
		end
	end
end

local function ParseFile( path )
	f = file.Open( path, "r", "DATA" )
	if !f then
		error( "Failed to open "..path )
	end

	local tab = {}
	local activetab

	local line_i = 0

	local line = f:ReadLine()
	while line do
		line_i = line_i + 1
		if !string.match( line, "^%s*#" ) and !string.match( line, "^%s+$" ) then
			local section = string.match( line, "%s*%[(%S+)%]" )
			if section then
				tab[section] = {}
				activetab = section
			end

			local key, value = string.match( line, "%s*(.+)%s+=%s*(.*%S+)%s*" )
			if key and value then
				if value == "true" then
					value = true
				elseif value == "false" then
					value = false
				elseif tonumber( value ) then
					value = tonumber( value )
				end
				tab[activetab][key] = value
			end

			if !section and !key and !value then
				error( "Unexpected char at line "..line_i )
			end
		end
		line = f:ReadLine()
	end

	f:Close()

	return tab
end

function util.LoadINI( f, target )
	local data = ParseFile( f )
	if !data._ini or !data._GLOBAL then return end

	local char = data._ini.char
	local version = data._ini.version
	if !char then return end

	if !version or version != INI_LOADER_VERSION then
		print( version, INI_LOADER_VERSION )
		MsgC( Color( 255, 50, 50 ), "Version of file and parser is different!", "\tFile: "..f, "\tVersion of parser: "..INI_LOADER_VERSION, "\tVersion of file: "..(version or "Undefined").."\n" )
	end

	local result = target or {}
	for k, v in pairs( data._GLOBAL ) do
		result[k] = v
	end

	for k, v in pairs( data ) do
		if k != "_ini" and k != "_GLOBAL" then
			local stack = {}

			for s in string.gmatch( k, "[^%"..char.."]+" ) do
				table.insert( stack, s )
			end

			local parent
			for i = 1, #stack do
				if !parent then
					result[stack[i]] = result[stack[i]] or {}
					parent = result[stack[i]]
				else
					parent[stack[i]] = parent[stack[i]] or {}
					parent = parent[stack[i]]
				end
				if i == #stack then
					for _k, _v in pairs( v ) do
						parent[_k] = _v
					end
				end
			end
		end
	end

	return result
end

function util.WriteINI( f, data, ignoretables, customchar )
	--PrintTable( data )
	customchar = customchar or "."
	local sections = {
		_GLOBAL = {},
		_ini = {
			char = customchar,
			version = INI_LOADER_VERSION
		}
	}
	for k, v in pairs( data ) do
		if type( v ) != "table" then
			sections._GLOBAL[k] = v
		else
			sections[k] = {}
			for _k, _v in pairs( v ) do
				if type( _v ) != "table" and type( _v ) != "function" and type( _v ) != "userdata" then
					sections[k][_k] = _v
				elseif type( _v ) == "table" and !ignoretables then
					CreateSections( _v, _k, k, sections, customchar )
				end
			end
		end
	end
	--PrintTable( sections )
	WriteSections( f, sections )
end

--Better timers
_TimersCache = {}

Timer = {}
Timer.__index = Timer

Timer.name = ""
Timer.repeats = 0
Timer.current = 0
Timer.time = 0
Timer.ncall = 0
Timer.alive = false
Timer.destroyed = false

function Timer:Create( name, time, repeats, callback, endcallback, noactivete, nocache )
	if !name or !time or !repeats or !callback then return end
	local t = setmetatable( {}, Timer )
	t.name = name
	t.time = time
	t.repeats = repeats
	t.callback = callback
	t.endcallback = endcallback

	t.Create = function() end

	if !nocache then
		_TimersCache[name] = t
	end

	if !noactivate then
		t:Start()
	end

	return t
end

function Timer:GetName()
	if self.destroyed then return end
	return self.name
end

function Timer:Stop()
	if self.destroyed then return end
	self.alive = false
end

function Timer:Start()
	if self.destroyed then return end
	self.alive = true
	self.ncall = CurTime() + self.time
end

function Timer:Reset()
	if self.destroyed then return end
	self.current = 0
end

function Timer:Change( time, repeats )
	if self.destroyed then return end
	if time then
		self.time = time
	end
	if repeats then
		self.repeats = repeats
	end
end

function Timer:StopReset()
	if self.destroyed then return end
	self:Stop()
	self:Reset()
end

function Timer:Destroy()
	if self.destroyed then return end
	self.destroyed = true
	_TimersCache[self.name] = nil
	self:Stop()
end

function Timer:Tick()
	if self.destroyed then return end

	self.ncall = self.ncall + self.time

	self.current = self.current + 1
	self.callback( self, self.current )

	if self.repeats > 0 then
		if self.current >= self.repeats then
			self:Destroy()
			if self.endcallback then
				self.endcallback()
			end
		end
	end
end

setmetatable( Timer, { __call = Timer.Create } )

function GetTimer( name )
	return _TimersCache[name]
end

hook.Add( "Tick", "TimersTick", function()
	for k, v in pairs( _TimersCache ) do
		if v.ncall <= CurTime() then
			v:Tick()
		end
	end
end )


================================================
FILE: gamemodes/breach/gamemode/modules/sh_weapons.lua
================================================
local CW_WEP_DMG = {
	cw_fiveseven = 20,
	cw_deagle = 35,
	cw_mp5 = 13,
	cw_ump45 = 16,
	cw_g36c = 20,
	cw_scarh = 22.5,
	cw_m14 = 25,
	cw_ar15 = 10,
	cw_ak74 = 14,
	cw_l115 = 90,
	cw_shorty = 6,
	cw_m3super90 = 4,
}

local handlers = {}

function registerDMGHandler( handler )
	table.insert( handlers, handler )
end

function applyDMGMods()
	for i, v in ipairs( handlers ) do
		v()
	end
end

registerDMGHandler( function()
	for k, v in pairs( CW_WEP_DMG ) do
		local wep_tab = weapons.GetStored( k )
		wep_tab.Damage = v
	end
end )

timer.Simple( 0, function()
	applyDMGMods()
end )


================================================
FILE: gamemodes/breach/gamemode/modules/sv_base_scps — kopia.lua.bac
================================================
--[[-------------------------------------------------------------------------

								READ CAREFULLY!

Now to add SCP you have to call RegisterSCP() inside 'RegisterSCP' hook
Therefore if you only want to add SCPs, you don't have to reupload gamemode! Use hook instead and
place files in 'lua/autorun/server/'!


Basic infotmations about RegisterSCP():
	

	RegisterSCP( name, model, weapon, static_stats, dynamic_stats, callback, post_callback )


		name (String) - name of SCP, it will be used by most things. This function will automatically add
			every necessary variablesso you no longer have to care about ROLES table(function will
			create ROLES.ROLE_name = name). Funtion will look for valid language and spawnpos entries
			(for language: english.ROLES.ROLE_name and english.starttexts.ROLE_name, for
			spawnpos: SPAWN_name = Vector or Table of vectors). Function will throw error if something
			is wrong(See errors section below)


		model (String) - full path to model. If you put wrong path you will see error instead of model!


		weapon (String) - SWEP call name. If you put wrong name your scp will not receive weapon and you
			will see red error in console


		static_stats (Table) - this table contain important entries for your SCP. Things specified inside
			this table are more important than dynamic_stats, so it will overwrite them. These stats cannot
			be changed in 'scp.txt' file. This table cotains keys and values(key = "value"). List of valid keys is below.


		dynamic_stats (Table) - this table contains entries for your SCP that can be accessed and changed in
			'garrysmod/data/breach/scp.txt' file. So everybody can customize them. These stats will be overwritten
			by statc_stats. This table cotains keys and values(key = "value") or tables that contains value and
			clamping info(num values only!)(key = "value" or key = { var = num_value, max = max_value, min = minimum_value }).
			List of valid keys is below. 

					Valid entreis for static_stats and dynamic_stats:
							base_speed - walk speed
							run_speed - run speed
							max_speed - maximum speed
							base_health - starting health
							max_health - maximum health
							jump_power - jump power
							crouch_speed - crouched walk speed
							no_ragdoll - if true, rgdoll will not appear
							model_scale - scale of model
							hands_model - model of hands
							prep_freeze - if true, SCP will not be able to move during preparing
							no_spawn - position will not be changed
							no_model - model will not be changed
							no_swep - SCP won't have SWEP
							no_strip - player EQ won't be stripped
							no_select - SCP won't appear in game


		callback (Function) - called on beginning of SetupPlayer return true to override default actions(post callback will not be called).
			function( ply, basestats, ... ) - 3 arguments are passed:
				ply - player
				basestats - result of static_stats and dynamic_stats
				... - (varargs) passsed from SetupPlayer
		

		post_callback (Function) - called on end of SetupPlayer. Only player is passed as argument:
			function( ply )
				ply - player


To get registered SCP:
		GetSCP( name ) - global function that returns SCP object
			arguments:
				name - name of SCP(same as used in RegisterSCP)

			return:
				ObjectSCP - (explained below)

	ObjectSCP:
		functions:
			ObjectSCP:SetCallback( callback, post ) - used internally by RegisterSCP. Sets callback, if post == true, sets post_callback

			ObjectSCP:SetupPlayer( ply, ... ) - use to set specified player as SCP.
					ply - player who become SCP
					... - varargs passed to callback if ObjectSCP has one

---------------------------------------------------------------------------]]

hook.Add( "RegisterSCP", "RegisterBaseSCPs", function()
	/*RegisterSCP( "SCPSantaJ", "models/player/christmas/santa.mdl", "weapon_scp_santaJ", {
		jump_power = 200,
		prep_freeze = true,
		no_ragdoll = true,
	}, {
		base_health = 2500,
		max_health = 2500,
		base_speed = 160,
		run_speed = 160,
		max_speed = 160,
	} )*/

	RegisterSCP( "SCP023", "models/Novux/023/Novux_SCP-023.mdl", "weapon_scp_023", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 2000,
		max_health = 2000,
		base_speed = 150,
		run_speed = 250,
		max_speed = 250,
	} )

	RegisterSCP( "SCP049", "models/vinrax/player/scp049_player.mdl", "weapon_scp_049", {
		jump_power = 200,
	}, {
		base_health = 1600,
		max_health = 1600,
		base_speed = 135,
		run_speed = 135,
		max_speed = 135,
	} )

	RegisterSCP( "SCP0492", "models/player/zombie_classic.mdl", "weapon_br_zombie", {
		jump_power = 200,
		no_spawn = true,
		no_select = true,
	}, {
		base_health = 750,
		max_health = 750,
		base_speed = 160,
		run_speed = 160,
		max_speed = 160,
	}, nil, function( ply )
		WinCheck()
	end )

	RegisterSCP( "SCP066", "models/player/mrsilver/scp_066pm/scp_066_pm.mdl", "weapon_scp_066", {
		jump_power = 200,
		no_ragdoll = true,
		prep_freeze = true,
	}, {
		base_health = 2250,
		max_health = 2250,
		base_speed = 160,
		run_speed = 160,
		max_speed = 160,
	} )

	RegisterSCP( "SCP076", "models/abel/abel.mdl", "weapon_scp_076", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 300,
		max_health = 300,
		base_speed = 220,
		run_speed = 220,
		max_speed = 220,
	}, nil, function( ply )
		SetupSCP0761( ply )
	end )

	RegisterSCP( "SCP082", "models/models/konnie/savini/savini.mdl", "weapon_scp_082", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 2300,
		max_health = 2800,
		base_speed = 160,
		run_speed = 160,
		max_speed = 160,
	}, nil, function( ply )
		ply:SetBodygroup( ply:FindBodygroupByName( "Mask" ), 1 )
	end )

	RegisterSCP( "SCP096", "models/scp096anim/player/scp096pm_raf.mdl", "weapon_scp_096", {
		jump_power = 200,
	}, {
		base_health = 1750,
		max_health = 1750,
		base_speed = 120,
		run_speed = 500,
		max_speed = 500,
	} )

	RegisterSCP( "SCP106", "models/scp/106/unity/unity_scp_106_player.mdl", "weapon_scp_106", {
		jump_power = 200,
	}, {
		base_health = 2000,
		max_health = 2000,
		base_speed = 170,
		run_speed = 170,
		max_speed = 170,
	} )

	RegisterSCP( "SCP173", "models/jqueary/scp/unity/scp173/scp173unity.mdl", "weapon_scp_173", {
		jump_power = 200,
		no_ragdoll = true,
	}, {
		base_health = 3000,
		max_health = 3000,
		base_speed = 400,
		run_speed = 400,
		max_speed = 400,
	} )

	RegisterSCP( "SCP457", "models/player/corpse1.mdl", "weapon_scp_457", {
		jump_power = 200,
		//no_draw = true,
		no_select = true, -- Wyłączone na razie
	}, {
		base_health = 2300,
		max_health = 2300,
		base_speed = 135,
		run_speed = 135,
		max_speed = 135,
	} )

	RegisterSCP( "SCP682", "models/danx91/scp/scp_682.mdl", "weapon_scp_682", {
		jump_power = 200,
		no_ragdoll = true,
	}, {
		base_health = 2000,
		max_health = 2000,
		base_speed = 120,
		run_speed = 275,
		max_speed = 275,
	} )

	RegisterSCP( "SCP689", "models/dwdarksouls/models/darkwraith.mdl", "weapon_scp_689", {
		jump_power = 200,
	}, {
		base_health = 1750,
		max_health = 1750,
		base_speed = 100,
		run_speed = 100,
		max_speed = 100,
	} )

	RegisterSCP( "SCP8602", "models/props/forest_monster/forest_monster2.mdl", "weapon_scp_8602", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 2250,
		max_health = 2250,
		base_speed = 190,
		run_speed = 190,
		max_speed = 190,
	} )

	RegisterSCP( "SCP939", "models/scp/939/unity/unity_scp_939.mdl", "weapon_scp_939", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 2000,
		max_health = 2000,
		base_speed = 190,
		run_speed = 190,
		max_speed = 190,
	} )

	RegisterSCP( "SCP957", "models/immigrant/outlast/walrider_pm.mdl", "weapon_scp_957", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 1500,
		max_health = 1500,
		base_speed = 175,
		run_speed = 175,
		max_speed = 175,
	} )

	RegisterSCP( "SCP9571", "", "", {
		no_spawn = true,
		no_select = true,
	}, {
		base_health = 500,
		max_health = 500,
	}, function( ply, basestats )
		if !ply.SetLastRole or !ply.SetLastTeam then
			player_manager.RunClass( ply, "SetupDataTables" )
		end

		ply:SetHealth( basestats.base_health or 500 )
		ply:SetMaxHealth( basestats.max_health or 500 )

		ply:SetLastRole( ply:GetNClass() )
		ply:SetLastTeam( ply:GTeam() )
		ply:SetGTeam( TEAM_SCP )
		ply:SetNClass( ROLES.ROLE_SCP9571 )
		ply.canblink = false

		net.Start( "RolesSelected" )
		net.Send( ply )

		return true
	end )

	RegisterSCP( "SCP966", "models/player/mishka/966_new.mdl", "weapon_scp_966", {
		jump_power = 200,
	}, {
		base_health = 800,
		max_health = 800,
		base_speed = 140,
		run_speed = 140,
		max_speed = 140,
	} )

	RegisterSCP( "SCP999", "models/scp/999/jq/scp_999_pmjq.mdl", "weapon_scp_999", {
		jump_power = 200,
	}, {
		base_health = 1000,
		max_health = 1000,
		base_speed = 150,
		run_speed = 150,
		max_speed = 150,
	} )

	RegisterSCP( "SCP1048A", "models/1048/tdyear/tdybrownearpm.mdl", "weapon_scp_1048A", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 1500,
		max_health = 1500,
		base_speed = 135,
		run_speed = 135,
		max_speed = 135,
	} )

	RegisterSCP( "SCP1048B", "models/player/teddy_bear/teddy_bear.mdl", "weapon_scp_1048B", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 2000,
		max_health = 2000,
		base_speed = 165,
		run_speed = 165,
		max_speed = 165,
	} )

	RegisterSCP( "SCP1471", "models/burd/scp1471/scp1471.mdl", "weapon_scp_1471", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 3000,
		max_health = 3000,
		base_speed = 160,
		run_speed = 325,
		max_speed = 160,
	} )

	RegisterSCP( "SCP069", "models/player/kerry/class_d_1.mdl", "weapon_scp_069", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 1800,
		max_health = 1800,
		base_speed = 160,
		run_speed = 200,
		max_speed = 200,
	} )

	RegisterSCP( "SCPDOOMGUYJ", "models/player/doom_fn_pm.mdl", "weapon_scp_doomguyj", {
		jump_power = 300,
		prep_freeze = true,
		no_ragdoll = true,
	}, {
		base_health = 1500,
		max_health = 1500,
		base_speed = 220,
		run_speed = 220,
		max_speed = 220,
	} )

	RegisterSCP( "SCP3199", "models/washton/3199.mdl", "weapon_scp_3199", {
		jump_power = 250,
		prep_freeze = true,
		no_ragdoll = true,
	}, {
		base_health = 1200,
		max_health = 1200,
		base_speed = 180,
		run_speed = 200,
		max_speed = 220,
	} )
end )

function SetupSCP0761( ply )
	local cspawn076 = table.Random( SPAWN_SCP076 )
	if !cspawn076 then
		ErrorNoHalt("No spawn point for SCP-076 found!\n")
		return
	end

	if !IsValid( SCP0761 ) then
		SCP0761 = ents.Create( "item_scp_0761" )
		if IsValid(SCP0761) then
			SCP0761:Spawn()
			SCP0761:SetPos( cspawn076 )
		else
			ErrorNoHalt("Could not create 'item_scp_0761' entity!\n")
		end
	end
	ply:SetPos( cspawn076 )
end

RegisterSCP( "SCP054", "models/xiali/scp_054/ctg/scp_054.mdl", "weapon_scp_054", {
	jump_power = 250,
	prep_freeze = true,
	no_ragdoll = true,
}, {
	base_health = 2500,
	max_health = 2500,
	base_speed = 150,
	run_speed = 180,
	max_speed = 200,
} )


================================================
FILE: gamemodes/breach/gamemode/modules/sv_base_scps.lua
================================================
--[[-------------------------------------------------------------------------

								READ CAREFULLY!

Now to add SCP you have to call RegisterSCP() inside 'RegisterSCP' hook
Therefore if you only want to add SCPs, you don't have to reupload gamemode! Use hook instead and
place files in 'lua/autorun/server/'!


Basic infotmations about RegisterSCP():
	

	RegisterSCP( name, model, weapon, static_stats, dynamic_stats, callback, post_callback )


		name (String) - name of SCP, it will be used by most things. This function will automatically add
			every necessary variablesso you no longer have to care about ROLES table(function will
			create ROLES.ROLE_name = name). Funtion will look for valid language and spawnpos entries
			(for language: english.ROLES.ROLE_name and english.starttexts.ROLE_name, for
			spawnpos: SPAWN_name = Vector or Table of vectors). Function will throw error if something
			is wrong(See errors section below)


		model (String) - full path to model. If you put wrong path you will see error instead of model!


		weapon (String) - SWEP call name. If you put wrong name your scp will not receive weapon and you
			will see red error in console


		static_stats (Table) - this table contain important entries for your SCP. Things specified inside
			this table are more important than dynamic_stats, so it will overwrite them. These stats cannot
			be changed in 'scp.txt' file. This table cotains keys and values(key = "value"). List of valid keys is below.


		dynamic_stats (Table) - this table contains entries for your SCP that can be accessed and changed in
			'garrysmod/data/breach/scp.txt' file. So everybody can customize them. These stats will be overwritten
			by statc_stats. This table cotains keys and values(key = "value") or tables that contains value and
			clamping info(num values only!)(key = "value" or key = { var = num_value, max = max_value, min = minimum_value }).
			List of valid keys is below. 

					Valid entreis for static_stats and dynamic_stats:
							base_speed - walk speed
							run_speed - run speed
							max_speed - maximum speed
							base_health - starting health
							max_health - maximum health
							jump_power - jump power
							crouch_speed - crouched walk speed
							no_ragdoll - if true, rgdoll will not appear
							model_scale - scale of model
							hands_model - model of hands
							prep_freeze - if true, SCP will not be able to move during preparing
							no_spawn - position will not be changed
							no_model - model will not be changed
							no_swep - SCP won't have SWEP
							no_strip - player EQ won't be stripped
							no_select - SCP won't appear in game


		callback (Function) - called on beginning of SetupPlayer return true to override default actions(post callback will not be called).
			function( ply, basestats, ... ) - 3 arguments are passed:
				ply - player
				basestats - result of static_stats and dynamic_stats
				... - (varargs) passsed from SetupPlayer
		

		post_callback (Function) - called on end of SetupPlayer. Only player is passed as argument:
			function( ply )
				ply - player


To get registered SCP:
		GetSCP( name ) - global function that returns SCP object
			arguments:
				name - name of SCP(same as used in RegisterSCP)

			return:
				ObjectSCP - (explained below)

	ObjectSCP:
		functions:
			ObjectSCP:SetCallback( callback, post ) - used internally by RegisterSCP. Sets callback, if post == true, sets post_callback

			ObjectSCP:SetupPlayer( ply, ... ) - use to set specified player as SCP.
					ply - player who become SCP
					... - varargs passed to callback if ObjectSCP has one

---------------------------------------------------------------------------]]

hook.Add( "RegisterSCP", "RegisterBaseSCPs", function()
	/*RegisterSCP( "SCPSantaJ", "models/player/christmas/santa.mdl", "weapon_scp_santaJ", {
		jump_power = 200,
		prep_freeze = true,
		no_ragdoll = true,
	}, {
		base_health = 2500,
		max_health = 2500,
		base_speed = 160,
		run_speed = 160,
		max_speed = 160,
	} )*/

	RegisterSCP( "SCP023", "models/Novux/023/Novux_SCP-023.mdl", "weapon_scp_023", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 2000,
		max_health = 2000,
		base_speed = 150,
		run_speed = 250,
		max_speed = 250,
	} )

	RegisterSCP( "SCP049", "models/vinrax/player/scp049_player.mdl", "weapon_scp_049", {
		jump_power = 200,
	}, {
		base_health = 1600,
		max_health = 1600,
		base_speed = 135,
		run_speed = 135,
		max_speed = 135,
	} )

	RegisterSCP( "SCP0492", "models/player/zombie_classic.mdl", "weapon_br_zombie", {
		jump_power = 200,
		no_spawn = true,
		no_select = true,
	}, {
		base_health = 750,
		max_health = 750,
		base_speed = 160,
		run_speed = 160,
		max_speed = 160,
	}, nil, function( ply )
		WinCheck()
	end )

	RegisterSCP( "SCP066", "models/player/mrsilver/scp_066pm/scp_066_pm.mdl", "weapon_scp_066", {
		jump_power = 200,
		no_ragdoll = true,
		prep_freeze = true,
	}, {
		base_health = 2250,
		max_health = 2250,
		base_speed = 160,
		run_speed = 160,
		max_speed = 160,
	} )

	RegisterSCP( "SCP076", "models/abel/abel.mdl", "weapon_scp_076", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 300,
		max_health = 300,
		base_speed = 220,
		run_speed = 220,
		max_speed = 220,
	}, nil, function( ply )
		SetupSCP0761( ply )
	end )

	RegisterSCP( "SCP082", "models/models/konnie/savini/savini.mdl", "weapon_scp_082", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 2300,
		max_health = 2800,
		base_speed = 160,
		run_speed = 160,
		max_speed = 160,
	}, nil, function( ply )
		ply:SetBodygroup( ply:FindBodygroupByName( "Mask" ), 1 )
	end )

	RegisterSCP( "SCP096", "models/scp096anim/player/scp096pm_raf.mdl", "weapon_scp_096", {
		jump_power = 200,
	}, {
		base_health = 1750,
		max_health = 1750,
		base_speed = 120,
		run_speed = 500,
		max_speed = 500,
	} )

	RegisterSCP( "SCP106", "models/scp/106/unity/unity_scp_106_player.mdl", "weapon_scp_106", {
		jump_power = 200,
	}, {
		base_health = 2000,
		max_health = 2000,
		base_speed = 170,
		run_speed = 170,
		max_speed = 170,
	} )

	RegisterSCP( "SCP173", "models/jqueary/scp/unity/scp173/scp173unity.mdl", "weapon_scp_173", {
		jump_power = 200,
		no_ragdoll = true,
	}, {
		base_health = 3000,
		max_health = 3000,
		base_speed = 400,
		run_speed = 400,
		max_speed = 400,
	} )

	RegisterSCP( "SCP457", "models/player/corpse1.mdl", "weapon_scp_457", {
		jump_power = 200,
		//no_draw = true,
		no_select = true, -- Wyłączone na razie
	}, {
		base_health = 2300,
		max_health = 2300,
		base_speed = 135,
		run_speed = 135,
		max_speed = 135,
	} )

	RegisterSCP( "SCP682", "models/danx91/scp/scp_682.mdl", "weapon_scp_682", {
		jump_power = 200,
		no_ragdoll = true,
	}, {
		base_health = 2000,
		max_health = 2000,
		base_speed = 120,
		run_speed = 275,
		max_speed = 275,
	} )

	RegisterSCP( "SCP689", "models/dwdarksouls/models/darkwraith.mdl", "weapon_scp_689", {
		jump_power = 200,
	}, {
		base_health = 1750,
		max_health = 1750,
		base_speed = 100,
		run_speed = 100,
		max_speed = 100,
	} )

	RegisterSCP( "SCP8602", "models/props/forest_monster/forest_monster2.mdl", "weapon_scp_8602", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 2250,
		max_health = 2250,
		base_speed = 190,
		run_speed = 190,
		max_speed = 190,
	} )

	RegisterSCP( "SCP939", "models/scp/939/unity/unity_scp_939.mdl", "weapon_scp_939", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 2000,
		max_health = 2000,
		base_speed = 190,
		run_speed = 190,
		max_speed = 190,
	} )

	RegisterSCP( "SCP957", "models/immigrant/outlast/walrider_pm.mdl", "weapon_scp_957", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 1500,
		max_health = 1500,
		base_speed = 175,
		run_speed = 175,
		max_speed = 175,
	} )

	RegisterSCP( "SCP9571", "", "", {
		no_spawn = true,
		no_select = true,
	}, {
		base_health = 500,
		max_health = 500,
	}, function( ply, basestats )
		if !ply.SetLastRole or !ply.SetLastTeam then
			player_manager.RunClass( ply, "SetupDataTables" )
		end

		ply:SetHealth( basestats.base_health or 500 )
		ply:SetMaxHealth( basestats.max_health or 500 )

		ply:SetLastRole( ply:GetNClass() )
		ply:SetLastTeam( ply:GTeam() )
		ply:SetGTeam( TEAM_SCP )
		ply:SetNClass( ROLES.ROLE_SCP9571 )
		ply.canblink = false

		net.Start( "RolesSelected" )
		net.Send( ply )

		return true
	end )

	RegisterSCP( "SCP966", "models/player/mishka/966_new.mdl", "weapon_scp_966", {
		jump_power = 200,
	}, {
		base_health = 800,
		max_health = 800,
		base_speed = 140,
		run_speed = 140,
		max_speed = 140,
	} )

	RegisterSCP( "SCP999", "models/scp/999/jq/scp_999_pmjq.mdl", "weapon_scp_999", {
		jump_power = 200,
	}, {
		base_health = 1000,
		max_health = 1000,
		base_speed = 150,
		run_speed = 150,
		max_speed = 150,
	} )

	RegisterSCP( "SCP1048A", "models/1048/tdyear/tdybrownearpm.mdl", "weapon_scp_1048A", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 1500,
		max_health = 1500,
		base_speed = 135,
		run_speed = 135,
		max_speed = 135,
	} )

	RegisterSCP( "SCP1048B", "models/player/teddy_bear/teddy_bear.mdl", "weapon_scp_1048B", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 2000,
		max_health = 2000,
		base_speed = 165,
		run_speed = 165,
		max_speed = 165,
	} )

	RegisterSCP( "SCP1471", "models/burd/scp1471/scp1471.mdl", "weapon_scp_1471", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 3000,
		max_health = 3000,
		base_speed = 160,
		run_speed = 325,
		max_speed = 160,
	} )

	RegisterSCP( "SCP069", "models/player/kerry/class_d_1.mdl", "weapon_scp_069", {
		jump_power = 200,
		prep_freeze = true,
	}, {
		base_health = 1800,
		max_health = 1800,
		base_speed = 160,
		run_speed = 200,
		max_speed = 200,
	} )
	

	RegisterSCP( "SCPDOOMGUYJ", "models/player/doom_fn_pm.mdl", "weapon_scp_doomguyj", {
		jump_power = 300,
		prep_freeze = true,
		no_ragdoll = true,
	}, {
		base_health = 1500,
		max_health = 1500,
		base_speed = 220,
		run_speed = 220,
		max_speed = 220,
	} )

	RegisterSCP( "SCP3199", "models/washton/3199.mdl", "weapon_scp_3199", {
		jump_power = 200,
		prep_freeze = true,
		no_ragdoll = true,
	}, {
		base_health = 3000,
		max_health = 3000,
		base_speed = 180,
		run_speed = 180,
		max_speed = 180,
	} )
	
	-- DODAJ TUTAJ SCP-054:
RegisterSCP( "SCP054", "models/xiali/scp_054/ctg/scp_054.mdl", "weapon_scp_054", {
	jump_power = 200,
	prep_freeze = true,
	no_ragdoll = true,
}, {
	base_health = 2500,
	max_health = 2500,
	base_speed = 150,
	run_speed = 150,
	max_speed = 150,
} )

-- SCP-2521:
RegisterSCP( "SCP2521", "models/cultist/scp/scp_no1.mdl", "weapon_scp_2521", {
	jump_power = 200,
	prep_freeze = false,
	no_ragdoll = true,
}, {
	base_health = 3000,
	max_health = 3000,
	base_speed = 100,
	run_speed = 100,
	max_speed = 100,
} )

-- SCP-239:
RegisterSCP( "SCP239", "models/cultist/scp/scp_239.mdl", "weapon_scp_239", {
	jump_power = 200,
	prep_freeze = true,
	no_ragdoll = true,
}, {
	base_health = 1000,
	max_health = 1000,
	base_speed = 120,
	run_speed = 120,
	max_speed = 120,
} )

-- SCP-3166:
RegisterSCP( "SCP3166", "models/nickelodeon_all_stars/garfield/garfield.mdl", "weapon_scp_3166", {
	jump_power = 200,
	prep_freeze = true,
	no_ragdoll = true,
}, {
	base_health = 1800,
	max_health = 1800,
	base_speed = 140,
	run_speed = 140,
	max_speed = 140,
} )

-- SCP-TTT-SAHUR:
RegisterSCP( "SCPTTT_SAHUR", "models/gacommissions/tungtungtungsahur.mdl", "weapon_scp_ttt_sahur", {
	jump_power = 200,
	prep_freeze = true,
	no_ragdoll = true,
}, {
	base_health = 5000,
	max_health = 5000,
	base_speed = 150,
	run_speed = 150,
	max_speed = 150,
} )

-- SCP-1316:
RegisterSCP( "SCP1316", "models/yevocore/cat/cat.mdl", "weapon_scp_1316", {
	jump_power = 200,
	prep_freeze = true,
	no_ragdoll = true,
}, {
	base_health = 1000,
	max_health = 1000,
	base_speed = 160,
	run_speed = 160,
	max_speed = 160,
} )

-- SCP-2137-J:
RegisterSCP( "SCP2137J", "models/t37/papaj.mdl", "weapon_scp_2137j", {
	jump_power = 200,
	prep_freeze = true,
	no_ragdoll = true,
}, {
	base_health = 1200,
	max_health = 1200,
	base_speed = 140,
	run_speed = 140,
	max_speed = 140,
} )

-- SCP-Steve-J:
RegisterSCP( "SCPSTEVEJ", "models/minecraft/steve/steve.mdl", "weapon_scp_steve_j", {
	jump_power = 200,
	prep_freeze = true,
	no_ragdoll = true,
}, {
	base_health = 1000,
	max_health = 1000,
	base_speed = 150,
	run_speed = 150,
	max_speed = 150,
} )

-- SCP-Impostor-J:
RegisterSCP( "SCPIMPOSTORJ", "models/lenoax/amongus/suit_pm.mdl", "weapon_scp_impostor_j", {
	jump_power = 200,
	prep_freeze = true,
	no_ragdoll = true,
}, {
	base_health = 1000,
	max_health = 1000,
	base_speed = 150,
	run_speed = 150,
	max_speed = 150,
} )

-- SCP-617:
RegisterSCP( "SCP617", "models/dawson/stoned_men/stone_man/stone_man.mdl", "weapon_scp_617", {
	jump_power = 200,
	prep_freeze = true,
	no_ragdoll = true,
}, {
	base_health = 20000,
	max_health = 20000,
	base_speed = 80,
	run_speed = 80,
	max_speed = 80,
} )

-- SCP-035 (The Possessive Mask):
RegisterSCP( "SCP035", "models/player/Group01/male_02.mdl", "", {
	jump_power = 200,
	no_strip = true,  -- KLUCZOWE: Zachowuje ekwipunek!
	no_spawn = true, -- Nie spawn automatycznie
	no_swep = true,  -- Nie daj SCP weapona
	no_model = true, -- Nie zmienia modelu
}, {
	base_health = 200,
	max_health = 200,
	base_speed = 125,
	run_speed = 250,
	max_speed = 250,
} )
end )

function SetupSCP0761( ply )
	local cspawn076 = table.Random( SPAWN_SCP076 )
	if !cspawn076 then
		ErrorNoHalt("No spawn point for SCP-076 found!\n")
		return
	end

	if !IsValid( SCP0761 ) then
		SCP0761 = ents.Create( "item_scp_0761" )
		if IsValid(SCP0761) then
			SCP0761:Spawn()
			SCP0761:SetPos( cspawn076 )
		else
			ErrorNoHalt("Could not create 'item_scp_0761' entity!\n")
		end
	end
	ply:SetPos( cspawn076 )
end


================================================
FILE: gamemodes/breach/gamemode/modules/sv_bodycam_audio.lua
================================================
if SERVER then
    util.AddNetworkString("Bodycam_Voice")
    util.AddNetworkString("Bodycam_Micro")
    util.AddNetworkString("Bodycam_SelectedTarget")

    net.Receive("Bodycam_Voice", function(_, ply)
        ply:SetNWBool("Bodycam_AllowVoice", net.ReadBool())
    end)

    net.Receive("Bodycam_Micro", function(_, ply)
        ply:SetNWBool("Bodycam_AllowMic", net.ReadBool())
    end)

    net.Receive("Bodycam_SelectedTarget", function(_, ply)
        ply:SetNWEntity("Bodycam_SelectedTarget", net.ReadEntity())
    end)

    hook.Add("PlayerCanHearPlayersVoice", "BodycamTabletAudio", function(listener, talker)
        if not (IsValid(listener) and IsValid(talker)) then return end
        if not (listener:IsPlayer() and talker:IsPlayer()) then return end
        if not (listener:Alive() and talker:Alive()) then return end
        if not (listener:GetNWBool("BodycamTabletOpen", false) and listener:GetNWBool("Bodycam_AllowVoice", true)) then return end

        local listenerWep = listener:GetActiveWeapon()
        if not (IsValid(listenerWep) and listenerWep:GetClass() == "weapon_bodycam_tablet") then return end

        local bodycampeople = listenerWep.BodyCamPeople
        if not istable(bodycampeople) then return end

        local trackedTarget = listener:GetNWEntity("Bodycam_SelectedTarget")
        if not (IsValid(trackedTarget) and table.HasValue(bodycampeople, trackedTarget)) then return end

            if talker == trackedTarget then
                return true
            end

            if talker ~= trackedTarget then
                local nearby = ents.FindInSphere(trackedTarget:GetPos(), 550)
                for _, ent in ipairs(nearby) do
                    if ent == talker and ent:IsPlayer() then
                        local trace = util.TraceLine({
                            start = trackedTarget:EyePos(),
                            endpos = ent:EyePos(),
                            filter = function(ent) return ent:IsWorld() end
                        })
                        if not trace.Hit or trace.Entity == ent then
                            return true
                        end
                    end
                end
            end

        return
    end)

    hook.Add("PlayerCanHearPlayersVoice", "BodycamTabletMicro", function(listener,talker)
        if not (IsValid(listener) and IsValid(talker)) then return end
        if not (listener:IsPlayer() and talker:IsPlayer()) then return end
        if not (listener:Alive() and talker:Alive()) then return end
        if not (talker:GetNWBool("Bodycam_AllowMic", false) and talker:GetNWBool("BodycamTabletOpen", false)) then return end
        if talker == listener then  return end

        local talkerWep = talker:GetActiveWeapon()
        if not (IsValid(talkerWep) and talkerWep:GetClass() == "weapon_bodycam_tablet") then return end

        local bodycampeople = talkerWep.BodyCamPeople
        if not istable(bodycampeople) then return end

        local trackedTarget = talker:GetNWEntity("Bodycam_SelectedTarget")
        if not (IsValid(trackedTarget) and table.HasValue(bodycampeople, trackedTarget) and trackedTarget == listener) then return end

        if IsValid(listener:GetNWEntity("BodyCam")) and listener:GetNWEntity("BodyCam") == talkerWep then
            return true
        end

        return
    end)
end 


================================================
FILE: gamemodes/breach/gamemode/modules/sv_credits_system.lua
================================================
-- ===============================================
-- SYSTEM KREDYTÓW ZA ZABÓJSTWA - SCP BREACH
-- ===============================================

-- Player metatable
local PlayerMeta = FindMetaTable("Player")

-- Network strings
util.AddNetworkString("UpdateCredits")
-- util.AddNetworkString("CreditsNotification") -- Wyłączone powiadomienia

-- Inicjalizacja kredytów dla gracza
local function InitPlayerCredits(ply)
    if not ply.Credits then
        ply.Credits = 0
    end
    if not ply.RoundKills then
        ply.RoundKills = 0
    end
    if not ply.TeamKills then
        ply.TeamKills = 0
    end
end

-- FUNKCJE ZARZĄDZANIA KREDYTAMI
function PlayerMeta:GetCredits()
    InitPlayerCredits(self)
    return self.Credits or 0
end

function PlayerMeta:SetCredits(amount)
    InitPlayerCredits(self)
    self.Credits = math.max(0, amount)
    
    -- Wyślij aktualizację do klienta
    net.Start("UpdateCredits")
        net.WriteInt(self.Credits, 32)
    net.Send(self)
end

function PlayerMeta:AddCredits(amount, reason)
    InitPlayerCredits(self)
    local oldCredits = self.Credits
    self.Credits = math.max(0, self.Credits + amount)
    
    -- Wyślij aktualizację do klienta
    net.Start("UpdateCredits")
        net.WriteInt(self.Credits, 32)
    net.Send(self)
    
    -- Powiadomienia o kredytach wyłączone
    
    return self.Credits
end

function PlayerMeta:CanAfford(amount)
    return self:GetCredits() >= amount
end

function PlayerMeta:SpendCredits(amount, reason)
    if not self:CanAfford(amount) then
        return false
    end
    
    self:AddCredits(-amount, reason or "Purchase")
    return true
end

-- TABELA NAGRÓD ZA ZABÓJSTWA (kredyty za różne drużyny)
local KILL_REWARDS = {
    [TEAM_SCP] = 15,     -- SCP = 15 kredytów (trudne do zabicia)
    [TEAM_GUARD] = 8,    -- MTF = 8 kredytów  
    [TEAM_CLASSD] = 5,   -- Klasa D = 5 kredytów
    [TEAM_SCI] = 6,      -- Naukowcy = 6 kredytów
    [TEAM_CHAOS] = 8,    -- Chaos = 8 kredytów
    [TEAM_GOC] = 12,     -- GOC = 12 kredytów (elita)
    [TEAM_SPEC] = 0      -- Spektatorzy = 0 kredytów
}

-- UWAGA: System kredytów za zabójstwa jest teraz zintegrowany bezpośrednio w GM:PlayerDeath w sv_player_hooks.lua
-- Oryginalny hook PlayerDeath został usunięty, ponieważ GM:PlayerDeath ma pierwszeństwo nad hookami

-- Reset kredytów na początku rundy - BEZ STARTOWYCH KREDYTÓW
hook.Add("BreachPreround", "CreditsSystem_Reset", function()
    for _, ply in pairs(player.GetAll()) do
        if IsValid(ply) then
            ply:SetCredits(0) -- Gracze zaczynają z 0 kredytów
            ply.RoundKills = 0
            ply.TeamKills = 0
        end
    end
    print("[CREDITS] Reset all credits to 0")
end)

-- Bonus za przeżycie - WYŁĄCZONY
-- hook.Add("BreachPostround", "CreditsSystem_SurvivalBonus", function()
--     for _, ply in pairs(player.GetAll()) do
--         if IsValid(ply) and ply:Alive() and ply:GTeam() != TEAM_SPEC then
--             ply:AddCredits(5, "Survival bonus (+5 credits)")
--         end
--     end
--     print("[CREDITS] Gave survival bonus to alive players")
-- end)

-- Inicjalizacja kredytów gdy gracz dołącza
hook.Add("PlayerInitialSpawn", "CreditsSystem_Init", function(ply)
    timer.Simple(1, function()
        if IsValid(ply) then
            InitPlayerCredits(ply)
            ply:SetCredits(0)
        end
    end)
end)

-- Koncommand do sprawdzania kredytów (admin) - wyłączone
-- concommand.Add("br_credits_check", function(ply, cmd, args)
--     if not IsValid(ply) or not ply:IsAdmin() then return end
--     local target = nil
--     for _, p in pairs(player.GetAll()) do
--         if string.find(string.lower(p:Nick()), string.lower(args[1])) then
--             target = p
--             break
--         end
--     end
--     if IsValid(target) then
--         ply:PrintMessage(HUD_PRINTTALK, "[CREDITS] " .. target:Nick() .. " has " .. target:GetCredits() .. " credits")
--     end
-- end)

-- Koncommand do dawania kredytów (admin) - wyłączone
-- concommand.Add("br_credits_give", function(ply, cmd, args)
--     if not IsValid(ply) or not ply:IsAdmin() then return end
--     local target = nil
--     for _, p in pairs(player.GetAll()) do
--         if string.find(string.lower(p:Nick()), string.lower(args[1])) then
--             target = p
--             break
--         end
--     end
--     if IsValid(target) and tonumber(args[2]) then
--         target:AddCredits(tonumber(args[2]), "Admin gave credits")
--     end
-- end)

-- Koncommand do resetowania kredytów (admin)
concommand.Add("br_credits_reset", function(ply, cmd, args)
    if not IsValid(ply) or not ply:IsAdmin() then return end
    
    for _, p in pairs(player.GetAll()) do
        if IsValid(p) then
            p:SetCredits(0)
        end
    end
    
    -- Komunikat o resecie kredytów wyłączony
    print("[CREDITS ADMIN] " .. ply:Nick() .. " reset all credits")
end)

-- Koncommand do ustawienia kredytów wszystkim (admin)
concommand.Add("br_credits_setall", function(ply, cmd, args)
    if not IsValid(ply) or not ply:IsAdmin() then return end
    
    if not args[1] then
        ply:PrintMessage(HUD_PRINTTALK, "[CREDITS] Usage: br_credits_setall <amount>")
        return
    end
    
    local amount = tonumber(args[1])
    if not amount then
        ply:PrintMessage(HUD_PRINTTALK, "[CREDITS] Invalid amount!")
        return
    end
    
    for _, p in pairs(player.GetAll()) do
        if IsValid(p) then
            p:SetCredits(amount)
        end
    end
    
    ply:PrintMessage(HUD_PRINTTALK, "[CREDITS] Set all player credits to " .. amount)
    print("[CREDITS ADMIN] " .. ply:Nick() .. " set all credits to " .. amount)
end)

-- Informacja o systemie kredytów przy spawnie gracza
hook.Add("PlayerSpawn", "CreditsSystem_Info", function(ply)
    if ply.CreditsInfoSent then return end
    
    timer.Simple(3, function()
        if IsValid(ply) and not ply.CreditsInfoSent then
            ply.CreditsInfoSent = true
        end
    end)
end)

-- Koncommand dla gracza do sprawdzania swoich statystyk
concommand.Add("br_mystats", function(ply, cmd, args)
    if not IsValid(ply) then return end
    
    InitPlayerCredits(ply)
    
    ply:PrintMessage(HUD_PRINTTALK, "=== YOUR ROUND STATS ===")
    ply:PrintMessage(HUD_PRINTTALK, "Credits: " .. ply:GetCredits())
    ply:PrintMessage(HUD_PRINTTALK, "Kills this round: " .. (ply.RoundKills or 0))
    ply:PrintMessage(HUD_PRINTTALK, "Team kills: " .. (ply.TeamKills or 0))
    ply:PrintMessage(HUD_PRINTTALK, "Team: " .. team.GetName(ply:GTeam() or TEAM_SPEC))
end)

-- Koncommand dla gracza do sprawdzania tylko kredytów - wyłączone
-- concommand.Add("br_credits", function(ply, cmd, args)
--     if not IsValid(ply) then return end
--     ply:PrintMessage(HUD_PRINTTALK, "[CREDITS] Your credits: " .. ply:GetCredits())
-- end)

-- Koncommand do testowania systemu kredytów - wyłączone
-- concommand.Add("br_credits_test", function(ply, cmd, args)
--     if not IsValid(ply) or not ply:IsAdmin() then return end
--     -- Test funkcjonalności kredytów bez komunikatów HUD
-- end)

print("[BREACH] Credits system loaded!")


================================================
FILE: gamemodes/breach/gamemode/modules/sv_deathcard.lua
================================================
-- Server-side death card system
util.AddNetworkString("BR_ShowDeathCard")

-- Table to track damage between players
local damageTracker = {}

-- Reset damage tracking for a player
local function ResetDamageTracking(ply)
    local steamid = ply:SteamID()
    damageTracker[steamid] = {}
end

-- Track damage dealt
hook.Add("PlayerHurt", "BR_TrackDamage", function(victim, attacker, healthRemaining, damageTaken)
    if not IsValid(victim) or not IsValid(attacker) then return end
    if not victim:IsPlayer() or not attacker:IsPlayer() then return end
    if victim == attacker then return end
    
    local victimID = victim:SteamID()
    local attackerID = attacker:SteamID()
    
    -- Initialize tables if needed
    damageTracker[victimID] = damageTracker[victimID] or {}
    damageTracker[attackerID] = damageTracker[attackerID] or {}
    
    -- Track damage dealt by attacker to victim
    damageTracker[attackerID][victimID] = (damageTracker[attackerID][victimID] or 0) + damageTaken
end)

-- Send death card info when player dies
hook.Add("PlayerDeath", "BR_SendDeathCard", function(victim, inflictor, attacker)
    if not IsValid(victim) then return end
    
    -- Don't show death card for invalid attackers or self-kills
    if not IsValid(attacker) or not attacker:IsPlayer() or attacker == victim then
        return
    end
    
    local victimID = victim:SteamID()
    local attackerID = attacker:SteamID()
    
    -- Get damage statistics
    local damageDealt = 0
    local damageReceived = 0
    
    if damageTracker[victimID] and damageTracker[victimID][attackerID] then
        damageDealt = damageTracker[victimID][attackerID]
    end
    
    if damageTracker[attackerID] and damageTracker[attackerID][victimID] then
        damageReceived = damageTracker[attackerID][victimID]
    end
    
    -- Get weapon info
    local weaponClass = "Unknown"
    local weaponName = "Unknown"
    
    if IsValid(inflictor) then
        if inflictor:IsWeapon() then
            weaponClass = inflictor:GetClass()
            weaponName = inflictor:GetPrintName() or weaponClass
        elseif inflictor:IsPlayer() then
            local wep = inflictor:GetActiveWeapon()
            if IsValid(wep) then
                weaponClass = wep:GetClass()
                weaponName = wep:GetPrintName() or weaponClass
            end
        else
            weaponClass = inflictor:GetClass()
            weaponName = inflictor:GetClass()
        end
    end
    
    -- Send death card info to victim
    net.Start("BR_ShowDeathCard")
        net.WriteEntity(attacker)
        net.WriteString(weaponClass)
        net.WriteString(weaponName)
        net.WriteUInt(math.Round(damageDealt), 16)
        net.WriteUInt(math.Round(damageReceived), 16)
    net.Send(victim)
    
    -- Reset damage tracking for the victim
    ResetDamageTracking(victim)
end)

-- Reset tracking on spawn
hook.Add("PlayerSpawn", "BR_ResetDamageTracking", function(ply)
    ResetDamageTracking(ply)
end)

-- Clean up on disconnect
hook.Add("PlayerDisconnected", "BR_CleanupDamageTracking", function(ply)
    local steamid = ply:SteamID()
    damageTracker[steamid] = nil
    
    -- Also clean up references to this player in other tables
    for id, damages in pairs(damageTracker) do
        damages[steamid] = nil
    end
end)


================================================
FILE: gamemodes/breach/gamemode/modules/sv_door_access_sync.lua
================================================
-- Server-side door access synchronization
util.AddNetworkString("BR_SyncDoorAccess")
util.AddNetworkString("BR_RequestDoorAccess")

-- Send door access data to clients when they spawn or when round starts
local function SendDoorAccessData(ply)
    if not MAPBUTTONS then return end
    
    -- Filter only doors with access requirements
    local accessDoors = {}
    for k, v in pairs(MAPBUTTONS) do
        if v.access and v.pos then
            table.insert(accessDoors, {
                pos = v.pos,
                access = v.access,
                name = v.name or "Door"
            })
        end
    end
    
    print("[DOOR ACCESS] Sending " .. #accessDoors .. " doors with access requirements")
    
    net.Start("BR_SyncDoorAccess")
        net.WriteTable(accessDoors)
    if ply then
        net.Send(ply)
        print("[DOOR ACCESS] Sent to player: " .. ply:Nick())
    else
        net.Broadcast()
        print("[DOOR ACCESS] Broadcasted to all players")
    end
end

-- Hook to send data when player spawns
hook.Add("PlayerInitialSpawn", "BR_SendDoorAccess", function(ply)
    timer.Simple(1, function()
        if IsValid(ply) then
            SendDoorAccessData(ply)
        end
    end)
end)

-- Send data when player fully spawns into the game
hook.Add("PlayerSpawn", "BR_SendDoorAccessPlayerSpawn", function(ply)
    -- Wait longer to ensure MAPBUTTONS is loaded
    timer.Simple(2, function()
        if IsValid(ply) and MAPBUTTONS then
            SendDoorAccessData(ply)
        end
    end)
end)

-- Send data when player spawns for the first time after joining
hook.Add("PlayerFullyConnected", "BR_SendDoorAccessConnected", function(ply)
    timer.Simple(3, function()
        if IsValid(ply) and MAPBUTTONS then
            SendDoorAccessData(ply)
        end
    end)
end)

-- Hook to send data when round starts/restarts
hook.Add("BreachStartRound", "BR_SendDoorAccessRound", function()
    timer.Simple(0.5, function()
        SendDoorAccessData()
    end)
end)

-- Also send when preparing phase starts
hook.Add("BreachStartPrep", "BR_SendDoorAccessPrep", function()
    timer.Simple(0.5, function()
        SendDoorAccessData()
    end)
end)

-- Console command to manually sync door access data
concommand.Add("br_sync_doors", function(ply, cmd, args)
    if IsValid(ply) and ply:IsAdmin() then
        print("[DOOR ACCESS] Manual sync requested by " .. ply:Nick())
        SendDoorAccessData()
    end
end)

-- Also try to send data on a timer after map load
timer.Simple(5, function()
    print("[DOOR ACCESS] Initial sync after map load")
    if MAPBUTTONS then
        SendDoorAccessData()
    else
        print("[DOOR ACCESS] MAPBUTTONS not loaded yet, retrying...")
        timer.Simple(5, function()
            if MAPBUTTONS then
                print("[DOOR ACCESS] Delayed sync after map load")
                SendDoorAccessData()
            end
        end)
    end
end)

-- Hook for when the map is initialized
hook.Add("InitPostEntity", "BR_SendDoorAccessInit", function()
    timer.Simple(10, function()
        if MAPBUTTONS then
            print("[DOOR ACCESS] Sync after InitPostEntity")
            SendDoorAccessData()
        end
    end)
end)

-- Allow clients to request door data
net.Receive("BR_RequestDoorAccess", function(len, ply)
    if IsValid(ply) then
        print("[DOOR ACCESS] Client request from " .. ply:Nick())
        timer.Simple(0.1, function()
            if IsValid(ply) and MAPBUTTONS then
                SendDoorAccessData(ply)
            end
        end)
    end
end)


================================================
FILE: gamemodes/breach/gamemode/modules/sv_jailbird_admin.lua
================================================
-- Jailbird Admin Commands for Breach
-- Server-side admin management for Jailbird weapon

if SERVER then
    -- Help command for Jailbird
    concommand.Add("breach_jailbird_help", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        ply:PrintMessage(HUD_PRINTTALK, "=== Jailbird Admin Commands ===")
        ply:PrintMessage(HUD_PRINTTALK, "breach_give_jailbird [player] - Give Jailbird to player")
        ply:PrintMessage(HUD_PRINTTALK, "breach_spawn_jailbird - Spawn Jailbird at crosshair")
        ply:PrintMessage(HUD_PRINTTALK, "breach_jailbird_cleanup [player] - Remove all Jailbird effects from player")
        ply:PrintMessage(HUD_PRINTTALK, "breach_jailbird_force_spawn - Force spawn Jailbird (100% chance)")
        ply:PrintMessage(HUD_PRINTTALK, "breach_jailbird_test_spawn - Test auto-spawn (normal 10% chance)")
        ply:PrintMessage(HUD_PRINTTALK, "breach_jailbird_info - Show Jailbird status information")
        ply:PrintMessage(HUD_PRINTTALK, "breach_jailbird_debug [player] - Debug player speeds and effects")
        ply:PrintMessage(HUD_PRINTTALK, "breach_jailbird_help - Show this help message")
    end)
    
    -- Give Jailbird to player
    concommand.Add("breach_give_jailbird", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        local target = args[1]
        local targetPly = ply
        
        if target then
            targetPly = nil
            for _, p in pairs(player.GetAll()) do
                if string.find(string.lower(p:Nick()), string.lower(target)) then
                    targetPly = p
                    break
                end
            end
            
            if not targetPly then
                ply:PrintMessage(HUD_PRINTTALK, "Player not found!")
                return
            end
        end
        
        if IsValid(targetPly) then
            targetPly:Give("weapon_jailbird")
            ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] Gave Jailbird to " .. targetPly:Nick())
            print("[ADMIN] " .. ply:Nick() .. " gave Jailbird to " .. targetPly:Nick())
        end
    end)
    
    -- Spawn Jailbird entity
    concommand.Add("breach_spawn_jailbird", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        local trace = ply:GetEyeTrace()
        local pos = trace.HitPos + trace.HitNormal * 5
        
        local jailbird = ents.Create("weapon_jailbird")
        if IsValid(jailbird) then
            jailbird:SetPos(pos)
            jailbird:Spawn()
            
            print("[ADMIN] " .. ply:Nick() .. " spawned Jailbird at " .. tostring(pos))
            ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] Jailbird spawned successfully!")
        end
    end)
    
    -- Check Jailbird status
    concommand.Add("breach_jailbird_info", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        ply:PrintMessage(HUD_PRINTTALK, "=== Jailbird Information ===")
        ply:PrintMessage(HUD_PRINTTALK, "Active Jailbird weapons: " .. #ents.FindByClass("weapon_jailbird"))
        
        local playersWithJailbird = 0
        for _, p in pairs(player.GetAll()) do
            if p:HasWeapon("weapon_jailbird") then
                playersWithJailbird = playersWithJailbird + 1
            end
        end
        
        ply:PrintMessage(HUD_PRINTTALK, "Players carrying Jailbird: " .. playersWithJailbird)
        ply:PrintMessage(HUD_PRINTTALK, "Auto-spawn location: Vector(3488.99, 1715.43, 0.03)")
        ply:PrintMessage(HUD_PRINTTALK, "Auto-spawn chance: 10% per round")
        ply:PrintMessage(HUD_PRINTTALK, "Models path: models/weapons/sweps/scpsl/jailbird/")
        ply:PrintMessage(HUD_PRINTTALK, "Sounds path: weapons/scpsl/jailbird/")
        
        -- Count stored speeds
        local storedSpeedsCount = 0
        for _, weapon in pairs(ents.FindByClass("weapon_jailbird")) do
            if IsValid(weapon) and weapon.OriginalSpeeds then
                for steamID, speeds in pairs(weapon.OriginalSpeeds) do
                    storedSpeedsCount = storedSpeedsCount + 1
                end
            end
        end
        ply:PrintMessage(HUD_PRINTTALK, "Players with stored speeds: " .. storedSpeedsCount)
    end)
    
    -- Debug command to check player speeds
    concommand.Add("breach_jailbird_debug", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        local target = args[1] or ply:Nick()
        local targetPly = nil
        
        for _, p in pairs(player.GetAll()) do
            if string.find(string.lower(p:Nick()), string.lower(target)) then
                targetPly = p
                break
            end
        end
        
        if not targetPly then
            ply:PrintMessage(HUD_PRINTTALK, "Player not found!")
            return
        end
        
        local steamID = targetPly:SteamID64()
        
        ply:PrintMessage(HUD_PRINTTALK, "=== " .. targetPly:Nick() .. " Speed Debug ===")
        ply:PrintMessage(HUD_PRINTTALK, "Current Walk Speed: " .. targetPly:GetWalkSpeed())
        ply:PrintMessage(HUD_PRINTTALK, "Current Run Speed: " .. targetPly:GetRunSpeed())
        
        -- Check stored speeds
        local hasStoredSpeeds = false
        for _, weapon in pairs(ents.FindByClass("weapon_jailbird")) do
            if IsValid(weapon) and weapon.OriginalSpeeds and weapon.OriginalSpeeds[steamID] then
                ply:PrintMessage(HUD_PRINTTALK, "Stored Walk Speed: " .. weapon.OriginalSpeeds[steamID].walk)
                ply:PrintMessage(HUD_PRINTTALK, "Stored Run Speed: " .. weapon.OriginalSpeeds[steamID].run)
                hasStoredSpeeds = true
                break
            end
        end
        
        if not hasStoredSpeeds then
            ply:PrintMessage(HUD_PRINTTALK, "No stored speeds found")
        end
        
        -- Check active timers
        local activeTimers = {}
        if timer.Exists("JailbirdHaste_" .. targetPly:EntIndex()) then
            table.insert(activeTimers, "Haste")
        end
        if timer.Exists("JailbirdDischarge_" .. targetPly:EntIndex()) then
            table.insert(activeTimers, "Discharge")
        end
        if timer.Exists("JailbirdHindered_" .. targetPly:EntIndex()) then
            table.insert(activeTimers, "Hindered")
        end
        
        if #activeTimers > 0 then
            ply:PrintMessage(HUD_PRINTTALK, "Active effects: " .. table.concat(activeTimers, ", "))
        else
            ply:PrintMessage(HUD_PRINTTALK, "No active effects")
        end
    end)
    
    -- Clean up Jailbird effects for a player
    concommand.Add("breach_jailbird_cleanup", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        local target = args[1] or ply:Nick()
        local targetPly = nil
        
        for _, p in pairs(player.GetAll()) do
            if string.find(string.lower(p:Nick()), string.lower(target)) then
                targetPly = p
                break
            end
        end
        
        if not targetPly then
            ply:PrintMessage(HUD_PRINTTALK, "Player not found!")
            return
        end
        
        local steamID = targetPly:SteamID64()
        
        -- Remove all Jailbird effects
        timer.Remove("JailbirdHaste_" .. targetPly:EntIndex())
        timer.Remove("JailbirdDischarge_" .. targetPly:EntIndex())
        timer.Remove("JailbirdHindered_" .. targetPly:EntIndex())
        
        -- Check for any Jailbird weapon and clean its speed storage
        local jailbirdWeapon = targetPly:GetWeapon("weapon_jailbird")
        if IsValid(jailbirdWeapon) and jailbirdWeapon.OriginalSpeeds then
            if jailbirdWeapon.OriginalSpeeds[steamID] then
                targetPly:SetWalkSpeed(jailbirdWeapon.OriginalSpeeds[steamID].walk)
                targetPly:SetRunSpeed(jailbirdWeapon.OriginalSpeeds[steamID].run)
                jailbirdWeapon.OriginalSpeeds[steamID] = nil
            else
                -- Fallback speed reset
                targetPly:SetWalkSpeed(100)
                targetPly:SetRunSpeed(400)
            end
        else
            -- No weapon found, use fallback
            targetPly:SetWalkSpeed(100)
            targetPly:SetRunSpeed(400)
        end
        
        ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] Cleaned up Jailbird effects for " .. targetPly:Nick())
        print("[ADMIN] " .. ply:Nick() .. " cleaned up Jailbird effects for " .. targetPly:Nick())
    end)
    
    -- Reset all Jailbird effects on round start
    hook.Add("BreachPreround", "JailbirdEffects_RoundReset", function()
        print("[Breach] Resetting all Jailbird effects for new round...")
        for _, ply in pairs(player.GetAll()) do
            if IsValid(ply) then
                local steamID = ply:SteamID64()
                
                -- Remove all Jailbird effect timers
                timer.Remove("JailbirdHaste_" .. ply:EntIndex())
                timer.Remove("JailbirdDischarge_" .. ply:EntIndex())
                timer.Remove("JailbirdHindered_" .. ply:EntIndex())
                
                -- Clean up stored speeds from any Jailbird weapons
                for _, weapon in pairs(ents.FindByClass("weapon_jailbird")) do
                    if IsValid(weapon) and weapon.OriginalSpeeds and weapon.OriginalSpeeds[steamID] then
                        ply:SetWalkSpeed(weapon.OriginalSpeeds[steamID].walk)
                        ply:SetRunSpeed(weapon.OriginalSpeeds[steamID].run)
                        weapon.OriginalSpeeds[steamID] = nil
                    end
                end
                
                -- Fallback reset (other systems will override if needed)
                if ply:GetWalkSpeed() == 0 or ply:GetRunSpeed() == 0 then
                    ply:SetWalkSpeed(100)
                    ply:SetRunSpeed(400)
                end
            end
        end
    end)
    
    -- Also reset on player spawn
    hook.Add("PlayerSpawn", "JailbirdEffects_PlayerSpawn", function(ply)
        if IsValid(ply) then
            local steamID = ply:SteamID64()
            
            timer.Remove("JailbirdHaste_" .. ply:EntIndex())
            timer.Remove("JailbirdDischarge_" .. ply:EntIndex())
            timer.Remove("JailbirdHindered_" .. ply:EntIndex())
            
            -- Clean up stored speeds
            for _, weapon in pairs(ents.FindByClass("weapon_jailbird")) do
                if IsValid(weapon) and weapon.OriginalSpeeds and weapon.OriginalSpeeds[steamID] then
                    weapon.OriginalSpeeds[steamID] = nil
                end
            end
        end
    end)
    
    -- Jailbird Auto-Spawn System
    function JailbirdAutoSpawn()
        local spawnPos = Vector(3488.990723, 1715.433716, 0.031250)
        local spawnAngles = Angle(0, 0, 0)
        
        -- 10% chance to spawn
        if math.random(100) <= 10 then
            -- Remove any existing Jailbirds first
            for _, ent in pairs(ents.FindByClass("weapon_jailbird")) do
                if ent:GetPos():Distance(spawnPos) < 100 then -- Within 100 units of spawn point
                    ent:Remove()
                end
            end
            
            -- Spawn new Jailbird
            local jailbird = ents.Create("weapon_jailbird")
            if IsValid(jailbird) then
                jailbird:SetPos(spawnPos)
                jailbird:SetAngles(spawnAngles)
                jailbird:Spawn()
                
                print("[Breach] Jailbird auto-spawned at " .. tostring(spawnPos) .. " (10% chance triggered)")
                return true
            end
        else
            print("[Breach] Jailbird auto-spawn skipped (90% chance)")
            return false
        end
    end
    
    -- Auto-spawn on round start
    hook.Add("PostCleanupMap", "JailbirdAutoSpawn", function()
        timer.Simple(2, function() -- Small delay to ensure map is fully loaded
            JailbirdAutoSpawn()
        end)
    end)
    
    -- Alternative hook for round restarts
    hook.Add("BreachPreround", "JailbirdAutoSpawn_Round", function()
        timer.Simple(2, function()
            JailbirdAutoSpawn()
        end)
    end)
    
    -- Force spawn command for testing
    concommand.Add("breach_jailbird_force_spawn", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        local spawnPos = Vector(3488.990723, 1715.433716, 0.031250)
        local spawnAngles = Angle(0, 0, 0)
        
        -- Remove existing first
        for _, ent in pairs(ents.FindByClass("weapon_jailbird")) do
            if ent:GetPos():Distance(spawnPos) < 100 then
                ent:Remove()
            end
        end
        
        -- Force spawn (100% chance)
        local jailbird = ents.Create("weapon_jailbird")
        if IsValid(jailbird) then
            jailbird:SetPos(spawnPos)
            jailbird:SetAngles(spawnAngles)
            jailbird:Spawn()
            
            ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] Jailbird force spawned at " .. tostring(spawnPos))
            print("[ADMIN] " .. ply:Nick() .. " force spawned Jailbird at " .. tostring(spawnPos))
        end
    end)
    
    -- Test auto-spawn command (with normal 10% chance)
    concommand.Add("breach_jailbird_test_spawn", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        local success = JailbirdAutoSpawn()
        if success then
            ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] Jailbird auto-spawn test succeeded (10% chance)")
        else
            ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] Jailbird auto-spawn test failed (90% chance)")
        end
    end)
    
    print("[Breach] Jailbird admin commands and auto-spawn system loaded successfully!")
end 


================================================
FILE: gamemodes/breach/gamemode/modules/sv_model_camera_heights.lua
================================================
local MODEL_CAMERA_HEIGHTS = {
	-- Małe modele (misie, SCP-066)
	["models/player/mrsilver/scp_066pm/scp_066_pm.mdl"] = {stand = 30, duck = 15},
	["models/yevocore/cat/cat.mdl"] = {stand = 30, duck = 15},
	["models/nickelodeon_all_stars/garfield/garfield.mdl"] = {stand = 35, duck = 15},
	["models/cktheamazingfrog/player/lasagna/lasagna.mdl"] = {stand = 35, duck = 15},
	["models/lenoax/amongus/suit_pm.mdl"] = {stand = 40, duck = 15},
	["models/scp/999/jq/scp_999_pmjq.mdl"] = {stand = 30, duck = 15},
	["models/1048/tdyear/tdybrownearpm.mdl"] = {stand = 20, duck = 15},
	["models/player/teddy_bear/teddy_bear.mdl"] = {stand = 56, duck = 28},
	
	-- Niskie modele models/yevocore/cat/cat.mdl
	["models/novux/023/novux_scp-023.mdl"] = {stand = 36, duck = 28},
	["models/props/forest_monster/forest_monster2.mdl"] = {stand = 36, duck = 28},
	
	-- Średnio-niskie modele
	--["models/vinrax/player/scp049_player.mdl"] = {stand = 46, duck = 28},--
	["models/scp/939/unity/unity_scp_939.mdl"] = {stand = 50, duck = 28},
	
	-- SCP-527 (Mr. Fish)
	["models/scp_527/scp_527.mdl"] = {stand = 64, duck = 28}, -- Normalna wysokość
	
	-- Wysokie modele models/nickelodeon_all_stars/garfield/garfield.mdl
	["models/scp096anim/player/scp096pm_raf.mdl"] = {stand = 69, duck = 28},
	["models/danx91/scp/scp_682.mdl"] = {stand = 69, duck = 28},
	["models/jqueary/scp/unity/scp173/scp173unity.mdl"] = {stand = 75, duck = 28},
}

-- Funkcja do aktualizacji wysokości kamery
local function UpdateCameraHeight(ply)
	if not IsValid(ply) then return end
	
	local model = ply:GetModel()
	if not model then return end
	

	
	-- Znajdź wysokość dla tego modelu
	local heights = MODEL_CAMERA_HEIGHTS[string.lower(model)]
	
	if heights then
		-- Ustaw niestandardową wysokość
		ply:SetViewOffset(Vector(0, 0, heights.stand))
		ply:SetViewOffsetDucked(Vector(0, 0, heights.duck))
	else
		-- Ustaw domyślną wysokość
		ply:SetViewOffset(Vector(0, 0, 64))
		ply:SetViewOffsetDucked(Vector(0, 0, 28))
	end
end

-- Hook na spawn gracza
hook.Add("PlayerSpawn", "ModelBasedCameraHeight_OnSpawn", function(ply)
	UpdateCameraHeight(ply)
end)

-- Hook na zmianę modelu
hook.Add("PlayerSetModel", "ModelBasedCameraHeight_OnSetModel", function(ply)
	UpdateCameraHeight(ply)
end)

-- Dodatkowy hook na PlayerLoadout
hook.Add("PlayerLoadout", "ModelBasedCameraHeight_OnLoadout", function(ply)
	timer.Simple(0.1, function()
		if IsValid(ply) then
			UpdateCameraHeight(ply)
		end
	end)
end)

-- Hook na PlayerInitialSpawn
hook.Add("PlayerInitialSpawn", "ModelBasedCameraHeight_OnInitialSpawn", function(ply)
	timer.Simple(0.1, function()
		if IsValid(ply) then
			UpdateCameraHeight(ply)
		end
	end)
end)

-- Hook na Think - sprawdza zmiany modelu w czasie rzeczywistym
local lastModels = {}
hook.Add("Think", "ModelBasedCameraHeight_OnThink", function()
	for _, ply in pairs(player.GetAll()) do
		if IsValid(ply) then
			local currentModel = ply:GetModel()
			if lastModels[ply] ~= currentModel then
				lastModels[ply] = currentModel
				UpdateCameraHeight(ply)
			end
		end
	end
end)


================================================
FILE: gamemodes/breach/gamemode/modules/sv_module.lua
================================================
// Initialization file
-- AddCSLuaFile( "fonts.lua" )
-- AddCSLuaFile( "cl_font.lua" )
-- AddCSLuaFile( "class_breach.lua" )
-- AddCSLuaFile( "cl_hud_new.lua" )
-- AddCSLuaFile( "cl_hud.lua" )
-- AddCSLuaFile( "shared.lua" )
-- AddCSLuaFile( "gteams.lua" )
-- AddCSLuaFile( "cl_scoreboard.lua" )
-- AddCSLuaFile( "cl_mtfmenu.lua" )
-- AddCSLuaFile( "sh_player.lua" )
-- AddCSLuaFile( "sh_playersetups.lua" )
-- mapfile = "mapconfigs/" .. game.GetMap() .. ".lua"
-- AddCSLuaFile(mapfile)
-- ALLLANGUAGES = {}
-- WEPLANG = {}
-- clang = nil
-- cwlang = nil

-- local files, dirs = file.Find(GM.FolderName .. "/gamemode/languages/*.lua", "LUA" )
-- for k,v in pairs(files) do
-- 	local path = "languages/"..v
-- 	if string.Right(v, 3) == "lua" and string.Left(v, 3) != "wep" then
-- 		AddCSLuaFile( path )
-- 		include( path )
-- 		print("Language found: " .. path)
-- 	end
-- end
-- local files, dirs = file.Find(GM.FolderName .. "/gamemode/languages/wep_*.lua", "LUA" )
-- for k,v in pairs(files) do
-- 	local path = "languages/"..v
-- 	if string.Right(v, 3) == "lua" then
-- 		AddCSLuaFile( path )
-- 		include( path )
-- 		print("Weapon lang found: " .. path)
-- 	end
-- end
-- AddCSLuaFile( "rounds.lua" )
-- AddCSLuaFile( "cl_sounds.lua" )
-- AddCSLuaFile( "cl_targetid.lua" )
-- AddCSLuaFile( "classes.lua" )
-- AddCSLuaFile( "cl_classmenu.lua" )
-- AddCSLuaFile( "cl_headbob.lua" )
-- --AddCSLuaFile( "cl_splash.lua" )
-- AddCSLuaFile( "cl_init.lua" )
-- AddCSLuaFile( "ulx.lua" )
-- AddCSLuaFile( "cl_minigames.lua" )
-- AddCSLuaFile( "cl_eq.lua" )
-- include( "server.lua" )
-- include( "rounds.lua" )
-- include( "class_breach.lua" )
-- include( "shared.lua" )
-- include( "classes.lua" )
-- include( mapfile )
-- include( "sh_player.lua" )
-- include( "sv_player.lua" )
-- include( "player.lua" )
-- include( "sv_round.lua" )
-- include( "gteams.lua" )
-- include( "sv_func.lua" )

-- Death card system
AddCSLuaFile( "cl_deathcard.lua" )
include( "sv_deathcard.lua" )

-- Door access indicator system
AddCSLuaFile( "cl_door_access_hud.lua" )
include( "sv_door_access_sync.lua" )

-- Weapon damage modifiers system
AddCSLuaFile( "cl_weapon_damage_menu.lua" )
include( "sv_weapon_damage_modifiers.lua" )



-- Include SCP Upgrader modules
AddCSLuaFile( "sh_upgrader_config.lua" )
AddCSLuaFile( "cl_upgrader_menu.lua" )
include( "sh_upgrader_config.lua" )

-- Include SCP-313 module
include( "sv_scp313.lua" )



AddCSLuaFile( "cl_bomber_lottery.lua" )

-- SCP-294 Network Strings removed - menu system no longer used

resource.AddFile( "sound/radio/chatter1.ogg" )
resource.AddFile( "sound/radio/chatter2.ogg" )
resource.AddFile( "sound/radio/chatter3.ogg" )
resource.AddFile( "sound/radio/chatter4.ogg" )
resource.AddFile( "sound/radio/franklin1.ogg" )
resource.AddFile( "sound/radio/franklin2.ogg" )
resource.AddFile( "sound/radio/franklin3.ogg" )
resource.AddFile( "sound/radio/franklin4.ogg" )
resource.AddFile( "sound/radio/radioalarm.ogg" )
resource.AddFile( "sound/radio/radioalarm2.ogg" )
resource.AddFile( "sound/radio/scpradio0.ogg" )
resource.AddFile( "sound/radio/scpradio1.ogg" )
resource.AddFile( "sound/radio/scpradio2.ogg" )
resource.AddFile( "sound/radio/scpradio3.ogg" )
resource.AddFile( "sound/radio/scpradio4.ogg" )
resource.AddFile( "sound/radio/scpradio5.ogg" )
resource.AddFile( "sound/radio/scpradio6.ogg" )
resource.AddFile( "sound/radio/scpradio7.ogg" )
resource.AddFile( "sound/radio/scpradio8.ogg" )
resource.AddFile( "sound/radio/ohgod.ogg" )

// Variables
gamestarted = gamestarted or false
preparing = false
postround = false
roundcount = 0
MAPBUTTONS = table.Copy(BUTTONS)
itemsSpawned = false

function GM:PlayerSpray( ply )
	if ply:GTeam() == TEAM_SPEC then
		return true
	end
	if ply:GetPos():WithinAABox( POCKETD_MINS, POCKETD_MAXS ) then
		ply:PrintMessage( HUD_PRINTCENTER, "You can't use spray in Pocket Dimension" )
		return true
	end
end

function GetActivePlayers()
	local tab = {}
	for k,v in pairs(player.GetAll()) do
		if IsValid( v ) then
			if v.ActivePlayer == nil then
				v.ActivePlayer = true
				v:SetNActive( true )
			end

			if v.ActivePlayer == true then
				table.ForceInsert(tab, v)
			end
		end
	end
	return tab
end

function GetNotActivePlayers()
	local tab = {}
	for k,v in pairs(player.GetAll()) do
		if v.ActivePlayer == nil then v.ActivePlayer = true v:SetNActive( true ) end
		if v.ActivePlayer == false then
			table.ForceInsert(tab, v)
		end
	end
	return tab
end

function GM:ShutDown()
	--
end

function WakeEntity(ent)
	local phys = ent:GetPhysicsObject()
	if phys:IsValid() then
		phys:Wake()
		phys:SetVelocity( Vector( 0, 0, 25 ) )
	end
end

function PlayerNTFSound(sound, ply)
	if (ply:GTeam() == TEAM_GUARD or ply:GTeam() == TEAM_CHAOS) and ply:Alive() then
		if ply.lastsound == nil then ply.lastsound = 0 end
		if ply.lastsound > CurTime() then
			ply:PrintMessage(HUD_PRINTTALK, "You must wait " .. math.Round(ply.lastsound - CurTime()) .. " seconds to do this.")
			return
		end
		//ply:EmitSound( "Beep.ogg", 500, 100, 1 )
		ply.lastsound = CurTime() + 3
		//timer.Create("SoundDelay"..ply:SteamID64() .. "s", 1, 1, function()
			ply:EmitSound( sound, 450, 100, 1 )
		//end)
	end
end

function OnUseEyedrops(ply)
	if ply.usedeyedrops == true then
		ply:PrintMessage(HUD_PRINTTALK, "Don't use them that fast!")
		return
	end
	ply.usedeyedrops = true
	ply:StripWeapon("item_eyedrops")
	ply:PrintMessage(HUD_PRINTTALK, "Used eyedrops, you will not be blinking for 10 seconds")
	timer.Create("Unuseeyedrops" .. ply:SteamID64(), 10, 1, function()
		ply.usedeyedrops = false
		ply:PrintMessage(HUD_PRINTTALK, "You will be blinking now")
	end)
end

timer.Create( "CheckStart", 10, 0, function()
	if !gamestarted then
		CheckStart()
	end
end )

// Timer naprawiający problem z przezroczystością na scoreboardzie
timer.Create( "FixActivePlayerSync", 5, 0, function()
	for k, v in pairs(player.GetAll()) do
		if IsValid(v) then
			// Napraw ActivePlayer jeśli jest nil
			if v.ActivePlayer == nil then
				v.ActivePlayer = true
			end
			
			// Wymuś synchronizację zmiennej sieciowej
			if v.GetNActive and v.SetNActive then
				if v:GetNActive() != v.ActivePlayer then
					v:SetNActive(v.ActivePlayer)
				end
			end
		end
	end
end )

timer.Create("BlinkTimer", GetConVar("br_time_blinkdelay"):GetInt(), 0, function()
	local time = GetConVar("br_time_blink"):GetFloat()
	if time >= 5 then return end
	for k,v in pairs(player.GetAll()) do
		if v.canblink and v.blinkedby173 == false and v.usedeyedrops == false then
			net.Start("PlayerBlink")
				net.WriteFloat(time)
			net.Send(v)
			v.isblinking = true
		end
	end
	timer.Create("UnBlinkTimer", time + 0.2, 1, function()
		for k,v in pairs(player.GetAll()) do
			if v.blinkedby173 == false then
				v.isblinking = false
			end
		end
	end)
end)

timer.Create("EffectTimer", 0.3, 0, function()
	for k, v in pairs( player.GetAll() ) do
		if v.mblur == nil then v.mblur = false end
		net.Start("Effect")
			net.WriteBool( v.mblur )
		net.Send(v)
	end
end )

/*nextgateaopen = 0
function RequestOpenGateA(ply)
	if preparing or postround then return end
	if !(ply:GTeam() == TEAM_GUARD or ply:GTeam() == TEAM_CHAOS) then return end
	if nextgateaopen > CurTime() then
		ply:PrintMessage(HUD_PRINTTALK, "You cannot open Gate A now, you must wait " .. math.Round(nextgateaopen - CurTime()) .. " seconds")
		return
	end
	local gatea
	local rdc
	for id,ent in pairs(ents.FindByClass("func_rot_button")) do
		for k,v in pairs(MAPBUTTONS) do
			if v["pos"] == ent:GetPos() then
				if v["name"] == "Remote Door Control" then
					rdc = ent
					rdc:Use(ply, ply, USE_ON, 1)
				end
			end
		end
	end
	for id,ent in pairs(ents.FindByClass("func_button")) do
		for k,v in pairs(MAPBUTTONS) do
			if v["pos"] == ent:GetPos() then
				if v["name"] == "Gate A" then
					gatea = ent
				end
			end
		end
	end
	if IsValid(gatea) then
		nextgateaopen = CurTime() + 20
		timer.Simple(2, function()
			if IsValid(gatea) then
				gatea:Use(ply, ply, USE_ON, 1)
			end
		end)
	end
end*/

function GetPocketPos()
	if istable( POS_POCKETD ) then
		return table.Random( POS_POCKETD )
	else
		return POS_POCKETD
	end
end

function UseAll()
	for k, v in pairs( FORCE_USE ) do
		local enttab = ents.FindInSphere( v, 3 )
		for _, ent in pairs( enttab ) do
			if ent:GetPos() == v then
				ent:Fire( "Use" )
				break
			end
		end
	end
end

function DestroyAll()
	for k, v in pairs( FORCE_DESTROY ) do
		if isvector( v ) then
			local enttab = ents.FindInSphere( v, 1 )
			for _, ent in pairs( enttab ) do
				if ent:GetPos() == v then
					ent:Remove()
					break
				end
			end
		elseif isnumber( v ) then
			local ent = ents.GetByIndex( v )
			if IsValid( ent ) then
				ent:Remove()
			end
		end
	end
end

function SpawnAllItems()
	if itemsSpawned then return end
	if not MAP_LOADED then return end
	itemsSpawned = true



	// Remove old kebab stands
	for _, ent in pairs( ents.FindByClass("br_kebab_stand") ) do
		if IsValid(ent) then
			ent:Remove()
		end
	end

	------XMAS PART------

	/*for k, v in pairs( XMAS_TREES ) do
		local tree = ents.Create( "prop_physics" )
		tree:SetModel( "models/unconid/xmas/xmas_tree.mdl" )
		tree:SetPos( v )
		local phys = tree:GetPhysicsObject()
		if IsValid( phys ) then
			phys:Wake()
			phyas:EnableMotion( false )
		end
	end

	for k, v in pairs( XMAS_SNOWMANS_SMALL ) do
		local snowman = ents.Create( "prop_physics" )
		snowman:SetModel( "models/unconid/xmas/snowman_u.mdl" )
		snowman:SetPos( v[1] )
		snowman:SetAngles( v[2] )
		local phys = snowman:GetPhysicsObject()
		if IsValid( phys ) then
			phys:Wake()
			phyas:EnableMotion( false )
		end
	end

	for k, v in pairs( XMAS_SNOWMANS_BIG ) do
		local snowman = ents.Create( "prop_physics" )
		snowman:SetModel( "models/unconid/xmas/snowman_u_big.mdl" )
		snowman:SetPos( v[1] )
		snowman:SetAngles( v[2] )
		local phys = snowman:GetPhysicsObject()
		if IsValid( phys ) then
			phys:Wake()
			phyas:EnableMotion( false )
		end
	end*/

	---------------------

	for k,v in pairs(SPAWN_FIREPROOFARMOR) do
		local vest = ents.Create( "armor_fireproof" )
		if IsValid( vest ) then
			vest:Spawn()
			vest:SetPos( v )
			WakeEntity(vest)
		end
	end
	
	for k,v in pairs(SPAWN_ARMORS) do
		local vest = ents.Create( "armor_mtfguard" )
		if IsValid( vest ) then
			vest:Spawn()
			vest:SetPos( v )
			WakeEntity(vest)
		end
	end
	
	for k,v in pairs(SPAWN_ELECTROPROOFARMOR) do
		local vest = ents.Create( "armor_electroproof" )
		if IsValid( vest ) then
			vest:Spawn()
			vest:SetPos( v )
			WakeEntity( vest )
		end
	end
	
	local pistols = {
		"cw_deagle",
		"cw_fiveseven",
	}

	for k,v in pairs( SPAWN_PISTOLS ) do
		local selected = table.Random( pistols )
		local wep = ents.Create( selected )
		if IsValid( wep ) then
			wep:Spawn()
			wep:SetPos( v )
			WakeEntity( wep )
		end
	end
	
	local smgs = {
		"cw_g36c",
		"cw_ump45",
		"cw_mp5",
	}

	for k,v in pairs( SPAWN_SMGS ) do
		local selected = table.Random( smgs )
		local wep = ents.Create( selected )
		if IsValid( wep ) then
			wep:Spawn()
			wep:SetPos( v )
			WakeEntity( wep )
		end
	end
	
	local rifles = {
		"cw_ak74",
		"cw_ar15",
		"cw_m14",
		"cw_scarh",
	}

	for k,v in pairs( SPAWN_RIFLES ) do
		local selected = table.Random( rifles )
		local wep = ents.Create( selected )
		if IsValid( wep ) then
			wep:Spawn()
			wep:SetPos( v )
			WakeEntity( wep )
		end
	end
	
	for k,v in pairs( SPAWN_SNIPER ) do
		local wep = ents.Create( "cw_l115" )
		if IsValid( wep ) then
			wep:Spawn()
			wep:SetPos( v )
			WakeEntity( wep )
		end
	end
	
	local pumps = {
		"cw_shorty",
		"cw_m3super90",
	}

	for k,v in pairs(SPAWN_PUMP) do
		local selected = table.Random( pumps )
		local wep = ents.Create( selected )
		if IsValid( wep ) then
			wep:Spawn()
			wep:SetPos( v )
			WakeEntity( wep )
		end
	end
	
	for k,v in pairs(SPAWN_AMMO_CW) do
		local wep = ents.Create("cw_ammo_kit_regular")
		if IsValid( wep ) then
			wep.AmmoCapacity = 25
			wep:Spawn()
			wep:SetPos( v )
			// Disable collision with players
			wep:SetCollisionGroup(COLLISION_GROUP_WEAPON)
			WakeEntity( wep )
		end
	end
	
/*	for k,v in pairs(SPAWN_AMMO_G) do
		local wep = ents.Create("cw_ammo_40mm")
		if IsValid( wep ) then
			wep:Spawn()
			wep:SetPos( v )
			WakeEntity(wep)
		end
	end */
	
	if GetConVar("br_allow_vehicle"):GetInt() != 0 then
		for k, v in pairs(SPAWN_VEHICLE_GATE_A) do
			local car = ents.Create("prop_vehicle_jeep")
			if IsValid(car) then
				if GetConVar("br_cars_oldmodels"):GetInt() == 0 then
					car:SetModel("models/tdmcars/jeep_wrangler_fnf.mdl")
					car:SetKeyValue("vehiclescript","scripts/vehicles/TDMCars/wrangler_fnf.txt")
				else
					car:SetModel("models/buggy.mdl")
					car:SetKeyValue("vehiclescript","scripts/vehicles/jeep_test.txt")
				end
				car:SetPos( v )
				car:SetAngles( Angle( 0, 90, 0 ) )
				car:Spawn()
				WakeEntity( car )
			else
				ErrorNoHalt("Could not create 'prop_vehicle_jeep' entity!\n")
			end
		end
	
		for k, v in ipairs(SPAWN_VEHICLE_NTF) do
			if k > math.Clamp( GetConVar( "br_cars_ammount" ):GetInt(), 0, 12 ) then
				break
			end
			local car = ents.Create("prop_vehicle_jeep")
			if IsValid(car) then
				if GetConVar("br_cars_oldmodels"):GetInt() == 0 then
					car:SetModel("models/tdmcars/jeep_wrangler_fnf.mdl")
					car:SetKeyValue("vehiclescript","scripts/vehicles/TDMCars/wrangler_fnf.txt")
				else
					car:SetModel("models/buggy.mdl")
					car:SetKeyValue("vehiclescript","scripts/vehicles/jeep_test.txt")
				end
				car:SetPos( v )
				car:SetAngles( Angle( 0, 270, 0 ) )
				car:Spawn()
				WakeEntity( car )
			else
				ErrorNoHalt("Could not create 'prop_vehicle_jeep' entity!\n")
			end
		end
	end
	
	local item = ents.Create( "item_scp_714" )
	if IsValid( item ) then
		item:SetPos( SPAWN_714 )
		item:Spawn()
	end
	
	// Spawn SCP-035 mask with 25% chance
	if SPAWN_SCP035 then
		local spawnChance = math.random(1, 100)
		if spawnChance <= 25 then
			local mask = ents.Create("scp_035")
			if IsValid(mask) then
				mask:SetPos(SPAWN_SCP035)
				mask:SetAngles(Angle(0, math.random(0, 360), 0))
				mask:Spawn()
				mask:Activate()
				
				-- Add small physics force
				local phys = mask:GetPhysicsObject()
				if IsValid(phys) then
					phys:Wake()
				end
				
				print("[BREACH] SCP-035 mask spawned successfully (25% chance)")
			else
				print("[BREACH] ERROR: Failed to create SCP-035 mask entity!")
			end
		else
			print("[BREACH] SCP-035 mask spawn skipped (rolled " .. spawnChance .. "%, needed <= 25%)")
		end
	end
	
	// Spawn SCP-1499
	if SPAWN_1499 then
		local item1499 = ents.Create( "weapon_scp_1499" )
		if IsValid( item1499 ) then
			item1499:SetPos( SPAWN_1499 )
			item1499:Spawn()
			WakeEntity( item1499 )
		end
	end
	
	// Spawn SCP Wall Hole
	if SPAWN_WALLHOLE then
		local wallhole = ents.Create( "scp_wall_hole" )
		if IsValid( wallhole ) then
			wallhole:SetPos( SPAWN_WALLHOLE )
			wallhole:Spawn()
		end
	end
	
	// SCP-297 (Wish Machine) - DISABLED to avoid conflict with SCP-294
	// Use br_spawn_scp297 command to manually spawn if needed
	// local scp297 = ents.Create( "scp_297" )
	// if IsValid( scp297 ) then
	//	scp297:SetPos( Vector(94.679100, 3120.276855, -88.759789) )
	//	scp297:SetAngles( Angle(0, 90, 0) )
	//	scp297:Spawn()
	//	print("[BREACH] SCP-297 Wish Machine spawned")
	// end
	
	// OPTYMALIZACJA: Zoptymalizowane wyszukiwanie SCP-294 z cache
	timer.Simple(3, function() // Zwiększono delay dla lepszej stabilności
		local foundSCP294 = false
		local foundCount = 0

		print("[OPTIMIZATION] Searching for SCP-294 models...")

		// Znajdź wszystkie entity na mapie - tylko raz
		for _, ent in pairs(ents.GetAll()) do
			if IsValid(ent) and ent:GetModel() == "models/vinrax/scp294/scp294.mdl" then
				// Stwórz interaktywne entity w tym miejscu
				local scp294 = ents.Create("scp_294")
				if IsValid(scp294) then
					scp294:SetPos(ent:GetPos())
					scp294:SetAngles(ent:GetAngles())
					scp294:Spawn()
					scp294:Activate()

					// Usuń oryginalny model
					ent:Remove()

					foundSCP294 = true
					foundCount = foundCount + 1
					print("[OPTIMIZATION] Found and converted SCP-294 model #" .. foundCount .. " at position: " .. tostring(scp294:GetPos()))
				end
			end
		end

		if not foundSCP294 then
			print("[BREACH] No SCP-294 models found on map. To spawn manually, use: ent_create scp_294")
		else
			print("[OPTIMIZATION] SCP-294 search completed. Found: " .. foundCount .. " models")
		end
	end)
	
	local pos500 = table.Copy( SPAWN_500 )
	
	for i = 1, 2 do
		local item = ents.Create( "item_scp_500" )
		if IsValid( item ) then
			local pos = table.Random( pos500 )
			item:SetPos( pos )
			item:Spawn()
			table.RemoveByValue( pos500, pos )
		end
	end
	
	-- Spawn SCP-018
	local item = ents.Create( "weapon_scp_018" )
	if IsValid( item ) then
		item:SetPos( Vector(1819.275024, 1296.073730, 41.031250) )
		item:Spawn()
	end
	
	-- Spawn SCP-313
	local scp313 = ents.Create( "scp_313" )
	if IsValid( scp313 ) then
		scp313:SetPos( Vector(1901.448975, 145.031250, 53.363686) )
		scp313:SetAngles( Angle(0, 360, 0) ) -- Skierowana do ściany
		scp313:Spawn()
	end
	
	-- Spawn Facility Intercom
	local intercom = ents.Create( "br_intercom" )
	if IsValid( intercom ) then
		intercom:SetPos( Vector(-2505.753662, 3720.031250, 317.261230) )
		intercom:SetAngles( Angle(90, 90, 0) )
		intercom:Spawn()
		print("[BREACH] Facility Intercom spawned")
	end
	
	-- Spawn SCP-207 (Max 3 random bottles)
	if SPAWN_SCP207 and #SPAWN_SCP207 > 0 then
		local pos207 = table.Copy( SPAWN_SCP207 )
		local maxBottles = math.min(3, #pos207) -- Maximum 3 bottles
		
		for i = 1, maxBottles do
			local scp207 = ents.Create( "scp_207" )
			if IsValid( scp207 ) then
				local pos = table.remove( pos207, math.random( 1, #pos207 ) )
				scp207:SetPos( pos )
				scp207:Spawn()
			end
		end
		print("[BREACH] SCP-207 bottles spawned: " .. maxBottles .. " bottles at random locations")
	end
	
	for k, v in pairs( SPAWN_420 ) do
		local item = ents.Create( "item_scp_420j" )
		if IsValid( item ) then
			local pos
			if istable(v) then
				// If 'v' is a table of spawn points, pick one
				pos = table.Random(v)
			else
				// Otherwise, assume 'v' is the spawn point itself
				pos = v
			end
			item:SetPos( pos )
			item:Spawn()
		end
	end
	
	for k, v in pairs( KEYCARDS or {} ) do
		local spawns = table.Copy( v.spawns )
		//local cards = table.Copy( v.ents )
		local dices = {}

		local n = 0
		for _, dice in pairs( v.ents ) do
			local d = {
				min = n,
				max = n + dice[2],
				ent = dice[1]
			}
			
			table.insert( dices, d )
			n = n + dice[2]
		end

		for i = 1, math.min( v.amount, #spawns ) do
			local spawn = table.remove( spawns, math.random( 1, #spawns ) )
			local dice = math.random( 0, n - 1 )
			local ent

			for _, d in pairs( dices ) do
				if d.min <= dice and d.max > dice then
					ent = d.ent
					break
				end
			end

			if ent then
				local keycard = ents.Create( "br_keycard" )
				if IsValid( keycard ) then
					keycard:Spawn()
					keycard:SetPos( spawn )
					keycard:SetKeycardType( ent )
				end
			end
		end
	end
	
	local resps_items = table.Copy( SPAWN_MISCITEMS )
	local resps_melee = table.Copy( SPAWN_MELEEWEPS )
	local resps_medkits = table.Copy( SPAWN_MEDKITS )
	
	for i = 1, 2 do
		local item = ents.Create( "item_medkit" )
		if IsValid( item ) then
			local spawn = table.remove( resps_medkits, math.random( 1, #resps_medkits ) )
			item:Spawn()
			item:SetPos( spawn )
		end
	end

	local item = ents.Create( "item_radio" )
	if IsValid( item ) then
		local spawn = table.remove( resps_items, math.random( 1, #resps_items ) )
		item:Spawn()
		item:SetPos( spawn )
	end
	
	local item = ents.Create( "item_eyedrops" )
	if IsValid( item ) then
		local spawn = table.remove( resps_items, math.random( 1, #resps_items ) )
		item:Spawn()
		item:SetPos( spawn )
	end
	
	local item = ents.Create( "item_snav_300" )
	if IsValid( item ) then
		local spawn = table.remove( resps_items, math.random( 1, #resps_items ) )
		item:Spawn()
		item:SetPos( spawn )
	end
	
	local item = ents.Create( "item_snav_ultimate" )
	if IsValid( item ) then
		local spawn = table.remove( resps_items, math.random( 1, #resps_items ) )
		item:Spawn()
		item:SetPos( spawn )
	end
	
	local item = ents.Create( "item_nvg" )
	if IsValid( item ) then
		local spawn = table.remove( resps_items, math.random( 1, #resps_items ) )
		item:Spawn()
		item:SetPos( spawn )
	end
	
	for i = 1, 2 do
		local item = ents.Create( "weapon_crowbar" )
		if IsValid( item ) then
			local spawn = table.remove( resps_melee, math.random( 1, #resps_melee ) )
			item:Spawn()
			item:SetPos( spawn )
		end
	end
	
	for i, v in ipairs( CCTV ) do
		local cctv = ents.Create( "item_cctv" )

		if IsValid( cctv ) then
			cctv:Spawn()
			cctv:SetPos( v.pos )

			cctv:SetCam( i )

			v.ent = cctv
		end
	end

	// Spawn Kebab Stand only if Cook is in the game
	local hasCook = false
	for _, ply in pairs(player.GetAll()) do
		if IsValid(ply) and ply:GetNClass() == ROLES.ROLE_COOK then
			hasCook = true
			break
		end
	end
	
	if hasCook then
		print("[BREACH] Cook found in game, spawning kebab stand...")
		local kebab_stand = ents.Create( "br_kebab_stand" )
		if IsValid( kebab_stand ) then
			kebab_stand:SetPos( Vector(227.936295, 3185.166016, -87.968750) )
			kebab_stand:SetAngles( Angle(0, 0, 0) )
			kebab_stand:Spawn()
			print("[BREACH] Kebab stand spawned successfully at cafeteria")
		else
			print("[BREACH] ERROR: Failed to create br_kebab_stand entity!")
		end
	else
		print("[BREACH] No Cook in game, skipping kebab stand spawn")
	end


end

function SpawnNTFS(forceChaos)
	if disableNTF then return end

	// Niestandardowe pozycje spawnu dla GOC
	local GOC_SPAWN_POSITIONS = {
		Vector(558.671509, 7106.799316, 2087.195557),
		Vector(555.054871, 6996.205078, 2087.200195),
		Vector(554.845947, 6909.542480, 2087.218262),
		Vector(554.125305, 6822.297852, 2088.832520),
		Vector(405.279938, 6975.074219, 2122.880371)
	}

	// Sprawdź czy są żywi gracze Klasy D przed spawnem Chaos
	local aliveclassd = 0
	for _, ply in pairs(player.GetAll()) do
		if ply:GTeam() == TEAM_CLASSD and ply:Alive() then
			aliveclassd = aliveclassd + 1
		end
	end

	local usechaos = forceChaos or (math.random( 1, 100 ) <= GetConVar("br_ci_percentage"):GetInt())
	
	// Jeśli nie ma żywej Klasy D, wymuś spawn MTF zamiast Chaos
	if usechaos and aliveclassd == 0 then
		usechaos = false
		print("[BREACH] Chaos spawn blocked - no alive Class D personnel")
	end

	local roles = {}
	local plys = {}
	local inuse = {}
	local spawnpos = usechaos and SPAWN_OUTSIDE_CI or SPAWN_OUTSIDE

	for k, v in pairs( ALLCLASSES.support.roles ) do
		if usechaos then
			if v.team == TEAM_CHAOS then
				table.insert( roles, v )
			end
		else
			if v.team == TEAM_GUARD then
				table.insert( roles, v )
			end
		end
	end

	// Zbierz wszystkich dostępnych graczy (spektatorzy i martwi)
	local availablePlayers = {}
	for _, ply in pairs( player.GetAll() ) do
		if (ply:GTeam() == TEAM_SPEC or !ply:Alive()) and ply.ActivePlayer then
			table.insert(availablePlayers, ply)
		end
	end

	// Przypisz graczy do ról (brak wymagania poziomu tylko dla MTF NTF i CI Soldier)
	for k, v in pairs( roles ) do
		plys[v.name] = {}
		inuse[v.name] = 0
		for _, ply in pairs( availablePlayers ) do
			local levelCheck = true
			// Sprawdź wymagania poziomu tylko dla ról innych niż MTF NTF i CI Soldier
			if v.name != ROLES.ROLE_MTFNTF and v.name != ROLES.ROLE_CHAOS then
				levelCheck = ply:GetLevel() >= v.level
			end
			
			if levelCheck and ( v.customcheck and v.customcheck( ply ) or true ) then
				table.insert( plys[v.name], ply )
			end
		end

		if #plys[v.name] < 1 then
			roles[k] = nil
		end
	end

	if #roles < 1 then
		return
	end

	// Spawn pozostałych dostępnych graczy jako MTF/Chaos
	local spawnedCount = 0
	
	for _, ply in pairs(availablePlayers) do
		if #roles > 0 then
			local role = table.Random( roles )
			
			ply:SetupNormal()
			ply:ApplyRoleStats( role )
			
			// Użyj pozycji spawnu lub losowej pozycji w pobliżu jeśli brakuje pozycji
			local spawnIndex = (spawnedCount % #spawnpos) + 1
			local basePos = spawnpos[spawnIndex]
			local offset = Vector(math.random(-100, 100), math.random(-100, 100), 0)
			ply:SetPos( basePos + offset )

			// Dodaj ochronę przed spawn killingiem na 5 sekund
			SetSupportSpawnProtection(ply, 5)

			spawnedCount = spawnedCount + 1
		end
	end

	// Zachowaj dźwiękowy komunikat dla MTF
	if !usechaos and spawnedCount > 0 then
		BroadcastLua( 'surface.PlaySound( "EneteredFacility.ogg" )' )
	end
end

function SpawnGOC()
	// Niestandardowe pozycje spawnu dla GOC
	local GOC_SPAWN_POSITIONS = {
		Vector(558.671509, 7106.799316, 2087.195557),
		Vector(555.054871, 6996.205078, 2087.200195),
		Vector(554.845947, 6909.542480, 2087.218262),
		Vector(554.125305, 6822.297852, 2088.832520),
		Vector(405.279938, 6975.074219, 2122.880371)
	}

	local maxGOC = 5 // Maksymalnie 5 graczy GOC
	local gocRoles = {}
	
	// Zbierz role GOC
	for k, v in pairs( ALLCLASSES.goc.roles ) do
		if v.team == TEAM_GOC then
			table.insert( gocRoles, v )
		end
	end
	
	if #gocRoles < 1 then
		return
	end
	
	// Zbierz wszystkich dostępnych graczy (spektatorzy i martwi)
	local availablePlayers = {}
	for _, ply in pairs( player.GetAll() ) do
		if (ply:GTeam() == TEAM_SPEC or !ply:Alive()) and ply.ActivePlayer then
			table.insert(availablePlayers, ply)
		end
	end
	
	if #availablePlayers < 1 then
		return
	end
	
	// Filtruj graczy według poziomów dla każdej roli GOC
	local qualifiedPlayers = {}
	for _, role in pairs(gocRoles) do
		for _, ply in pairs(availablePlayers) do
			// Sprawdź poziom gracza
			if ply:GetLevel() >= role.level and (role.customcheck and role.customcheck(ply) or true) then
				if !qualifiedPlayers[ply] then
					qualifiedPlayers[ply] = {}
				end
				table.insert(qualifiedPlayers[ply], role)
			end
		end
	end
	
	// Sprawdź czy są jakikolwiek gracze spełniający wymagania
	local hasQualifiedPlayers = false
	for k, v in pairs(qualifiedPlayers) do
		hasQualifiedPlayers = true
		break
	end
	
	if !hasQualifiedPlayers then
		print("[BREACH] No players qualified for GOC roles - spawning MTF instead")
		// Jeśli nikt nie ma poziomu na GOC, spawnuj MTF zamiast tego
		SpawnNTFS()
		return
	end
	
	// Spawn GOC graczy (max 5)
	local gocSpawned = 0
	local usedPlayers = {}
	
	for i = 1, math.min(maxGOC, #availablePlayers) do
		// Znajdź gracza który może być GOC
		local selectedPly = nil
		local selectedRole = nil
		
		for ply, roles in pairs(qualifiedPlayers) do
			if !usedPlayers[ply] and #roles > 0 then
				selectedPly = ply
				selectedRole = table.Random(roles)
				usedPlayers[ply] = true
				break
			end
		end
		
		if !selectedPly then
			// Brak więcej kwalifikujących się graczy
			break
		end
		
		if IsValid(selectedPly) then
			selectedPly:SetupNormal()
			selectedPly:ApplyRoleStats( selectedRole )
			
			// Użyj niestandardowej pozycji spawnu dla GOC
			local spawnPos = GOC_SPAWN_POSITIONS[gocSpawned + 1]
			selectedPly:SetPos( spawnPos )
			
			// Ustaw odpowiedni kąt patrzenia
			local spawnIndex = gocSpawned + 1
			if spawnIndex == 1 then
				selectedPly:SetAngles(Angle(3.855751, 175.663879, 0))
			elseif spawnIndex == 2 then
				selectedPly:SetAngles(Angle(-2.179303, -179.893661, 0))
			elseif spawnIndex == 3 then
				selectedPly:SetAngles(Angle(-2.682222, -179.809799, 0))
			elseif spawnIndex == 4 then
				selectedPly:SetAngles(Angle(-1.676380, 179.603409, 0))
			elseif spawnIndex == 5 then
				selectedPly:SetAngles(Angle(-2.095481, 179.687286, 0))
			end
			
			// Dodaj ochronę przed spawn killingiem na 5 sekund
			SetSupportSpawnProtection(selectedPly, 5)
			
			gocSpawned = gocSpawned + 1
		end
	end
	
	if gocSpawned > 0 then
		print("[BREACH] Spawned " .. gocSpawned .. " GOC players")
		// GOC ma swoją własną wiadomość dźwiękową lub brak
		// BroadcastLua( 'surface.PlaySound( "goc_arrival.ogg" )' )
	else
		print("[BREACH] Could not spawn any GOC - spawning MTF instead")
		// Jeśli nie udało się zrespić żadnego GOC, spawnuj MTF
		SpawnNTFS()
	end
end

SCP914InUse = false
function Use914( ent )
	if SCP914InUse then return false end
	SCP914InUse = true

	if SCP_914_BUTTON and ent:GetPos() != SCP_914_BUTTON then
		for k, v in pairs( ents.FindByClass( "func_door" ) ) do
			if v:GetPos() == SCP_914_DOORS[1] or v:GetPos() == SCP_914_DOORS[2] then
				v:Fire( "Close" )
				timer.Create( "914DoorOpen"..v:EntIndex(), 15, 1, function()
					v:Fire( "Open" )
				end )
			end
		end
	end

	local button = ents.FindByName( SCP_914_STATUS )[1]
	local angle = button:GetAngles().roll
	local mode = 0

	if angle == 45 then
		mode = 1
	elseif	angle == 90 then
		mode = 2
	elseif	angle == 135 then
		mode = 3
	elseif	angle == 180 then
		mode = 4
	end
	
	timer.Create( "SCP914UpgradeEnd", 16, 1, function()
		SCP914InUse = false
	end )

	timer.Create( "SCP914Upgrade", 10, 1, function()
		local items = ents.FindInBox( SCP_914_INTAKE_MINS, SCP_914_INTAKE_MAXS )
		for k, v in pairs( items ) do
			if IsValid( v ) then
				if v.HandleUpgrade then
					v:HandleUpgrade( mode, SCP_914_OUTPUT )
				elseif v.betterone or v.GetBetterOne then
					local item_class
					if v.betterone then item_class = v.betterone end
					if v.GetBetterOne then item_class = v:GetBetterOne( mode ) end

					local item = ents.Create( item_class )
					if IsValid( item ) then
						v:Remove()
						item:SetPos( SCP_914_OUTPUT )
						item:Spawn()
						WakeEntity( item )
					end
				end
			end
		end
	end )

	return true
end

function OpenSCPDoors()
	for k, v in pairs( ents.FindByClass( "func_door" ) ) do
		for k0, v0 in pairs( POS_DOOR ) do
			if ( v:GetPos() == v0 ) then
				v:Fire( "unlock" )
				v:Fire( "open" )
			end
		end
	end
	for k, v in pairs( ents.FindByClass( "func_button" ) ) do
		for k0, v0 in pairs( POS_BUTTON ) do
			if ( v:GetPos() == v0 ) then
				v:Fire( "use" )
			end
		end
	end
	for k, v in pairs( ents.FindByClass( "func_rot_button" ) ) do
		for k0, v0 in pairs( POS_ROT_BUTTON ) do
			if ( v:GetPos() == v0 ) then
				v:Fire( "use" )
			end
		end
	end
end

function GetAlivePlayers()
	local plys = {}
	for k,v in pairs(player.GetAll()) do
		if v:GTeam() != TEAM_SPEC then
			if v:Alive() or v:GetNClass() == ROLES.ROLE_SCP076 then
				table.ForceInsert(plys, v)
			end
		end
	end
	return plys
end

function BroadcastDetection( ply, tab )
	local transmit = { ply }
	local radio = ply:GetWeapon( "item_radio" )

	if radio and radio.Enabled and radio.Channel > 4 then
		local ch = radio.Channel

		for k, v in pairs( player.GetAll() ) do
			if v:GTeam() != TEAM_SCP and v:GTeam() != TEAM_SPEC and v != ply then
				local r = v:GetWeapon( "item_radio" )

				if r and r.Enabled and r.Channel == ch then
					table.insert( transmit, v )
				end
			end
		end
	end

	local info = {}

	for k, v in pairs( tab ) do
		table.insert( info, {
			name = v:GetNClass(),
			pos = v:GetPos() + v:OBBCenter()
		} )
	end

	net.Start( "CameraDetect" )
		net.WriteTable( info )
	net.Send( transmit )
end

function GM:GetFallDamage( ply, speed )
	return ( speed / 6 )
end

function PlayerCount()
	return #player.GetAll()
end

function GM:OnEntityCreated( ent )
	ent:SetShouldPlayPickupSound( false )
end

function GetPlayer(nick)
	for k,v in pairs(player.GetAll()) do
		if v:Nick() == nick then
			return v
		end
	end
	return nil
end

function CreateRagdollPL(victim, attacker, dmgtype)
	if victim:GetGTeam() == TEAM_SPEC then return end
	if not IsValid(victim) then return end

	local rag = ents.Create("prop_ragdoll")
	if not IsValid(rag) then return nil end

	rag:SetPos(victim:GetPos())
	rag:SetModel(victim:GetModel())
	rag:SetAngles(victim:GetAngles())
	rag:SetColor(victim:GetColor())

	rag:Spawn()
	rag:Activate()
	
	// Copy bodygroups from player to ragdoll
	for i = 0, victim:GetNumBodyGroups() - 1 do
		local bodygroup = victim:GetBodygroup(i)
		rag:SetBodygroup(i, bodygroup)
	end
	
	// Copy model scale (for Child D and others)
	local modelScale = victim:GetModelScale()
	if modelScale and modelScale != 1 then
		rag:SetModelScale(modelScale, 0)
	end
	
	// Note: Ragdolls don't support SetPlayerColor, so we skip this
	
	// Copy bone manipulations (for Fat D, Skinny D, etc.)
	timer.Simple(0.1, function()
		if IsValid(rag) and IsValid(victim) then
			// Copy all bone manipulations from player to ragdoll
			for i = 0, victim:GetBoneCount() - 1 do
				local boneName = victim:GetBoneName(i)
				if boneName then
					local boneScale = victim:GetManipulateBoneScale(i)
					local bonePos = victim:GetManipulateBonePosition(i)
					local boneAng = victim:GetManipulateBoneAngles(i)
					
					// Only copy if bone manipulation is not default
					if boneScale != Vector(1, 1, 1) or bonePos != Vector(0, 0, 0) or boneAng != Angle(0, 0, 0) then
						local ragBoneID = rag:LookupBone(boneName)
						if ragBoneID then
							rag:ManipulateBoneScale(ragBoneID, boneScale)
							rag:ManipulateBonePosition(ragBoneID, bonePos)
							rag:ManipulateBoneAngles(ragBoneID, boneAng)
						end
					end
				end
			end
		end
	end)
	
	rag.Info = {}
	rag.Info.CorpseID = rag:GetCreationID()
	rag:SetNWInt( "CorpseID", rag.Info.CorpseID )
	rag.Info.Victim = victim:Nick()
	rag.Info.DamageType = dmgtype
	rag.Info.Time = CurTime()
	
	local group = COLLISION_GROUP_DEBRIS_TRIGGER
	rag:SetCollisionGroup(group)
	timer.Simple( 1, function() if IsValid( rag ) then rag:CollisionRulesChanged() end end )
	timer.Simple( 60, function() if IsValid( rag ) then rag:Remove() end end )
	
	local num = rag:GetPhysicsObjectCount()-1
	local v = victim:GetVelocity() * 0.35
	
	for i=0, num do
		local bone = rag:GetPhysicsObjectNum(i)
		if IsValid(bone) then
		local bp, ba = victim:GetBonePosition(rag:TranslatePhysBoneToBone(i))
		if bp and ba then
			bone:SetPos(bp)
			bone:SetAngles(ba)
		end
		bone:SetVelocity(v * 1.2)
		end
	end
end

function ServerSound( file, ent, filter )
	ent = ent or game.GetWorld()
	if !filter then
		filter = RecipientFilter()
		filter:AddAllPlayers()
	end

	local sound = CreateSound( ent, file, filter )

	return sound
end

inUse = false
function explodeGateA( ply )
	if ply and !isInTable( ply, ents.FindInSphere(POS_EXPLODE_A, 250) ) then return end
	if inUse == true then return end
	if isGateAOpen() then return end
	inUse = true
	
	local filter = RecipientFilter()
	filter:AddAllPlayers()
	local sound = CreateSound( game.GetWorld(), "ambient/alarms/alarm_citizen_loop1.wav", filter )
	sound:SetSoundLevel( 0 )
	
	BroadcastLua( 'surface.PlaySound("radio/franklin1.ogg")' )
	sound:Play()
	sound:ChangeVolume( 0.25 )
	local waitTime = GetConVar( "br_time_explode" ):GetInt()
	local ttime = 0
	PrintMessage( HUD_PRINTTALK, "Time to Gate A explosion: "..waitTime.."s")
	timer.Create( "GateExplode", 1, waitTime, function()
		if ttime > waitTime then return end
		if isGateAOpen() then 
			timer.Destroy( "GateExplode" )
			sound:Stop()
			PrintMessage( HUD_PRINTTALK, "Gate A explosion terminated")
			inUse = false
			return
		end
		
		ttime = ttime + 1
		if ttime % 5 == 0 then PrintMessage( HUD_PRINTTALK, "Time to Gate A explosion: "..waitTime - ttime.."s" ) end
		if ttime + 1 == waitTime then sound:Stop() end
		if ttime == waitTime then
			BroadcastLua( 'surface.PlaySound("ambient/explosions/exp2.wav")' )
			local explosion = ents.Create( "env_explosion" ) // Creating our explosion
			explosion:SetKeyValue( "spawnflags", 210 ) //Setting the key values of the explosion 
			explosion:SetPos( POS_MIDDLE_GATE_A )
			explosion:Spawn()
			explosion:Fire( "explode", "", 0 )
			destroyGate()
			takeDamage( explosion, ply )
			if ply then
				ply:AddExp(100, true)
			end
		end
	end )
end

function takeDamage( ent, ply )
	local dmg = 0
	for k, v in pairs( ents.FindInSphere( POS_MIDDLE_GATE_A, 1000 ) ) do
		if v:IsPlayer() then
			if v:Alive() then
				if v:GTeam() != TEAM_SPEC then
					dmg = ( 1001 - v:GetPos():Distance( POS_MIDDLE_GATE_A ) ) * 10
					if dmg > 0 then 
						v:TakeDamage( dmg, ply or v, ent )
					end
				end
			end
		end
	end
end

function destroyGate()
	if isGateAOpen() then return end
	local doorsEnts = ents.FindInSphere( POS_MIDDLE_GATE_A, 125 )
	for k, v in pairs( doorsEnts ) do
		if v:GetClass() == "prop_dynamic" or v:GetClass() == "func_door" then
			v:Remove()
		end
	end
end

function isGateAOpen()
	local doors = ents.FindInSphere( POS_MIDDLE_GATE_A, 125 )
	for k, v in pairs( doors ) do
		if v:GetClass() == "prop_dynamic" then 
			if isInTable( v:GetPos(), POS_GATE_A_DOORS ) then return false end
		end
	end
	return true
end

function Recontain106( ply )
	if Recontain106Used then
		ply:PrintMessage( HUD_PRINTCENTER, "SCP 106 recontain procedure can be triggered only once per round" )
		return false
	end

	local cage
	for k, v in pairs( ents.GetAll() ) do
		if v:GetPos() == CAGE_DOWN_POS then
			cage = v
			break
		end
	end
	if !cage then
		ply:PrintMessage( HUD_PRINTCENTER, "Power down ELO-IID electromagnet in order to start SCP 106 recontain procedure" )
		return false
	end

	local e = ents.FindByName( SOUND_TRANSMISSION_NAME )[1]
	if e:GetAngles().roll == 0 then
		ply:PrintMessage( HUD_PRINTCENTER, "Enable sound transmission in order to start SCP 106 recontain procedure" )
		return false
	end

	local fplys = ents.FindInBox( CAGE_BOUNDS.MINS, CAGE_BOUNDS.MAXS )
	local plys = {}
	for k, v in pairs( fplys ) do
		if IsValid( v ) and v:IsPlayer() and v:GTeam() != TEAM_SPEC and v:GTeam() != TEAM_SCP then
			table.insert( plys, v )
		end
	end

	if #plys < 1 then
		ply:PrintMessage( HUD_PRINTCENTER, "Living human in cage is required in order to start SCP 106 recontain procedure" )
		return false
	end

	local scps = {}
	for k, v in pairs( player.GetAll() ) do
		if IsValid( v ) and v:GTeam() == TEAM_SCP and v:GetNClass() == ROLES.ROLE_SCP106 then
			table.insert( scps, v )
		end
	end

	if #scps < 1 then
		ply:PrintMessage( HUD_PRINTCENTER, "SCP 106 is already recontained" )
		return false
	end

	Recontain106Used = true

	timer.Simple( 6, function()
		if postround or !Recontain106Used then return end
		for k, v in pairs( plys ) do
			if IsValid( v ) then
				v:Kill()
			end
		end

		for k, v in pairs( scps ) do
			if IsValid( v ) then
				local swep = v:GetActiveWeapon()
				if IsValid( swep ) and swep:GetClass() == "weapon_scp_106" then
					swep:TeleportSequence( CAGE_INSIDE )
				end
			end
		end

		timer.Simple( 11, function()
			if postround or !Recontain106Used then return end
			for k, v in pairs( scps ) do
				if IsValid( v ) then
					v:Kill()
				end
			end
			local eloiid = ents.FindByName( ELO_IID_NAME )[1]
			eloiid:Use( game.GetWorld(), game.GetWorld(), USE_TOGGLE, 1 )
			if IsValid( ply ) then
				ply:PrintMessage(HUD_PRINTTALK, "You've been awarded with 10 points for recontaining SCP 106!")
				ply:AddFrags( 10 )
			end
		end )


	end )

	return true
end

OMEGAEnabled = false
OMEGADoors = false
-- Funkcja sprawdzająca czy gracz może aktywować Omega Warhead
function CanActivateOmegaWarhead( ply )
	-- 1. Sprawdź czy warhead jest włączony
	if GetConVar( "br_enable_warhead" ):GetInt() != 1 then
		return false, "You inserted keycard but nothing happened"
	end

	-- 2. Sprawdź czy dźwignia istnieje i czy nie jest wyłączona (obrócona)
	local remote = ents.FindByName( OMEGA_REMOTE_NAME )[1]
	if IsValid( remote ) and remote:GetAngles().pitch == 180 then
		return false, "OMEGA Warhead has been disabled"
	end

	-- 3. Sprawdź czy zostało więcej niż 10 minut rundy (blokada aktywna gdy za dużo czasu)
	if timer.Exists("RoundTime") then
		local timeLeft = timer.TimeLeft("RoundTime")
		
		if timeLeft > 600 then -- 600 sekund = 10 minut
			local minutes = math.floor(timeLeft / 60)
			local seconds = math.floor(timeLeft % 60)
			return false, string.format("OMEGA Warhead is locked until 10:00 remaining. Current time: %d:%02d", minutes, seconds)
		end
	end

	-- 4. Sprawdź czy gracz może aktywować warhead na podstawie teamów
	local playerTeam = ply:GTeam()
	local playerClass = ply:GetNClass()
	
	-- SCP - całkowity zakaz aktywacji
	if playerTeam == TEAM_SCP then
		return false, "SCP entities cannot activate OMEGA Warhead"
	end
	
	-- MTF/Guard - nie mogą aktywować jeśli w placówce są żywi naukowcy
	if playerTeam == TEAM_GUARD then
		local scientistsInside = {}
		local scientistsOutside = 0
		
		for k, v in pairs(player.GetAll()) do
			if IsValid(v) and v:Alive() and v:GTeam() == TEAM_SCI then
				-- Sprawdź czy naukowiec jest w placówce (nie na zewnątrz)
				if not OUTSIDE_BUFF or not OUTSIDE_BUFF(v:GetPos()) then
					table.insert(scientistsInside, v:Nick())
				else
					scientistsOutside = scientistsOutside + 1
				end
			end
		end
		
		if #scientistsInside > 0 then
			local message = string.format("Cannot detonate OMEGA Warhead! %d scientists still inside facility: %s", 
				#scientistsInside, table.concat(scientistsInside, ", "))
			if scientistsOutside > 0 then
				message = message .. string.format(" (%d already evacuated)", scientistsOutside)
			end
			return false, message
		end
	end
	
	-- Chaos Insurgency - nie mogą aktywować jeśli w placówce są żywi Class-D
	if playerTeam == TEAM_CHAOS then
		local classDInside = {}
		local classDOutside = 0
		
		for k, v in pairs(player.GetAll()) do
			if IsValid(v) and v:Alive() and v:GTeam() == TEAM_CLASSD then
				-- Sprawdź czy Class-D jest w placówce (nie na zewnątrz)
				if not OUTSIDE_BUFF or not OUTSIDE_BUFF(v:GetPos()) then
					table.insert(classDInside, v:Nick())
				else
					classDOutside = classDOutside + 1
				end
			end
		end
		
		if #classDInside > 0 then
			local message = string.format("Cannot detonate OMEGA Warhead! %d Class-D personnel still inside facility: %s", 
				#classDInside, table.concat(classDInside, ", "))
			if classDOutside > 0 then
				message = message .. string.format(" (%d already evacuated)", classDOutside)
			end
			return false, message
		end
	end
	
	-- Class-D - nie mogą aktywować jeśli w placówce są żywi Class-D
	if playerTeam == TEAM_CLASSD then
		local classDInside = {}
		local classDOutside = 0
		
		for k, v in pairs(player.GetAll()) do
			if IsValid(v) and v:Alive() and v:GTeam() == TEAM_CLASSD and v != ply then -- Pomijamy aktywującego gracza
				-- Sprawdź czy Class-D jest w placówce (nie na zewnątrz)
				if not OUTSIDE_BUFF or not OUTSIDE_BUFF(v:GetPos()) then
					table.insert(classDInside, v:Nick())
				else
					classDOutside = classDOutside + 1
				end
			end
		end
		
		if #classDInside > 0 then
			local message = string.format("Cannot detonate OMEGA Warhead! %d other Class-D personnel still inside facility: %s", 
				#classDInside, table.concat(classDInside, ", "))
			if classDOutside > 0 then
				message = message .. string.format(" (%d already evacuated)", classDOutside)
			end
			return false, message
		end
	end
	
	-- Scientists - nie mogą aktywować jeśli w placówce są żywi naukowcy
	if playerTeam == TEAM_SCI then
		local scientistsInside = {}
		local scientistsOutside = 0
		
		for k, v in pairs(player.GetAll()) do
			if IsValid(v) and v:Alive() and v:GTeam() == TEAM_SCI and v != ply then -- Pomijamy aktywującego gracza
				-- Sprawdź czy naukowiec jest w placówce (nie na zewnątrz)
				if not OUTSIDE_BUFF or not OUTSIDE_BUFF(v:GetPos()) then
					table.insert(scientistsInside, v:Nick())
				else
					scientistsOutside = scientistsOutside + 1
				end
			end
		end
		
		if #scientistsInside > 0 then
			local message = string.format("Cannot detonate OMEGA Warhead! %d other scientists still inside facility: %s", 
				#scientistsInside, table.concat(scientistsInside, ", "))
			if scientistsOutside > 0 then
				message = message .. string.format(" (%d already evacuated)", scientistsOutside)
			end
			return false, message
		end
	end
	
	-- Wszystkie warunki spełnione - można aktywować warhead
	local playerTeam = ply:GTeam()
	local successMessage = "OMEGA Warhead activation authorized"
	
	if playerTeam == TEAM_GUARD then
		successMessage = "All scientists evacuated. OMEGA Warhead activation authorized"
	elseif playerTeam == TEAM_GOC then
		successMessage = "OMEGA Warhead activation authorized"
	elseif playerTeam == TEAM_CHAOS then
		successMessage = "All Class-D personnel evacuated. OMEGA Warhead activation authorized"
	elseif playerTeam == TEAM_CLASSD then
		successMessage = "All other Class-D personnel evacuated. OMEGA Warhead activation authorized"
	elseif playerTeam == TEAM_SCI then
		successMessage = "All other scientists evacuated. OMEGA Warhead activation authorized"
	end
	
	return true, successMessage
end

function OMEGAWarhead( ply )
	if OMEGAEnabled then return end

	-- Sprawdź wszystkie warunki aktywacji
	local canActivate, message = CanActivateOmegaWarhead( ply )
	if not canActivate then
		ply:PrintMessage( HUD_PRINTCENTER, message )
		return
	end
	
	-- Wyświetl komunikat sukcesu
	ply:PrintMessage( HUD_PRINTCENTER, message )
	PrintMessage( HUD_PRINTTALK, ply:Nick() .. " activated OMEGA Warhead!" )

	OMEGAEnabled = true

	//local alarm = ServerSound( "warhead/alarm.ogg" )
	//alarm:SetSoundLevel( 0 )
	//alarm:Play()
	net.Start( "SendSound" )
		net.WriteInt( 1, 2 )
		net.WriteString( "warhead/alarm.ogg" )
	net.Broadcast()

	timer.Create( "omega_announcement", 3, 1, function()
		//local announcement = ServerSound( "warhead/announcement.ogg" )
		//announcement:SetSoundLevel( 0 )
		//announcement:Play()
		net.Start( "SendSound" )
			net.WriteInt( 1, 2 )
			net.WriteString( "warhead/announcement.ogg" )
		net.Broadcast()

		timer.Create( "omega_delay", 11, 1, function()
			for k, v in pairs( ents.FindByClass( "func_door" ) ) do
				if IsInTolerance( OMEGA_GATE_A_DOORS[1], v:GetPos(), 100 ) or IsInTolerance( OMEGA_GATE_A_DOORS[2], v:GetPos(), 100 ) then
					v:Fire( "Unlock" )
					v:Fire( "Open" )
					v:Fire( "Lock" )
				end
			end

			OMEGADoors = true

			//local siren = ServerSound( "warhead/siren.ogg" )
			//siren:SetSoundLevel( 0 )
			//siren:Play()
			net.Start( "SendSound" )
				net.WriteInt( 1, 2 )
				net.WriteString( "warhead/siren.ogg" )
			net.Broadcast()
			timer.Create( "omega_alarm", 12, 5, function()
				//siren = ServerSound( "warhead/siren.ogg" )
				//siren:SetSoundLevel( 0 )
				//siren:Play()
				net.Start( "SendSound" )
					net.WriteInt( 1, 2 )
					net.WriteString( "warhead/siren.ogg" )
				net.Broadcast()
			end )

			// OPTYMALIZACJA: Sprawdzaj co 3 sekundy zamiast co sekundę
			local checkCount = 0
			local maxChecks = 30 // 30 sprawdzeń co 3 sekundy = 90 sekund

			local function OptimizedOmegaCheck()
				checkCount = checkCount + 1

				local remote_check = ents.FindByName( OMEGA_REMOTE_NAME )[1]
				if (IsValid( remote_check ) and remote_check:GetAngles().pitch == 180) or !OMEGAEnabled then
					WarheadDisabled( siren )
					return // Early exit
				end

				if checkCount < maxChecks then
					timer.Simple(3, OptimizedOmegaCheck) // Co 3 sekundy zamiast co sekundę
				end
			end

			OptimizedOmegaCheck() // Rozpocznij sprawdzanie
		end )

		timer.Create( "omega_detonation", 90, 1, function()
			//local boom = ServerSound( "warhead/explosion.ogg" )
			//boom:SetSoundLevel( 0 )
			//boom:Play()
			net.Start( "SendSound" )
				net.WriteInt( 1, 2 )
				net.WriteString( "warhead/explosion.ogg" )
			net.Broadcast()
			for k, v in pairs( player.GetAll() ) do
				v:Kill()
			end
		end )
	end )
end

function WarheadDisabled( siren )
	OMEGAEnabled = false
	OMEGADoors = false

	//if siren then
		//siren:Stop()
	//end
	net.Start( "SendSound" )
		net.WriteInt( 0, 2 )
		net.WriteString( "warhead/siren.ogg" )
	net.Broadcast()

	if timer.Exists( "omega_check" ) then timer.Remove( "omega_check" ) end
	if timer.Exists( "omega_alarm" ) then timer.Remove( "omega_alarm" ) end
	if timer.Exists( "omega_detonation" ) then timer.Remove( "omega_detonation" ) end
	
	for k, v in pairs( ents.FindByClass( "func_door" ) ) do
		if IsInTolerance( OMEGA_GATE_A_DOORS[1], v:GetPos(), 100 ) or IsInTolerance( OMEGA_GATE_A_DOORS[2], v:GetPos(), 100 ) then
			v:Fire( "Unlock" )
			v:Fire( "Close" )
		end
	end
end

function GM:BreachSCPDamage( ply, ent, dmg )
	if IsValid( ply ) and IsValid( ent ) then
		if ent:GetClass() == "func_breakable" then
			ent:TakeDamage( dmg, ply, ply )
			return true
		end
	end
end

function isInTable( element, tab )
	for k, v in pairs( tab ) do
		if v == element then return true end
	end
	return false
end

function DARK()
    -- Ustawienie normalnego oświetlenia zamiast jasnego 'a'
    engine.LightStyle( 0, "m" )  -- 'm' = normalne oświetlenie zamiast 'a' = maksymalna jasność
    BroadcastLua('render.RedownloadAllLightmaps(true)')
    BroadcastLua('RunConsoleCommand("mat_specular", 0)')  -- mat_specular na 0 dla SCP: Breach
end

-- Funkcja przywracająca normalne ustawienia renderowania
function RestoreNormalLighting()
    engine.LightStyle( 0, "m" )  -- Normalne oświetlenie
    BroadcastLua('render.RedownloadAllLightmaps(true)')
    BroadcastLua('RunConsoleCommand("mat_specular", 0)')  -- mat_specular na 0 dla SCP: Breach
    BroadcastLua('RunConsoleCommand("mat_bloom_scalefactor_scalar", 1)')
    print("[BREACH] Przywrócono normalne ustawienia oświetlenia mapy")
end

-- Komenda dla administratorów do ręcznego przywracania normalnego oświetlenia
concommand.Add("br_fix_lighting", function(ply, cmd, args)
    if IsValid(ply) and !ply:IsAdmin() then
        ply:PrintMessage(HUD_PRINTTALK, "[BREACH] Tylko administratorzy mogą używać tej komendy!")
        return
    end
    
    RestoreNormalLighting()
    
    if IsValid(ply) then
        ply:PrintMessage(HUD_PRINTTALK, "[BREACH] Przywrócono normalne oświetlenie mapy")
    end
end)

// NAPRAWA PROBLEMU Z MAP_LOADED
hook.Add("InitPostEntity", "BreachMapLoadedEmergencyFix", function()
    -- Przywróć normalne ustawienia oświetlenia po załadowaniu mapy
    timer.Simple(1, function()
        RestoreNormalLighting()
    end)
    
    timer.Simple(2, function()
        if not MAP_LOADED then
            print("[BREACH FIX] UWAGA: MAP_LOADED = false! Wymuszam true dla mapy: " .. game.GetMap())
            MAP_LOADED = true
        end
        
        -- Inicjalizuj zmienne globalne jeśli to pierwsza runda
        if rounds == -1 then
            print("[BREACH FIX] Inicjalizacja zmiennych dla pierwszej rundy")
            itemsSpawned = false
            gamestarted = false
            preparing = false
            postround = false
        end
    end)
end)

// Usunięto nadpisywanie RoundRestart - może powodować problemy

print("[BREACH] Załadowano awaryjną naprawę systemu rund")

// Hook blokujący obrażenia dla ammo kitów CW2.0
hook.Add("EntityTakeDamage", "BR_BlockAmmoKitDamage", function(target, dmginfo)
	if not IsValid(target) then return end
	
	local class = target:GetClass()
	// Blokuj obrażenia dla wszystkich ammo kitów CW2.0
	if string.StartWith(class, "cw_ammo_") then
		// Całkowicie anuluj obrażenia
		dmginfo:SetDamage(0)
		dmginfo:ScaleDamage(0)
		return true // Blokuj dalsze przetwarzanie
	end
end)

print("[BREACH] Załadowano ochronę ammo kitów przed eksplozją")

// Debug command to spawn kebab stand
concommand.Add("br_spawn_kebab", function(ply, cmd, args)
	if not IsValid(ply) or not ply:IsAdmin() then return end
	
	// Remove existing kebab stands
	for _, ent in pairs( ents.FindByClass("br_kebab_stand") ) do
		if IsValid(ent) then
			ent:Remove()
		end
	end
	
	// Spawn new kebab stand
	local kebab_stand = ents.Create( "br_kebab_stand" )
	if IsValid( kebab_stand ) then
		kebab_stand:SetPos( Vector(227.936295, 3185.166016, -87.968750) )
		kebab_stand:SetAngles( Angle(0, 0, 0) )
		kebab_stand:Spawn()
		ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] Kebab stand spawned at cafeteria")
		print("[BREACH ADMIN] " .. ply:Nick() .. " spawned kebab stand")
	else
		ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] ERROR: Failed to spawn kebab stand!")
		print("[BREACH ERROR] Failed to create br_kebab_stand entity for " .. ply:Nick())
	end
end)

// Test command to check position
concommand.Add("br_test_pos", function(ply, cmd, args)
	if not IsValid(ply) or not ply:IsAdmin() then return end
	
	// Spawn test prop
	local test_prop = ents.Create( "prop_physics" )
	if IsValid( test_prop ) then
		test_prop:SetModel("models/props_c17/oildrum001.mdl")
		test_prop:SetPos( Vector(227.936295, 3185.166016, -87.968750) )
		test_prop:SetAngles( Angle(0, 0, 0) )
		test_prop:Spawn()
		ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] Test prop spawned at kebab position")
	else
		ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] ERROR: Failed to spawn test prop!")
	end
end)

// Test command to spawn kebab meat
concommand.Add("br_test_meat", function(ply, cmd, args)
	if not IsValid(ply) or not ply:IsAdmin() then return end
	
	// Spawn kebab meat at player position
	local kebab_meat = ents.Create( "br_kebab_meat" )
	if IsValid( kebab_meat ) then
		kebab_meat:SetPos( ply:GetPos() + ply:GetForward() * 50 + Vector(0,0,20) )
		kebab_meat:SetAngles( ply:GetAngles() )
		kebab_meat:Spawn()
		ply:PrintMessage(HUD_PRINTTALK, "[BREACH] Spawned kebab meat")
	end
end)

// SCP-294 admin commands
concommand.Add("br_spawn_scp294", function(ply, cmd, args)
	if not IsValid(ply) or not ply:IsAdmin() then return end
	
	local scp294 = ents.Create("scp_294")
	if IsValid(scp294) then
		scp294:SetPos(ply:GetPos() + ply:GetForward() * 100)
		scp294:SetAngles(ply:GetAngles())
		scp294:Spawn()
		scp294:Activate()
		ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] Spawned SCP-294 Coffee Machine")
	end
end)

concommand.Add("br_find_scp294", function(ply, cmd, args)
	if not IsValid(ply) or not ply:IsAdmin() then return end
	
	local found = 0
	for _, ent in pairs(ents.GetAll()) do
		if IsValid(ent) and ent:GetModel() == "models/vinrax/scp294/scp294.mdl" then
			found = found + 1
			ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] Found model at: " .. tostring(ent:GetPos()))
		end
	end
	
	if found == 0 then
		ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] No SCP-294 models found on this map")
	else
		ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] Found " .. found .. " SCP-294 models")
	end
end)

concommand.Add("br_convert_scp294", function(ply, cmd, args)
	if not IsValid(ply) or not ply:IsAdmin() then return end
	
	local converted = 0
	for _, ent in pairs(ents.GetAll()) do
		if IsValid(ent) and ent:GetModel() == "models/vinrax/scp294/scp294.mdl" then
			// Create interactive entity
			local scp294 = ents.Create("scp_294")
			if IsValid(scp294) then
				scp294:SetPos(ent:GetPos())
				scp294:SetAngles(ent:GetAngles())
				scp294:Spawn()
				scp294:Activate()
				
				// Remove original model
				ent:Remove()
				converted = converted + 1
			end
		end
	end
	
	ply:PrintMessage(HUD_PRINTTALK, "[SCP-294] Converted " .. converted .. " SCP-294 models to interactive entities")
end)

-- Komenda do spawnowania SCP-035 maski
concommand.Add("br_spawn_scp035", function(ply, cmd, args)
	if not IsValid(ply) or not ply:IsAdmin() then return end
	
	local mask = ents.Create("scp_035")
	if IsValid(mask) then
		mask:SetPos(ply:GetPos() + ply:GetForward() * 100)
		mask:SetAngles(ply:GetAngles())
		mask:Spawn()
		mask:Activate()
		
		ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] SCP-035 mask spawned")
		print("[ADMIN] " .. ply:Nick() .. " spawned SCP-035 mask")
	end
end)

-- Komenda do spawnowania interkomu
concommand.Add("br_spawn_intercom", function(ply, cmd, args)
	if not IsValid(ply) or not ply:IsAdmin() then return end
	
	local intercom = ents.Create("br_intercom")
	if IsValid(intercom) then
		intercom:SetPos(ply:GetPos() + ply:GetForward() * 100)
		intercom:SetAngles(ply:GetAngles())
		intercom:Spawn()
		
		ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] Facility Intercom spawned")
		print("[ADMIN] " .. ply:Nick() .. " spawned Facility Intercom")
	end
end)

-- Komenda do testowania interkomu
concommand.Add("br_test_intercom", function(ply, cmd, args)
	if not IsValid(ply) or not ply:IsAdmin() then return end
	
	-- Broadcast test message to all players
	for _, v in pairs(player.GetAll()) do
		if IsValid(v) and v:Alive() and v:GTeam() != TEAM_SPEC then
			v:PrintMessage(HUD_PRINTTALK, "[FACILITY INTERCOM] *** TEST TRANSMISSION ***")
			v:PrintMessage(HUD_PRINTTALK, "[FACILITY INTERCOM] This is a test of the facility intercom system.")
			v:PrintMessage(HUD_PRINTTALK, "[FACILITY INTERCOM] *** END TEST ***")
		end
	end
	
	ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] Intercom test broadcast sent")
	print("[ADMIN] " .. ply:Nick() .. " sent intercom test broadcast")
end)

-- Komenda do spawnowania SCP-268
concommand.Add("br_spawn_scp268", function(ply, cmd, args)
	if not IsValid(ply) or not ply:IsAdmin() then return end
	
	local scp268 = ents.Create("item_scp_268")
	if IsValid(scp268) then
		scp268:SetPos(ply:GetPos() + ply:GetForward() * 100 + Vector(0, 0, 20))
		scp268:SetAngles(ply:GetAngles())
		scp268:Spawn()
		scp268:Activate()
		
		ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] SCP-268 (Berret of Invisibility) spawned")
		print("[ADMIN] " .. ply:Nick() .. " spawned SCP-268")
	end
end)

-- Komenda do dania graczowi SCP-268
concommand.Add("br_give_scp268", function(ply, cmd, args)
	if not IsValid(ply) or not ply:IsAdmin() then return end
	
	local target = ply
	if args[1] then
		target = nil
		for _, v in pairs(player.GetAll()) do
			if string.find(string.lower(v:Nick()), string.lower(args[1])) then
				target = v
				break
			end
		end
		
		if not IsValid(target) then
			ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] Player not found: " .. args[1])
			return
		end
	end
	
	if target:HasWeapon("item_scp_268") then
		ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] " .. target:Nick() .. " already has SCP-268")
		return
	end
	
	target:Give("item_scp_268")
	ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] Gave SCP-268 to " .. target:Nick())
	target:PrintMessage(HUD_PRINTTALK, "[ADMIN] You received SCP-268 - The Berret of Invisibility")
	print("[ADMIN] " .. ply:Nick() .. " gave SCP-268 to " .. target:Nick())
end)




================================================
FILE: gamemodes/breach/gamemode/modules/sv_player.lua
================================================
local mply = FindMetaTable( "Player" )

-- Network string dla vest HUD
util.AddNetworkString("BR_UpdateVest")

-- Network string dla NVG
util.AddNetworkString("NVG_Toggle")

-- Clear NVG when player dies
hook.Add("PlayerDeath", "ClearNVGOnDeath", function(victim, inflictor, attacker)
	if IsValid(victim) then
		victim.NVGActive = false
		net.Start("NVG_Toggle")
			net.WriteBool(false)
		net.Send(victim)
	end
end)

-- Clear NVG when player spawns
hook.Add("PlayerSpawn", "ClearNVGOnSpawn", function(ply)
	if IsValid(ply) then
		ply.NVGActive = false
		net.Start("NVG_Toggle")
			net.WriteBool(false)
		net.Send(ply)
	end
end)

function mply:PrintTranslatedMessage( string )
	net.Start( "TranslatedMessage" )
		net.WriteString( string )
		//net.WriteBool( center or false )
	net.Send( self )
end

function mply:ForceDropWeapon( class )
	if self:HasWeapon( class ) then
		local wep = self:GetWeapon( class )
		if IsValid( wep ) and IsValid( self ) then
			if self:GTeam() == TEAM_SPEC then return end
			local atype = wep:GetPrimaryAmmoType()
			if atype > 0 then
				wep.SavedAmmo = wep:Clip1()
			end	
			if wep:GetClass() == nil then return end
			if wep.droppable != nil and !wep.droppable then return end
			self:DropWeapon( wep )
			self:ConCommand( "lastinv" )
		end
	end
end

function mply:DropAllWeapons( strip )
	if GetConVar( "br_dropvestondeath" ):GetInt() != 0 then
		self:UnUseArmor()
	end
	if #self:GetWeapons() > 0 then
		local pos = self:GetPos()
		for k, v in pairs( self:GetWeapons() ) do
			local candrop = true
			if v.droppable != nil then
				if v.droppable == false then
					candrop = false
				end
			end
			if candrop then
				local class = v:GetClass()
				local wep = ents.Create( class )
				if IsValid( wep ) then
					wep:SetPos( pos )
					wep:Spawn()
					if class == "br_keycard" then
						local cardtype = v.KeycardType or v:GetNWString( "K_TYPE", "safe" )
						wep:SetKeycardType( cardtype )
					end
					local atype = v:GetPrimaryAmmoType()
					if atype > 0 then
						wep.SavedAmmo = v:Clip1()
					end
				end
			end
			if strip then
				v:Remove()
			end
		end
	end
end

// just for finding a bad spawns :p
function mply:FindClosest(tab, num)
	local allradiuses = {}
	for k,v in pairs(tab) do
		table.ForceInsert(allradiuses, {v:Distance(self:GetPos()), v})
	end
	table.sort( allradiuses, function( a, b ) return a[1] < b[1] end )
	local rtab = {}
	for i=1, num do
		if i <= #allradiuses then
			table.ForceInsert(rtab, allradiuses[i])
		end
	end
	return rtab
end

function mply:GiveRandomWep(tab)
	local mainwep = table.Random(tab)
	self:Give(mainwep)
	local getwep = self:GetWeapon(mainwep)
	if getwep.Primary == nil then
		print("ERROR: weapon: " .. mainwep)
		print(getwep)
		return
	end
	getwep:SetClip1(getwep.Primary.ClipSize)
	self:SelectWeapon(mainwep)
	self:GiveAmmo((getwep.Primary.ClipSize * 4), getwep.Primary.Ammo, false)
end

function mply:GiveNTFwep()
	self:GiveRandomWep({"cw_ump45", "cw_mp5"})
end

function mply:GiveMTFwep()
	self:GiveRandomWep({"cw_ar15", "cw_ump45", "cw_mp5"})
end

function mply:GiveCIwep()
	self:GiveRandomWep({"cw_ak74", "cw_scarh", "cw_g36c"})
end

function mply:DeleteItems()
	for k,v in pairs(ents.FindInSphere( self:GetPos(), 150 )) do
		if v:IsWeapon() then
			if !IsValid(v.Owner) then
				v:Remove()
			end
		end
	end
end

function mply:ApplyArmor(name)
	-- Security Droid nie może nosić vestów
	if self:GetNClass() == ROLES.ROLE_SECURITY_DROID then
		self:PrintMessage(HUD_PRINTTALK, "[SYSTEM] ERROR: Armor incompatible with droid chassis!")
		self:EmitSound("ambient/energy/spark" .. math.random(1, 6) .. ".wav", 75, math.random(90, 110))
		return
	end
	
	-- SCP-035 system vestów
	if self:GetNClass() == ROLES.ROLE_SCP035 then
		if self.LockedArmor == true then
			-- Miał vest przed transformacją - nie może go zmienić
			self:PrintMessage(HUD_PRINTTALK, "[SCP-035] Your vest is fused with your body and cannot be changed!")
			print("[SCP-035 DEBUG] " .. self:Nick() .. " tried to change locked vest")
			return
		elseif self.LockedArmor == false then
			-- Nie miał vesta przed transformacją - nie może założyć żadnego
			self:PrintMessage(HUD_PRINTTALK, "[SCP-035] The vest phases through your corrupted body...")
			print("[SCP-035 DEBUG] " .. self:Nick() .. " tried to equip vest but had none before transformation")
			return
		else
			-- LockedArmor nie jest ustawione - gracz nie był SCP-035 od początku
			self:PrintMessage(HUD_PRINTTALK, "[SCP-035] ERROR: Invalid vest state for SCP-035!")
			print("[SCP-035 ERROR] " .. self:Nick() .. " has undefined LockedArmor state")
			return
		end
	end
	
	self.BaseStats = {
		wspeed = self:GetWalkSpeed(),
		rspeed = self:GetRunSpeed(),
		jpower = self:GetJumpPower(),
		model = self:GetModel(),
		bodygroups = {}
	}
	
	-- Zapisz obecne bodygroups
	for i = 0, 14 do
		self.BaseStats.bodygroups[i] = self:GetBodygroup(i)
	end

	local stats = 0.9
	if name == "armor_ntf" then
		self:SetModel("models/kyo/reyes_deadofnight_pm.mdl")
		stats = 0.8
	elseif name == "armor_mtfguard" then
		self:SetModel("models/scp/guard_noob.mdl")
		stats = 0.85
	elseif name == "armor_mtfcom" then
		self:SetModel("models/scp/captain.mdl")
		stats = 0.9
	elseif name == "armor_mtfl" then
		self:SetModel("models/scp/guard_left.mdl")
		stats = 0.85
	elseif name == "armor_mtfmedic" then
		self:SetModel("models/scp/guard_med.mdl")
		stats = 0.9
	elseif name == "armor_security" then
		self:SetModel("models/scp/guard_sci.mdl")
		stats = 0.92
	elseif name == "armor_fireproof" then
		self:SetModel("models/player/kerry/class_securety.mdl")
		stats = 0.9
	elseif name == "armor_chaosins" then
		self:SetModel("models/chaos_insurgency_trooper/chaos_insurgency_trooper.mdl")
		stats = 0.85
	elseif name == "armor_chaosjugg" then
		self:SetModel("models/arty/codmw2022/mp/dmz/alqatala/juggernaut/juggernaut_pm.mdl")
		-- Set bodygroups for the juggernaut armor
		for i = 0, 14 do
			self:SetBodygroup(i, 0)
		end
		stats = 0.25 -- 75% reduction in movement speed
	elseif name == "armor_hazmat" then
		self:SetModel("models/che_pm.mdl")
		stats = 0.93
	elseif name == "armor_electroproof" then
		self:SetModel("models/scp/soldier_2.mdl")
		stats = 0.8
	elseif name == "armor_csecurity" then
		self:SetModel("models/scp/soldier_1.mdl")
		stats = 0.91
	elseif name == "armor_goc" then
		self:SetModel("models/arty/codmw2022/mp/shadow company/velikan/standard/velikan_pm.mdl")
		-- Ustaw wszystkie bodygroups na 0 (z vestem/pancerzem)
		for i = 0, 14 do
			self:SetBodygroup(i, 0)
		end
		stats = 0.88
	elseif name == "armor_heavysupport" then
		self:SetModel("models/scp_mtf_russian/mtf_rus_02.mdl")
		-- Ustaw bodygroups dla Heavy Support
		timer.Simple(0.5, function()
			if IsValid(self) then
				print("[DEBUG] Heavy Support - ustawiam bodygroups dla: " .. self:Nick())
				self:SetBodygroup(0, 0) -- Vest (remove) = 0 (vest visible)
				self:SetBodygroup(1, 0) -- Vest emblem = 0 (emblem visible)
				self:SetBodygroup(2, 0) -- Group = 0
				self:SetBodygroup(3, 0) -- Headgear = 1
				self:SetBodygroup(4, 1) -- Face Protection = 0
				self:SetBodygroup(5, 0) -- Może vest? - spróbuj różne wartości 0-4
				self:SetBodygroup(6, 0) -- Może emblem? - spróbuj 0 lub 1
				self:SetBodygroup(7, 1) -- Może grupa? - spróbuj 0, 1 lub 2
				
				-- Debug - sprawdź czy bodygroups się ustawiły
				print("[DEBUG] Bodygroups po ustawieniu:")
				for i = 0, 4 do
					print("  Bodygroup " .. i .. " = " .. self:GetBodygroup(i))
				end
				print("[DEBUG] Model ma " .. self:GetNumBodyGroups() .. " bodygroups")
				for i = 0, self:GetNumBodyGroups()-1 do
					print("  Bodygroup " .. i .. " ma " .. self:GetBodygroupCount(i) .. " opcji")
				end
			end
		end)
		stats = 0.75 -- Najcięższy vest, najlepsza ochrona (25% spowolnienie)
	end
	
	self:SetWalkSpeed(self.BaseStats.wspeed * stats)
	self:SetRunSpeed(self.BaseStats.rspeed * stats)
	self:SetJumpPower(self.BaseStats.jpower * stats)
	self.UsingArmor = name
	
	-- Przywróć fat belly dla Fat D po założeniu vesta
	if self:GetNClass() == ROLES.ROLE_FAT_D then
		timer.Simple(0.2, function()
			if IsValid(self) then
				local bones = {"ValveBiped.Bip01_Spine1", "ValveBiped.Bip01_Spine2", "ValveBiped.Bip01_Pelvis"}
				for _, boneName in pairs(bones) do
					local boneID = self:LookupBone(boneName)
					if boneID then
						self:ManipulateBoneScale(boneID, Vector(1.4, 1.0, 1.6))
					end
				end
			end
		end)
	end
	
	-- Wyślij informację o kamizelce do klienta
	net.Start("BR_UpdateVest")
		net.WriteString(name)
	net.Send(self)
end

function mply:UnUseArmor()
	if self.UsingArmor == nil then return end
	
	-- SCP-035 nie może zdjąć vesta jeśli ma zablokowany
	if self:GetNClass() == ROLES.ROLE_SCP035 and self.LockedArmor then
		self:PrintMessage(HUD_PRINTTALK, "[SCP-035] Your vest is fused with your body and cannot be removed!")
		return
	end
	
	-- Sprawdź czy BaseStats istnieje
	if not self.BaseStats then return end
	
	self:SetWalkSpeed(self.BaseStats.wspeed)
	self:SetRunSpeed(self.BaseStats.rspeed)
	self:SetJumpPower(self.BaseStats.jpower)
	
	-- Jeśli to GOC lub Heavy Support, zostaw ten sam model ale zmień bodygroups na bez vesta
	if self.UsingArmor == "armor_goc" then
		self:SetModel("models/player/cheddar/goc/goc_soldier2.mdl")
		timer.Simple(0.1, function()
			if IsValid(self) and self.BaseStats then
				for i = 0, 14 do
					self:SetBodygroup(i, 1)
				end
			end
		end)
	else
		self:SetModel(self.BaseStats.model)
		-- Przywróć zapisane bodygroups dla innych
		if self.BaseStats.bodygroups then
			timer.Simple(0.1, function()
				if IsValid(self) and self.BaseStats and self.BaseStats.bodygroups then
					for group, value in pairs(self.BaseStats.bodygroups) do
						self:SetBodygroup(group, value)
					end
					
					-- Przywróć fat belly dla Fat D po zdjęciu vesta
					if self:GetNClass() == ROLES.ROLE_FAT_D then
						local bones = {"ValveBiped.Bip01_Spine1", "ValveBiped.Bip01_Spine2", "ValveBiped.Bip01_Pelvis"}
						for _, boneName in pairs(bones) do
							local boneID = self:LookupBone(boneName)
							if boneID then
								self:ManipulateBoneScale(boneID, Vector(1.4, 1.0, 1.6))
							end
						end
					end
				end
			end)
		end
	end
	
	local item = ents.Create( self.UsingArmor )
	if IsValid( item ) then
		item:Spawn()
		item:SetPos( self:GetPos() )
		self:EmitSound( Sound("npc/combine_soldier/gear".. math.random(1, 6).. ".wav") )
	end
	self.UsingArmor = nil
	
	-- Wyślij informację o zdjęciu kamizelki do klienta
	net.Start("BR_UpdateVest")
		net.WriteString("")
	net.Send(self)
end

function mply:SetSpectator()
	self:Flashlight( false )
	self:AllowFlashlight( false )
	self.handsmodel = nil
	self:Spectate( OBS_MODE_CHASE )
	self:StripWeapons()
	self:RemoveAllAmmo()
	self:SetGTeam(TEAM_SPEC)
	self:SetNoDraw(true)
	if self.SetNClass then
		self:SetNClass(ROLES.ROLE_SPEC)
	end
	self.Active = true
	print("adding " .. self:Nick() .. " to spectators")
	self.canblink = false
	self:SetNoTarget( true )
	self.BaseStats = nil
	self.UsingArmor = nil
	
	-- Clear vest info on client
	net.Start("BR_UpdateVest")
		net.WriteString("")
	net.Send(self)
	
	//self:Spectate(OBS_MODE_IN_EYE)
end

function mply:SetSCP0082( hp, speed, spawn )
	self:Flashlight( false )
	self.handsmodel = nil
	self:UnSpectate()
	self:GodDisable()
	if spawn then
		self:Spawn()
	end
	self:DropAllWeapons( true )
	self:SetModel("models/player/zombie_classic.mdl")
	self:SetGTeam(TEAM_SCP)
	self:SetHealth(hp)
	self:SetMaxHealth(hp)
	self:SetArmor(0)
	self:SetWalkSpeed(speed)
	self:SetRunSpeed(speed)
	self:SetMaxSpeed(speed)
	self:SetJumpPower(200)
	self:SetNoDraw(false)
	self:SetNClass(ROLES.ROLE_SCP0082)
	self.Active = true
	print("adding " .. self:Nick() .. " to zombies")
	self:SetupHands()
	if !spawn then
		WinCheck()
	end
	self.canblink = false
	self.noragdoll = false
	self:AllowFlashlight( false )
	self.WasTeam = TEAM_SCP
	self:SetNoTarget( true )
	net.Start("RolesSelected")
	net.Send(self)
	self:Give("weapon_br_zombie_infect")
	self:SelectWeapon("weapon_br_zombie_infect")
	self.BaseStats = nil
	self.UsingArmor = nil
	
	-- Clear vest info on client
	net.Start("BR_UpdateVest")
		net.WriteString("")
	net.Send(self)
	
	self:SetupHands()
end

function mply:SetInfectD()
	self:Flashlight( false )
	self.handsmodel = nil
	self:UnSpectate()
	self:GodDisable()
	self:Spawn()
	self:StripWeapons()
	self:RemoveAllAmmo()
	self:SetGTeam(TEAM_CLASSD)
	self:SetNClass(ROLES.ROLE_INFECTD)
	self:SetModel( table.Random( CLASSDMODELS ) )
	self:SetHealth(100)
	self:SetMaxHealth(100)
	self:SetArmor(0)
	self:SetWalkSpeed(130)
	self:SetRunSpeed(250)
	self:SetMaxSpeed(250)
	self:SetJumpPower(200)
	self:SetNoDraw(false)
	self:SetupHands()
	self.canblink = true
	self.noragdoll = false
	self:AllowFlashlight( true )
	self.WasTeam = TEAM_CLASSD
	self:SetNoTarget( false )
	self:Give("br_holster")
	self:Give("br_id")

	local card = self:Give( "br_keycard" )
	if card then
		card:SetKeycardType( "safe" )
	end
	self:SelectWeapon( "br_keycard" )

	self.BaseStats = nil
	self.UsingArmor = nil
	
	-- Clear vest info on client
	net.Start("BR_UpdateVest")
		net.WriteString("")
	net.Send(self)
end

function mply:SetInfectMTF()
	self:Flashlight( false )
	self.handsmodel = nil
	self:UnSpectate()
	self:GodDisable()
	self:Spawn()
	self:StripWeapons()
	self:RemoveAllAmmo()
	self:SetGTeam(TEAM_GUARD)
	self:SetNClass(ROLES.ROLE_INFECTMTF)
	self:SetModel( table.Random( SECURITYMODELS ) )
	self:SetHealth(150)
	self:SetMaxHealth(150)
	self:SetArmor(0)
	self:SetWalkSpeed(140)
	self:SetRunSpeed(260)
	self:SetMaxSpeed(260)
	self:SetJumpPower(215)
	self:SetNoDraw(false)
	self:SetupHands()
	self.canblink = true
	self.noragdoll = false
	self:AllowFlashlight( true )
	self.WasTeam = TEAM_GUARD
	self:SetNoTarget( false )
	self:Give("br_holster")
	self:Give("br_id")
	self:Give("cw_ar15")
	self:GiveAmmo( 60, "5.56x45MM" )

	local card = self:Give( "br_keycard" )
	if card then
		card:SetKeycardType( "euclid" )
	end
	self:SelectWeapon( "br_keycard" )

	self.BaseStats = nil
	self.UsingArmor = nil
	-- Clear previous vest first
	net.Start("BR_UpdateVest")
		net.WriteString("")
	net.Send(self)
	
	self:ApplyArmor("armor_mtfcom")
end

function mply:SetupNormal()
	self.BaseStats = nil
	self.UsingArmor = nil
	
	-- Clear vest info on client
	net.Start("BR_UpdateVest")
		net.WriteString("")
	net.Send(self)
	
	-- RESET skali modelu i manipulacji kości używanych przez specjalne klasy
	self:SetModelScale(1.0, 0)
	timer.Simple(0.05, function()
		if IsValid(self) then
			local specialBones = {
				"ValveBiped.Bip01_Spine1", "ValveBiped.Bip01_Spine2", "ValveBiped.Bip01_Pelvis",
				"ValveBiped.Bip01_L_UpperArm", "ValveBiped.Bip01_R_UpperArm", "ValveBiped.Bip01_Head1"
			}
			for _, boneName in pairs(specialBones) do
				local boneID = self:LookupBone(boneName)
				if boneID then
					self:ManipulateBoneScale(boneID, Vector(1, 1, 1))
				end
			end
		end
	end)
	
	self.handsmodel = nil
	self:UnSpectate()
	self:Spawn()
	self:GodDisable()
	self:SetNoDraw(false)
	self:SetNoTarget(false)
	self:SetupHands()
	self:RemoveAllAmmo()
	self:StripWeapons()
	self.canblink = true
	self.noragdoll = false
	self.scp1471stacks = 1
end

function mply:SetupAdmin()
	self:Flashlight( false )
	self:AllowFlashlight( true )
	self.handsmodel = nil
	self:UnSpectate()
	//self:Spectate(6)
	self:StripWeapons()
	self:RemoveAllAmmo()
	self:SetGTeam(TEAM_SPEC)
	self:SetNoDraw(true)
	if self.SetNClass then
		self:SetNClass(ROLES.ADMIN)
	end
	self.canblink = false
	self:SetNoTarget( false )
	self.BaseStats = nil
	self.UsingArmor = nil
	
	-- Clear vest info on client
	net.Start("BR_UpdateVest")
		net.WriteString("")
	net.Send(self)
	
	self:GodEnable()
	self:SetupHands()
	self:SetWalkSpeed(400)
	self:SetRunSpeed(400)
	self:SetMaxSpeed(300)
	self:ConCommand( "noclip" )
	self:Give( "br_holster" )
	self:Give( "br_entity_remover" )
	self:Give( "br_tool_teleporter" )
	self:Give( "weapon_physgun" )
end

function mply:ApplyRoleStats( role )
	self:SetNClass( role.name )
	self:SetGTeam( role.team )
	
	for k, v in pairs( role.weapons ) do
		-- Random weapon system for Scout D
		if role.name == ROLES.ROLE_SCOUT_D then
			if v == "item_radio" and math.random(1, 100) <= 50 then
				self:Give( v )
			elseif v == "weapon_pocket_knife" and math.random(1, 100) <= 25 then
				self:Give( v )
			elseif v != "item_radio" and v != "weapon_pocket_knife" then
				self:Give( v )
			end
		-- Standard weapon system for Clearance Technician
		elseif role.name == ROLES.ROLE_CLEARANCE_TECH then
			self:Give( v )
		-- Random weapon system for Veteran D
		elseif role.name == ROLES.ROLE_VETERAN then
			if v == "weapon_piss" and math.random(1, 100) <= 25 then
				self:Give( v )
			elseif v != "weapon_piss" then
				self:Give( v )
			end
		else
			self:Give( v )
		end
	end
	if role.keycard and role.keycard != "" then
		local card = self:Give( "br_keycard" )
		if IsValid(card) then
			card:SetKeycardType( role.keycard )
			self:SelectWeapon( "br_keycard" )
		end
	end

	for k, v in pairs( role.ammo ) do
		for _, wep in pairs( self:GetWeapons() ) do
			if v[1] == wep:GetClass() then
				local max_clip = wep:GetMaxClip1()
				local new_clip = math.min( v[2], max_clip )
				local reserve = v[2] - new_clip

				wep:SetClip1( new_clip )

				if reserve > 0 then
					self:GiveAmmo( reserve, wep:GetPrimaryAmmoType() )
				end

				break
			end
		end
	end

	self:SetHealth(role.health)
	self:SetMaxHealth(role.health)
	self:SetWalkSpeed(100 * role.walkspeed)
	self:SetRunSpeed(210 * role.runspeed)
	self:SetJumpPower(190 * role.jumppower)
	self:SetModel( table.Random(role.models) )
	self:Flashlight( false )
	self:AllowFlashlight( role.flashlight )
	
	-- RESET skali modelu i manipulacji kości używanych przez specjalne klasy przed zastosowaniem nowych
	self:SetModelScale(1.0, 0)
	
	local specialBones = {
		"ValveBiped.Bip01_Spine1", "ValveBiped.Bip01_Spine2", "ValveBiped.Bip01_Pelvis",
		"ValveBiped.Bip01_L_UpperArm", "ValveBiped.Bip01_R_UpperArm", "ValveBiped.Bip01_Head1"
	}
	for _, boneName in pairs(specialBones) do
		local boneID = self:LookupBone(boneName)
		if boneID then
			self:ManipulateBoneScale(boneID, Vector(1, 1, 1))
		end
	end
	
	-- Fat belly system dla Fat D
	if role.fatbelly then
		timer.Simple(0.1, function()
			if IsValid(self) then
				-- Powiększ kości brzucha/tułowia
				local bones = {"ValveBiped.Bip01_Spine1", "ValveBiped.Bip01_Spine2", "ValveBiped.Bip01_Pelvis"}
				for _, boneName in pairs(bones) do
					local boneID = self:LookupBone(boneName)
					if boneID then
						-- Powiększ X (szerokość) i Z (głębokość) brzucha
						self:ManipulateBoneScale(boneID, Vector(1.4, 1.0, 1.6))
					end
				end
			end
		end)
	end
	
	-- Skinny body system dla Skinny D
	if role.skinnybody then
		timer.Simple(0.1, function()
			if IsValid(self) then
				-- Zmniejsz kości tułowia/ramion dla chudego efektu
				local bones = {"ValveBiped.Bip01_Spine1", "ValveBiped.Bip01_Spine2", "ValveBiped.Bip01_L_UpperArm", "ValveBiped.Bip01_R_UpperArm", "ValveBiped.Bip01_Pelvis"}
				for _, boneName in pairs(bones) do
					local boneID = self:LookupBone(boneName)
					if boneID then
						-- Zmniejsz X (szerokość) i Z (głębokość) dla chudego efektu
						self:ManipulateBoneScale(boneID, Vector(0.7, 1.0, 0.8))
					end
				end
			end
		end)
	end
	

	
	-- SCP-527 bodygroups system
	if role.name == ROLES.ROLE_SCP527 then
		timer.Simple(0.1, function()
			if IsValid(self) then
				-- Ustaw bodygroups dla SCP-527
				local hatGroup = self:FindBodygroupByName("Hat")
				local clothesGroup = self:FindBodygroupByName("Clothes")
				
				if hatGroup != -1 then
					self:SetBodygroup(hatGroup, 1)
				end
				
				if clothesGroup != -1 then
					self:SetBodygroup(clothesGroup, 1)
				end
			end
		end)
	end
	
	-- General bodygroups system
	if role.bodygroups then
		timer.Simple(0.1, function()
			if IsValid(self) then
				for _, bg in pairs(role.bodygroups) do
					local groupID = bg[1]
					local value = bg[2]
					self:SetBodygroup(groupID, value)
				end
			end
		end)
	end
	
	-- Random bodygroups system
	if role.bodygroups_random then
		timer.Simple(0.1, function()
			if IsValid(self) then
				for _, bg in pairs(role.bodygroups_random) do
					local groupID = bg[1]
					local range = bg[2]
					local randomValue = math.random(range[1], range[2])
					self:SetBodygroup(groupID, randomValue)
				end
			end
		end)
	end
	if role.vest != nil then
		self:ApplyArmor(role.vest)
	end
	if role.pmcolor != nil then
		self:SetPlayerColor(Vector(role.pmcolor.r / 255, role.pmcolor.g / 255, role.pmcolor.b / 255))
	end
	net.Start("RolesSelected")
	net.Send(self)
	self:SetupHands()
end

function mply:SetSecurityI1()
	local thebestone = nil
	local usechaos = false
	if math.random(1,6) == 6 then usechaos = true end
	for k,v in pairs(ALLCLASSES["security"]["roles"]) do
		if v.importancelevel == 1 then
			local skip = false
			if usechaos == true then
				if v.team == TEAM_GUARD then
					skip = true
				end
			else
				if v.team == TEAM_CHAOS then
					skip = true
				end
			end
			if skip == false then
				local can = true
				if v.customcheck != nil then
					if v.customcheck(self) == false then
						can = false
					end
				end
				local using = 0
				for _,pl in pairs(player.GetAll()) do
					if pl:GetNClass() == v.name then
						using = using + 1
					end
				end
				if using >= v.max then can = false end
				if can == true then
					if self:GetLevel() >= v.level then
						if thebestone != nil then
							if thebestone.sorting < v.sorting then
								thebestone = v
							end
						else
							thebestone = v
						end
					end
				end
			end
		end
	end
	if thebestone == nil then
		thebestone = ALLCLASSES["security"]["roles"][1]
	end
	self:SetupNormal()
	self:ApplyRoleStats(thebestone)
end

function mply:SetClassD()
	self:SetRoleBestFrom("classds")
end

function mply:SetResearcher()
	self:SetRoleBestFrom("researchers")
end

function mply:SetRoleBestFrom(role)
	local thebestone = nil
	for k,v in pairs(ALLCLASSES[role]["roles"]) do
		local can = true
		if v.customcheck != nil then
			if v.customcheck(self) == false then
				can = false
			end
		end
		local using = 0
		for _,pl in pairs(player.GetAll()) do
			if pl:GetNClass() == v.name then
				using = using + 1
			end
		end
		if using >= v.max then can = false end
		if can == true then
			if self:GetLevel() >= v.level then
				if thebestone != nil then
					if thebestone.level < v.level then
						thebestone = v
					end
				else
					thebestone = v
				end
			end
		end
	end
	if thebestone == nil then
		thebestone = ALLCLASSES[role]["roles"][1]
	end
	if thebestone == ALLCLASSES["classds"]["roles"][4] and #player.GetAll() < 4 then
		thebestone = ALLCLASSES["classds"]["roles"][3]
	end
	if ( GetConVar("br_dclass_keycards"):GetInt() != 0 ) then
		if thebestone == ALLCLASSES["classds"]["roles"][1] then thebestone = ALLCLASSES["classds"]["roles"][2] end
	else
		if thebestone == ALLCLASSES["classds"]["roles"][2] then thebestone = ALLCLASSES["classds"]["roles"][1] end
	end
	self:SetupNormal()
	self:ApplyRoleStats(thebestone)
end

function mply:IsActivePlayer()
	return self.Active
end

hook.Add( "KeyPress", "keypress_spectating", function( ply, key )
	if ply:GTeam() != TEAM_SPEC or ply:GetNClass() == ROLES.ADMIN then return end
	if ( key == IN_ATTACK ) then
		ply:SpectatePlayerLeft()
	elseif ( key == IN_ATTACK2 ) then
		ply:SpectatePlayerRight()
	elseif ( key == IN_RELOAD ) then
		ply:ChangeSpecMode()
	end
end )

function mply:SpectatePlayerRight()
	if !self:Alive() then return end
	if self:GetObserverMode() != OBS_MODE_IN_EYE and
	   self:GetObserverMode() != OBS_MODE_CHASE 
	then return end
	self:SetNoDraw(true)
	local allply = GetAlivePlayers()
	if #allply == 1 then return end
	if not self.SpecPly then
		self.SpecPly = 0
	end
	self.SpecPly = self.SpecPly - 1
	if self.SpecPly < 1 then
		self.SpecPly = #allply 
	end
	for k,v in pairs(allply) do
		if k == self.SpecPly then
			self:SpectateEntity( v )
		end
	end
end

function mply:SpectatePlayerLeft()
	if !self:Alive() then return end
	if self:GetObserverMode() != OBS_MODE_IN_EYE and
	   self:GetObserverMode() != OBS_MODE_CHASE 
	then return end
	self:SetNoDraw(true)
	local allply = GetAlivePlayers()
	if #allply == 1 then return end
	if not self.SpecPly then
		self.SpecPly = 0
	end
	self.SpecPly = self.SpecPly + 1
	if self.SpecPly > #allply then
		self.SpecPly = 1
	end
	for k,v in pairs(allply) do
		if k == self.SpecPly then
			self:SpectateEntity( v )
		end
	end
end

function mply:ChangeSpecMode()
	if !self:Alive() then return end
	if !(self:GTeam() == TEAM_SPEC) then return end
	self:SetNoDraw(true)
	local m = self:GetObserverMode()
	local allply = #GetAlivePlayers()
	if allply < 2 then
		self:Spectate(OBS_MODE_ROAMING)
		return
	end
	/*
	if m == OBS_MODE_CHASE then
		self:Spectate(OBS_MODE_IN_EYE)
	else
		self:Spectate(OBS_MODE_CHASE)
	end
	*/
	
	if m == OBS_MODE_IN_EYE then
		self:Spectate(OBS_MODE_CHASE)	
	elseif m == OBS_MODE_CHASE then
		if GetConVar( "br_allow_roaming_spectate" ):GetInt() == 1 then
			self:Spectate(OBS_MODE_ROAMING)
		elseif GetConVar( "br_allow_ineye_spectate" ):GetInt() == 1 then
			self:Spectate(OBS_MODE_IN_EYE)
			self:SpectatePlayerLeft()
		else
			self:SpectatePlayerLeft()
		end	
	elseif m == OBS_MODE_ROAMING then
		if GetConVar( "br_allow_ineye_spectate" ):GetInt() == 1 then
			self:Spectate(OBS_MODE_IN_EYE)
			self:SpectatePlayerLeft()
		else
			self:Spectate(OBS_MODE_CHASE)
			self:SpectatePlayerLeft()
		end
	else
		self:Spectate(OBS_MODE_ROAMING)
	end
end

function mply:SaveExp()
	self:SetPData( "breach_exp", self:GetExp() )
end

function mply:SaveLevel()
	self:SetPData( "breach_level", self:GetLevel() )
end

function mply:AddExp(amount, msg)
	amount = amount * GetConVar("br_expscale"):GetInt()
	if self.Premium == true then
		amount = amount * GetConVar("br_premium_mult"):GetFloat()
	end
	amount = math.Round(amount)
	if not self.GetNEXP then
		player_manager.RunClass( self, "SetupDataTables" )
	end
	if self.GetNEXP and self.SetNEXP then
		self:SetNEXP( self:GetNEXP() + amount )
		local xp = self:GetNEXP()
		local lvl = self:GetNLevel()
		if lvl == 0 then
			if xp >= 3000 then
				self:AddLevel(1)
				self:SetNEXP(xp - 3000)
				self:SaveLevel()
				PrintMessage(HUD_PRINTTALK, self:Nick() .. " reached level 1! Congratulations!")
			end
		elseif lvl == 1 then
			if xp >= 5000 then
				self:AddLevel(1)
				self:SetNEXP(xp - 5000)
				self:SaveLevel()
				PrintMessage(HUD_PRINTTALK, self:Nick() .. " reached level 2! Congratulations!")
			end
		elseif lvl == 2 then
			if xp >= 7500 then
				self:AddLevel(1)
				self:SetNEXP(xp - 7500)
				self:SaveLevel()
				PrintMessage(HUD_PRINTTALK, self:Nick() .. " reached level 3! Congratulations!")
			end
		elseif lvl == 3 then
			if xp >= 11000 then
				self:AddLevel(1)
				self:SetNEXP(xp - 11000)
				self:SaveLevel()
				PrintMessage(HUD_PRINTTALK, self:Nick() .. " reached level 4! Congratulations!")
			end
		elseif lvl == 4 then
			if xp >= 14000 then
				self:AddLevel(1)
				self:SetNEXP(xp - 14000)
				self:SaveLevel()
				PrintMessage(HUD_PRINTTALK, self:Nick() .. " reached level 5! Congratulations!")
			end
		elseif lvl == 5 then
			if xp >= 25000 then
				self:AddLevel(1)
				self:SetNEXP(xp - 25000)
				self:SaveLevel()
				PrintMessage(HUD_PRINTTALK, self:Nick() .. " reached level OMNI! Congratulations!")
			end
		elseif lvl == 6 then
			if xp >= 100000 then
				self:AddLevel(1)
				self:SetNEXP(xp - 100000)
				self:SaveLevel()
				PrintMessage(HUD_PRINTTALK, self:Nick() .. " is a now a Veteran! Congratulations!")
			end
		elseif lvl > 6 then
			if xp >= 100000 then
				self:AddLevel(1)
				self:SetNEXP(xp - 100000)
				self:SaveLevel()
				PrintMessage(HUD_PRINTTALK, self:Nick() .. " reached level "..lvl.."! Congratulations!")
			end
		end
		self:SetPData( "breach_exp", self:GetExp() )
	else
		if self.SetNEXP then
			self:SetNEXP( 0 )
		else
			ErrorNoHalt( "Cannot set the exp, SetNEXP invalid" )
		end
	end
end

function mply:AddLevel(amount)
	if not self.GetNLevel then
		player_manager.RunClass( self, "SetupDataTables" )
	end
	if self.GetNLevel and self.SetNLevel then
		self:SetNLevel( self:GetNLevel() + amount )
		self:SetPData( "breach_level", self:GetNLevel() )
	else
		if self.SetNLevel then
			self:SetNLevel( 0 )
		else
			ErrorNoHalt( "Cannot set the exp, SetNLevel invalid" )
		end
	end
end

function mply:SetRoleName(name)
	local rl = nil
	for k,v in pairs(ALLCLASSES) do
		for _,role in pairs(v.roles) do
			if role.name == name then
				rl = role
			end
		end
	end
	if rl != nil then
		self:SetupNormal()
		self:ApplyRoleStats(rl)
	end
end

function mply:SetActive( active )
	self.ActivePlayer = active
	self:SetNActive( active )
	if !gamestarted then
		CheckStart()
	end
end

function mply:ToggleAdminModePref()
	if self.admpref == nil then self.admpref = false end
	if self.admpref then
		self.admpref = false
		if self.AdminMode then
			self:ToggleAdminMode()
			self:SetSpectator()
		end
	else
		self.admpref = true
		if self:GetNClass() == ROLES.ROLE_SPEC then
			self:ToggleAdminMode()
			self:SetupAdmin()
		end
	end
end

function mply:ToggleAdminMode()
	if self.AdminMode == nil then self.AdminMode = false end
	if self.AdminMode == true then
		self.AdminMode = false
		self:SetActive( true )
		self:DrawWorldModel( true ) 
	else
		self.AdminMode = true
		self:SetActive( false )
		self:DrawWorldModel( false )
	end
end

-- Synchronizacja kamizelki przy spawnie
hook.Add("PlayerSpawn", "BR_SyncVestOnSpawn", function(ply)
	-- Reset Security Droid variables
	ply.SecurityDroidStunHits = 0
	ply.SecurityDroidOverheated = false
	ply.SecurityDroidOriginalSpeeds = nil
	
	-- Usuń timer przegrzania jeśli istnieje
	timer.Remove("SecurityDroid_Overheat_" .. ply:EntIndex())
	
	-- Reset wszystkich manipulacji kości i bodygroups przy spawnie
	timer.Simple(0.1, function()
		if IsValid(ply) then
			-- Reset kości
			ply:SetModelScale(1.0, 0)
			for i = 0, ply:GetBoneCount() - 1 do
				ply:ManipulateBoneScale(i, Vector(1, 1, 1))
			end
			
			-- Reset bodygroups
			for i = 0, ply:GetNumBodyGroups() - 1 do
				ply:SetBodygroup(i, 0)
			end
			
			-- Reset przezroczystości (jeśli nie ma ochrony wsparcia)
			if not (ply.SupportSpawnProtection and CurTime() < ply.SupportSpawnProtection) then
				ply:SetColor(Color(255, 255, 255, 255))
				ply:SetRenderMode(RENDERMODE_NORMAL)
			end
		end
	end)
	
	timer.Simple(0.5, function()
		if IsValid(ply) and ply.UsingArmor then
			net.Start("BR_UpdateVest")
				net.WriteString(ply.UsingArmor)
			net.Send(ply)
		end
	end)
end)

-- Synchronizacja przy dołączeniu do serwera
hook.Add("PlayerInitialSpawn", "BR_SyncVestOnJoin", function(ply)
	timer.Simple(2, function()
		if IsValid(ply) and ply.UsingArmor then
			net.Start("BR_UpdateVest")
				net.WriteString(ply.UsingArmor)
			net.Send(ply)
		end
	end)
end)



-- D-CLASS INFECTED PASSIVE ABILITY
-- Viral Aura - damages players who stay too close for too long
local InfectedProximity = {} -- Tabela do śledzenia czasu bliskości

-- Usuń stary timer jeśli istnieje
if timer.Exists("DClassInfected_ViralAura") then
	timer.Remove("DClassInfected_ViralAura")
end

timer.Create("DClassInfected_ViralAura", 1, 0, function()
	for _, infected in pairs(player.GetAll()) do
		if IsValid(infected) and infected:Alive() and infected:GetNClass() == ROLES.ROLE_DCLASS_INFECTED then
			local nearbyPlayers = ents.FindInSphere(infected:GetPos(), 50) -- 50 unit radius
			
			-- Sprawdź wszystkich graczy w pobliżu
			for _, ply in pairs(nearbyPlayers) do
				if IsValid(ply) and ply:IsPlayer() and ply:Alive() and ply != infected and ply:GetNClass() != ROLES.ROLE_DCLASS_INFECTED then
					local steamID = ply:SteamID()
					
					-- Inicjalizuj tracking dla gracza jeśli nie istnieje
					if not InfectedProximity[steamID] then
						InfectedProximity[steamID] = 0
					end
					
					-- Zwiększ czas bliskości
					InfectedProximity[steamID] = InfectedProximity[steamID] + 1
					
					-- Po 10 sekundach bliskości zacznij zadawać damage
					if InfectedProximity[steamID] >= 10 then
						-- Własny system trucizny - zadaj 2 damage co sekundę
						ply:SetHealth(ply:Health() - 2)
						
						-- Sprawdź czy gracz nie umarł
						if ply:Health() <= 0 then
							ply:Kill()
							-- Ustaw infected jako zabójcę
							if IsValid(infected) then
								ply:SetNWEntity("killer", infected)
							end
						end
						
						-- Komunikat co 5 sekund żeby nie spamować
						if InfectedProximity[steamID] % 5 == 0 then
							ply:ChatPrint("You feel sick from prolonged exposure to the infected...")
						end
						
						-- Efekt wizualny trucizny
						ply:ScreenFade(SCREENFADE.IN, Color(50, 200, 50, 20), 0.5, 0)
					end
				end
			end
			
			-- Reset czasu dla graczy którzy odeszli za daleko
			for steamID, time in pairs(InfectedProximity) do
				local ply = player.GetBySteamID(steamID)
				if not IsValid(ply) or not ply:Alive() or ply:GetPos():Distance(infected:GetPos()) > 50 then
					InfectedProximity[steamID] = 0
				end
			end
		end
	end
end)

-- Reset przy śmierci
hook.Add("PostPlayerDeath", "InfectedReset", function(ply)
	if ply:GetNClass() == ROLES.ROLE_DCLASS_INFECTED then
		-- Wyczyść wszystkie timery dla tego gracza
		InfectedProximity = {}
	else
		-- Wyczyść timer dla zmarłego gracza
		InfectedProximity[ply:SteamID()] = nil
	end
end)

-- PSYCHOLOGIST PASSIVE ABILITIES
-- Network strings
util.AddNetworkString("Psychologist_AddFootstep")

-- Passive 1: Therapeutic Presence - Healing Aura
-- Use a timer instead of Think hook for precise 1-second intervals
timer.Create("Psychologist_TherapeuticPresence", 1, 0, function()
	for _, psychologist in pairs(player.GetAll()) do
		if IsValid(psychologist) and psychologist:Alive() and psychologist:GetNClass() == ROLES.ROLE_PSYCHOLOGIST then
			local nearbyPlayers = ents.FindInSphere(psychologist:GetPos(), 125) -- 125 unit radius (half of original)
			
			for _, ply in pairs(nearbyPlayers) do
				if IsValid(ply) and ply:IsPlayer() and ply:Alive() and ply != psychologist then
					-- Check if player is from supported teams/roles
					local team = ply:GTeam()
					local class = ply:GetNClass()
					
					-- Heal: Scientists, MTF, and CI Spy only (not all Chaos)
					if team == TEAM_SCI or team == TEAM_GUARD or (team == TEAM_CHAOS and class == ROLES.ROLE_CHAOSSPY) then
						-- Check if player needs healing (below 50 HP)
						local currentHP = ply:Health()
						if currentHP < 50 and currentHP > 0 then
							-- Heal +1 HP (but don't exceed 50 HP)
							ply:SetHealth(math.min(currentHP + 1, 50))
						end
					end
				end
			end
		end
	end
end)

-- Passive 2: Psychological Insight - Footstep tracking for players in crisis
hook.Add("PlayerFootstep", "Psychologist_FootstepTracking", function(ply, pos, foot, sound, volume, rf)
	-- Only track footsteps from players with <30% HP (psychological crisis)
	if not ply:IsPlayer() or not ply:Alive() then return end
	
	local maxHP = ply:GetMaxHealth()
	local currentHP = ply:Health()
	
	-- Check if player is in crisis (<30% HP)
	if currentHP < (maxHP * 0.3) then
		-- Determine team identifier for footstep traces
		local teamIdentifier = ply:GTeam()
		
		-- CI Spy should be marked as ally (green), not enemy (red)
		if ply:GetNClass() == ROLES.ROLE_CHAOSSPY then
			teamIdentifier = 99 -- Special number for CI Spy (ally)
		end
		
		-- Send footstep data to all psychologists
		for _, psychologist in pairs(player.GetAll()) do
			if IsValid(psychologist) and psychologist:Alive() and psychologist:GetNClass() == ROLES.ROLE_PSYCHOLOGIST then
				net.Start("Psychologist_AddFootstep")
					net.WriteVector(pos)
					net.WriteInt(teamIdentifier, 8)
					net.WriteFloat(CurTime())
				net.Send(psychologist)
			end
		end
	end
end)

-- THIEF D PASSIVE ABILITY
-- Weapon Theft - steal active weapon from other players
hook.Add("PlayerUse", "ThiefD_WeaponTheft", function(ply, ent)
	if not IsValid(ply) or not ply:IsPlayer() then return end
	if not IsValid(ent) or not ent:IsPlayer() then return end
	if preparing or postround then return end
	
	-- Only Thief D can steal
	if ply:GetNClass() != ROLES.ROLE_THIEF_D then return end
	
	-- Check cooldown (60 seconds)
	if ply.ThiefNextSteal and ply.ThiefNextSteal > CurTime() then
		local timeLeft = math.ceil(ply.ThiefNextSteal - CurTime())
		ply:PrintMessage(HUD_PRINTCENTER, "Theft on cooldown: " .. timeLeft .. "s")
		return false
	end
	
	-- Cannot steal from SCPs
	if ent:GTeam() == TEAM_SCP then 
		return false
	end
	
	-- Cannot steal from yourself
	if ply == ent then return end
	
	-- Check distance (shorter range for theft - 50 units instead of default ~85)
	local distance = ply:GetPos():Distance(ent:GetPos())
	if distance > 50 then
		return false
	end
	
	-- Get target's active weapon
	local targetWeapon = ent:GetActiveWeapon()
	if not IsValid(targetWeapon) then 
		return false
	end
	
	local weaponClass = targetWeapon:GetClass()
	
	-- Blocked weapons: holster and br_tag (security tags)
	if weaponClass == "br_holster" or weaponClass == "br_tag" then
		return false
	end
	
	-- Check if thief already has this weapon
	if ply:HasWeapon(weaponClass) then
		return false
	end
	
	-- Get weapon info before removal
	local weaponAmmo = 0
	local ammoType = targetWeapon:GetPrimaryAmmoType()
	if ammoType and ammoType != -1 then
		weaponAmmo = ent:GetAmmoCount(ammoType)
	end
	
	-- Special handling for keycards - preserve access level
	local keycardType = nil
	if weaponClass == "br_keycard" then
		keycardType = targetWeapon:GetNWString("K_TYPE", "safe")
	end
	
	-- Remove weapon from target
	ent:StripWeapon(weaponClass)
	
	-- Give weapon to thief
	local newWeapon = ply:Give(weaponClass)
	if IsValid(newWeapon) then
		-- Set keycard type if it's a keycard
		if weaponClass == "br_keycard" and keycardType then
			newWeapon:SetKeycardType(keycardType)
		end
		
		-- Give ammo if applicable
		if ammoType and ammoType != -1 and weaponAmmo > 0 then
			ply:GiveAmmo(weaponAmmo, ammoType)
		end
	end
	
	-- Switch to stolen weapon
	ply:SelectWeapon(weaponClass)
	
	-- Set cooldown (60 seconds)
	ply.ThiefNextSteal = CurTime() + 60
	
	-- Visual effects
	ply:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 20), 0.3, 0)
	ent:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 30), 0.5, 0)
	
	-- Sound effects
	ply:EmitSound("buttons/button14.wav", 50, 120)
	ent:EmitSound("buttons/button10.wav", 50, 80)
	
	return false -- Prevent normal USE interaction
end)

-- Reset Thief cooldown on spawn
hook.Add("PlayerSpawn", "ThiefD_ResetCooldown", function(ply)
	if IsValid(ply) then
		ply.ThiefNextSteal = nil
	end
end)

-- DR. HOUSE PASSIVE ABILITY
-- Death Harvest - gains 10 HP when someone nearby dies
hook.Add("PostPlayerDeath", "DrHouse_DeathHarvest", function(victim, inflictor, attacker)
	if not IsValid(victim) or not victim:IsPlayer() then return end
	if preparing or postround then return end
	
	-- Find all Dr. House players nearby the death location
	for _, drhouse in pairs(player.GetAll()) do
		if IsValid(drhouse) and drhouse:Alive() and drhouse:GetNClass() == ROLES.ROLE_DRHOUSE then
			local distance = drhouse:GetPos():Distance(victim:GetPos())
			
			-- Check if Dr. House is within 300 units of the death
			if distance <= 300 then
				-- Heal Dr. House by 10 HP (but don't exceed max health)
				local currentHP = drhouse:Health()
				local maxHP = drhouse:GetMaxHealth()
				local newHP = math.min(currentHP + 10, maxHP)
				
				drhouse:SetHealth(newHP)
				
				-- Send notification to Dr. House
				drhouse:PrintMessage(HUD_PRINTTALK, "[DR. HOUSE] Death nearby healed you for " .. (newHP - currentHP) .. " HP!")
				
				-- Visual effect for healing
				drhouse:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 30), 0.5, 0)
			end
		end
	end
end)


================================================
FILE: gamemodes/breach/gamemode/modules/sv_player_hooks.lua
================================================
// Serverside file for all player related functions

-- Network string dla powiadomień o zabójstwach
util.AddNetworkString("KillNotification")

-- Funkcja wysyłająca powiadomienie o zabójstwie
local function SendKillNotification(attacker, victimClass, victimName, points, isTeamkill)
	if not IsValid(attacker) or not attacker:IsPlayer() then return end
	
	net.Start("KillNotification")
		net.WriteInt(victimClass, 8)
		net.WriteString(victimName)
		net.WriteInt(points, 16)
		net.WriteBool(isTeamkill or false)
	net.Send(attacker)
end

function IsPremium( ply, silent )
	ply:SetNPremium( false )
	ply.Premium = false
	if CheckULXPremium( ply, silent ) == true then return end
	if GetConVar("br_premium_url"):GetString() == "" or GetConVar("br_premium_url"):GetString() == "none" then return end
	http.Fetch( GetConVar("br_premium_url"):GetString(), function( body, size, headers, code )
		if ( body == nil ) then return end
		local ID = string.find( tostring(body), "<ID64>"..ply:SteamID64().."</ID64>" )
			if ID != nil then
				ply.Premium = true
				ply:SetNPremium( true )
				if GetConVar("br_premium_display"):GetString() != "" and GetConVar("br_premium_display"):GetString() != "none" and !silent then
					print("Premium member "..ply:GetName().." has joined")
					PrintMessage(HUD_PRINTCENTER, string.format(GetConVar("br_premium_display"):GetString(), ply:GetName()))
				end
			end
	end,
	function( error )
		print("HTTP ERROR")
		print(error)
	end )
end

function CheckULXPremium( ply, silent )
	if GetConVar("br_ulx_premiumgroup_name"):GetString() == "" or GetConVar("br_ulx_premiumgroup_name"):GetString() == "none" then return end
	if !ply.CheckGroup then
		print( "To use br_ulx_premiumgroup_name you have to install ULX!" )
		return
	end
	local pgroups = string.Split( GetConVar("br_ulx_premiumgroup_name"):GetString(), "," )
	local ispremium
	for k,v in pairs( pgroups ) do
		if ply:CheckGroup( v ) then
			ispremium = true
			break
		end
	end
	if ispremium then
		ply.Premium = true
		ply:SetNPremium( true )
		if GetConVar("br_premium_display"):GetString() != "" and GetConVar("br_premium_display"):GetString() != "none" and !silent then
			print("Premium member "..ply:GetName().." has joined")
			PrintMessage(HUD_PRINTCENTER, string.format(GetConVar("br_premium_display"):GetString(), ply:GetName()))
		end
		return true
	end
end

local roundStartInProgress = false

function CheckStart()
	MINPLAYERS = GetConVar("br_min_players"):GetInt()
	
	-- Zapobiegaj wielokrotnemu uruchamianiu rundy
	if roundStartInProgress then return end
	
	if gamestarted == false and #GetActivePlayers() >= MINPLAYERS then
		print("[BREACH] CheckStart: Wystarczająca liczba graczy, rozpoczynanie rundy...")
		roundStartInProgress = true
		-- Dodaj małe opóźnienie dla pierwszej rundy
		timer.Simple(0.5, function()
			RoundRestart()
			roundStartInProgress = false
		end)
	end
	if gamestarted then
		BroadcastLua( 'gamestarted = true' )
	end
end

function GM:PlayerInitialSpawn( ply )
	ply:SetCanZoom( false )
	ply:SetNoDraw(true)
	ply.Active = false
	ply.freshspawn = true
	ply.isblinking = false
	ply.Premium = false
	if timer.Exists( "RoundTime" ) == true then
		net.Start("UpdateTime")
			net.WriteString(tostring(timer.TimeLeft( "RoundTime" )))
		net.Send(ply)
	end
	player_manager.SetPlayerClass( ply, "class_breach" )
	player_manager.RunClass( ply, "SetupDataTables" )
	IsPremium(ply)
	
	-- Napraw problem z przezroczystością na scoreboardzie
	-- Ustaw ActivePlayer przed SetActive, żeby uniknąć problemów z synchronizacją
	ply.ActivePlayer = false
	ply:SetActive( false )
	if ply:IsBot() then
		ply.ActivePlayer = true
		ply:SetActive( true )
	end
	
	-- Wymuś synchronizację zmiennej sieciowej
	timer.Simple(0.1, function()
		if IsValid(ply) then
			ply:SetNActive(ply.ActivePlayer or false)
		end
	end)
	
	--print( ply.ActivePlayer, ply:GetNActive() )
	CheckStart()
	if gamestarted then
		ply:SendLua( 'gamestarted = true' )
	end
end
/*
function GM:PlayerAuthed( ply, steamid, uniqueid )
	ply.Active = false
	ply.Leaver = "none"
	if prepring then
		ply:SetClassD()
	else
		ply:SetSpectator()
	end
end
*/
function GM:PlayerSpawn( ply )
	//ply:SetupHands()
	ply:SetTeam(1)
	ply:SetNoCollideWithTeammates(true)
	//ply:SetCustomCollisionCheck( true )
	if ply.freshspawn then
		ply:SetSpectator()
		ply.freshspawn = false
	end
	
	-- RESET manipulacji kości przy spawnie - naprawia problem z Fat D i Skinny D
	timer.Simple(0.05, function()
		if IsValid(ply) then
			ply:SetModelScale(1.0, 0)
			-- Reset wszystkich manipulacji kości do wartości domyślnych
			for i = 0, ply:GetBoneCount() - 1 do
				ply:ManipulateBoneScale(i, Vector(1, 1, 1))
				ply:ManipulateBonePosition(i, Vector(0, 0, 0))
				ply:ManipulateBoneAngles(i, Angle(0, 0, 0))
			end
		end
	end)
	
	//ply:SetupHands()
end

function GM:PlayerSetHandsModel( ply, ent )
	local simplemodel = player_manager.TranslateToPlayerModelName( ply:GetModel() )
	local info = player_manager.TranslatePlayerHands( simplemodel )
	if ( info ) then
		if ply.handsmodel != nil then
			info.model = ply.handsmodel
		end
		ent:SetModel( info.model )
		ent:SetSkin( info.skin )
		ent:SetBodyGroups( info.body )
	end
end

function GM:DoPlayerDeath( ply, attacker, dmginfo )
	if (ply.noragdoll != true) then
		CreateRagdollPL(ply, attacker, dmginfo:GetDamageType())
	end
	ply:AddDeaths(1)
end


function GM:PlayerDeathThink( ply )
	if ply:GetNClass() == ROLES.ROLE_SCP076 and IsValid( SCP0761 ) then
		if ply.n076nextspawn and ply.n076nextspawn < CurTime() then
			--ply:SetSCP076()
			local scp = GetSCP( "SCP076" )
			if scp then
				scp:SetupPlayer( ply )
			end
		end
		return
	end
	if !ply:IsBot() and ply:GTeam() != TEAM_SPEC then
		ply:SetGTeam(TEAM_SPEC)
	end
	if ( ply:IsBot() || ply:KeyPressed( IN_ATTACK ) || ply:KeyPressed( IN_ATTACK2 ) || ply:KeyPressed( IN_JUMP ) || postround ) then
		ply:Spawn()
		ply:SetSpectator()
	end
end

function GM:PlayerNoClip( ply, desiredState )
	if ply:GTeam() == TEAM_SPEC and desiredState == true then return true end
end

function GM:PlayerDeath( victim, inflictor, attacker )
	net.Start( "Effect" )
		net.WriteBool( false )
	net.Send( victim )

	net.Start( "957Effect" )
		net.WriteBool( false )
	net.Send( victim )

	victim:SetModelScale( 1 )
	if attacker:IsPlayer() then
		print("[KILL] " .. attacker:Nick() .. " [" .. attacker:GetNClass() .. "] killed " .. victim:Nick() .. " [" .. victim:GetNClass() .. "]")
	end
	
	-- SYSTEM KREDYTÓW ZA ZABÓJSTWA
	if IsValid(attacker) and attacker:IsPlayer() and IsValid(victim) and victim:IsPlayer() and attacker != victim and not preparing and not postround then
		-- Inicjalizuj kredyty jeśli nie istnieją
		if not attacker.Credits then attacker.Credits = 0 end
		if not attacker.RoundKills then attacker.RoundKills = 0 end
		if not attacker.TeamKills then attacker.TeamKills = 0 end
		
		local attackerTeam = attacker:GTeam()
		local victimTeam = victim:GTeam()
		
		-- Stała nagroda za zabójstwo przeciwnika
		local KILL_REWARD = 1  -- 1 kredyt za każde zabójstwo przeciwnika
		
		-- Sprawdź czy to zabójstwo przeciwnika
		local isEnemyKill = false
		local creditsReward = 0
		
		if attackerTeam != victimTeam then
			-- Różne drużyny - sprawdź czy to nie są sojusznicy
			local isAlly = ((attackerTeam == TEAM_GUARD and victimTeam == TEAM_SCI) or 
							(attackerTeam == TEAM_SCI and victimTeam == TEAM_GUARD) or
							(attackerTeam == TEAM_CLASSD and victimTeam == TEAM_CHAOS) or
							(attackerTeam == TEAM_CHAOS and victimTeam == TEAM_CLASSD))
			
			if not isAlly then
				isEnemyKill = true
				creditsReward = KILL_REWARD
				
				-- Sprawdź czy to nie SCP-999 (nie nagradzaj za jego zabicie)
				local victimClass = victim:GetNClass()
				if victimClass == ROLES.ROLE_SCP999 then
					creditsReward = 0 -- Nie nagradzaj za zabicie SCP-999
				end
			end
		end
		
		if isEnemyKill and creditsReward > 0 then
			-- Dodaj kredyty za zabójstwo przeciwnika
			attacker.RoundKills = attacker.RoundKills + 1
			attacker:AddCredits(creditsReward, "Killed " .. victim:Nick() .. " (+" .. creditsReward .. " credits)")
			print("[CREDITS] " .. attacker:Nick() .. " earned " .. creditsReward .. " credits for killing " .. victim:Nick() .. " (" .. attacker:GetCredits() .. " total)")
		elseif attackerTeam == victimTeam or 
			   (attackerTeam == TEAM_GUARD and victimTeam == TEAM_SCI) or
			   (attackerTeam == TEAM_SCI and victimTeam == TEAM_GUARD) or
			   (attackerTeam == TEAM_CLASSD and victimTeam == TEAM_CHAOS) or
			   (attackerTeam == TEAM_CHAOS and victimTeam == TEAM_CLASSD) then
			-- Teamkill - kara
			attacker.TeamKills = attacker.TeamKills + 1
			attacker:AddCredits(-10, "Teamkill penalty (-10 credits)")
			print("[CREDITS] " .. attacker:Nick() .. " lost 10 credits for teamkill (" .. attacker:GetCredits() .. " total)")
		end
	end
	
	-- Specjalna kara za zabicie SCP-999
	if attacker:IsPlayer() and attacker != victim and victim:GetNClass() == ROLES.ROLE_SCP999 then
		attacker:AddFrags(-10)
		SendKillNotification(attacker, TEAM_SCP, victim:Nick(), -10, false)
		print("[" .. attacker:Nick() .. "] killed SCP-999! -10 points penalty!")
	end
	if victim:GetNClass() == ROLES.ROLE_SCP9571 then
		for k, v in pairs( player.GetAll() ) do
			if v:GetNClass() == ROLES.ROLE_SCP957 then
				v:TakeDamage( 500, attacker, inflictor)
			end
		end
	end
	if victim:GetNClass() == ROLES.ROLE_SCP076 and IsValid( SCP0761 ) and !postround then
		victim.n076nextspawn = CurTime() + 10
		return
	end
	victim:SetNClass(ROLES.ROLE_SPEC)
	if attacker != victim and postround == false and attacker:IsPlayer() then
		if attacker:IsPlayer() then
			if attacker:GTeam() == TEAM_GUARD then
				victim:PrintMessage(HUD_PRINTTALK, "You were killed by an MTF Guard: " .. attacker:Nick())
				if victim:GTeam() == TEAM_SCP then
					-- Nie dawaj punktów za zabicie SCP-999 (już obsłużone wcześniej)
					if victim:GetNClass() != ROLES.ROLE_SCP999 then
						print("[" .. attacker:Nick() .. "] You've been awarded with 10 points for killing an SCP!")
						attacker:AddFrags(10)
						SendKillNotification(attacker, TEAM_SCP, victim:Nick(), 10, false)
					end
				elseif victim:GTeam() == TEAM_CHAOS then
					print("[" .. attacker:Nick() .. "] You've been awarded with 5 points for killing a Chaos Insurgency member!")
					attacker:AddFrags(5)
					SendKillNotification(attacker, TEAM_CHAOS, victim:Nick(), 5, false)
				elseif victim:GTeam() == TEAM_CLASSD then
					print("[" .. attacker:Nick() .. "] You've been awarded with 2 points for killing a Class D Personell!")
					attacker:AddFrags(2)
					SendKillNotification(attacker, TEAM_CLASSD, victim:Nick(), 2, false)
				elseif victim:GTeam() == TEAM_GOC then
					print("[" .. attacker:Nick() .. "] You've been awarded with 5 points for killing a GOC member!")
					attacker:AddFrags(5)
					SendKillNotification(attacker, TEAM_GOC, victim:Nick(), 5, false)
				end
			elseif attacker:GTeam() == TEAM_CHAOS then
				victim:PrintMessage(HUD_PRINTTALK, "You were killed by a Chaos Insurgency Soldier: " .. attacker:Nick())
				if victim:GTeam() == TEAM_GUARD then
					print("[" .. attacker:Nick() .. "] You've been awarded with 2 points for killing an MTF Guard!")
					attacker:AddFrags(2)
					SendKillNotification(attacker, TEAM_GUARD, victim:Nick(), 2, false)
				elseif victim:GTeam() == TEAM_SCI then
					print("[" .. attacker:Nick() .. "] You've been awarded with 2 points for killing a Researcher!")
					attacker:AddFrags(2)
					SendKillNotification(attacker, TEAM_SCI, victim:Nick(), 2, false)
				elseif victim:GTeam() == TEAM_SCP then
					-- Nie dawaj punktów za zabicie SCP-999 (już obsłużone wcześniej)
					if victim:GetNClass() != ROLES.ROLE_SCP999 then
						print("[" .. attacker:Nick() .. "] You've been awarded with 10 points for killing an SCP!")
						attacker:AddFrags(10)
						SendKillNotification(attacker, TEAM_SCP, victim:Nick(), 10, false)
					end
				elseif victim:GTeam() == TEAM_CLASSD then
					print("[" .. attacker:Nick() .. "] Don't kill Class D Personnel, they are your allies!")
					-- Usunięto punkty za zabicie Klasy D - to są sojusznicy Chaos
				elseif victim:GTeam() == TEAM_GOC then
					print("[" .. attacker:Nick() .. "] You've been awarded with 5 points for killing a GOC member!")
					attacker:AddFrags(5)
					SendKillNotification(attacker, TEAM_GOC, victim:Nick(), 5, false)
				end
			elseif attacker:GTeam() == TEAM_SCP then
				victim:PrintMessage(HUD_PRINTTALK, "You were killed by an SCP: " .. attacker:Nick())
				print("[" .. attacker:Nick() .. "] You've been awarded with 2 points for killing " .. victim:Nick())
				attacker:AddFrags(2)
				SendKillNotification(attacker, victim:GTeam(), victim:Nick(), 2, false)
			elseif attacker:GTeam() == TEAM_CLASSD then
				victim:PrintMessage(HUD_PRINTTALK, "You were killed by a Class D: " .. attacker:Nick())
				if victim:GTeam() == TEAM_GUARD then
					print("[" .. attacker:Nick() .. "] You've been awarded with 4 points for killing an MTF Guard!")
					attacker:AddFrags(4)
					SendKillNotification(attacker, TEAM_GUARD, victim:Nick(), 4, false)
				elseif victim:GTeam() == TEAM_SCI then
					print("[" .. attacker:Nick() .. "] You've been awarded with 2 points for killing a Researcher!")
					attacker:AddFrags(2)
					SendKillNotification(attacker, TEAM_SCI, victim:Nick(), 2, false)
				elseif victim:GTeam() == TEAM_SCP then
					-- Nie dawaj punktów za zabicie SCP-999 (już obsłużone wcześniej)
					if victim:GetNClass() != ROLES.ROLE_SCP999 then
						print("[" .. attacker:Nick() .. "] You've been awarded with 10 points for killing an SCP!")
						attacker:AddFrags(10)
						SendKillNotification(attacker, TEAM_SCP, victim:Nick(), 10, false)
					end
				elseif victim:GTeam() == TEAM_CHAOS then
					print("[" .. attacker:Nick() .. "] Don't kill Chaos Insurgency members, they are your allies!")
					-- Usunięto punkty za zabicie Chaos - to są sojusznicy Klasy D
				elseif victim:GTeam() == TEAM_GOC then
					print("[" .. attacker:Nick() .. "] You've been awarded with 5 points for killing a GOC member!")
					attacker:AddFrags(5)
					SendKillNotification(attacker, TEAM_GOC, victim:Nick(), 5, false)
				end
			elseif attacker:GTeam() == TEAM_SCI then
				victim:PrintMessage(HUD_PRINTTALK, "You were killed by a Researcher: " .. attacker:Nick())
				if victim:GTeam() == TEAM_SCP then
					-- Nie dawaj punktów za zabicie SCP-999 (już obsłużone wcześniej)
					if victim:GetNClass() != ROLES.ROLE_SCP999 then
						print("[" .. attacker:Nick() .. "] You've been awarded with 10 points for killing an SCP!")
						attacker:AddFrags(10)
						SendKillNotification(attacker, TEAM_SCP, victim:Nick(), 10, false)
					end
				elseif victim:GTeam() == TEAM_CHAOS then
					print("[" .. attacker:Nick() .. "] You've been awarded with 5 points for killing a Chaos Insurgency member!")
					attacker:AddFrags(5)
					SendKillNotification(attacker, TEAM_CHAOS, victim:Nick(), 5, false)
				elseif victim:GTeam() == TEAM_CLASSD then
					print("[" .. attacker:Nick() .. "] You've been awarded with 2 points for killing a Class D Personell!")
					attacker:AddFrags(2)
					SendKillNotification(attacker, TEAM_CLASSD, victim:Nick(), 2, false)
				elseif victim:GTeam() == TEAM_GOC then
					print("[" .. attacker:Nick() .. "] You've been awarded with 5 points for killing a GOC member!")
					attacker:AddFrags(5)
					SendKillNotification(attacker, TEAM_GOC, victim:Nick(), 5, false)
				end
			elseif attacker:GTeam() == TEAM_GOC then
				-- GOC nie dostaje punktów za zabijanie innych GOC (friendly fire)
				if victim:GTeam() != TEAM_GOC then
					victim:PrintMessage(HUD_PRINTTALK, "You were killed by a GOC member: " .. attacker:Nick())
					if victim:GTeam() == TEAM_SCP then
						-- Nie dawaj punktów za zabicie SCP-999 (już obsłużone wcześniej)
						if victim:GetNClass() != ROLES.ROLE_SCP999 then
							print("[" .. attacker:Nick() .. "] You've been awarded with 10 points for killing an SCP!")
							attacker:AddFrags(10)
							SendKillNotification(attacker, TEAM_SCP, victim:Nick(), 10, false)
						end
					elseif victim:GTeam() == TEAM_CHAOS then
						print("[" .. attacker:Nick() .. "] You've been awarded with 5 points for killing a Chaos Insurgency member!")
						attacker:AddFrags(5)
						SendKillNotification(attacker, TEAM_CHAOS, victim:Nick(), 5, false)
					elseif victim:GTeam() == TEAM_GUARD then
						print("[" .. attacker:Nick() .. "] You've been awarded with 5 points for killing an MTF Guard!")
						attacker:AddFrags(5)
						SendKillNotification(attacker, TEAM_GUARD, victim:Nick(), 5, false)
					elseif victim:GTeam() == TEAM_SCI then
						print("[" .. attacker:Nick() .. "] You've been awarded with 2 points for killing a Researcher!")
						attacker:AddFrags(2)
						SendKillNotification(attacker, TEAM_SCI, victim:Nick(), 2, false)
					elseif victim:GTeam() == TEAM_CLASSD then
						print("[" .. attacker:Nick() .. "] You've been awarded with 2 points for killing a Class D Personnel!")
						attacker:AddFrags(2)
						SendKillNotification(attacker, TEAM_CLASSD, victim:Nick(), 2, false)
					end
				else
					-- Friendly fire - brak punktów
					victim:PrintMessage(HUD_PRINTTALK, "You were killed by a fellow GOC member: " .. attacker:Nick())
				end
			end
		end
	end
	if not roundstats then
		roundstats = { deaths = 0 }
	end
	roundstats.deaths = roundstats.deaths + 1
	local wasteam = victim:GTeam()
	victim:SetTeam(TEAM_SPEC)
	victim:SetGTeam(TEAM_SPEC)
	
	victim:DropAllWeapons( true )

	WinCheck()
	if !postround then
		if !IsValid( attacker ) or !attacker.GTeam then return end
		local isTeamkill = false
		local teamkillPenalty = 0
		
		if attacker:GTeam() == wasteam then
			PunishVote( attacker, victim )
			isTeamkill = true
			teamkillPenalty = -5
		elseif attacker:GTeam() == TEAM_GUARD then
			if wasteam == TEAM_SCI then
				PunishVote( attacker, victim )
				isTeamkill = true
				teamkillPenalty = -3
			end
		elseif attacker:GTeam() == TEAM_SCI then
			if wasteam == TEAM_GUARD then
				PunishVote( attacker, victim )
				isTeamkill = true
				teamkillPenalty = -3
			end
		elseif attacker:GTeam() == TEAM_CLASSD then
			if wasteam == TEAM_CHAOS then
				PunishVote( attacker, victim )
				isTeamkill = true
				teamkillPenalty = -3
			end
		elseif attacker:GTeam() == TEAM_CHAOS then
			if wasteam == TEAM_CLASSD then
				PunishVote( attacker, victim )
				isTeamkill = true
				teamkillPenalty = -3
			end
		end
		
		-- Wyślij powiadomienie o teamkill
		if isTeamkill then
			attacker:AddFrags(teamkillPenalty)
			SendKillNotification(attacker, wasteam, victim:Nick(), teamkillPenalty, true)
		end
	end
end

function GM:PlayerDisconnected( ply )
	 ply:SetTeam(TEAM_SPEC)
	 if #player.GetAll() < MINPLAYERS then
		BroadcastLua('gamestarted = false')
		gamestarted = false
	 end
	 WinCheck()
end

function HaveRadio(pl1, pl2)
	if pl1:HasWeapon("item_radio") then
		if pl2:HasWeapon("item_radio") then
			local r1 = pl1:GetWeapon("item_radio")
			local r2 = pl2:GetWeapon("item_radio")
			if !IsValid(r1) or !IsValid(r2) then return false end
			/*
			print(pl1:Nick() .. " - " .. pl2:Nick())
			print(r1.Enabled)
			print(r1.Channel)
			print(r2.Enabled)
			print(r2.Channel)
			*/
			if r1.Enabled == true then
				if r2.Enabled == true then
					if r1.Channel == r2.Channel then
						if r1.Channel > 4 then
							return true
						end
					end
				end
			end
		end
	end
	return false
end

function GM:PlayerCanHearPlayersVoice( listener, talker )
	if talker:Alive() == false then return false end
	if listener:Alive() == false then return false end

	if !talker.GetNClass then
		player_manager.SetPlayerClass( talker, "class_breach" )
		player_manager.RunClass( talker, "SetupDataTables" )
	end

	if !listener.GetNClass then
		player_manager.SetPlayerClass( listener, "class_breach" )
		player_manager.RunClass( listener, "SetupDataTables" )
	end

	if talker:GetNClass() == ROLES.ROLE_SCP957 or listener:GetNClass() == ROLES.ROLE_SCP957 then
		if talker:GetNClass() == ROLES.ROLE_SCP9571 or listener:GetNClass() == ROLES.ROLE_SCP9571 then
			return true
		end
	end

	-- Sprawdź efekt SCP-420-J
	local talkerHas420J = talker.n420endtime and talker.n420endtime > CurTime()
	local listenerHas420J = listener.n420endtime and listener.n420endtime > CurTime()
	
	-- Jeśli któryś ma efekt SCP-420-J i jedna osoba jest SCP, pozwól na komunikację
	if talkerHas420J or listenerHas420J then
		if talker:GTeam() == TEAM_SCP or listener:GTeam() == TEAM_SCP then
			return true
		end
	end

	if talker:GTeam() == TEAM_SCP and talker:GetNClass() != ROLES.ROLE_SCP9571 then
		local omit = false

		if talker:GetNClass() == ROLES.ROLE_SCP939 then
			local wep = talker:GetWeapon("weapon_scp_939")
			if IsValid( wep ) then
				if wep.Channel == "ALL" then
					omit = true
				end
			end
		end

		if !omit and GetConVar( "br_allow_scptovoicechat" ):GetInt() == 0 then
			if listener:GTeam() != TEAM_SCP then
				return false
			end
		end
	end
	if talker:GTeam() == TEAM_SPEC then
		if listener:GTeam() == TEAM_SPEC then
			return true
		else
			return false
		end
	end
	if HaveRadio(listener, talker) == true then
		return true
	end
	if talker:GetPos():Distance(listener:GetPos()) < 750 then
		return true, true
	else
		return false
	end
end

function GM:PlayerCanSeePlayersChat( text, teamOnly, listener, talker )
	if activevote and ( text == "!forgive" or text == "!punish" ) then
		local votemsg = false
		if talker.voted == true or talker:SteamID64() == activesuspect then
			if !talker.timeout then talker.timeout = 0 end
			if talker.timeout < CurTime() then
				talker.timeout = CurTime() + 0.5
				net.Start( "ShowText" )
					net.WriteString( "vote_fail" )
				net.Send( talker )
			end
			return
		end
		if text == "!forgive" then
			if talker:SteamID64() == activevictim then
				voteforgive = voteforgive + 5
			elseif talker:GTeam() == TEAM_SPEC then
				specforgive = specforgive + 1
			else
				voteforgive = voteforgive + 1
			end
			talker.voted = true
			votemsg = true
			talker.timeout = CurTime() + 0.5
		elseif text == "!punish" then
			if talker:SteamID64() == activevictim then
				votepunish = votepunish + 5
			elseif talker:GTeam() == TEAM_SPEC then
				specpunish = specpunish + 1
			else
				votepunish = votepunish + 1
			end
			talker.voted = true
			votemsg = true
			talker.timeout = CurTime() + 0.5
		end
		if votemsg then
			if listener:IsSuperAdmin() then
				return true
			else
				return false
			end
		end
	end

	if !talker.GetNClass or !listener.GetNClass then
		player_manager.SetPlayerClass( ply, "class_breach" )
		player_manager.RunClass( ply, "SetupDataTables" )
	end

	-- SCP-957: specjalne grupowanie głosowe / czatowe
	if talker:GetNClass() == ROLES.ROLE_SCP957 or listener:GetNClass() == ROLES.ROLE_SCP957 then
		if talker:GetNClass() == ROLES.ROLE_SCP9571 or listener:GetNClass() == ROLES.ROLE_SCP9571 then
			return true
		end
	end

	-- SCP-420-J: pozwól na widoczność czatu pomiędzy graczem pod efektem 420-J a drużyną SCP
	local talkerHas420J   = talker.n420endtime   and talker.n420endtime   > CurTime()
	local listenerHas420J = listener.n420endtime and listener.n420endtime > CurTime()
	if (talkerHas420J or listenerHas420J) and (talker:GTeam() == TEAM_SCP or listener:GTeam() == TEAM_SCP) then
		return true
	end

	if talker:GetNClass() == ROLES.ADMIN or listener:GetNClass() == ROLES.ADMIN then return true end
	if talker:Alive() == false then return false end
	if listener:Alive() == false then return false end
	if teamOnly then
		if talker:GetPos():Distance(listener:GetPos()) < 750 then
			return (listener:GTeam() == talker:GTeam())
		else
			return false
		end
	end
	if talker:GTeam() == TEAM_SPEC then
		if listener:GTeam() == TEAM_SPEC then
			return true
		else
			return false
		end
	end
	if HaveRadio(listener, talker) == true then
		return true
	end
	return (talker:GetPos():Distance(listener:GetPos()) < 750)
end

function GM:PlayerDeathSound()
	return true
end

hook.Add( "PlayerSay", "SCPPenaltyShow", function( ply, msg, teamonly )
	if string.lower( msg ) == "!scp" then
		if !ply.nscpcmdcheck or ply.nscpcmdcheck < CurTime() then
			ply.nscpcmdcheck = CurTime() + 10

			local r = tonumber( ply:GetPData( "scp_penalty", 0 ) ) - 1
			r = math.max( r, 0 )

			if r == 0 then
				ply:PrintTranslatedMessage( "scpready#50,200,50" )
			else
				ply:PrintTranslatedMessage( "scpwait".."$"..r.."#200,50,50" )
			end
		end

		return ""
	end
end )

hook.Add( "SetupPlayerVisibility", "CCTVPVS", function( ply, viewentity )
	local wep = ply:GetActiveWeapon()
	if IsValid( wep ) and wep:GetClass() == "item_cameraview" then
		if wep:GetEnabled() and IsValid( CCTV[wep:GetCAM()].ent ) then
			AddOriginToPVS( CCTV[wep:GetCAM()].pos )// + Vector( 0, 0, -10 ) )
		end
	end
end )

function GM:PlayerCanPickupWeapon( ply, wep )
	//if ply.lastwcheck == nil then ply.lastwcheck = 0 end
	//if ply.lastwcheck > CurTime() then return end
	//ply.lastwcheck = CurTime() + 0.5
	-- if wep.IDK != nil then
	-- 	for k,v in pairs(ply:GetWeapons()) do
	-- 		if wep.Slot == v.Slot then return false end
	-- 	end
	-- end

	if ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 and ply:GetNClass() != ROLES.ROLE_SCP035 then
		if wep.ISSCP then
			return true
		end

		return false
		/*if not wep.ISSCP then
			return false
		else
			if wep.ISSCP == true then
				return true
			else
				return false
			end
		end*/
	end

	if ply:GTeam() != TEAM_SPEC then
		-- Security Droid nie może podnosić SCP-714 i eyedrops (nie działają na androidy)
		if ply:GetNClass() == ROLES.ROLE_SECURITY_DROID then
			local wepClass = wep:GetClass()
			if wepClass == "item_scp_714" or wepClass == "item_czysty" or wepClass == "item_eyedrops" then
				return false
			end
		end
		
		if wep.teams then
			local canuse = false
			for k,v in pairs(wep.teams) do
				if v == ply:GTeam() then
					canuse = true
				end
			end

			if canuse == false and ply:GetNClass() != ROLES.ROLE_SCP9571 and ply:GetNClass() != ROLES.ROLE_SCP035 then
				return false
			end
		end

		for k,v in pairs(ply:GetWeapons()) do
			if v:GetClass() == wep:GetClass() then
				return false
			end
		end

		if string.Left( wep:GetClass(), 3 ) == "cw_" then
			for k, v in pairs( ply:GetWeapons() ) do
				//if ( string.starts( v:GetClass(), "cw_" ) and string.starts( wep:GetClass(), "cw_" )) then return false end
				if string.Left( v:GetClass(), 3 ) == "cw_" then return false end
			end
		end

		if table.Count( ply:GetWeapons() ) >= 12 then
			return false
		end

		ply.gettingammo = wep.SavedAmmo

		return true
	else
		if ply:GetNClass() == ROLES.ADMIN then
			if wep:GetClass() == "br_holster" then return true end
			if wep:GetClass() == "weapon_physgun" then return true end
			if wep:GetClass() == "gmod_tool" then return true end
			if wep:GetClass() == "br_entity_remover" then return true end
			if wep:GetClass() == "br_tool_teleporter" then return true end
		end

		return false
	end
end

function GM:PlayerCanPickupItem( ply, item )
	-- Blokuj SCP możliwość podnoszenia itemów (oprócz SCP-9571 i SCP-035)
	if ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 and ply:GetNClass() != ROLES.ROLE_SCP035 then
		return false
	end
	
	return ply:GTeam() != TEAM_SPEC or ply:GetNClass() == ROLES.ADMIN
end

function GM:AllowPlayerPickup( ply, ent )
	-- Blokuj SCP możliwość podnoszenia obiektów (oprócz SCP-9571 i SCP-035)
	if ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 and ply:GetNClass() != ROLES.ROLE_SCP035 then
		return false
	end
	
	return ply:GTeam() != TEAM_SPEC or ply:GetNClass() == ROLES.ADMIN
end
// usesounds = true,
function IsInTolerance( spos, dpos, tolerance )
	if spos == dpos then return true end

	if isnumber( tolerance ) then
		tolerance = { x = tolerance, y = tolerance, z = tolerance }
	end

	local allaxes = { "x", "y", "z" }
	for k, v in pairs( allaxes ) do
		if spos[v] != dpos[v] then
			if tolerance[v] then
				if math.abs( dpos[v] - spos[v] ) > tolerance[v] then
					return false
				end
			else
				return false
			end
		end
	end

	return true
end

function GM:PlayerUse( ply, ent )
	if ply:GTeam() == TEAM_SPEC and ply:GetNClass() != ROLES.ADMIN then return false end
	if ply:GetNClass() == ROLES.ADMIN then return true end
	if ply.lastuse == nil then ply.lastuse = 0 end
	if ply.lastuse > CurTime() then return false end

	if MAPBUTTONS then
		for k, v in pairs( MAPBUTTONS ) do
		if v.pos == ent:GetPos() or v.tolerance then
			if v.tolerance and !IsInTolerance( v.pos, ent:GetPos(), v.tolerance ) then
				continue
			end

			ply.lastuse = CurTime() + 1

			if v.access then
				if OMEGADoors then
					return true
				end

				if v.levelOverride and v.levelOverride( ply ) then
					return true
				end

				local wep = ply:GetActiveWeapon()
				if IsValid( wep ) and wep:GetClass() == "br_keycard" then
					local keycard = wep
					if IsValid( keycard ) then
						if bit.band( keycard.Access, v.access ) > 0 then
							if !v.nosound then
								ply:EmitSound( "KeycardUse1.ogg" )
							end

							ply:PrintMessage( HUD_PRINTCENTER, v.custom_access or "Access granted to "..v.name )

							if v.custom_access_granted then
								return v.custom_access_granted( ply, ent ) or false
							else
								return true
							end
						else
							if !v.nosound then
								ply:EmitSound( "KeycardUse2.ogg" )
							end

							ply:PrintMessage( HUD_PRINTCENTER, v.custom_deny or "You cannot operate this door with this keycard" )

							return false
						end
					end
				else
					ply:PrintMessage( HUD_PRINTCENTER, v.custom_nocard or "A keycard is required to operate this door" )
					return false
				end
			end

			if v.canactivate == nil or v.canactivate( ply, ent ) then
				if !v.nosound then
					ply:EmitSound( "KeycardUse1.ogg" )
				end

				if v.customaccessmsg then
					ply:PrintMessage( HUD_PRINTCENTER, v.customaccessmsg )
				else
					ply:PrintMessage( HUD_PRINTCENTER, "Access granted to " .. v["name"] )
				end

				return true
			else
				if !v.nosound then
					ply:EmitSound( "KeycardUse2.ogg" )
				end

				if v.customdenymsg then
					ply:PrintMessage( HUD_PRINTCENTER, v.customdenymsg )
				else
					ply:PrintMessage( HUD_PRINTCENTER, "Access denied" )
				end

				return false
			end
		end
		end
	end

	if ( GetConVar( "br_scp_cars" ):GetInt() == 0 ) then
		if ( ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 ) then
			if ( ent:GetClass() == "prop_vehicle_jeep" ) then
				return false
			end
		end
	end

	if ply:GTeam() == TEAM_SCP and ply:GetNClass() != ROLES.ROLE_SCP9571 and ply:GetNClass() != ROLES.ROLE_SCP035 then
		if ent:GetClass() == "cw_ammo_40mm" then
			return false
		end
		
		-- Blokuj SCP możliwość podnoszenia przedmiotów (itemów)
		if string.find(ent:GetClass(), "item_") then
			return false
		end
	end

	-- Medic Droid healing system - DISABLED (class removed)
	-- if ply:GetNClass() == ROLES.ROLE_MEDIC_DROID and ent:IsPlayer() then
	--	local target = ent
	--	-- Sprawdź czy target to Security Droid z życiem poniżej 50%
	--	if target:GetNClass() == ROLES.ROLE_SECURITY_DROID and target:Health() < 50 and target:Health() > 0 then
	--		-- Rozpocznij proces leczenia
	--		if not ply.HealingTarget then
	--			ply.HealingTarget = target
	--			ply.HealingStartTime = CurTime()
	--			ply:PrintMessage(HUD_PRINTCENTER, "Rozpoczynam leczenie Security Droid...")
	--			target:PrintMessage(HUD_PRINTCENTER, "Medic Droid rozpoczął Twoje leczenie...")
	--		end
	--		return false -- Blokuj normalne użycie
	--	end
	-- end

	return true
end

function GM:CanPlayerSuicide( ply )
	return false
end

-- Hook naprawiający problem z przezroczystością na scoreboardzie
function GM:ScoreboardShow( ply )
	-- Wymuś synchronizację ActivePlayer dla wszystkich graczy gdy ktoś otwiera scoreboard
	timer.Simple(0.1, function()
		for k, v in pairs(player.GetAll()) do
			if IsValid(v) then
				if v.ActivePlayer == nil then
					v.ActivePlayer = true
				end
				if v.GetNActive and v.SetNActive then
					v:SetNActive(v.ActivePlayer)
				end
			end
		end
	end)
end

-- Ochrona przed spawn killingiem MTF podczas preparing i wsparcia
function GM:EntityTakeDamage( target, dmginfo )
	-- Sprawdź czy to gracz
	if not target:IsPlayer() then return end
	
	-- Ochrona MTF i CI Spy podczas fazy preparing
	if preparing then
		if target:GTeam() == TEAM_GUARD or (target:GTeam() == TEAM_CHAOS and target:GetNClass() == ROLES.ROLE_CHAOSSPY) then
			local attacker = dmginfo:GetAttacker()
			if IsValid(attacker) and attacker:IsPlayer() then
				dmginfo:SetDamage(0)
				dmginfo:ScaleDamage(0)
				return true
			end
		end
	end
	
	-- Ochrona wsparcia MTF i Chaos przed spawn killingiem (5 sekund)
	if target.SupportSpawnProtection and CurTime() < target.SupportSpawnProtection then
		dmginfo:SetDamage(0)
		dmginfo:ScaleDamage(0)
		return true
	end
end

-- System przezroczystości dla chronionych MTF i CI Spy TYLKO podczas preparing
local function UpdateMTFProtection()
	if not preparing then 
		-- Zatrzymaj timer gdy preparing się kończy
		timer.Remove("MTFProtectionEffect")
		return 
	end
	
	for k, v in pairs(player.GetAll()) do
		if IsValid(v) then
			-- Chroń MTF i CI Spy podczas preparing (ale NIE tych co mają ochronę wsparcia)
			if (v:GTeam() == TEAM_GUARD or (v:GTeam() == TEAM_CHAOS and v:GetNClass() == ROLES.ROLE_CHAOSSPY)) and not v.SupportSpawnProtection then
				-- Efekt przezroczystości (miganie)
				local alpha = math.sin(CurTime() * 3) * 50 + 100 -- Oscyluje między 50 a 150
				v:SetColor(Color(255, 255, 255, alpha))
				v:SetRenderMode(RENDERMODE_TRANSALPHA)
			end
		end
	end
end

-- Timer dla efektu przezroczystości
timer.Create("MTFProtectionEffect", 0.1, 0, UpdateMTFProtection)

-- OPTYMALIZACJA: Zastąpienie Think hook event-driven systemem
local preparingEndHandled = false

-- Timer zamiast Think hook - znacznie lepsza wydajność
local function CheckPreparingEnd()
	if not preparing and not preparingEndHandled then
		-- Wykonaj tylko raz po zakończeniu preparing
		timer.Remove("MTFProtectionEffect")
		timer.Remove("CheckPreparingEnd") -- Usuń timer po wykonaniu

		-- Użyj cache graczy zamiast player.GetAll()
		if UpdatePlayerCache then UpdatePlayerCache() end
		local players = PlayerCache and PlayerCache.All or player.GetAll()

		-- Resetuj przezroczystość dla wszystkich graczy (oprócz tych z ochroną wsparcia)
		for k, v in pairs(players) do
			if IsValid(v) and not (v.SupportSpawnProtection and CurTime() < v.SupportSpawnProtection) then
				v:SetColor(Color(255, 255, 255, 255))
				v:SetRenderMode(RENDERMODE_NORMAL)
			end
		end

		preparingEndHandled = true
		print("[OPTIMIZATION] MTF Protection reset completed")
	elseif preparing then
		-- Reset flagi gdy preparing się zaczyna ponownie
		preparingEndHandled = false
	end
end

-- Event-driven system zamiast Think hook
hook.Add("OnRoundStateChanged", "OptimizedMTFProtection", function(newState)
	if newState == "active" and not preparingEndHandled then
		CheckPreparingEnd()
	elseif newState == "preparing" then
		preparingEndHandled = false
	end
end)

-- Fallback timer dla kompatybilności
timer.Create("CheckPreparingEnd", 1, 0, CheckPreparingEnd)

-- Hook blokujący strzelanie dla chronionych graczy wsparcia
hook.Add("EntityFireBullets", "BlockSupportProtectedShooting", function(ent, data)
	if IsValid(ent) and ent:IsPlayer() then
		if ent.SupportSpawnProtection and CurTime() < ent.SupportSpawnProtection then
			return false -- Blokuj strzelanie
		end
	end
end)

-- Medic Droid healing system - KeyPress hook - DISABLED (class removed)
-- hook.Add("KeyPress", "MedicDroidHealing", function(ply, key)
--	if not IsValid(ply) or not ply:Alive() then return end
--	if ply:GetNClass() ~= ROLES.ROLE_MEDIC_DROID then return end
--
--	-- Sprawdź czy gracz przytrzymuje klawisz E (IN_USE)
--	if ply:KeyDown(IN_USE) then
--		-- Znajdź Security Droid w pobliżu
--		local trace = ply:GetEyeTrace()
--		local target = trace.Entity
--
--		if IsValid(target) and target:IsPlayer() and target:GetNClass() == ROLES.ROLE_SECURITY_DROID then
--			local distance = ply:GetPos():Distance(target:GetPos())
--
--			-- Sprawdź dystans (maksymalnie 100 jednostek)
--			if distance <= 100 and target:Health() < 50 and target:Health() > 0 then
--				-- Rozpocznij leczenie jeśli jeszcze nie rozpoczęte
--				if not ply.HealingTarget then
--					ply.HealingTarget = target
--					ply.HealingStartTime = CurTime()
--					ply.HealingProgress = 0
--					ply:PrintMessage(HUD_PRINTCENTER, "Rozpoczynam leczenie Security Droid...")
--					target:PrintMessage(HUD_PRINTCENTER, "Medic Droid rozpoczął Twoje leczenie...")
--
--					-- OPTYMALIZACJA: Użyj nowej funkcji zamiast Think hook
--					StartMedicHealing(ply, target)
--				end
--			end
--		end
--	end
-- end)

-- Medic Droid healing system - KeyRelease hook - DISABLED (class removed)
-- hook.Add("KeyRelease", "MedicDroidHealingStop", function(ply, key)
--	if not IsValid(ply) then return end
--	if ply:GetNClass() ~= ROLES.ROLE_MEDIC_DROID then return end
--
--	-- Sprawdź czy gracz puścił klawisz E (IN_USE)
--	if key == IN_USE then
--		-- Zatrzymaj leczenie
--		if ply.HealingTarget then
--			ply:PrintMessage(HUD_PRINTCENTER, "Healing interrupted")
--		if IsValid(ply.HealingTarget) then
--			ply.HealingTarget:PrintMessage(HUD_PRINTCENTER, "Healing interrupted")
--			end
--			ply.HealingTarget = nil
--			ply.HealingStartTime = nil
--			ply.HealingProgress = nil
--		end
--	end
-- end)

-- ========================================
-- OPTYMALIZACJE WYDAJNOŚCI - WBUDOWANE
-- ========================================

-- Cache dla graczy (aktualizowany co sekundę)
PlayerCache = PlayerCache or {}
local LastCacheUpdate = 0

function UpdatePlayerCache()
	if CurTime() - LastCacheUpdate < 1 then return end

	PlayerCache.All = player.GetAll()
	PlayerCache.Alive = {}
	PlayerCache.SCP = {}
	PlayerCache.Human = {}

	for _, ply in pairs(PlayerCache.All) do
		if IsValid(ply) and ply:Alive() then
			table.insert(PlayerCache.Alive, ply)

			local team = ply:GTeam()
			if team == TEAM_SCP then
				table.insert(PlayerCache.SCP, ply)
			else
				table.insert(PlayerCache.Human, ply)
			end
		end
	end

	LastCacheUpdate = CurTime()
end

-- Zoptymalizowane wyszukiwanie graczy w pobliżu
function FindNearbyPlayers(pos, radius, excludePlayer)
	UpdatePlayerCache()
	local players = PlayerCache.Alive or player.GetAll()
	local nearbyPlayers = {}
	local radiusSq = radius * radius

	for _, ply in pairs(players) do
		if IsValid(ply) and ply ~= excludePlayer and ply:Alive() then
			if ply:GetPos():DistToSqr(pos) <= radiusSq then
				table.insert(nearbyPlayers, ply)
			end
		end
	end

	return nearbyPlayers
end

-- Eksportuj funkcje globalnie
_G.UpdatePlayerCache = UpdatePlayerCache
_G.FindNearbyPlayers = FindNearbyPlayers

-- OPTYMALIZACJA: Medic Droid healing system - Timer zamiast Think hook - DISABLED (class removed)
-- local ActiveHealers = {}
--
-- local function ProcessMedicHealing()
--	for steamid, data in pairs(ActiveHealers) do
--		local ply = data.healer
--		local target = data.target
--
--		if not IsValid(ply) or not IsValid(target) or not ply:Alive() then
--			ActiveHealers[steamid] = nil
--			continue
--		end
--
--		local distance = ply:GetPos():Distance(target:GetPos())
--
--		-- Sprawdź warunki leczenia
--		if ply:KeyDown(IN_USE) and distance <= 100 and target:Health() < 50 and target:Health() > 0 then
--			local healTime = CurTime() - data.startTime
--
--			if healTime >= 3.0 then
--				-- Heal to 50% health
--				target:SetHealth(50)
--				ply:PrintMessage(HUD_PRINTCENTER, "Security Droid healed successfully!")
--				target:PrintMessage(HUD_PRINTCENTER, "You have been healed by Medic Droid!")
--
--				-- Efekt dźwiękowy
--				ply:EmitSound("items/medshot4.wav")
--				target:EmitSound("items/medshot4.wav")
--
--				-- Zakończ leczenie
--				ActiveHealers[steamid] = nil
--				ply.HealingTarget = nil
--				ply.HealingStartTime = nil
--				ply.HealingProgress = nil
--			else
--				-- Show healing progress
--				local progress = math.floor((healTime / 3.0) * 100)
--				ply:PrintMessage(HUD_PRINTCENTER, "Healing: " .. progress .. "%")
--				target:PrintMessage(HUD_PRINTCENTER, "Healing: " .. progress .. "%")
--			end
--		else
--			-- Warunki nie spełnione, przerwij leczenie
--			ply:PrintMessage(HUD_PRINTCENTER, "Healing interrupted")
--			if IsValid(target) then
--				target:PrintMessage(HUD_PRINTCENTER, "Healing interrupted")
--			end
--			ActiveHealers[steamid] = nil
--			ply.HealingTarget = nil
--			ply.HealingStartTime = nil
--			ply.HealingProgress = nil
--		end
--	end
--
--	-- Usuń timer jeśli nie ma aktywnych lecących
--	if table.IsEmpty(ActiveHealers) then
--		timer.Remove("OptimizedMedicHealing")
--	end
-- end
--
-- -- Funkcja do rozpoczęcia leczenia (wywoływana z KeyPress hook)
-- function StartMedicHealing(healer, target)
--	if not IsValid(healer) or not IsValid(target) then return end
--
--	local steamid = healer:SteamID64()
--	ActiveHealers[steamid] = {
--		healer = healer,
--		target = target,
--		startTime = CurTime()
--	}
--
--	-- Uruchom timer jeśli nie istnieje
--	if not timer.Exists("OptimizedMedicHealing") then
--		timer.Create("OptimizedMedicHealing", 0.1, 0, ProcessMedicHealing)
--	end
-- end

-- Medic Droid weapon pickup restriction - DISABLED (class removed)
-- hook.Add("PlayerCanPickupWeapon", "MedicDroidWeaponRestriction", function(ply, weapon)
--	if not IsValid(ply) or not IsValid(weapon) then return end
--	if ply:GetNClass() ~= ROLES.ROLE_MEDIC_DROID then return end
--
--	-- Sprawdź czy to broń CW2
--	if weapon.CW20Weapon then
--		ply:PrintMessage(HUD_PRINTCENTER, "As Medic Droid you cannot pick up CW2 weapons!")
--		return false
--	end
--
--	-- Sprawdź czy to broń z prefiksem "cw_"
--	local weaponClass = weapon:GetClass()
--	if string.StartWith(weaponClass, "cw_") then
--		ply:PrintMessage(HUD_PRINTCENTER, "As Medic Droid you cannot pick up CW2 weapons!")
--		return false
--	end
-- end)

-- Hook obsługujący strzałki dla kamer
hook.Add("PlayerButtonDown", "CameraArrowKeys", function(ply, button)
	local wep = ply:GetActiveWeapon()
	if IsValid(wep) and wep:GetClass() == "item_cameraview" and wep:GetEnabled() then
		if button == KEY_LEFT then
			if wep.NextChange and wep.NextChange < CurTime() then
				wep:PrevCamera()
				wep.NextChange = CurTime() + 0.1
			end
		elseif button == KEY_RIGHT then
			if wep.NextChange and wep.NextChange < CurTime() then
				wep:NextCamera()
				wep.NextChange = CurTime() + 0.1
			end
		end
	end
end)

-- Hook blokujący wszystkie ataki dla chronionych graczy wsparcia
hook.Add("PlayerButtonDown", "BlockSupportProtectedAttack", function(ply, button)
	if ply.SupportSpawnProtection and CurTime() < ply.SupportSpawnProtection then
		if button == KEY_LMOUSE or button == KEY_RMOUSE then
			return false -- Blokuj atak
		end
	end
end)

-- Hook blokujący prop damage od cw_40mm_explosive
hook.Add("EntityTakeDamage", "BlockCW40mmPropDamage", function(target, dmginfo)
	if target:IsPlayer() then
		local inflictor = dmginfo:GetInflictor()
		local attacker = dmginfo:GetAttacker()
		
		-- Blokuj prop damage od cw_40mm_explosive (uderza przed eksplozją)
		if IsValid(inflictor) and inflictor:GetClass() == "cw_40mm_explosive" then
			-- Sprawdź czy to prop damage (gdy attacker == world/inflictor)
			if not IsValid(attacker) or attacker == inflictor or attacker:GetClass() == "worldspawn" then
				dmginfo:SetDamage(0)
				dmginfo:ScaleDamage(0)
				return true
			end
		end
	end
end)

-- OPTYMALIZACJA: System wsparcia - indywidualne timery zamiast Think hook
local function RemoveSupportProtection(ply)
	if not IsValid(ply) then return end

	ply.SupportSpawnProtection = nil
	ply:SetColor(Color(255, 255, 255, 255))
	ply:SetRenderMode(RENDERMODE_NORMAL)

	-- Upewnij się że bronie mogą strzelać
	local weapon = ply:GetActiveWeapon()
	if IsValid(weapon) then
		weapon:SetNextPrimaryFire(CurTime())
		weapon:SetNextSecondaryFire(CurTime())
	end

	print("[OPTIMIZATION] Support protection removed for " .. ply:Nick())
end

-- Funkcja do ustawienia ochrony wsparcia
function SetSupportSpawnProtection(ply, duration)
	if not IsValid(ply) then return end

	duration = duration or 10 -- Domyślnie 10 sekund

	ply.SupportSpawnProtection = CurTime() + duration
	ply:SetColor(Color(255, 255, 255, 100))
	ply:SetRenderMode(RENDERMODE_TRANSALPHA)

	-- Indywidualny timer dla gracza
	local timerName = "SupportProtection_" .. ply:SteamID64()
	timer.Create(timerName, duration, 1, function()
		RemoveSupportProtection(ply)
	end)

	print("[OPTIMIZATION] Support protection set for " .. ply:Nick() .. " (" .. duration .. "s)")
end

-- Hook do blokowania akcji podczas ochrony (zoptymalizowany)
hook.Add("PlayerButtonDown", "OptimizedSupportProtection", function(ply, button)
	if ply.SupportSpawnProtection and CurTime() < ply.SupportSpawnProtection then
		if button == IN_ATTACK or button == IN_ATTACK2 then
			return false -- Blokuj atak
		end
	end
end)

function string.starts( String, Start )
   return string.sub( String, 1, string.len( Start ) ) == Start
end

-- SCP-035 Transformation Function
local PlayerMeta = FindMetaTable("Player")

function PlayerMeta:BecomeSCP035()
    if not IsValid(self) then return end
    
    -- Zapisz starą drużynę dla logów
    local oldTeam = self:GTeam()
    
    print("[SCP-035 DEBUG] Starting transformation for " .. self:Nick() .. " (Team: " .. team.GetName(oldTeam) .. ")")
    
    -- Zapisz aktualny vest PRZED transformacją
    local currentVest = self.UsingArmor
    print("[SCP-035 DEBUG] Current vest: " .. tostring(currentVest))
    
    -- Oznacz jako SCP-035
    self.IsSCP035 = true
    
    -- Użyj systemu RegisterSCP który automatycznie zachowa ekwipunek dzięki no_strip = true
    local scp035 = GetSCP("SCP035")
    if scp035 then
        print("[SCP-035 DEBUG] Using RegisterSCP system with no_strip = true")
        scp035:SetupPlayer(self)
    else
        print("[SCP-035 ERROR] SCP-035 not found in RegisterSCP system!")
        -- Fallback do starej metody
        self:SetGTeam(TEAM_SCP)
        self:SetNClass(ROLES.ROLE_SCP035)
        self:SetHealth(200)
        self:SetMaxHealth(200)
        self:SetRunSpeed(250)
        self:SetWalkSpeed(125)
    end
    
    -- Ustaw system vestów dla SCP-035
    if currentVest then
        -- Miał vest przed transformacją - zablokuj go na ciele
        self.UsingArmor = currentVest
        self.LockedArmor = true -- Vest jest przytwierdzony do ciała
        print("[SCP-035 DEBUG] Vest locked to body: " .. currentVest)
        
        -- Wyślij informację o kamizelce do klienta
        net.Start("BR_UpdateVest")
            net.WriteString(currentVest)
        net.Send(self)
    else
        -- Nie miał vesta - całkowity zakaz zakładania vestów
        self.LockedArmor = false -- Oznacza że nie może zakładać vestów w ogóle
        print("[SCP-035 DEBUG] No vest before transformation - vest equipping blocked")
    end
    
    -- Efekty
    self:PrintMessage(HUD_PRINTTALK, "[SCP-035] The mask has bonded with you... You feel... different.")
    self:PrintMessage(HUD_PRINTTALK, "[SCP-035] You can now kill both humans AND SCPs!")
    self:PrintMessage(HUD_PRINTTALK, "[SCP-035] Your equipment remains with you...")
    if currentVest then
        self:PrintMessage(HUD_PRINTTALK, "[SCP-035] Your vest has fused with your body - you cannot remove it.")
    end
    
    -- Log dla adminów
    print("[SCP-035] " .. self:Nick() .. " became SCP-035 (was " .. team.GetName(oldTeam) .. ") - Using RegisterSCP system")
end

-- SCP-035 Death Hook - maska spada po śmierci
hook.Add("PlayerDeath", "SCP035_DropMask", function(victim, inflictor, attacker)
	if IsValid(victim) and victim:GetNClass() == ROLES.ROLE_SCP035 then
		-- Stwórz maskę w miejscu śmierci
		timer.Simple(0.1, function() -- Małe opóźnienie dla stabilności
			local mask = ents.Create("scp_035")
			if IsValid(mask) then
				mask:SetPos(victim:GetPos() + Vector(0, 0, 10))
				mask:SetAngles(Angle(0, math.random(0, 360), 0))
				mask:Spawn()
				mask:Activate()
				
				-- Dodaj małą siłę
				local phys = mask:GetPhysicsObject()
				if IsValid(phys) then
					phys:Wake()
					phys:SetVelocity(Vector(math.random(-100, 100), math.random(-100, 100), 100))
				end
				
				print("[SCP-035] Mask dropped after " .. victim:Nick() .. "'s death")
			end
		end)
		
		-- Wyczyść flagi SCP-035
		victim.IsSCP035 = nil
		victim.LockedArmor = nil
	end
end)

-- Blokada komendy thirdperson_toggle
hook.Add("PlayerSay", "BlockThirdPersonToggle", function(ply, text, public)
    local msg = string.lower(string.Trim(text))
    
    -- Blokuj tylko !thirdperson na czacie
    if msg == "!thirdperson" then
        ply:ChatPrint("[SERWER] Komenda thirdperson jest zablokowana na tym serwerze!")
        return ""  -- Blokuj wyświetlenie wiadomości
    end
end)

-- Blokada console command thirdperson_toggle
concommand.Add("thirdperson_toggle", function(ply, cmd, args)
    if IsValid(ply) then
        ply:ChatPrint("[SERWER] Komenda thirdperson jest zablokowana na tym serwerze!")
    end
end)


================================================
FILE: gamemodes/breach/gamemode/modules/sv_player_infected_fix.lua
================================================
-- D-CLASS INFECTED PASSIVE ABILITY FIX
-- Skopiuj ten kod do sv_player.lua zamiast istniejącego kodu infected

-- Viral Aura - damages players who stay too close for too long
local InfectedProximity = {} -- Tabela do śledzenia czasu bliskości

-- Usuń stary timer jeśli istnieje
if timer.Exists("DClassInfected_ViralAura") then
	timer.Remove("DClassInfected_ViralAura")
end

timer.Create("DClassInfected_ViralAura", 1, 0, function()
	for _, infected in pairs(player.GetAll()) do
		if IsValid(infected) and infected:Alive() and infected:GetNClass() == ROLES.ROLE_DCLASS_INFECTED then
			local nearbyPlayers = ents.FindInSphere(infected:GetPos(), 50) -- 50 unit radius
			
			-- Sprawdź wszystkich graczy w pobliżu
			for _, ply in pairs(nearbyPlayers) do
				if IsValid(ply) and ply:IsPlayer() and ply:Alive() and ply != infected and ply:GetNClass() != ROLES.ROLE_DCLASS_INFECTED then
					local steamID = ply:SteamID()
					
					-- Inicjalizuj tracking dla gracza jeśli nie istnieje
					if not InfectedProximity[steamID] then
						InfectedProximity[steamID] = 0
					end
					
					-- Zwiększ czas bliskości
					InfectedProximity[steamID] = InfectedProximity[steamID] + 1
					
					-- Po 10 sekundach bliskości zacznij zadawać damage
					if InfectedProximity[steamID] >= 10 then
						-- Własny system trucizny - zadaj 2 damage co sekundę
						ply:SetHealth(ply:Health() - 2)
						
						-- Sprawdź czy gracz nie umarł
						if ply:Health() <= 0 then
							ply:Kill()
							-- Ustaw infected jako zabójcę
							if IsValid(infected) then
								ply:SetNWEntity("killer", infected)
							end
						end
						
						-- Komunikat co 5 sekund żeby nie spamować
						local safeProx = InfectedProximity[steamID] or 0
						if safeProx % 5 == 0 then
							ply:ChatPrint("You feel sick from prolonged exposure to the infected...")
						end
						
						-- Efekt wizualny trucizny
						ply:ScreenFade(SCREENFADE.IN, Color(50, 200, 50, 20), 0.5, 0)
					end
				end
			end
			
			-- Reset czasu dla graczy którzy odeszli za daleko
			for steamID, time in pairs(InfectedProximity) do
				local ply = player.GetBySteamID(steamID)
				if not IsValid(ply) or not ply:Alive() or ply:GetPos():Distance(infected:GetPos()) > 50 then
					InfectedProximity[steamID] = 0
				end
			end
		end
	end
end)

-- Reset przy śmierci
hook.Add("PostPlayerDeath", "InfectedReset", function(ply)
	if ply:GetNClass() == ROLES.ROLE_DCLASS_INFECTED then
		-- Wyczyść wszystkie timery dla tego gracza
		InfectedProximity = {}
	else
		-- Wyczyść timer dla zmarłego gracza
		InfectedProximity[ply:SteamID()] = nil
	end
end)

-- ConVar do włączania/wyłączania debugowania
if not ConVarExists("breach_infected_debug") then
	CreateConVar("breach_infected_debug", "0", FCVAR_ARCHIVE, "Enable debug messages for D-Class Infected")
end 


================================================
FILE: gamemodes/breach/gamemode/modules/sv_round.lua
================================================
activeRound = activeRound
rounds = rounds or -1
roundEnd = roundEnd or 0

MAP_LOADED = MAP_LOADED or false

function RestartGame()
	game.ConsoleCommand("changelevel "..game.GetMap().."\n")
end

function CleanUp()
	timer.Destroy("PreparingTime")
	timer.Destroy("RoundTime")
	timer.Destroy("PostTime")
	timer.Destroy("GateOpen")
	timer.Destroy("PlayerInfo")
	timer.Destroy("NTFEnterTime")
	timer.Destroy("966Debug")
	timer.Destroy("MTFDebug")
	timer.Destroy("PunishEnd")
	timer.Destroy("GateExplode")
	
	-- Usuń timery specjalnych rund
	timer.Remove("SwapperTimer")		-- Swapper round
	timer.Remove("BomberTimer")		-- Bomber round
	timer.Remove("MoveOrDieCheck")		-- Move or Die round
	timer.Remove("TTTRoundTimer")		-- TTT round (jeśli istnieje)
	timer.Remove("InfectTimer")		-- Infect round (jeśli istnieje)
	
	-- Wyczyść zmienne globalne specjalnych rund
	MOVEORDIE_DATA = nil			-- Move or Die round data
	if timer.Exists("CheckEscape") == false then
		timer.Create("CheckEscape", 1, 0, CheckEscape)
	end
	
	game.CleanUpMap()
	
	-- Czyść spraypainty i decale między rundami
	for _, ply in pairs(player.GetAll()) do
		ply:ConCommand("r_cleardecals")
	end
	
	-- Usuń wszystkie spraypainty/decale z mapy
	for _, ent in pairs(ents.GetAll()) do
		if ent:GetClass() == "env_spritecard" then -- spraypainty graczy
			ent:Remove()
		end
		-- Usuń decale z entity
		if IsValid(ent) then
			ent:RemoveAllDecals()
		end
	end
	
	print("[BREACH] Wyczyszczono spraypainty i decale")
	
	Recontain106Used = false
	OMEGAEnabled = false
	OMEGADoors = false
	nextgateaopen = 0
	spawnedntfs = 0
	-- Reset zmiennej itemsSpawned aby itemy mogły się zespawnować w nowej rundzie
	itemsSpawned = false
	
	-- Clean up SCP-268 effects from all players
	for _, ply in pairs(player.GetAll()) do
		if IsValid(ply) then
			-- Remove SCP-268 invisibility effects
			ply:SetColor(Color(255, 255, 255, 255))
			ply:SetRenderMode(RENDERMODE_NORMAL)
			ply:SetNWBool("SCP268_Invisible", false)
			ply:SetNWFloat("SCP268_InvisTime", 0)
			ply:SetNWFloat("SCP268_Cooldown", 0)
			
			-- Clean up SCP-1123 effects
			ply:SetNWBool("SCP1123_InEffect", false)
			ply:SetNWFloat("SCP1123_EffectEnd", 0)
			ply:SetViewEntity(ply) -- Reset camera to self
			
			-- Clean up timers
			timer.Remove("SCP268_Death_" .. ply:SteamID64())
			timer.Remove("SCP1123_Effect_" .. ply:SteamID64())
		end
	end
	roundstats = {
		descaped = 0,
		rescaped = 0,
		sescaped = 0,
		dcaptured = 0,
		rescorted = 0,
		deaths = 0,
		teleported = 0,
		snapped = 0,
		zombies = 0,
		secretf = false
	}
	inUse = false

	-- MANUALNE CZYSZCZENIE CCTV
	if CCTV then
		for i, cam in ipairs(CCTV) do
			if IsValid(cam.ent) then
				cam.ent:Remove()
			end
			cam.ent = nil -- Usuń tylko referencję do encji, a nie cały wpis
		end
		print("[BREACH] Wyczyszczono referencje do kamer CCTV")
	end
end

function CleanUpPlayers()
	for k,v in pairs(player.GetAll()) do
		v:SetModelScale( 1 )
		v:SetCrouchedWalkSpeed(0.6)
		v.mblur = false
		--print( v.ActivePlayer, v:GetNActive() )
		player_manager.SetPlayerClass( v, "class_breach" )
		player_manager.RunClass( v, "SetupDataTables" )
		--print( v.ActivePlayer, v:GetNActive() )
		v:Freeze(false)
		v.MaxUses = nil
		v.blinkedby173 = false
		v.scp173allow = false
		v.scp1471stacks = 1
		v.usedeyedrops = false
		v.isescaping = false
		v:SendLua( "CamEnable = false" )
	end
	net.Start("Effect")
		net.WriteBool( false )
	net.Broadcast()
	net.Start("957Effect")
		net.WriteBool( false )
	net.Broadcast()
end

function RoundTypeUpdate()
	local nextRoundName = GetConVar( "br_force_specialround" ):GetString()
	activeRound = nil
	if tonumber( nextRoundName ) then
		nextRoundName = tonumber( nextRoundName )
	end
	if ROUNDS[ nextRoundName ] then
		activeRound = ROUNDS[ nextRoundName ]
	end
	RunConsoleCommand( "br_force_specialround", "" )
	if !activeRound /*and #ROUNDS > 1*/ then
		local pct = math.Clamp( GetConVar( "br_specialround_pct" ):GetInt(), 0, 100 )
		--print( pct )
		if math.random( 0, 100 ) < pct then
			repeat
				activeRound = table.Random( ROUNDS )
			until( activeRound != ROUNDS.normal )
		end
	end
	if !activeRound then
		activeRound = ROUNDS.normal
	end
end

function RoundRestart()
	if !MAP_LOADED then
		error( "Map config is not loaded!" )
	end
	print( debug.traceback() )  
	print("round: starting")
	CleanUp()
	print("round: map cleaned")
	if GetConVar("br_firstround_debug"):GetInt() > 0 and rounds == -1 then
		rounds = 0
		RoundRestart()
		return
	end
	if GetConVar("br_rounds"):GetInt() > 0 then
		if rounds == GetConVar("br_rounds"):GetInt() then
			RestartGame()
		end
		rounds = rounds + 1
	else
		rounds = 0
	end	
	CleanUpPlayers()
	print("round: players cleaned")
	preparing = true
	postround = false
	activeRound = nil
	if #GetActivePlayers() < MINPLAYERS then WinCheck() end
	RoundTypeUpdate()
	SetupCollide()
	SetupAdmins( player.GetAll() )
activeRound.setup()
	print( "round: setup end" )	
	net.Start("UpdateRoundType")
		net.WriteString(activeRound.name)
	net.Broadcast()	
	activeRound.init()	
	print( "round: int end / preparation start" )	
	gamestarted = true
	BroadcastLua('gamestarted = true')
	print("round: gamestarted")
	timer.Create("966Debug", GetConVar("br_time_preparing"):GetInt() + 15, 1, function()
		local fent = ents.FindInSphere(SPAWN_SCP966, 250)
		for k, v in pairs(fent) do
			if (v:IsPlayer()) then
				if (v:GetNClass() == ROLES.ROLE_SCP966) then
					v:SetPos(OUTSIDE_966)
					print("Do SCP 966 stuck?? Debugging...")
					break
				end
			end
		end
	end )
	net.Start("PrepStart")
		net.WriteInt(GetPrepTime(), 8)
	net.Broadcast()
	UseAll()
	DestroyAll()
	
	-- Spawn SCP Items (including SCP-268)
	SpawnSCPItems()
	
	timer.Destroy("PostTime") -----?????
	hook.Run( "BreachPreround" )
	timer.Create("PreparingTime", GetPrepTime(), 1, function()
		for k,v in pairs(player.GetAll()) do
			v:Freeze(false)
		end
		preparing = false
		postround = false
		
		-- Wyświetl statystyki drużyn po zakończeniu preparing
		local scps = gteams.NumPlayers(TEAM_SCP)
		local mtfs = gteams.NumPlayers(TEAM_GUARD) + gteams.NumPlayers(TEAM_CHAOS)
		local res = gteams.NumPlayers(TEAM_SCI)
		local ds = gteams.NumPlayers(TEAM_CLASSD)
		
		local statsMessage = string.format("Runda rozpoczęta! SCP: %d | MTF: %d | Naukowcy: %d | Klasa D: %d",
			scps, mtfs, res, ds)
		PrintMessage(HUD_PRINTTALK, statsMessage)
		
		activeRound.roundstart()
		
		-- Check if TTT round and set custom time
		local roundTime = GetRoundTime()
		if activeRound and activeRound.name == "TTT" then
			roundTime = 600 -- 10 minutes for TTT round
		end
		
		net.Start("RoundStart")
			net.WriteInt(roundTime, 12)
		net.Broadcast()
		print("round: started")
		roundEnd = CurTime() + roundTime + 3
		hook.Run( "BreachRound" )
		timer.Create("RoundTime", roundTime, 1, function()
			postround = false
			postround = true	
			print( "post init: good" )
			activeRound.postround()		
			GiveExp()	
			print( "post functions: good" )
			print( "round: post" )			
			net.Start("SendRoundInfo")
				net.WriteTable(roundstats)
			net.Broadcast()		
			net.Start("PostStart")
				net.WriteInt(GetPostTime(), 6)
				net.WriteInt(1, 4)
			net.Broadcast()	
			print( "data broadcast: good" )
			roundEnd = 0
			timer.Destroy("PunishEnd")
			hook.Run( "BreachPostround" )
			timer.Create("PostTime", GetPostTime(), 1, function()
				print( "restarting round" )
				RoundRestart()
			end)		
		end)
	end)
end

canescortds = true
canescortrs = true
function CheckEscape()
	for k,v in pairs(ents.FindInSphere(POS_ESCAPE, 250)) do
		if v:IsPlayer() == true then
			if v:Alive() == false then return end
			if v.isescaping == true then return end
			if v:GTeam() == TEAM_CLASSD or v:GTeam() == TEAM_SCI or v:GTeam() == TEAM_SCP then
				if v:GTeam() == TEAM_SCI then
					roundstats.rescaped = roundstats.rescaped + 1
					local rtime = timer.TimeLeft("RoundTime")
					local exptoget = 300
					if rtime != nil then
						exptoget = GetConVar("br_time_round"):GetInt() - (CurTime() - rtime)
						exptoget = exptoget * 1.8
						exptoget = math.Round(math.Clamp(exptoget, 300, 10000))
					end
					net.Start("OnEscaped")
						net.WriteInt(1,4)
					net.Send(v)
					v:AddFrags(5)
					v:AddExp(exptoget, true)
					v:GodEnable()
					v:Freeze(true)
					v.canblink = false
					v.isescaping = true
					timer.Create("EscapeWait" .. v:SteamID64(), 2, 1, function()
						v:Freeze(false)
						v:GodDisable()
						v:SetSpectator()
						WinCheck()
						v.isescaping = false
					end)
					//v:PrintMessage(HUD_PRINTTALK, "You escaped! Try to get escorted by MTF next time to get bonus points.")
				elseif v:GTeam() == TEAM_CLASSD then
					roundstats.descaped = roundstats.descaped + 1
					local rtime = timer.TimeLeft("RoundTime")
					local exptoget = 500
					if rtime != nil then
						exptoget = GetConVar("br_time_round"):GetInt() - (CurTime() - rtime)
						exptoget = exptoget * 2
						exptoget = math.Round(math.Clamp(exptoget, 500, 10000))
					end
					net.Start("OnEscaped")
						net.WriteInt(2,4)
					net.Send(v)
					v:AddFrags(5)
					v:AddExp(exptoget, true)
					v:GodEnable()
					v:Freeze(true)
					v.canblink = false
					v.isescaping = true
					timer.Create("EscapeWait" .. v:SteamID64(), 2, 1, function()
						v:Freeze(false)
						v:GodDisable()
						v:SetSpectator()
						WinCheck()
						v.isescaping = false
					end)
					//v:PrintMessage(HUD_PRINTTALK, "You escaped! Try to get escorted by Chaos Insurgency Soldiers next time to get bonus points.")
				elseif v:GTeam() == TEAM_SCP then
					roundstats.sescaped = roundstats.sescaped + 1
					local rtime = timer.TimeLeft("RoundTime")
					local exptoget = 425
					if rtime != nil then
						exptoget = GetConVar("br_time_round"):GetInt() - (CurTime() - rtime)
						exptoget = exptoget * 1.9
						exptoget = math.Round(math.Clamp(exptoget, 425, 10000))
					end
					net.Start("OnEscaped")
						net.WriteInt(4,4)
					net.Send(v)
					v:AddFrags(5)
					v:AddExp(exptoget, true)
					v:GodEnable()
					v:Freeze(true)
					v.canblink = false
					v.isescaping = true
					timer.Create("EscapeWait" .. v:SteamID64(), 2, 1, function()
						v:Freeze(false)
						v:GodDisable()
						v:SetSpectator()
						WinCheck()
						v.isescaping = false
					end)
				end
			end
		end
	end
end
timer.Create("CheckEscape", 1, 0, CheckEscape)

function CheckEscortMTF(pl)
	if pl.nextescheck != nil then
		if pl.nextescheck > CurTime() then
			pl:PrintMessage(HUD_PRINTTALK, "Wait " .. math.Round(pl.nextescheck - CurTime()) .. " seconds.")
			return
		end
	end
	pl.nextescheck = CurTime() + 3
	if pl:GTeam() != TEAM_GUARD then return end
	local foundpl = nil
	local foundrs = {}
	local foundds = {}
	
	for k,v in pairs(ents.FindInSphere(POS_ESCORT, 350)) do
		if v:IsPlayer() then
			if pl == v then
				foundpl = v
			elseif v:GTeam() == TEAM_SCI and v:Alive() then
				table.ForceInsert(foundrs, v)
			elseif v:GTeam() == TEAM_CLASSD and v:Alive() then
				table.ForceInsert(foundds, v)
			end
		end
	end
	
	if not IsValid(foundpl) then return end
	
	-- Eskortowanie naukowców
	if #foundrs > 0 then
		local rsstr = ""
		for i,v in ipairs(foundrs) do
			if i == 1 then
				rsstr = v:Nick()
			elseif i == #foundrs then
				rsstr = rsstr .. " and " .. v:Nick()
			else
				rsstr = rsstr .. ", " .. v:Nick()
			end
		end
		
		pl:AddFrags(#foundrs * 3)
		pl:AddExp((#foundrs * 425), true)
		local rtime = timer.TimeLeft("RoundTime")
		local exptoget = 700
		if rtime != nil then
			exptoget = GetConVar("br_time_round"):GetInt() - (CurTime() - rtime)
			exptoget = exptoget * 2.25
			exptoget = math.Round(math.Clamp(exptoget, 700, 10000))
		end
		
		for k,v in ipairs(foundrs) do
			roundstats.rescaped = roundstats.rescaped + 1
			v:SetSpectator()
			v:AddFrags(10)
			v:AddExp(exptoget, true)
			v:PrintMessage(HUD_PRINTTALK, "You've been escorted by " .. pl:Nick())
			net.Start("OnEscaped")
				net.WriteInt(3,4)
			net.Send(v)
			WinCheck()
		end
		
		pl:PrintMessage(HUD_PRINTTALK, "You've successfully escorted: " .. rsstr)
	end
	
	-- Eskortowanie Class-D
	if #foundds > 0 then
		local dsstr = ""
		for i,v in ipairs(foundds) do
			if i == 1 then
				dsstr = v:Nick()
			elseif i == #foundds then
				dsstr = dsstr .. " and " .. v:Nick()
			else
				dsstr = dsstr .. ", " .. v:Nick()
			end
		end
		
		pl:AddFrags(#foundds * 3)
		pl:AddExp((#foundds * 500), true)
		local rtime = timer.TimeLeft("RoundTime")
		local exptoget = 800
		if rtime != nil then
			exptoget = GetConVar("br_time_round"):GetInt() - (CurTime() - rtime)
			exptoget = exptoget * 2.5
			exptoget = math.Round(math.Clamp(exptoget, 800, 10000))
		end
		
		for k,v in ipairs(foundds) do
			roundstats.rescaped = roundstats.rescaped + 1
			v:SetSpectator()
			v:AddFrags(10)
			v:AddExp(exptoget, true)
			v:PrintMessage(HUD_PRINTTALK, "You've been escorted by " .. pl:Nick())
			net.Start("OnEscaped")
				net.WriteInt(3,4)
			net.Send(v)
			WinCheck()
		end
		
		pl:PrintMessage(HUD_PRINTTALK, "You've successfully escorted: " .. dsstr)
	end
end

function CheckEscortChaos(pl)
	if pl.nextescheck != nil then
		if pl.nextescheck > CurTime() then
			pl:PrintMessage(HUD_PRINTTALK, "Wait " .. math.Round(pl.nextescheck - CurTime()) .. " seconds.")
			return
		end
	end
	pl.nextescheck = CurTime() + 3
	if pl:GTeam() != TEAM_CHAOS then return end
	local foundpl = nil
	local foundds = {}
	local foundrs = {}
	
	for k,v in pairs(ents.FindInSphere(POS_ESCORT_CI or POS_ESCORT, 350)) do
		if v:IsPlayer() then
			if pl == v then
				foundpl = v
			elseif v:GTeam() == TEAM_CLASSD and v:Alive() then
				table.ForceInsert(foundds, v)
			elseif v:GTeam() == TEAM_SCI and v:Alive() then
				table.ForceInsert(foundrs, v)
			end
		end
	end
	
	if not IsValid(foundpl) then return end
	
	-- Eskortowanie Class-D (oryginalna funkcjonalność)
	if #foundds > 0 then
		local dsstr = ""
		for i,v in ipairs(foundds) do
			if i == 1 then
				dsstr = v:Nick()
			elseif i == #foundds then
				dsstr = dsstr .. " and " .. v:Nick()
			else
				dsstr = dsstr .. ", " .. v:Nick()
			end
		end
		
		pl:AddFrags(#foundds * 3)
		pl:AddExp((#foundds * 500), true)
		local rtime = timer.TimeLeft("RoundTime")
		local exptoget = 800
		if rtime != nil then
			exptoget = GetConVar("br_time_round"):GetInt() - (CurTime() - rtime)
			exptoget = exptoget * 2.5
			exptoget = math.Round(math.Clamp(exptoget, 800, 10000))
		end
		
		for k,v in ipairs(foundds) do
			roundstats.dcaptured = roundstats.dcaptured + 1
			v:SetSpectator()
			v:AddFrags(10)
			v:AddExp(exptoget, true)
			v:PrintMessage(HUD_PRINTTALK, "You've been captured by " .. pl:Nick())
			net.Start("OnEscaped")
				net.WriteInt(3,4)
			net.Send(v)
			WinCheck()
		end
		
		pl:PrintMessage(HUD_PRINTTALK, "You've successfully captured: " .. dsstr)
	end
	
	-- NOWE: Eskortowanie naukowców przez CHAOS
	if #foundrs > 0 then
		local rsstr = ""
		for i,v in ipairs(foundrs) do
			if i == 1 then
				rsstr = v:Nick()
			elseif i == #foundrs then
				rsstr = rsstr .. " and " .. v:Nick()
			else
				rsstr = rsstr .. ", " .. v:Nick()
			end
		end
		
		pl:AddFrags(#foundrs * 3)
		pl:AddExp((#foundrs * 450), true) -- Nieco mniej niż za Class-D
		local rtime = timer.TimeLeft("RoundTime")
		local exptoget = 750 -- Nieco mniej niż za Class-D
		if rtime != nil then
			exptoget = GetConVar("br_time_round"):GetInt() - (CurTime() - rtime)
			exptoget = exptoget * 2.3
			exptoget = math.Round(math.Clamp(exptoget, 750, 10000))
		end
		
		for k,v in ipairs(foundrs) do
			roundstats.rescaped = roundstats.rescaped + 1
			v:SetSpectator()
			v:AddFrags(10)
			v:AddExp(exptoget, true)
			v:PrintMessage(HUD_PRINTTALK, "You've been captured by " .. pl:Nick())
			net.Start("OnEscaped")
				net.WriteInt(3,4)
			net.Send(v)
			WinCheck()
		end
		
		pl:PrintMessage(HUD_PRINTTALK, "You've successfully captured: " .. rsstr)
	end
end

function WinCheck()
	if postround then return end
	if !activeRound then return end
	activeRound.endcheck()
	if roundEnd > 0 and roundEnd < CurTime() then
		roundEnd = 0
	--	endround = true
	--	why = "game ran out of time limit"
		print( "Something went wrong! Error code: 100" )
		print( debug.traceback() )
	end
	/*if #GetActivePlayers() < 2 then 
		endround = true
		why = " there are not enough players"
		gamestarted = false
		BroadcastLua( "gamestarted = false" )
	end*/
	if endround then
		print("Ending round because " .. why)
		PrintMessage(HUD_PRINTCONSOLE, "Ending round because " .. why)
		StopRound()
		timer.Destroy("RoundTime")
		preparing = false
		postround = true
		// send infos
		net.Start("SendRoundInfo")
			net.WriteTable(roundstats)
		net.Broadcast()
		
		net.Start("PostStart")
			net.WriteInt(GetPostTime(), 6)
			net.WriteInt(2, 4)
		net.Broadcast()
		activeRound.postround()	
		GiveExp()
		endround = false
		--print( debug.traceback() )  
		hook.Run( "BreachPostround" )
		timer.Create("PostTime", GetPostTime(), 1, function()
			RoundRestart()
		end)
	end
end

function StopRound()
	timer.Stop("PreparingTime")
	timer.Stop("RoundTime")
	timer.Stop("PostTime")
	timer.Stop("GateOpen")
	timer.Stop("PlayerInfo")
end

timer.Create("WinCheckTimer", 5, 0, function()
	if postround == false and preparing == false then
		WinCheck()
	end
end)

timer.Create("EXPTimer", 180, 0, function()
	for k,v in pairs(player.GetAll()) do
		if IsValid(v) and v.AddExp != nil then
			v:AddExp(200, true)
		end
	end
end)

function SetupCollide()
	local fent = ents.GetAll()
	for k, v in pairs( fent ) do
		if v and v:GetClass() == "func_door" or v:GetClass() == "prop_dynamic" then
			if v:GetClass() == "prop_dynamic" then
				local ennt = ents.FindInSphere( v:GetPos(), 5 )
				local neardors = false
				for k, v in pairs( ennt ) do
					if v:GetClass() == "func_door" then
						neardors = true
						break
					end
				end
				if !neardors then
					v.ignorecollide106 = false
					v.ignorecollide999 = false -- Dodaj dla SCP-999
					v.ignoredoorcontroller = false -- Dodaj dla Door Controller
					continue
				end
			end

			local changed
			for _, pos in pairs( DOOR_RESTRICT106 ) do
				if v:GetPos():Distance( pos ) < 100 then
					v.ignorecollide106 = false
					v.ignorecollide999 = false -- Dodaj dla SCP-999
					changed = true
					break
				end
			end
			
			-- Sprawdź czy drzwi są w blackliście Door Controller
			local doorControllerBlocked = false
			if DOOR_RESTRICT_CONTROLLER then
				for _, pos in pairs( DOOR_RESTRICT_CONTROLLER ) do
					if v:GetPos():Distance( pos ) < 100 then
						v.ignoredoorcontroller = false
						doorControllerBlocked = true
						break
					end
				end
			end
			
			if !changed then
				v.ignorecollide106 = true
				v.ignorecollide999 = true -- Dodaj dla SCP-999
			end
			
			if !doorControllerBlocked then
				v.ignoredoorcontroller = true
			end
		end
	end
end

-- Function to spawn SCP Items
function SpawnSCPItems()
	if not SCP_ITEMS_SPAWN then return end
	
	-- Clean up existing SCP items
	for _, ent in pairs(ents.GetAll()) do
		if IsValid(ent) then
			local class = ent:GetClass()
					-- Remove any SCP items that might be configured in SCP_ITEMS_SPAWN
		for _, itemData in pairs(SCP_ITEMS_SPAWN) do
			if class == itemData.class then
				ent:Remove()
				break
			end
		end
		
		-- Also clean up SCP-1123 specifically
		if class == "scp_1123" then
			ent:Remove()
		end
		
		-- Clean up SCP-005
		if class == "weapon_scp_005" then
			ent:Remove()
		end
		end
	end
	
	-- Spawn new items based on chance
	local spawnedCount = 0
	for _, itemData in pairs(SCP_ITEMS_SPAWN) do
		if math.random() <= itemData.chance then
			local item = ents.Create(itemData.class)
			if IsValid(item) then
				item:SetPos(itemData.pos)
				item:SetAngles(Angle(0, math.random(0, 360), 0))
				item:Spawn()
				item:Activate()
				
				spawnedCount = spawnedCount + 1
				print("[BREACH] Spawned " .. itemData.class .. " at " .. tostring(itemData.pos))
			end
		end
	end
	
	-- Spawn SCP-005 with 50% chance at random location
	if SCP_005_SPAWN_POINTS and math.random() <= 0.5 then
		local randomPos = table.Random(SCP_005_SPAWN_POINTS)
		local scp005 = ents.Create("weapon_scp_005")
		if IsValid(scp005) then
			scp005:SetPos(randomPos)
			scp005:SetAngles(Angle(0, math.random(0, 360), 0))
			scp005:Spawn()
			scp005:Activate()
			
			spawnedCount = spawnedCount + 1
			print("[BREACH] Spawned SCP-005 at " .. tostring(randomPos))
		end
	end
	
	-- Spawn SCP-106 Barrier
	if SCP_106_BARRIER_SPAWN then
		-- Sprawdź czy bariera już istnieje
		local existing = ents.FindByClass("scp106_barrier")
		if #existing == 0 then
			local barrier = ents.Create("scp106_barrier")
			if IsValid(barrier) then
				barrier:SetPos(SCP_106_BARRIER_SPAWN)
				barrier:SetAngles(Angle(0, 0, 0))
				barrier:Spawn()
				barrier:Activate()
				
				spawnedCount = spawnedCount + 1
				print("[BREACH] Spawned SCP-106 barrier at " .. tostring(SCP_106_BARRIER_SPAWN))
			end
		end
	end
	
	if spawnedCount > 0 then
		print("[BREACH] Total SCP items spawned: " .. spawnedCount)
	end
end

-- Placeholder functions for compatibility
if not UseAll then
function UseAll()
	-- This placeholder will be used only if original UseAll is not defined elsewhere
end
end

if not DestroyAll then
function DestroyAll()
	-- Placeholder in case original DestroyAll is missing
end
end



================================================
FILE: gamemodes/breach/gamemode/modules/sv_round_setup.lua
================================================
function GetRoleTable( all )
	local scp = 0
	local mtf = 0
	local res = 0

	if all < 9 then
		scp = 1
	elseif all < 15 then
		scp = 2
	else
		scp = math.floor( ( all - 14 ) / 7 ) + 3
	end
	
	all = all - scp

	//if all < 14 then
		mtf = math.Round( all * 0.3 )
	//else
		//mtf = math.Round( all * 0.27 )
	//end

	all = all - mtf

	res = math.floor( all * 0.3 )
	all = all - res

	//print( "scp "..scp, "mtf "..mtf, "d"..all, "res"..res )
	return {scp, mtf, res, all}
end

local function PlayerLevelSorter(a, b)
	if a:GetLevel() > b:GetLevel() then return true end
end

function SetupPlayers( tab, multibreach )
	local players = GetActivePlayers()

	//Send info about penalties
	for k, v in pairs( players ) do
		local r = tonumber( v:GetPData( "scp_penalty", 0 ) )

		if r and r > 0 then
			v:SetPData( "scp_penalty", r - 1 )
		end
	end

	//Setup high priority players
	local scpply = {}
	for k, v in pairs( players ) do
		if tonumber( v:GetPData( "scp_penalty", 0 ) ) == 0 then
			table.insert( scpply, v )
			//print( v, "has NO penalty" )
		//else
			//print( v, "has penalty", v:GetPData( "scp_penalty", 0 ) )
		end
	end

	//Penalty values
	local p = GetConVar("br_scp_penalty"):GetInt() + 1
	local pp = GetConVar("br_premium_penalty"):GetInt() + 1

	//Select SCPs
	local SCP = table.Copy( SCPS )
	
	// Remove SCP-957 and SCP-239 from multi breach rounds
	if multibreach then
		-- Remove SCP-957
		for k, v in pairs(SCP) do
			if v == "SCP957" then
				table.remove(SCP, k)
				break
			end
		end
		-- Remove SCP-239
		for k, v in pairs(SCP) do
			if v == "SCP239" then
				table.remove(SCP, k)
				break
			end
		end
	end
	
	local rSCP = SCP[math.random( #SCP )]

	for i = 1, tab[1] do
		if #scpply == 0 then
			scpply = players
		end

		local scp = multibreach and GetSCP( rSCP ) or GetSCP( table.remove( SCP, math.random( #SCP ) ) )
		local ply = #scpply > 0 and table.remove( scpply, math.random( #scpply ) ) or table.Random( players )

		if IsValid(ply) then
			ply:SetPData( "scp_penalty", ply.Premium and pp or p )
			table.RemoveByValue( players, ply )

			scp:SetupPlayer( ply )
			print( "Assigning "..ply:Nick().." to role: "..scp.name.." [SCP]" )
		end
	end

	//Select MTFs
	local mtfsinuse = {}
	local mtfspawns = table.Copy( SPAWN_GUARD )
	local mtfs = {}

	for i = 1, tab[2] do
		table.insert( mtfs, table.remove( players, math.random( #players ) ) )
	end

	table.sort( mtfs, PlayerLevelSorter )

	for i, v in ipairs( mtfs ) do
		local mtfroles = table.Copy( ALLCLASSES.security.roles )
		local selected

		repeat
			local role = table.remove( mtfroles, math.random( #mtfroles ) )
			mtfsinuse[role.name] = mtfsinuse[role.name] or 0

			if role.max == 0 or mtfsinuse[role.name] < role.max then
				if role.level <= v:GetLevel() then
					if !role.customcheck or role.customcheck( v ) then
						selected = role
						break
					end
				end
			end
		until #mtfroles == 0

		if !selected then
			ErrorNoHalt( "Something went wrong! Error code: 001" )
			selected = ALLCLASSES.security.roles[1]
		end

		mtfsinuse[selected.name] = mtfsinuse[selected.name] + 1

		if #mtfspawns == 0 then mtfspawns = table.Copy( SPAWN_GUARD ) end
		local spawn = table.remove( mtfspawns, math.random( #mtfspawns ) )

		v:SetupNormal()
		v:ApplyRoleStats( selected )
		v:SetPos( spawn )

		print( "Assigning "..v:Nick().." to role: "..selected.name.." [MTF]" )
	end

	//Select Researchers
	local resinuse = {}
	local resspawns = table.Copy( SPAWN_SCIENT )

	for i = 1, tab[3] do
		local ply = table.Random( players )

		local resroles = table.Copy( ALLCLASSES.researchers.roles )
		local selected

		repeat
			local role = table.remove( resroles, math.random( #resroles ) )
			resinuse[role.name] = resinuse[role.name] or 0

			if role.max == 0 or resinuse[role.name] < role.max then
				if role.level <= ply:GetLevel() then
					if !role.customcheck or role.customcheck( ply ) then
						selected = role
						break
					end
				end
			end
		until #resroles == 0

		if !selected then
			ErrorNoHalt( "Something went wrong! Error code: 002" )
			selected = ALLCLASSES.researchers.roles[1]
		end

		resinuse[selected.name] = resinuse[selected.name] + 1

		table.RemoveByValue( players, ply )

		local spawn
		if selected.name == ROLES.ROLE_COOK and SPAWN_COOK and #SPAWN_COOK > 0 then
			-- Cook gets special spawn position
			local cookspawns = table.Copy( SPAWN_COOK )
			spawn = table.remove( cookspawns, math.random( #cookspawns ) )
		elseif selected.name == ROLES.ROLE_DRHOUSE and SPAWN_DRHOUSE and #SPAWN_DRHOUSE > 0 then
			-- Dr. House gets special spawn position
			local drhousespawns = table.Copy( SPAWN_DRHOUSE )
			spawn = table.remove( drhousespawns, math.random( #drhousespawns ) )
		elseif selected.name == ROLES.ROLE_PSYCHOLOGIST and SPAWN_PSYCHOLOGIST and #SPAWN_PSYCHOLOGIST > 0 then
			-- Psychologist gets special spawn position
			local psychspawns = table.Copy( SPAWN_PSYCHOLOGIST )
			spawn = table.remove( psychspawns, math.random( #psychspawns ) )
		else
			-- All other researchers use normal scientist spawns
			if #resspawns == 0 then resspawns = table.Copy( SPAWN_SCIENT ) end
			spawn = table.remove( resspawns, math.random( #resspawns ) )
		end

		ply:SetupNormal()
		ply:ApplyRoleStats( selected )
		ply:SetPos( spawn )

		print( "Assigning "..ply:Nick().." to role: "..selected.name.." [RESEARCHERS]" )
	end

	//Select Class D
	local dinuse = {}
	local dspawns = table.Copy( SPAWN_CLASSD )

	for i = 1, tab[4] do
		local ply = table.Random( players )

		local droles = table.Copy( ALLCLASSES.classds.roles )
		local selected

		repeat
			local role = table.remove( droles, math.random( #droles ) )
			dinuse[role.name] = dinuse[role.name] or 0

			if role.max == 0 or dinuse[role.name] < role.max then
				if role.level <= ply:GetLevel() then
					if !role.customcheck or role.customcheck( ply ) then
						selected = role
						break
					end
				end
			end
		until #droles == 0

		if !selected then
			ErrorNoHalt( "Something went wrong! Error code: 003" )
			selected = ALLCLASSES.classds.roles[1]
		end

		dinuse[selected.name] = dinuse[selected.name] + 1

		table.RemoveByValue( players, ply )

		if #dspawns == 0 then dspawns = table.Copy( SPAWN_CLASSD ) end
		local spawn = table.remove( dspawns, math.random( #dspawns ) )

		ply:SetupNormal()
		ply:ApplyRoleStats( selected )
		ply:SetPos( spawn )

		print( "Assigning "..ply:Nick().." to role: "..selected.name.." [CLASS D]" )
	end

	//Send info to everyone
	net.Start("RolesSelected")
	net.Broadcast()
end

function SetupInfect( ply )
	if !SERVER then return end

	local roles = {}

	roles[1] = math.ceil( ply * 0.15 )
	ply = ply - roles[1]
	roles[2] = math.Round( ply * 0.333 )
	ply = ply - roles[2]
	roles[3] = ply

	local players = GetActivePlayers()
	local spawns = table.Copy( SPAWN_GUARD )
	local ply, spawn = nil, nil

	for i = 1, roles[1] do
		ply = table.remove( players, math.random( 1, #players ) )
		spawn = table.remove( spawns, math.random( 1, #spawns ) )

		ply:SetSCP0082( 750, 250, true )
		ply:SetPos( spawn )
	end

	spawns = table.Copy( SPAWN_CLASSD )

	for i = 1, roles[2] do
		if #spawns < 1 then
			spawns = table.Copy( SPAWN_CLASSD )
		end

		ply = table.remove( players, math.random( 1, #players ) )
		spawn = table.remove( spawns, math.random( 1, #spawns ) )

		ply:SetInfectMTF()
		ply:SetPos( spawn )
	end

	for i = 1, roles[3] do
		if #spawns < 1 then
			spawns = table.Copy( SPAWN_CLASSD )
		end

		ply = table.remove( players, math.random( 1, #players ) )
		spawn = table.remove( spawns, math.random( 1, #spawns ) )

		ply:SetInfectD()
		ply:SetPos( spawn )
	end

	net.Start("RolesSelected")
	net.Broadcast()
end


================================================
FILE: gamemodes/breach/gamemode/modules/sv_rounds.lua
================================================
ROUNDS = {
	normal = {
		name = "Containment Breach",
		setup = function()
			MAPBUTTONS = table.Copy(BUTTONS)
			SetupPlayers( GetRoleTable( #GetActivePlayers() ) )
			disableNTF = false
			SpawnAllItems()
			-- Usunięto OpenSCPDoors() z setup - przeniesiono do roundstart
			timer.Create( "NTFEnterTime", GetNTFEnterTime(), 1, function()
				-- Losowanie z właściwymi proporcjami: NTF 50%, GOC 10%, Chaos 40%
				local rand = math.random(1, 100)
				if rand <= 50 then
					-- 50% szans dla NTF
					SpawnNTFS()
				elseif rand <= 60 then
					-- 10% szans dla GOC (51-60)
					SpawnGOC()
				else
					-- 40% szans dla Chaos (61-100)
					SpawnNTFS(true) -- Wymusza spawn Chaos
				end
			end )
			timer.Create("MTFDebug", 2, 1, function()
				local fent = ents.FindInSphere(MTF_DEBUG, 750)
				for k, v in pairs( player.GetAll() ) do
					if v:GTeam() == TEAM_GUARD or v:GetNClass() == ROLE_CHAOSSPY then
						local found = false
						for k0, v0 in pairs(fent) do
							if v == v0 then
								found = true
								break
							end
						end
						if !found then
							v:SetPos(MTF_DEBUG)
						end
					end
				end
			end )
		end,
		init = function()
		end,
		roundstart = function()
			-- Przeniesiono OpenSCPDoors() tutaj - drzwi otworzą się dopiero po rozpoczęciu rundy
			OpenSCPDoors()
		end,
		postround = function()
			local plys = GetActivePlayers()
			for k, v in pairs( plys ) do
				local r = tonumber( v:GetPData( "scp_penalty", 0 ) ) - 1
				r = math.max( r, 0 )

				if r == 0 then
					v:PrintTranslatedMessage( "scpready#50,200,50" )
					//print( v, "can be scp" )
				else
					v:PrintTranslatedMessage( "scpwait".."$"..r.."#200,50,50" )
					//dprint( v, "must wait", r )
				end
			end
		end,
		endcheck = function()
			if #GetActivePlayers() < 2 then return end
			endround = false
			local ds = gteams.NumPlayers(TEAM_CLASSD)
			local mtfs = gteams.NumPlayers(TEAM_GUARD)
			local res = gteams.NumPlayers(TEAM_SCI)
			local scps = gteams.NumPlayers(TEAM_SCP)
			local chaos = gteams.NumPlayers(TEAM_CHAOS)
			local goc = gteams.NumPlayers(TEAM_GOC)
			local all = #GetAlivePlayers()
			why = "idk man"
			if scps == all then
				endround = true
				why = "there are only scps"
			elseif mtfs == all then
				endround = true
				why = "there are only mtfs"
			elseif res == all then
				endround = true
				why = "there are only researchers"
			elseif ds == all then
				endround = true
				why = "there are only class ds"
			elseif chaos == all then
				endround = true
				why = "there are only chaos insurgency members"
			elseif goc == all then
				endround = true
				why = "there are only goc members"
			elseif (mtfs + res) == all then
				endround = true
				why = "there are only mtfs and researchers"
			elseif (chaos + ds) == all then
				endround = true
				why = "there are only chaos insurgency members and class ds"
			end
		end,
	},
/*	dm = {
		name = "MTF vs CI Deathmatch",
		setup = function()
			MAPBUTTONS = GetTableOverride( table.Copy(BUTTONS) ) + GetTableOverride( table.Copy(BUTTONS_DM) )
			SetupPlayers( GetRoleTableCustom( #GetActivePlayers(),  ) )
			
			disableNTF = false
		end,
		init = function()
			SpawnAllItems()
			DestroyGateA()
		end,
		roundstart = function()
			OpenSCPDoors()
		end,
		postround = function() end,
		cleanup = function() end,
	},*/
/*	omega = {
		name = "Omega Problem",
		setup = function()
			MAPBUTTONS = GetTableOverride( table.Copy(BUTTONS) ) + GetTableOverride( table.Copy(BUTTONS_OMEGA) )
			SetupPlayers( GetRoleTable( #GetActivePlayers() ) )
			disableNTF = false
		end,
		init = function()
			SpawnAllItems()
			timer.Create( "NTFEnterTime", GetNTFEnterTime(), 0, function()
				SpawnNTFS()
			end )
		end,
		roundstart = function()
			OpenSCPDoors()
		end,
		postround = function() end,
		cleanup = function() end,
	}, */
	multi = {
		name = "Multi Breach",
		setup = function()
			MAPBUTTONS = table.Copy(BUTTONS)
			SetupPlayers( GetRoleTable( #GetActivePlayers() ), true )
			disableNTF = false
		end,
		init = function()
			SpawnAllItems()
			timer.Create( "NTFEnterTime", GetNTFEnterTime(), 1, function()
				-- Losowanie z właściwymi proporcjami: NTF 50%, GOC 10%, Chaos 40%
				local rand = math.random(1, 100)
				if rand <= 50 then
					-- 50% szans dla NTF
					SpawnNTFS()
				elseif rand <= 60 then
					-- 10% szans dla GOC (51-60)
					SpawnGOC()
				else
					-- 40% szans dla Chaos (61-100)
					SpawnNTFS(true) -- Wymusza spawn Chaos
				end
			end )
			timer.Create("MTFDebug", 2, 1, function()
				local fent = ents.FindInSphere(MTF_DEBUG, 750)
				for k, v in pairs( player.GetAll() ) do
					if v:GTeam() == TEAM_GUARD or v:GetNClass() == ROLE_CHAOSSPY then
						local found = false
						for k0, v0 in pairs(fent) do
							if v == v0 then
								found = true
								break
							end
						end
						if !found then
							v:SetPos(MTF_DEBUG)
						end
					end
				end
			end )	
		end,
		roundstart = function()
			OpenSCPDoors()
		end,
		postround = function()
			local plys = GetActivePlayers()
			for k, v in pairs( plys ) do
				local r = tonumber( v:GetPData( "scp_penalty", 0 ) ) - 1
				r = math.max( r, 0 )

				if r == 0 then
					v:PrintTranslatedMessage( "scpready#50,200,50" )
					//print( v, "can be scp" )
				else
					v:PrintTranslatedMessage( "scpwait".."$"..r.."#200,50,50" )
					//dprint( v, "must wait", r )
				end
			end
		end,
		endcheck = function()
			if #GetActivePlayers() < 2 then return end
			endround = false
			local ds = gteams.NumPlayers(TEAM_CLASSD)
			local mtfs = gteams.NumPlayers(TEAM_GUARD)
			local res = gteams.NumPlayers(TEAM_SCI)
			local scps = gteams.NumPlayers(TEAM_SCP)
			local chaos = gteams.NumPlayers(TEAM_CHAOS)
			local goc = gteams.NumPlayers(TEAM_GOC)
			local all = #GetAlivePlayers()
			why = "idk man"
			if scps == all then
				endround = true
				why = "there are only scps"
			elseif mtfs == all then
				endround = true
				why = "there are only mtfs"
			elseif res == all then
				endround = true
				why = "there are only researchers"
			elseif ds == all then
				endround = true
				why = "there are only class ds"
			elseif chaos == all then
				endround = true
				why = "there are only chaos insurgency members"
			elseif goc == all then
				endround = true
				why = "there are only goc members"
			elseif (mtfs + res) == all then
				endround = true
				why = "there are only mtfs and researchers"
			elseif (chaos + ds) == all then
				endround = true
				why = "there are only chaos insurgency members and class ds"
			end
		end,
	},
	ttt = {
		name = "TTT",
		setup = function()
			MAPBUTTONS = table.Copy(BUTTONS)
			
			-- Custom TTT player setup
			local players = GetActivePlayers()
			local total = #players
			
			-- Calculate roles: 25% spies, 75% MTF Guards
			local spyCount = math.max(1, math.floor(total * 0.25))
			local mtfCount = total - spyCount
			
			-- Shuffle players
			local shuffledPlayers = {}
			for k, v in pairs(players) do
				table.insert(shuffledPlayers, v)
			end
			
			-- Assign spies (Chaos Spy)
			local spyspawns = table.Copy(SPAWN_GUARD)
			for i = 1, spyCount do
				if #shuffledPlayers > 0 then
					local ply = table.remove(shuffledPlayers, math.random(#shuffledPlayers))
					
					-- Set as Chaos Spy (disguised as MTF)
					ply:SetupNormal()
					ply:SetGTeam(TEAM_CHAOS)
					ply:SetNClass(ROLES.ROLE_CHAOSSPY)
					ply:SetModel(table.Random(SECURITYMODELS))
					ply:SetHealth(100)
					ply:SetMaxHealth(100)
					ply:SetWalkSpeed(111.25) -- 0.85 * 130
					ply:SetRunSpeed(230) -- 0.92 * 250
					ply:SetJumpPower(174) -- 0.87 * 200
					
					-- Give weapons and items
					ply:Give("br_holster")
					ply:Give("br_id")
					ply:Give("item_radio")
					ply:Give("weapon_stunstick")
					ply:Give("cw_mp5")
					
					-- Give keycard
					local card = ply:Give("br_keycard")
					if IsValid(card) then
						card:SetKeycardType("mtf")
					end
					
					-- Apply armor
					ply:ApplyArmor("armor_mtfguard")
					
					-- Set spawn position
					if #spyspawns == 0 then spyspawns = table.Copy(SPAWN_GUARD) end
					local spawn = table.remove(spyspawns, math.random(#spyspawns))
					ply:SetPos(spawn)
					
					print("Assigning " .. ply:Nick() .. " to role: SPY [TTT]")
				end
			end
			
			-- Assign MTF Guards
			local mtfspawns = table.Copy(SPAWN_GUARD)
			for i = 1, mtfCount do
				if #shuffledPlayers > 0 then
					local ply = table.remove(shuffledPlayers, math.random(#shuffledPlayers))
					
					-- Set as MTF Guard
					ply:SetupNormal()
					ply:SetGTeam(TEAM_GUARD)
					ply:SetNClass(ROLES.ROLE_MTFGUARD)
					ply:SetModel(table.Random(SECURITYMODELS))
					ply:SetHealth(100)
					ply:SetMaxHealth(100)
					ply:SetWalkSpeed(111.25) -- 0.85 * 130
					ply:SetRunSpeed(230) -- 0.92 * 250
					ply:SetJumpPower(174) -- 0.87 * 200
					
					-- Give weapons and items
					ply:Give("br_holster")
					ply:Give("br_id")
					ply:Give("item_radio")
					ply:Give("weapon_stunstick")
					ply:Give("cw_mp5")
					
					-- Give keycard
					local card = ply:Give("br_keycard")
					if IsValid(card) then
						card:SetKeycardType("mtf")
					end
					
					-- Apply armor
					ply:ApplyArmor("armor_mtfguard")
					
					-- Set spawn position
					if #mtfspawns == 0 then mtfspawns = table.Copy(SPAWN_GUARD) end
					local spawn = table.remove(mtfspawns, math.random(#mtfspawns))
					ply:SetPos(spawn)
					
					print("Assigning " .. ply:Nick() .. " to role: MTF GUARD [TTT]")
				end
			end
			
			disableNTF = true -- Disable NTF spawning for TTT round
		end,
		init = function()
			-- Spawn limited items for TTT gameplay
			SpawnAllItems()
		end,
		roundstart = function()
			-- Don't open SCP doors in TTT round
			-- OpenSCPDoors()
		end,
		postround = function()
			-- Standard postround handling
		end,
		endcheck = function()
			if #GetActivePlayers() < 2 then return end
			endround = false
			local spies = 0
			local mtfs = 0
			
			-- Count alive players by role
			for k, v in pairs(GetAlivePlayers()) do
				if v:GetNClass() == ROLES.ROLE_CHAOSSPY then
					spies = spies + 1
				elseif v:GetNClass() == ROLES.ROLE_MTFGUARD then
					mtfs = mtfs + 1
				end
			end
			
			local all = #GetAlivePlayers()
			why = "idk man"
			
			if spies == all then
				endround = true
				why = "all spies survived"
			elseif mtfs == all then
				endround = true
				why = "all mtf guards survived"
			elseif spies == 0 then
				endround = true
				why = "all spies eliminated"
			elseif mtfs == 0 then
				endround = true
				why = "all mtf guards eliminated"
			end
		end,
	},
	bomber = {
		name = "Bomber",
		setup = function()
			MAPBUTTONS = table.Copy(BUTTONS)
			SetupPlayers( GetRoleTable( #GetActivePlayers() ) )
			disableNTF = false
		end,
		init = function()
			SpawnAllItems()
			timer.Create( "NTFEnterTime", GetNTFEnterTime(), 1, function()
				-- Standard NTF spawning
				local rand = math.random(1, 100)
				if rand <= 50 then
					SpawnNTFS()
				elseif rand <= 60 then
					SpawnGOC()
				else
					SpawnNTFS(true)
				end
			end )
			timer.Create("MTFDebug", 2, 1, function()
				local fent = ents.FindInSphere(MTF_DEBUG, 750)
				for k, v in pairs( player.GetAll() ) do
					if v:GTeam() == TEAM_GUARD or v:GetNClass() == ROLES.ROLE_CHAOSSPY then
						local found = false
						for k0, v0 in pairs(fent) do
							if v == v0 then
								found = true
								break
							end
						end
						if !found then
							v:SetPos(MTF_DEBUG)
						end
					end
				end
			end )
		end,
		roundstart = function()
			OpenSCPDoors()
			
			-- OPTYMALIZACJA: Bomber timer z cache graczy
BomberRoundActive = true
local BomberNextExplosion = CurTime() + 60

local function OptimizedBomberTick()
	if not BomberRoundActive then return end

	local currentTime = CurTime()
	if currentTime < BomberNextExplosion then
		return
	end

	-- Użyj cache graczy jeśli dostępny
	local alivePlayers = GetAlivePlayers()
	if #alivePlayers > 0 then
		-- Choose the player who will explode NOW, not later
		local chosenPlayer = table.Random(alivePlayers)

		-- Send lottery animation to all players WITH the chosen player
		net.Start("BomberLottery")
			net.WriteTable(alivePlayers)
			net.WriteEntity(chosenPlayer) -- Send who was chosen
		net.Broadcast()

		-- Wait 5 seconds for animation + 6 seconds countdown, then explode the chosen player
		timer.Simple(11, function()
			if IsValid(chosenPlayer) and chosenPlayer:Alive() then
				-- Create explosion effect
				local explosionPos = chosenPlayer:GetPos()

				-- Kill the player with explosion damage
				local dmg = DamageInfo()
				dmg:SetDamage(999)
				dmg:SetDamageType(DMG_BLAST)
				dmg:SetAttacker(chosenPlayer)
				dmg:SetInflictor(chosenPlayer)
				chosenPlayer:TakeDamageInfo(dmg)
				
				-- Create explosion effects
				local effectdata = EffectData()
				effectdata:SetOrigin(explosionPos)
				effectdata:SetMagnitude(8)
				effectdata:SetScale(1)
				effectdata:SetRadius(8)
				util.Effect("Explosion", effectdata)

				-- OPTYMALIZACJA: Użyj zoptymalizowanej funkcji wyszukiwania
				local nearbyPlayers = {}
				for k, v in pairs(ents.FindInSphere(explosionPos, 200)) do
					if v:IsPlayer() and v != chosenPlayer and v:Alive() then
						table.insert(nearbyPlayers, v)
					end
				end

				-- Damage nearby players
				for _, v in pairs(nearbyPlayers) do
					local distance = v:GetPos():Distance(explosionPos)
					local damage = math.max(10, 100 - (distance / 2))

					local dmgInfo = DamageInfo()
					dmgInfo:SetDamage(damage)
					dmgInfo:SetDamageType(DMG_BLAST)
					dmgInfo:SetAttacker(chosenPlayer)
					dmgInfo:SetInflictor(chosenPlayer)
					v:TakeDamageInfo(dmgInfo)
				end

				-- Sound effect
				chosenPlayer:EmitSound("weapons/explode3.wav", 100, 100)

				-- Notify all players (użyj cache jeśli dostępny)
				local allPlayers = PlayerCache and PlayerCache.All or player.GetAll()
				for k, v in pairs(allPlayers) do
					if IsValid(v) then
						v:PrintMessage(HUD_PRINTTALK, chosenPlayer:Nick() .. " exploded!")
					end
				end
			end
		end)
	end

	BomberNextExplosion = currentTime + 60 -- Następna eksplozja za minutę
	timer.Adjust("BomberTimer", 1, 0, OptimizedBomberTick) -- Kontynuuj sprawdzanie
end

timer.Create("BomberTimer", 1, 0, OptimizedBomberTick) -- Rozpocznij bomber system
		end,
		postround = function()
			-- OPTYMALIZACJA: Clean up bomber system
			BomberRoundActive = false
			timer.Remove("BomberTimer")
			print("[OPTIMIZATION] Bomber round cleanup completed")
		end,
		endcheck = function()
			if #GetActivePlayers() < 2 then return end
			endround = false
			local ds = gteams.NumPlayers(TEAM_CLASSD)
			local mtfs = gteams.NumPlayers(TEAM_GUARD)
			local res = gteams.NumPlayers(TEAM_SCI)
			local scps = gteams.NumPlayers(TEAM_SCP)
			local chaos = gteams.NumPlayers(TEAM_CHAOS)
			local goc = gteams.NumPlayers(TEAM_GOC)
			local all = #GetAlivePlayers()
			why = "idk man"
			if scps == all then
				endround = true
				why = "there are only scps"
			elseif mtfs == all then
				endround = true
				why = "there are only mtfs"
			elseif res == all then
				endround = true
				why = "there are only researchers"
			elseif ds == all then
				endround = true
				why = "there are only class ds"
			elseif chaos == all then
				endround = true
				why = "there are only chaos insurgency members"
			elseif goc == all then
				endround = true
				why = "there are only goc members"
			elseif (mtfs + res) == all then
				endround = true
				why = "there are only mtfs and researchers"
			elseif (chaos + ds) == all then
				endround = true
				why = "there are only chaos insurgency members and class ds"
			end
		end,
	},
	swapper = {
		name = "Swapper",
		setup = function()
			MAPBUTTONS = table.Copy(BUTTONS)
			SetupPlayers( GetRoleTable( #GetActivePlayers() ) )
			disableNTF = false
		end,
		init = function()
			SpawnAllItems()
			timer.Create( "NTFEnterTime", GetNTFEnterTime(), 1, function()
				-- Standard NTF spawning
				local rand = math.random(1, 100)
				if rand <= 50 then
					SpawnNTFS()
				elseif rand <= 60 then
					SpawnGOC()
				else
					SpawnNTFS(true)
				end
			end )
			timer.Create("MTFDebug", 2, 1, function()
				local fent = ents.FindInSphere(MTF_DEBUG, 750)
				for k, v in pairs( player.GetAll() ) do
					if v:GTeam() == TEAM_GUARD or v:GetNClass() == ROLES.ROLE_CHAOSSPY then
						local found = false
						for k0, v0 in pairs(fent) do
							if v == v0 then
								found = true
								break
							end
						end
						if !found then
							v:SetPos(MTF_DEBUG)
						end
					end
				end
			end )
		end,
		roundstart = function()
			OpenSCPDoors()
			
			-- OPTYMALIZACJA: Swapper timer z cache graczy
SwapperRoundActive = true
local SwapperNextSwap = CurTime() + 30

local function OptimizedSwapperTick()
	if not SwapperRoundActive then return end

	local currentTime = CurTime()
	if currentTime < SwapperNextSwap then
		return
	end

	local alivePlayers = GetAlivePlayers()
	if #alivePlayers >= 2 then
		-- Create notification about upcoming swap (użyj cache)
		local allPlayers = PlayerCache and PlayerCache.All or player.GetAll()
		for k, v in pairs(allPlayers) do
			if IsValid(v) then
				v:PrintMessage(HUD_PRINTTALK, "Position swap in 5 seconds!")
				v:EmitSound("buttons/blip1.wav", 60, 150)
			end
		end
		
		-- Wait 5 seconds, then swap
		timer.Simple(5, function()
			local currentAlivePlayers = GetAlivePlayers()
			if #currentAlivePlayers >= 2 then
				-- Store original positions and angles
				local positions = {}
				local angles = {}

				for k, v in pairs(currentAlivePlayers) do
					positions[k] = v:GetPos()
					angles[k] = v:GetAngles()
				end

				-- Shuffle players (zoptymalizowane)
				local shuffledPlayers = table.Copy(currentAlivePlayers)
				table.Shuffle(shuffledPlayers)

				-- Apply swapped positions (batch processing)
				for k, v in pairs(currentAlivePlayers) do
					if IsValid(v) and v:Alive() then
						local targetIndex = (k % #positions) + 1
						if positions[targetIndex] and angles[targetIndex] then
							-- Rozłóż teleportacje w czasie
							timer.Simple(k * 0.05, function()
								if IsValid(v) then
									v:SetPos(positions[targetIndex] + Vector(0, 0, 5))
									v:SetAngles(angles[targetIndex])
									v:SetVelocity(Vector(0, 0, 0))
								end
							end)
						end
					end
				end

				-- Notification and effects (użyj cache)
				local allPlayers = PlayerCache and PlayerCache.All or player.GetAll()
				for k, v in pairs(allPlayers) do
					if IsValid(v) then
						v:PrintMessage(HUD_PRINTTALK, "Positions swapped!")
						v:EmitSound("ambient/levels/labs/electric_explosion1.wav", 70, 120)
					end
					
					-- Screen flash effect
					if v:Alive() then
						v:ScreenFade(SCREENFADE.IN, Color(255, 255, 255, 100), 0.5, 0.1)
					end
				end

				-- Visual effects at swap locations (batch processing)
				for k, pos in pairs(positions) do
					timer.Simple(k * 0.02, function() -- Rozłóż efekty w czasie
						local effectdata = EffectData()
						effectdata:SetOrigin(pos)
						effectdata:SetMagnitude(1)
						effectdata:SetScale(0.5)
						util.Effect("TeslaHitboxes", effectdata)
					end)
				end
			end
		end)
	end

	SwapperNextSwap = currentTime + 30 -- Następny swap za 30 sekund
	timer.Adjust("SwapperTimer", 1, 0, OptimizedSwapperTick) -- Kontynuuj sprawdzanie
end

timer.Create("SwapperTimer", 1, 0, OptimizedSwapperTick) -- Rozpocznij swapper system
		end,
		postround = function()
			-- OPTYMALIZACJA: Clean up swapper system
			SwapperRoundActive = false
			timer.Remove("SwapperTimer")
			print("[OPTIMIZATION] Swapper round cleanup completed")
		end,
		endcheck = function()
			if #GetActivePlayers() < 2 then return end
			endround = false
			local ds = gteams.NumPlayers(TEAM_CLASSD)
			local mtfs = gteams.NumPlayers(TEAM_GUARD)
			local res = gteams.NumPlayers(TEAM_SCI)
			local scps = gteams.NumPlayers(TEAM_SCP)
			local chaos = gteams.NumPlayers(TEAM_CHAOS)
			local goc = gteams.NumPlayers(TEAM_GOC)
			local all = #GetAlivePlayers()
			why = "idk man"
			if scps == all then
				endround = true
				why = "there are only scps"
			elseif mtfs == all then
				endround = true
				why = "there are only mtfs"
			elseif res == all then
				endround = true
				why = "there are only researchers"
			elseif ds == all then
				endround = true
				why = "there are only class ds"
			elseif chaos == all then
				endround = true
				why = "there are only chaos insurgency members"
			elseif goc == all then
				endround = true
				why = "there are only goc members"
			elseif (mtfs + res) == all then
				endround = true
				why = "there are only mtfs and researchers"
			elseif (chaos + ds) == all then
				endround = true
				why = "there are only chaos insurgency members and class ds"
			end
		end,
	},
	moveordie = {
		name = "Move or Die",
		setup = function()
			MAPBUTTONS = table.Copy(BUTTONS)
			SetupPlayers( GetRoleTable( #GetActivePlayers() ) )
			disableNTF = false
		end,
		init = function()
			SpawnAllItems()
			timer.Create( "NTFEnterTime", GetNTFEnterTime(), 1, function()
				-- Standard NTF spawning
				local rand = math.random(1, 100)
				if rand <= 50 then
					SpawnNTFS()
				elseif rand <= 60 then
					SpawnGOC()
				else
					SpawnNTFS(true)
				end
			end )
			timer.Create("MTFDebug", 2, 1, function()
				local fent = ents.FindInSphere(MTF_DEBUG, 750)
				for k, v in pairs( player.GetAll() ) do
					if v:GTeam() == TEAM_GUARD or v:GetNClass() == ROLES.ROLE_CHAOSSPY then
						local found = false
						for k0, v0 in pairs(fent) do
							if v == v0 then
								found = true
								break
							end
						end
						if !found then
							v:SetPos(MTF_DEBUG)
						end
					end
				end
			end )
		end,
		roundstart = function()
			OpenSCPDoors()
			
			-- Initialize movement tracking for all players
			if not MOVEORDIE_DATA then
				MOVEORDIE_DATA = {}
			end
			
			for k, v in pairs(GetAlivePlayers()) do
				if IsValid(v) then
					MOVEORDIE_DATA[v:SteamID()] = {
						lastPos = v:GetPos(),
						lastMoveTime = CurTime(),
						lastDamageTime = 0
					}
				end
			end
			
			-- Start movement checking timer - check every 0.1 seconds for responsive movement detection
			timer.Create("MoveOrDieCheck", 0.1, 0, function()
				local currentTime = CurTime()
				
				for k, v in pairs(GetAlivePlayers()) do
					if IsValid(v) and v:Alive() then
						local steamid = v:SteamID()
						
						-- Initialize data if player doesn't have it
						if not MOVEORDIE_DATA[steamid] then
							MOVEORDIE_DATA[steamid] = {
								lastPos = v:GetPos(),
								lastMoveTime = currentTime,
								lastDamageTime = 0
							}
						end
						
						local data = MOVEORDIE_DATA[steamid]
						local currentPos = v:GetPos()
						
						-- Check if player moved (minimum 2 unit distance for more responsive detection)
						local distance = currentPos:Distance(data.lastPos)
						if distance > 2 then
							-- Player moved, update position and time
							data.lastPos = currentPos
							data.lastMoveTime = currentTime
						else
							-- Player hasn't moved, check if damage should be applied
							local timeSinceMove = currentTime - data.lastMoveTime
							local timeSinceLastDamage = currentTime - data.lastDamageTime
							
							-- Apply damage if not moving for more than 1 second and haven't damaged in last second
							if timeSinceMove >= 1 and timeSinceLastDamage >= 1 then
								-- Take 2 HP damage
								local newHealth = math.max(0, v:Health() - 2)
								v:SetHealth(newHealth)
								data.lastDamageTime = currentTime
								
								-- Visual and audio feedback
								v:EmitSound("player/pl_pain" .. math.random(5, 7) .. ".wav", 60, 100)
								
								-- Screen effect
								v:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 50), 0.3, 0.1)
								
								-- Kill player if health reaches 0
								if newHealth <= 0 then
									v:Kill()
									for _, ply in pairs(player.GetAll()) do
										ply:PrintMessage(HUD_PRINTTALK, v:Nick() .. " died from standing still!")
									end
								end
							end
						end
					end
				end
			end)
			

		end,
		postround = function()
			-- Clean up movement tracking
			timer.Remove("MoveOrDieCheck")
			MOVEORDIE_DATA = nil
		end,
		endcheck = function()
			if #GetActivePlayers() < 2 then return end
			endround = false
			local ds = gteams.NumPlayers(TEAM_CLASSD)
			local mtfs = gteams.NumPlayers(TEAM_GUARD)
			local res = gteams.NumPlayers(TEAM_SCI)
			local scps = gteams.NumPlayers(TEAM_SCP)
			local chaos = gteams.NumPlayers(TEAM_CHAOS)
			local goc = gteams.NumPlayers(TEAM_GOC)
			local all = #GetAlivePlayers()
			why = "idk man"
			if scps == all then
				endround = true
				why = "there are only scps"
			elseif mtfs == all then
				endround = true
				why = "there are only mtfs"
			elseif res == all then
				endround = true
				why = "there are only researchers"
			elseif ds == all then
				endround = true
				why = "there are only class ds"
			elseif chaos == all then
				endround = true
				why = "there are only chaos insurgency members"
			elseif goc == all then
				endround = true
				why = "there are only goc members"
			elseif (mtfs + res) == all then
				endround = true
				why = "there are only mtfs and researchers"
			elseif (chaos + ds) == all then
				endround = true
				why = "there are only chaos insurgency members and class ds"
			end
		end,
	},

}


================================================
FILE: gamemodes/breach/gamemode/modules/sv_scp.lua
================================================
SCPObjects = {}
SCPNoSelectObjects = {}
TransmitSCPS = {}

SCP_VALID_ENTRIES = {
	base_speed = true,
	run_speed = true,
	max_speed = true,
	base_health = true,
	max_health = true,
	jump_power = true,
	crouch_speed = true,
	no_ragdoll = true,
	model_scale = true,
	hands_model = true,
	prep_freeze = true,
	no_spawn = true,
	no_model = true,
	no_swep = true,
	no_strip = true,
	no_select = true,
	no_draw = true,
}

SCP_DYNAMIC_VARS = {}

local lua_override = false

function UpdateDynamicVars()
	print( "Updating SCPs dynamic vars" )
	if !file.Exists( "breach", "DATA" ) then
		file.CreateDir( "breach" )
	end
	if !file.Exists( "breach/scp.txt", "DATA" ) then
		util.WriteINI( "breach/scp.txt", {} )
	end

	if lua_override then
		print( "Dev mode is enabled! Overwritting INI values..." )
	else
		util.LoadINI( "breach/scp.txt", SCP_DYNAMIC_VARS )
	end
end

UpdateDynamicVars()

function SaveDynamicVars()
	util.WriteINI( "breach/scp.txt", SCP_DYNAMIC_VARS )
end

function SendSCPList( ply )
	net.Start( "SCPList" )
		net.WriteTable( SCPS )	
		net.WriteTable( TransmitSCPS )
	net.Send( ply )
end

function GetSCP( name )
	return SCPObjects[name] or SCPNoSelectObjects[name]
end

function RegisterSCP( name, model, weapon, static_stats, dynamic_stats, custom_callback, post_callback )
	--RegisterSCP( "name", "path_to_model", "SWEP_class_name", {entry = value} )
	if !name or !model or !weapon or !static_stats then return end

	dynamic_stats = dynamic_stats or {}

	if SCPObjects[name] then
		error( "SCP " .. name .. "is already registered!" )
	end

	local rolename = "ROLE_"..name
	if !ALLLANGUAGES["english"]["ROLES"][rolename] or !ALLLANGUAGES["english"]["starttexts"][rolename] then
		error( "No language entry for: "..rolename )
	end

	local spawn = _G["SPAWN_"..name]
	if !static_stats.no_spawn and !dynamic_stats.no_spawn then
		if !spawn or ( !isvector( spawn ) and !istable( spawn ) ) then
			error( "No spawn position entry for: ".."SPAWN_"..name )
		end
	end

	ROLES[rolename] = name

	local scp = ObjectSCP( name, model, weapon, spawn, static_stats, dynamic_stats )

	if custom_callback and isfunction( custom_callback ) then
		scp:SetCallback( custom_callback )
	end

	if post_callback and isfunction( post_callback ) then
		scp:SetCallback( post_callback, true )
	end

	if !scp.basestats.no_select then
		SCPObjects[name] = scp
		table.insert( SCPS, name )
	else
		SCPNoSelectObjects[name] = scp
		table.insert( TransmitSCPS, name )
	end

	print( name.." has been registered!" )
	return true
end


-----SCP class-----
ObjectSCP = {}
ObjectSCP.__index = ObjectSCP

/*ObjectSCP.name = ""
ObjectSCP.basestats = {}
ObjectSCP.callback = function() end
ObjectSCP.post = function() end
ObjectSCP.swep = ""
ObjectSCP.model = ""
ObjectSCP.spawnpos = nil*/

function ObjectSCP:Create( name, model, weapon, pos, static_stats, dynamic_stats )
	local scp = setmetatable( {}, ObjectSCP )
	scp.Create = function() end

	scp.name = name
	scp.model = model
	scp.swep = weapon
	scp.spawnpos = pos
	scp.basestats = {}

	scp.callback = function() end
	scp.post = function() end

	if !SCP_DYNAMIC_VARS[name] then
		SCP_DYNAMIC_VARS[name] = {}
	end

	local dv = SCP_DYNAMIC_VARS[name]

	for k, v in pairs( dynamic_stats ) do
		if SCP_VALID_ENTRIES[k] then
			local istab = istable( v )
			local var = istab and v.var or v

			if dv[k] then
				var = dv[k]
			else
				dv[k] = var
			end

			if istab then
				if v.min or v.max then
					if !isnumber( var ) then
						ErrorNoHalt( name.." entry: "..k..". Number expected, got "..type( var ) )
						continue
					end

					if v.min then
						var = math.max( v.min, var )
					end

					if v.max then
						var = math.min( v.max, var )
					end
				end
			end

			scp.basestats[k] = var
		else
			print( "Invalid dynamic stat entry '"..k.."' for "..name )
		end
	end

	for k, v in pairs( static_stats ) do
		if SCP_VALID_ENTRIES[k] then
			scp.basestats[k] = v
		else
			print( "Invalid static stat entry '"..k.."' for "..name )
		end
	end

	return scp
end

function ObjectSCP:SetCallback( cb, post )
	if post then
		self.post = cb
	else
		self.callback = cb
	end
end

function ObjectSCP:SetupPlayer( ply, ... )
	if self.callback then
		if self.callback( ply, self.basestats, ... ) then
			return
		end
	end

	ply:UnSpectate()
	ply:GodDisable()
	
	-- RESET wszystkich manipulacji kości, bodygroups i skali modelu przed ustawieniem SCP
	ply:SetModelScale(1.0, 0)
	timer.Simple(0.05, function()
		if IsValid(ply) then
			-- Reset wszystkich manipulacji kości
			for i = 0, ply:GetBoneCount() - 1 do
				ply:ManipulateBoneScale(i, Vector(1, 1, 1))
			end
			
			-- Reset wszystkich bodygroups do wartości domyślnych (0)
			for i = 0, ply:GetNumBodyGroups() - 1 do
				ply:SetBodygroup(i, 0)
			end
			
			-- Reset przezroczystości
			ply:SetColor(Color(255, 255, 255, 255))
			ply:SetRenderMode(RENDERMODE_NORMAL)
		end
	end)
	
	if !self.basestats.no_strip then
		ply:StripWeapons()
		ply:RemoveAllAmmo()
	end

	local pos = self.spawnpos
	if pos and !self.basestats.no_spawn then
		if istable( pos ) then
			pos = table.Random( pos )
		end
		ply:Spawn()
		ply:SetPos( pos )
	end

	ply:SetGTeam( TEAM_SCP )
	ply:SetNClass( ROLES["ROLE_"..self.name] )

	if !self.basestats.no_model then
		ply:SetModel( self.model )
	end

	ply:SetModelScale( self.basestats.model_scale or 1 )

	ply:SetHealth( self.basestats.base_health or 1500 )
	ply:SetMaxHealth( self.basestats.max_health or 1500 )
	ply:SetWalkSpeed( self.basestats.base_speed or 200 )
	ply:SetRunSpeed( self.basestats.run_speed or 200 )
	ply:SetMaxSpeed( self.basestats.max_speed or 200 )
	ply:SetCrouchedWalkSpeed( self.basestats.crouch_speed or 0.6 )
	ply:SetJumpPower( self.basestats.jump_power or 200 )

	if !self.basestats.no_swep then
		local wep = ply:Give( self.swep )
		ply:SelectWeapon( self.swep )

		if IsValid( wep ) then
			wep.ShouldFreezePlayer = self.basestats.prep_freeze == true
		end
	end

	ply:SetArmor( 0 )

	ply:Flashlight( false )
	ply:AllowFlashlight( false )
	ply:SetNoDraw( self.basestats.no_draw == true )
	ply:SetNoTarget( true )

	ply.BaseStats = nil
	ply.UsingArmor = nil

	ply.Active = true
	ply.canblink = false
	ply.noragdoll = self.basestats.no_ragdoll == true

	ply.handsmodel = self.basestats.hands_model
	ply:SetupHands()

	net.Start( "RolesSelected" )
	net.Send( ply )

	if self.post then
		self.post( ply )
	end
end

setmetatable( ObjectSCP, { __call = ObjectSCP.Create } )
--------------------------------------------------------------------------------

timer.Simple( 0, function()
	hook.Run( "RegisterSCP" )
	SaveDynamicVars()
	--InitializeBreachULX()
	SetupForceSCP()
	for k, v in pairs( player.GetAll() ) do
		SendSCPList( v )
	end
end )


================================================
FILE: gamemodes/breach/gamemode/modules/sv_scp1123.lua
================================================
-- SCP-1123 Server Module
-- Moduł serwerowy dla SCP-1123 "Skull of Memories"

-- Network strings
util.AddNetworkString("SCP1123_StartEffect")
util.AddNetworkString("SCP1123_EndEffect")

-- Admin commands
concommand.Add("br_spawn_scp1123", function(ply, cmd, args)
	if not IsValid(ply) or not ply:IsSuperAdmin() then return end
	
	local tr = ply:GetEyeTrace()
	if tr.Hit then
		local ent = ents.Create("scp_1123")
		if IsValid(ent) then
			ent:SetPos(tr.HitPos + tr.HitNormal * 5)
			ent:Spawn()
			ply:PrintMessage(HUD_PRINTTALK, "SCP-1123 spawned!")
		end
	end
end)

concommand.Add("br_remove_scp1123", function(ply, cmd, args)
	if not IsValid(ply) or not ply:IsSuperAdmin() then return end
	
	for _, ent in pairs(ents.FindByClass("scp_1123")) do
		if IsValid(ent) then
			ent:Remove()
		end
	end
	ply:PrintMessage(HUD_PRINTTALK, "All SCP-1123 entities removed!")
end)

-- Hook dla cleanup przy śmierci gracza
hook.Add("PlayerDeath", "SCP1123_CleanupOnDeath", function(victim, inflictor, attacker)
	if IsValid(victim) and victim:GetNWBool("SCP1123_InEffect", false) then
		-- Znajdź SCP-1123 entity i zakończ efekt
		for _, ent in pairs(ents.FindByClass("scp_1123")) do
			if IsValid(ent) then
				ent:EndSCP1123Effect(victim)
				break
			end
		end
	end
end)

-- Hook dla cleanup przy zmianie zespołu
hook.Add("OnPlayerChangedTeam", "SCP1123_CleanupOnTeamChange", function(ply, oldTeam, newTeam)
	if IsValid(ply) and ply:GetNWBool("SCP1123_InEffect", false) then
		-- Znajdź SCP-1123 entity i zakończ efekt
		for _, ent in pairs(ents.FindByClass("scp_1123")) do
			if IsValid(ent) then
				ent:EndSCP1123Effect(ply)
				break
			end
		end
	end
end)

print("[Breach] SCP-1123 Server Module Loaded") 


================================================
FILE: gamemodes/breach/gamemode/modules/sv_scp207.lua
================================================
-- SCP-207 Module for SCP: Breach
-- Based on original SCP-207 addon by MrMarrant
-- Adapted for Breach gamemode

-- Global SCP-207 system
scp_207 = scp_207 or {}
SCP_207_CONFIG = SCP_207_CONFIG or {}
SCP_207_LANG = SCP_207_LANG or {}

-- Configuration
SCP_207_CONFIG.TimeDecay = CreateConVar( "breach_scp207_time_decay", 60, {FCVAR_PROTECTED, FCVAR_ARCHIVE}, "Time in seconds for each cycle", 1, 300 )
SCP_207_CONFIG.MaxLoop = 48 -- Max loop of the effect from SCP207
SCP_207_CONFIG.IncrementStat = CreateConVar( "breach_scp207_increment_stat", 0.1, {FCVAR_PROTECTED, FCVAR_ARCHIVE}, "The increment stat for walking/running speed", 0.01, 1 )
SCP_207_CONFIG.IncrementStatJump = 0.05
SCP_207_CONFIG.IncrementChanceDeath = 2
SCP_207_CONFIG.InitialChanceInstantDeath = 0
SCP_207_CONFIG.RadiusCollisionDoor = 30
SCP_207_CONFIG.VelocityMinDestroyDoor = 300
SCP_207_CONFIG.DamageTakeBreakingDoor = 20
SCP_207_CONFIG.DisabledInstantKill = CreateConVar( "breach_scp207_disabled_instant_kill", 0, {FCVAR_PROTECTED, FCVAR_ARCHIVE}, "If enable, disabled the instant death", 0, 1 )
SCP_207_CONFIG.PlayersCanBreakDoors = {}

-- Network strings
SCP_207_CONFIG.TextToSendToServer = "SCP207_TextToServer"
SCP_207_CONFIG.StartOverlayEffect = "SCP207_StartOverlay"
SCP_207_CONFIG.RemoveOverlayEffect = "SCP207_RemoveOverlay"

-- Add network strings
util.AddNetworkString(SCP_207_CONFIG.TextToSendToServer)
util.AddNetworkString(SCP_207_CONFIG.StartOverlayEffect)
util.AddNetworkString(SCP_207_CONFIG.RemoveOverlayEffect)

-- Door classes for breaking
SCP_207_CONFIG.DoorClass = {
    prop_door_rotating = true,
    func_door = true,
    func_door_rotating = true
}

-- Job restrictions (can be configured per team)
SCP_207_CONFIG.JobNotAllowed = {
    ["SCP"] = true, -- Block SCPs from using SCP-207
}

-- Effect states configuration
SCP_207_CONFIG.TableStateEffect = {
    [5] = { PrintMessageInfo = "You feel more energetic..." },
    [10] = { PrintMessageInfo = "Your heart rate increases..." },
    [15] = { PrintMessageInfo = "You feel extremely energized!", StartOverlayEffect = true },
    [20] = { PrintMessageInfo = "You can break doors!", EventDoorsDestroyable = true },
    [25] = { PrintMessageInfo = "Your vision becomes blurry..." },
    [30] = { PrintMessageInfo = "Warning: Heart palpitations detected!" },
    [35] = { PrintMessageInfo = "DANGER: Cardiac stress critical!" },
    [40] = { PrintMessageInfo = "CRITICAL: Imminent cardiac failure!" },
    [45] = { PrintMessageInfo = "FINAL WARNING: Death imminent!" }
}

-- Drop SCP-207 function
function scp_207.DropSCP207(ply, ent)
	if (!IsValid(ply) or !IsValid(ent)) then return end
	local LookForward = ply:EyeAngles():Forward()
	local LookUp = ply:EyeAngles():Up()
	local SCP207 = ents.Create( "scp_207" )
	local DistanceToPos = 50
	local PosObject = ply:GetShootPos() + LookForward * DistanceToPos + LookUp
    PosObject.z = ply:GetPos().z

	SCP207:SetPos( PosObject )
	SCP207:SetAngles( ply:EyeAngles() )
	SCP207:Spawn()
	SCP207:Activate()
	ent:Remove()
end

-- Consume SCP-207 function
function scp_207.ConsumeSCP207(ply)
	if (!IsValid(ply)) then return end

	-- Initialize SCP-207 data if first time
	if not ply.HasDrinkSCP207 then
		ply.HasDrinkSCP207 = true
		ply.scp207_Stack = 0
		scp_207.GetPreviousStatPlayer(ply)
	end
	
	-- Increase stack count
	ply.scp207_Stack = ply.scp207_Stack + 1
	
	-- Calculate new multiplier (each bottle adds 25%)
	local multiplier = 1 + (ply.scp207_Stack * 0.25)
	
	-- Apply cumulative boost based on original stats
	local walkSpeed = ply.scp207_PreviousInfoData.WalkSpeed
	local runSpeed = ply.scp207_PreviousInfoData.RunSpeed
	local jumpPower = ply.scp207_PreviousInfoData.JumpPower
	
	ply:SetWalkSpeed(walkSpeed * multiplier)
	ply:SetRunSpeed(runSpeed * multiplier)
	ply:SetJumpPower(jumpPower * multiplier)
    
    local boostPercent = (multiplier - 1) * 100
    print("[BREACH SCP-207] " .. ply:Nick() .. " consumed SCP-207 x" .. ply.scp207_Stack .. " (+" .. boostPercent .. "% speed/jump boost)")
end

-- Apply state effects (simplified - no effects needed)
function scp_207.ApplyStateEffect(ply, index)
    -- No effects needed for simple speed boost
    return
end

-- Get previous player stats
function scp_207.GetPreviousStatPlayer(ply)
    if (!IsValid(ply)) then return end

    ply.scp207_PreviousInfoData = {
        WalkSpeed = ply:GetWalkSpeed(),
        RunSpeed = ply:GetRunSpeed(),
        JumpPower = ply:GetJumpPower(),
    }
end

-- Increment player stats (not needed for simple boost)
function scp_207.IncrementStat(ply)
    -- No incremental stats needed for simple 25% boost
    return
end

-- Instant death function
function scp_207.InstanDeath(ply, percent)
    if (percent >= math.Rand(1, 100)) then 
        ply:Kill() 
        print("[BREACH SCP-207] " .. ply:Nick() .. " died from SCP-207 cardiac failure")
    end
end

-- Print message to player (not needed)
function scp_207.PrintMessageInfo(ply, text)
	-- No messages needed for simple boost
	return
end

-- Start overlay effect (not needed)
function scp_207.StartOverlayEffect(ply, index)
	-- No overlay needed for simple boost
	return
end

-- Remove overlay effect (not needed)
function scp_207.RemoveOverlayEffect(ply)
	-- No overlay to remove
	return
end

-- Event: Door destructible
function scp_207.EventDoorsDestroyable(ply)
	if (!IsValid(ply)) then return end

	if (table.IsEmpty( SCP_207_CONFIG.PlayersCanBreakDoors)) then
		scp_207.AddHookCheckDoor()
	end

	SCP_207_CONFIG.PlayersCanBreakDoors[ply:EntIndex()] = true
	ply.scp207_CanDestroyDoors = true
end

-- Add hook to check doors
function scp_207.AddHookCheckDoor()
	hook.Add( "Think", "Think.CheckDoorsBreakable_SCP207", function()
		for key, value in pairs(SCP_207_CONFIG.PlayersCanBreakDoors) do
			local ent = Entity(key)
			scp_207.CheckDoor(ent)
		end
	end )
end

-- Check for doors to break
function scp_207.CheckDoor(ply)
	if (not IsValid(ply)) then return end
	local doorsFound = ents.FindInSphere( ply:GetPos(), SCP_207_CONFIG.RadiusCollisionDoor )
	for key, door in ipairs(doorsFound) do
		if (SCP_207_CONFIG.DoorClass[door:GetClass()]) then
			scp_207.DestroyDoor(door, ply)
			break
		end
	end
end

-- Remove door breaking hook
function scp_207.RemoveEventDoorsDestroyable()
	if (!table.IsEmpty( SCP_207_CONFIG.PlayersCanBreakDoors)) then return end
	hook.Remove( "Think", "Think.CheckDoorsBreakable_SCP207" )
end

-- Destroy door function
function scp_207.DestroyDoor(door, ply)
	local PhysPly = ply:GetPhysicsObject()
	if (PhysPly:GetVelocity():Length() < SCP_207_CONFIG.VelocityMinDestroyDoor) then return end

	if (door:GetClass() == "prop_door_rotating") then
		local BrokenDoor = ents.Create("prop_physics")
		BrokenDoor:SetPos(door:GetPos())
		BrokenDoor:SetAngles(door:GetAngles())
		BrokenDoor:SetModel(door:GetModel())
		BrokenDoor:SetBodyGroups(door:GetBodyGroups())
		BrokenDoor:SetSkin(door:GetSkin())
		BrokenDoor:SetCustomCollisionCheck(true)
	
		door:Remove()
	
		BrokenDoor:Spawn()
	
		local PhysBrokenDoor = BrokenDoor:GetPhysicsObject()
		if IsValid(PhysBrokenDoor) then
			PhysBrokenDoor:ApplyForceOffset(ply:GetForward() * 500, PhysBrokenDoor:GetMassCenter())
		end
		door:EmitSound("doors/heavy_metal_stop1.wav",350,120)
		ply:TakeDamage(SCP_207_CONFIG.DamageTakeBreakingDoor, ply, ply)

	elseif(!scp_207.DoorIsOpen( door )) then
		door:Fire("open")
		door.IsBreak = true
		timer.Simple(2, function()
			if (!door:IsValid()) then return end
			door.IsBreak = nil
		end)
		door:EmitSound("doors/heavy_metal_stop1.wav",350,120)
		ply:TakeDamage(SCP_207_CONFIG.DamageTakeBreakingDoor, ply, ply)
	end
end

-- Cure SCP-207 effects (simplified)
function scp_207.CureEffect(ply)
	if (!ply.HasDrinkSCP207) then return end

	-- Restore original stats
	if (ply.scp207_PreviousInfoData and ply:Alive()) then
		ply:SetWalkSpeed( ply.scp207_PreviousInfoData.WalkSpeed )
		ply:SetRunSpeed( ply.scp207_PreviousInfoData.RunSpeed )
		ply:SetJumpPower( ply.scp207_PreviousInfoData.JumpPower )

		ply.scp207_PreviousInfoData = nil
	end

	-- Clean up all SCP-207 data
	ply.HasDrinkSCP207 = nil
	ply.scp207_Stack = nil
	print("[BREACH SCP-207] Cured effects for " .. ply:Nick())
end

-- Check if door is open
function scp_207.DoorIsOpen( door )
	if (door.IsBreak) then return true end
	local doorClass = door:GetClass()

	if ( doorClass == "func_door" or doorClass == "func_door_rotating" ) then
		return door:GetInternalVariable( "m_toggle_state" ) == 0
	elseif ( doorClass == "prop_door_rotating" ) then
		return door:GetInternalVariable( "m_eDoorState" ) ~= 0
	else
		return false
	end
end

-- Hooks for Breach integration
hook.Add("PlayerDeath", "SCP207_PlayerDeath", function(victim, inflictor, attacker)
    if IsValid(victim) then
        scp_207.CureEffect(victim)
    end
end)

hook.Add("PlayerDisconnected", "SCP207_PlayerDisconnect", function(ply)
    if IsValid(ply) then
        scp_207.CureEffect(ply)
    end
end)

-- Clean up on round restart
hook.Add("RoundRestart", "SCP207_RoundRestart", function()
    for _, ply in pairs(player.GetAll()) do
        if IsValid(ply) then
            scp_207.CureEffect(ply)
        end
    end
end)

print("[BREACH] SCP-207 Module Loaded") 


================================================
FILE: gamemodes/breach/gamemode/modules/sv_scp313.lua
================================================
-- SCP 313, A representation of a paranormal object on a fictional series on the game Garry's Mod.
-- Copyright (C) 2023  MrMarrant aka BIBI.
-- Adapted for SCP: Breach gamemode

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

SCP_313 = {}
SCP_313_CONFIG = {}

-- Configuration
SCP_313_CONFIG.PercentEffect = CreateConVar("scp_313_percent_effect", 1.5, {FCVAR_PROTECTED, FCVAR_ARCHIVE}, "Percentage chance to trigger the effect of SCP-313.", 0, 100)
SCP_313_CONFIG.DisplayEffectClientSide = "SCP_313_CONFIG.DisplayEffectClientSide"

-- Network strings
if SERVER then
    util.AddNetworkString(SCP_313_CONFIG.DisplayEffectClientSide)
end

-- Functions
function SCP_313.IsArmed()
    local percent = SCP_313_CONFIG.PercentEffect:GetInt()
    assert(percent >= 0 and percent <= 100)
    return percent >= math.Rand(1, 100)
end

if SERVER then
    function SCP_313.DisplayEffectClientSide(effectName, pos)
        local effectdata = EffectData()
        effectdata:SetOrigin(pos)
        util.Effect(effectName, effectdata)
        net.Start(SCP_313_CONFIG.DisplayEffectClientSide)
            net.WriteVector(pos)
            net.WriteString(effectName)
        net.Broadcast()
    end
end

if CLIENT then
    net.Receive(SCP_313_CONFIG.DisplayEffectClientSide, function()
        local pos = net.ReadVector()
        local effectName = net.ReadString()
        local effectdata = EffectData()
        effectdata:SetOrigin(pos)
        util.Effect(effectName, effectdata)
    end)
end

-- Print initialization message
print("[BREACH] SCP-313 module loaded successfully") 


================================================
FILE: gamemodes/breach/gamemode/modules/sv_scp330.lua
================================================
-- SCP-330 Server Module dla gamemode Breach
-- Zarządza funkcjonalnością SCP-330

-- SCP-330 Global functions
SCP330 = SCP330 or {}

-- Configuration
SCP330.Config = {
    MaxCandies = 2,
    BleedDamage = 5,
    BleedInterval = 10,
    BleedDuration = 900, -- 15 minutes
    ProximityRadius = 150,
    HandRemovalTime = 300, -- 5 minutes
    CandyHealAmount = 10 -- HP healed per candy
}

-- Candy flavors
SCP330.CandyFlavors = {
    "Strawberry", "Apple", "Cherry", "Orange", "Lemon", "Banana",
    "Raspberry", "Blueberry", "Pineapple", "Melon", "Watermelon", 
    "Peach", "Pear", "Apricot", "Plum", "Mango", "Kiwi", "Fig", "Grape", "Hazelnut"
}

-- Global tracking
SCP330.PlayerData = {}

-- Initialize player data
function SCP330:InitPlayer(ply)
    if not IsValid(ply) then return end
    local steamID = ply:SteamID64()
    if not self.PlayerData[steamID] then
        self.PlayerData[steamID] = {
            candyTaken = 0,
            handsCut = false,
            bleeding = false,
            lastInteraction = 0
        }
    end
end

-- Get random candy flavor
function SCP330:GetRandomFlavor()
    return self.CandyFlavors[math.random(#self.CandyFlavors)]
end

-- Reset player data
function SCP330:ResetPlayer(ply)
    local steamID = ply:SteamID64()
    if self.PlayerData[steamID] then
        self.PlayerData[steamID] = {
            candyTaken = 0,
            handsCut = false,
            bleeding = false,
            lastInteraction = 0
        }
    end
    
    -- Remove bleeding timer
    timer.Remove("SCP330_Bleeding_" .. ply:EntIndex())
    
    -- Remove all SCP-330 candy weapons from player's inventory
    if IsValid(ply) then
        for _, weapon in pairs(ply:GetWeapons()) do
            if IsValid(weapon) and weapon:GetClass() == "weapon_scp330_candy" then
                ply:StripWeapon("weapon_scp330_candy")
            end
        end
    end
end

-- Check if player can take candy (only blocks if hands are cut)
function SCP330:CanTakeCandy(ply)
    local steamID = ply:SteamID64()
    local data = self.PlayerData[steamID]
    
    if not data then return true end
    if data.handsCut then return false end
    
    -- Allow taking candy even if over limit (punishment will be applied)
    return true
end

-- Get player candy count
function SCP330:GetCandyCount(ply)
    local steamID = ply:SteamID64()
    local data = self.PlayerData[steamID]
    return data and data.candyTaken or 0
end

-- Player hooks
hook.Add("PlayerInitialSpawn", "SCP330_PlayerInit", function(ply)
    SCP330:InitPlayer(ply)
end)

hook.Add("PlayerDeath", "SCP330_Module_PlayerDeath", function(ply)
    SCP330:ResetPlayer(ply)
end)

hook.Add("PlayerSpawn", "SCP330_Module_PlayerSpawn", function(ply)
    SCP330:ResetPlayer(ply)
end)

hook.Add("PlayerDisconnected", "SCP330_Module_PlayerDisconnect", function(ply)
    timer.Remove("SCP330_Bleeding_" .. ply:EntIndex())
end)

-- Prevent weapon pickup with cut hands
hook.Add("PlayerCanPickupWeapon", "SCP330_PreventPickup", function(ply, weapon)
    SCP330:InitPlayer(ply)
    local steamID = ply:SteamID64()
    local data = SCP330.PlayerData[steamID]
    
    if data and data.handsCut then
        return false
    end
end)

-- Prevent all USE interactions with cut hands (doors, props, buttons, etc.)
hook.Add("PlayerUse", "SCP330_PreventUse", function(ply, entity)
    SCP330:InitPlayer(ply)
    local steamID = ply:SteamID64()
    local data = SCP330.PlayerData[steamID]
    
    if data and data.handsCut then
        -- Allow using SCP-330 itself so players can see the "can't use" message
        if entity:GetClass() == "item_scp_330" then
            return true
        end
        
        -- Block all other interactions (silent)
        return false
    end
end)

-- Prevent picking up any entities/items with cut hands
hook.Add("AllowPlayerPickup", "SCP330_PreventEntityPickup", function(ply, entity)
    SCP330:InitPlayer(ply)
    local steamID = ply:SteamID64()
    local data = SCP330.PlayerData[steamID]
    
    if data and data.handsCut then
        -- Block pickup silently
        return false
    end
end)

-- Prevent dropping weapons/items with cut hands (since they can't hold anything)
hook.Add("PlayerDropWeapon", "SCP330_PreventDrop", function(ply, weapon)
    SCP330:InitPlayer(ply)
    local steamID = ply:SteamID64()
    local data = SCP330.PlayerData[steamID]
    
    if data and data.handsCut then
        -- This shouldn't happen since they can't have weapons, but just in case
        return false
    end
end)

-- Admin commands
if SERVER then
    concommand.Add("scp330_spawn", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        local trace = ply:GetEyeTrace()
        local pos = trace.HitPos + trace.HitNormal * 5
        
        local scp330 = ents.Create("item_scp_330")
        if IsValid(scp330) then
            scp330:SetPos(pos)
            scp330:Spawn()
            
            print("[ADMIN] " .. ply:Nick() .. " spawned SCP-330 at " .. tostring(pos))
            ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] SCP-330 spawned successfully!")
        end
    end)
    
    concommand.Add("scp330_reset_player", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        local target = args[1]
        if not target then
            ply:PrintMessage(HUD_PRINTTALK, "Usage: scp330_reset_player <player_name>")
            return
        end
        
        local targetPly = nil
        for _, p in pairs(player.GetAll()) do
            if string.find(string.lower(p:Nick()), string.lower(target)) then
                targetPly = p
                break
            end
        end
        
        if not targetPly then
            ply:PrintMessage(HUD_PRINTTALK, "Player not found!")
            return
        end
        
        SCP330:ResetPlayer(targetPly)
        print("[ADMIN] " .. ply:Nick() .. " reset SCP-330 data for " .. targetPly:Nick())
        ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] Reset SCP-330 data for " .. targetPly:Nick())
    end)
    
    concommand.Add("scp330_info", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        ply:PrintMessage(HUD_PRINTTALK, "=== SCP-330 Information ===")
        ply:PrintMessage(HUD_PRINTTALK, "Active SCP-330 entities: " .. #ents.FindByClass("item_scp_330"))
        ply:PrintMessage(HUD_PRINTTALK, "Candy healing amount: " .. SCP330.Config.CandyHealAmount .. " HP")
        ply:PrintMessage(HUD_PRINTTALK, "Max candies allowed: " .. SCP330.Config.MaxCandies)
        
        local activeBleeders = 0
        local cutHands = 0
        
        for steamID, data in pairs(SCP330.PlayerData) do
            if data.bleeding then activeBleeders = activeBleeders + 1 end
            if data.handsCut then cutHands = cutHands + 1 end
        end
        
        ply:PrintMessage(HUD_PRINTTALK, "Players with cut hands: " .. cutHands)
        ply:PrintMessage(HUD_PRINTTALK, "Players currently bleeding: " .. activeBleeders)
    end)
    
    concommand.Add("scp330_check_player", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        local target = args[1] or ply:Nick()
        local targetPly = nil
        
        for _, p in pairs(player.GetAll()) do
            if string.find(string.lower(p:Nick()), string.lower(target)) then
                targetPly = p
                break
            end
        end
        
        if not targetPly then
            ply:PrintMessage(HUD_PRINTTALK, "Player not found!")
            return
        end
        
        SCP330:InitPlayer(targetPly)
        local steamID = targetPly:SteamID64()
        local data = SCP330.PlayerData[steamID]
        
        ply:PrintMessage(HUD_PRINTTALK, "=== " .. targetPly:Nick() .. " SCP-330 Status ===")
        ply:PrintMessage(HUD_PRINTTALK, "Candies taken: " .. data.candyTaken)
        ply:PrintMessage(HUD_PRINTTALK, "Hands cut: " .. tostring(data.handsCut))
        ply:PrintMessage(HUD_PRINTTALK, "Bleeding: " .. tostring(data.bleeding))
        ply:PrintMessage(HUD_PRINTTALK, "Can take candy: " .. tostring(SCP330:CanTakeCandy(targetPly)))
    end)
    
    concommand.Add("scp330_spawn_table", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        local success = SCP330:SpawnAtTable()
        if success then
            ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] SCP-330 spawned on table at cafeteria")
        else
            ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] SCP-330 table spawn failed")
        end
    end)
    
    concommand.Add("scp330_force_spawn_table", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        local tablePos = Vector(2110.566406, -1492.138428, 15.031254)
        local scp330Pos = Vector(2111.600830, -1491.158447, 33.602257)
        local spawnAngles = Angle(0, 0, 0)
        
        -- Remove existing
        for _, ent in pairs(ents.FindByClass("item_scp_330")) do
            ent:Remove()
        end
        
        -- Force spawn table (100% chance)
        local table = ents.Create("prop_physics")
        if IsValid(table) then
            table:SetModel("models/props_c17/FurnitureTable001a.mdl")
            table:SetPos(tablePos)
            table:SetAngles(spawnAngles)
            table:Spawn()
            
            -- Make it indestructible and immovable
            if IsValid(table:GetPhysicsObject()) then
                table:GetPhysicsObject():EnableMotion(false)
            end
            table:SetHealth(999999) -- High health
            table:SetMaxHealth(999999)
            table.TakeDamage = function() end -- Override damage function
            table:SetName("SCP330_Table") -- Give it a name for identification
        end
        
        -- Force spawn SCP-330 at separate location
        local scp330 = ents.Create("item_scp_330")
        if IsValid(scp330) then
            scp330:SetPos(scp330Pos)
            scp330:SetAngles(spawnAngles)
            scp330:Spawn()
            
            -- Make SCP-330 immovable and indestructible
            if IsValid(scp330:GetPhysicsObject()) then
                scp330:GetPhysicsObject():EnableMotion(false) -- Make it static
            end
            scp330:SetHealth(999999) -- High health
            scp330:SetMaxHealth(999999)
            scp330.TakeDamage = function() end -- Override damage function
            scp330:SetName("SCP330_Bowl") -- Give it a name for identification
            
            ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] SCP-330 and table force spawned at separate locations")
            print("[ADMIN] " .. ply:Nick() .. " force spawned SCP-330 and table")
            print("[ADMIN] Table at: " .. tostring(tablePos))
            print("[ADMIN] SCP-330 at: " .. tostring(scp330Pos))
        end
    end)
    
    concommand.Add("scp330_reset_all", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        local resetCount = 0
        for _, p in pairs(player.GetAll()) do
            if IsValid(p) then
                SCP330:ResetPlayer(p)
                resetCount = resetCount + 1
            end
        end
        
        ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] Reset SCP-330 data for " .. resetCount .. " players")
        print("[ADMIN] " .. ply:Nick() .. " reset SCP-330 data for all " .. resetCount .. " players")
    end)
    
    concommand.Add("scp330_debug_hooks", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        ply:PrintMessage(HUD_PRINTTALK, "=== SCP-330 Hook Debug ===")
        ply:PrintMessage(HUD_PRINTTALK, "Available hooks:")
        ply:PrintMessage(HUD_PRINTTALK, "- SCP330_Module_PlayerInit (PlayerInitialSpawn)")
        ply:PrintMessage(HUD_PRINTTALK, "- SCP330_Module_PlayerDeath (PlayerDeath)")
        ply:PrintMessage(HUD_PRINTTALK, "- SCP330_Module_PlayerSpawn (PlayerSpawn)")
        ply:PrintMessage(HUD_PRINTTALK, "- SCP330_ResetAllPlayers (BreachPreround)")
        ply:PrintMessage(HUD_PRINTTALK, "- SCP330_CleanupReset (OnCleanup)")
        
        -- Test manual reset
        SCP330:ResetPlayer(ply)
        ply:PrintMessage(HUD_PRINTTALK, "Manual reset executed on you")
    end)
    
    concommand.Add("scp330_set_heal", function(ply, cmd, args)
        if not ply:IsAdmin() then return end
        
        local amount = tonumber(args[1])
        if not amount or amount < 0 or amount > 100 then
            ply:PrintMessage(HUD_PRINTTALK, "Usage: scp330_set_heal <amount> (0-100)")
            ply:PrintMessage(HUD_PRINTTALK, "Current healing amount: " .. SCP330.Config.CandyHealAmount .. " HP")
            return
        end
        
        SCP330.Config.CandyHealAmount = amount
        ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] SCP-330 candy healing set to " .. amount .. " HP")
        print("[ADMIN] " .. ply:Nick() .. " set SCP-330 candy healing to " .. amount .. " HP")
    end)
end

-- Network strings
util.AddNetworkString("SCP330_PlaySound")
util.AddNetworkString("SCP330_BloodEffect")
util.AddNetworkString("SCP330_ProximityWarning")

-- Helper function for logging
function SCP330:Log(message, category)
    -- Use simple print logging like other Breach modules
    print("[SCP-330] " .. message)
end

-- Spawn SCP-330 and table at separate locations
function SCP330:SpawnAtTable()
    local tablePos = Vector(2110.566406, -1492.138428, 15.031254)
    local scp330Pos = Vector(2111.600830, -1491.158447, 33.602257)
    local spawnAngles = Angle(0, 0, 0)
    
    -- Remove any existing SCP-330 entities first
    for _, ent in pairs(ents.FindByClass("item_scp_330")) do
        ent:Remove()
    end
    
    -- 25% chance to spawn
    if math.random(100) <= 25 then
        -- Spawn table prop at its location
        local table = ents.Create("prop_physics")
        if IsValid(table) then
            table:SetModel("models/props_c17/FurnitureTable001a.mdl")
            table:SetPos(tablePos)
            table:SetAngles(spawnAngles)
            table:Spawn()
            
            -- Make it indestructible and immovable
            if IsValid(table:GetPhysicsObject()) then
                table:GetPhysicsObject():EnableMotion(false) -- Make it static
            end
            table:SetHealth(999999) -- High health
            table:SetMaxHealth(999999)
            table.TakeDamage = function() end -- Override damage function
            table:SetName("SCP330_Table") -- Give it a name for identification
        end
        
        -- Spawn SCP-330 at its separate location
        local scp330 = ents.Create("item_scp_330")
        if IsValid(scp330) then
            scp330:SetPos(scp330Pos)
            scp330:SetAngles(spawnAngles)
            scp330:Spawn()
            
            -- Make SCP-330 immovable and indestructible
            if IsValid(scp330:GetPhysicsObject()) then
                scp330:GetPhysicsObject():EnableMotion(false) -- Make it static
            end
            scp330:SetHealth(999999) -- High health
            scp330:SetMaxHealth(999999)
            scp330.TakeDamage = function() end -- Override damage function
            scp330:SetName("SCP330_Bowl") -- Give it a name for identification
            
            SCP330:Log("SCP-330 and table spawned at separate locations (25% chance triggered)")
            SCP330:Log("Table at: " .. tostring(tablePos))
            SCP330:Log("SCP-330 at: " .. tostring(scp330Pos))
            return true
        end
    else
        SCP330:Log("SCP-330 and table spawn skipped (75% chance)")
        return false
    end
end

-- Auto-spawn on round start
hook.Add("PostCleanupMap", "SCP330_AutoSpawn", function()
    timer.Simple(2, function() -- Small delay to ensure map is fully loaded
        SCP330:SpawnAtTable()
    end)
end)

-- Alternative hook for round restarts
hook.Add("RoundRestart", "SCP330_RoundRestart", function()
    timer.Simple(2, function()
        SCP330:SpawnAtTable()
    end)
end)

-- Reset all players at round start (Breach-specific hook)
hook.Add("BreachPreround", "SCP330_ResetAllPlayers", function()
    print("[SCP-330] Resetting all players for new round...")
    for _, ply in pairs(player.GetAll()) do
        if IsValid(ply) then
            SCP330:ResetPlayer(ply)
        end
    end
    SCP330:Log("All players reset for new round")
end)

-- Additional cleanup hook
hook.Add("OnCleanup", "SCP330_CleanupReset", function()
    print("[SCP-330] Map cleanup - resetting all players...")
    for _, ply in pairs(player.GetAll()) do
        if IsValid(ply) then
            SCP330:ResetPlayer(ply)
        end
    end
    SCP330:Log("All players reset on map cleanup")
end)

-- Protect SCP-330 table and bowl from damage and removal
hook.Add("EntityTakeDamage", "SCP330_ProtectEntities", function(ent, dmg)
    if IsValid(ent) and (ent:GetName() == "SCP330_Table" or ent:GetName() == "SCP330_Bowl") then
        dmg:SetDamage(0) -- No damage
        return true -- Block damage
    end
end)

-- Prevent table and bowl removal
hook.Add("CanProperty", "SCP330_PreventProperty", function(ply, property, ent)
    if IsValid(ent) and (ent:GetName() == "SCP330_Table" or ent:GetName() == "SCP330_Bowl") then
        return false -- Block all property interactions (remove, etc.)
    end
end)

-- Additional protection against physgun
hook.Add("PhysgunPickup", "SCP330_PreventPhysgun", function(ply, ent)
    if IsValid(ent) and (ent:GetName() == "SCP330_Table" or ent:GetName() == "SCP330_Bowl") then
        return false -- Can't pick up with physgun
    end
end)

-- Prevent gravgun interactions
hook.Add("GravGunPunt", "SCP330_PreventGravGun", function(ply, ent)
    if IsValid(ent) and (ent:GetName() == "SCP330_Table" or ent:GetName() == "SCP330_Bowl") then
        return false -- Can't punt with gravgun
    end
end)

hook.Add("GravGunPickupAllowed", "SCP330_PreventGravGunPickup", function(ply, ent)
    if IsValid(ent) and (ent:GetName() == "SCP330_Table" or ent:GetName() == "SCP330_Bowl") then
        return false -- Can't pick up with gravgun
    end
end)

print("[SCP-330] Server module loaded successfully!") 


================================================
FILE: gamemodes/breach/gamemode/modules/sv_server.lua
================================================
util.AddNetworkString("PlayerBlink")
util.AddNetworkString("DropWeapon")
util.AddNetworkString("DropCurWeapon")
--util.AddNetworkString("RequestGateA")
util.AddNetworkString("RequestEscorting")
util.AddNetworkString("PrepStart")
util.AddNetworkString("RoundStart")
util.AddNetworkString("PostStart")
util.AddNetworkString("RolesSelected")
util.AddNetworkString("SendRoundInfo")
util.AddNetworkString("Sound_Random")
util.AddNetworkString("Sound_Searching")
util.AddNetworkString("Sound_Classd")
util.AddNetworkString("Sound_Stop")
util.AddNetworkString("Sound_Lost")
util.AddNetworkString("UpdateRoundType")
util.AddNetworkString("ForcePlaySound")
util.AddNetworkString("OnEscaped")
util.AddNetworkString("SlowPlayerBlink")
util.AddNetworkString("DropCurrentVest")
util.AddNetworkString("RoundRestart")
util.AddNetworkString("SpectateMode")
util.AddNetworkString("UpdateTime")
--util.AddNetworkString("Update914B")
util.AddNetworkString("Effect")
util.AddNetworkString("NTFRequest")
util.AddNetworkString("ExplodeRequest")
util.AddNetworkString("ForcePlayerSpeed")
util.AddNetworkString("ClearData")
util.AddNetworkString("Restart")
util.AddNetworkString("AdminMode")
util.AddNetworkString("ShowText")
util.AddNetworkString("PlayerReady")
util.AddNetworkString("RecheckPremium")
util.AddNetworkString("CancelPunish")
util.AddNetworkString("689")
util.AddNetworkString( "UpdateKeycard" )
util.AddNetworkString( "SendSound" )
util.AddNetworkString( "957Effect" )
util.AddNetworkString( "SCPList" )
util.AddNetworkString( "TranslatedMessage" )
util.AddNetworkString( "CameraDetect" )
util.AddNetworkString( "BomberLottery" )

net.Receive( "DropWeapon", function( len, ply )
	local class = net.ReadString()
	if class then
		ply:ForceDropWeapon( class )
	end
end )

net.Receive( "CancelPunish", function( len, ply )
	if ply:IsSuperAdmin() then
		CancelVote()
	end
end )

net.Receive( "PlayerReady", function( len, ply )
	ply:SetActive( true )
	net.Start( "PlayerReady" )
		net.WriteTable( { sR, sL } )
	net.Send( ply )
	SendSCPList( ply )
end )

net.Receive( "RecheckPremium", function( len, ply )
	if ply:IsSuperAdmin() then
		for k, v in pairs( player.GetAll() ) do
			IsPremium( v, true )
		end
	end
end )

net.Receive( "SpectateMode", function( len, ply )
	/*
	if ply.ActivePlayer == true then
		if ply:Alive() and ply:Team() != TEAM_SPEC then
			ply:SetSpectator()
		end
		ply.SetActive( false )
		ply:PrintMessage(HUD_PRINTTALK, "Changed mode to spectator")
	elseif ply.ActivePlayer == false then
		ply.SetActive( true )
		ply:PrintMessage(HUD_PRINTTALK, "Changed mode to player")
	end
	CheckStart()
	*/
end)

net.Receive( "AdminMode", function( len, ply )
	if ply:IsSuperAdmin() then
		ply:ToggleAdminModePref()
	end
end)

net.Receive( "RoundRestart", function( len, ply )
	if ply:IsSuperAdmin() then
		RoundRestart()
	end
end)

net.Receive( "Restart", function( len, ply )
	if ply:IsSuperAdmin() then
		RestartGame()
	end
end)

net.Receive( "Sound_Random", function( len, ply )
	PlayerNTFSound("Random"..math.random(1,4)..".ogg", ply)
end)

net.Receive( "Sound_Searching", function( len, ply )
	PlayerNTFSound("Searching"..math.random(1,6)..".ogg", ply)
end)

net.Receive( "Sound_Classd", function( len, ply )
	PlayerNTFSound("ClassD"..math.random(1,4)..".ogg", ply)
end)

net.Receive( "Sound_Stop", function( len, ply )
	PlayerNTFSound("Stop"..math.random(2,6)..".ogg", ply)
end)

net.Receive( "Sound_Lost", function( len, ply )
	PlayerNTFSound("TargetLost"..math.random(1,3)..".ogg", ply)
end)

net.Receive( "DropCurrentVest", function( len, ply )
	if ply:GTeam() != TEAM_SPEC and ( ply:GTeam() != TEAM_SCP or ply:GetNClass() == ROLES.ROLE_SCP9571 ) and ply:Alive() then
		if ply.UsingArmor != nil then
			ply:UnUseArmor()
		end
	end
end)

net.Receive( "RequestEscorting", function( len, ply )
	if ply:GTeam() == TEAM_GUARD then
		CheckEscortMTF(ply)
	elseif ply:GTeam() == TEAM_CHAOS then
		CheckEscortChaos(ply)
	end
end)

net.Receive( "ClearData", function( len, ply )
	if not(ply:IsSuperAdmin()) then return end
	local com = net.ReadString()
	if com == "&ALL" then
		for k, v in pairs( player:GetAll() ) do
			clearData( v )
		end
	else
		for k, v in pairs( player:GetAll() ) do
			if v:GetName() == com then
				clearData( v )
				return
			end
		end
		if IsValidSteamID( com ) then
			clearDataID( com )
		end
	end
end)

function clearData( ply )
	ply:SetPData( "breach_exp", 0 )
	ply:SetNEXP( 0 )
	ply:SetPData( "breach_level", 0 )
	ply:SetNLevel( 0 )
end

function clearDataID( id64 )
	util.RemovePData( id64, "breach_exp" )
	util.RemovePData( id64, "breach_level" )
end

function IsValidSteamID( id )
	if tonumber( id ) then
		return true
	end
	return false
end

--net.Receive( "RequestGateA", function( len, ply )
--	RequestOpenGateA(ply)
--end)

net.Receive( "NTFRequest" , function( len, ply )
	if ply:IsSuperAdmin() then
		SpawnNTFS()
	end
end )

net.Receive( "ExplodeRequest", function( len, ply )
	-- Pozwól wysadzić Gate A również członkom GOC
	if  ply:GetNClass() == ROLES.ROLE_MTFNTF
		or ply:GetNClass() == ROLES.ROLE_CHAOS
		or ply:GetNClass() == ROLES.ROLE_GOC_SOLDIER
		or ply:GetNClass() == ROLES.ROLE_GOC_OPERATIVE
		or ply:GetNClass() == ROLES.ROLE_GOC_COMMANDER
		or ply:GTeam()   == TEAM_GOC then

		explodeGateA( ply )
	end
end )

net.Receive( "DropCurWeapon", function( len, ply )
	local wep = ply:GetActiveWeapon()
	if ply:GTeam() == TEAM_SPEC then return end
	if IsValid(wep) and wep != nil and IsValid(ply) then
		local atype = wep:GetPrimaryAmmoType()
		if atype > 0 then
			wep.SavedAmmo = wep:Clip1()
		end
		
		-- Clear NVG state if dropping NVG
		if wep:GetClass() == "item_nvg" and ply.NVGActive then
			ply.NVGActive = false
			net.Start("NVG_Toggle")
				net.WriteBool(false)
			net.Send(ply)
		end
		
		if wep:GetClass() == nil then return end
		if wep.droppable != nil then
			if wep.droppable == false then return end
		end
		ply:DropWeapon( wep )
		ply:ConCommand( "lastinv" )
	end
end )

/*function dofloor(num, yes)
	if yes then
		return math.floor(num)
	end
	return num
end*/

/*function GetRoleTable(all)
	local classds = 0
	local mtfs = 0
	local researchers = 0
	local scps = 0
	if all < 8 then
		scps = 1
		all = all - 1
	elseif all > 7 and all < 16 then
		scps = 2
		all = all - 2
	elseif all > 15 then
		scps = 3
		all = all - 3
	end
	//mtfs = math.Round(all * 0.299)
	local mtfmul = 0.33
	if all > 12 then
		mtfmul = 0.3
	elseif all > 22 then
		mtfmul = 0.28
	end
	mtfs = math.Round(all * mtfmul)
	all = all - mtfs
	researchers = math.floor(all * 0.42)
	all = all - researchers
	classds = all
	//print(scps .. "," .. mtfs .. "," .. classds .. "," .. researchers .. "," .. chaosinsurgency)
	/*
	print("scps: " .. scps)
	print("mtfs: " .. mtfs)
	print("classds: " .. classds)
	print("researchers: " .. researchers)
	print("chaosinsurgency: " .. chaosinsurgency)
	*/
	/*return {scps, mtfs, classds, researchers}
end*/

function GetRoleTableCustom(all, scps, p_mtf, p_res)
	local classds = 0
	local mtfs = 0
	local researchers = 0
	all = all - scps
	mtfs = math.Round(all * p_mtf)
	all = all - mtfs
	researchers = math.floor(all * p_res)
	all = all - researchers
	classds = all
	return {scps, mtfs, classds, researchers}
end

cvars.AddChangeCallback( "br_roundrestart", function( convar_name, value_old, value_new )
	if tonumber( value_new ) == 1 then
		itemsSpawned = false
		RoundRestart()
		RunConsoleCommand("br_roundrestart", "0")
	end
end )

/*function SetupPlayers(pltab)
	local allply = GetActivePlayers()
	
	// SCPS
	local spctab = table.Copy(SCPS)
	for i=1, pltab[1] do
		if #spctab < 1 then
			spctab = table.Copy(SCPS)
			//print("not enough scps, copying another table")
		end
		local pl = table.Random(allply)
		if IsValid(pl) == false then continue end
		local scp = table.Random(spctab)
		--scp["func"](pl)
		GetSCP( scp ):SetupPlayer( pl )
		print("assigning " .. pl:Nick() .. " to scps")
		table.RemoveByValue(spctab, scp)
		table.RemoveByValue(allply, pl)
	end
	
	// Class D Personell
	local dspawns = table.Copy(SPAWN_CLASSD)
	for i=1, pltab[3] do
		if #dspawns < 1 then
			dspawns = table.Copy(SPAWN_CLASSD)
		end
		if #dspawns > 0 then
			local pl = table.Random(allply)
			if IsValid(pl) == false then continue end
			local spawn = table.Random(dspawns)
			pl:SetupNormal()
			pl:SetClassD()
			pl:SetPos(spawn)
			print("assigning " .. pl:Nick() .. " to classds")
			table.RemoveByValue(dspawns, spawn)
			table.RemoveByValue(allply, pl)
		end
	end
	
	// Researchers
	local resspawns = table.Copy(SPAWN_SCIENT)
	for i=1, pltab[4] do
		if #resspawns < 1 then
			resspawns = table.Copy(SPAWN_SCIENT)
		end
		if #resspawns > 0 then
			local pl = table.Random(allply)
			if IsValid(pl) == false then continue end
			local spawn = table.Random(resspawns)
			pl:SetupNormal()
			pl:SetResearcher()
			pl:SetPos(spawn)
			print("assigning " .. pl:Nick() .. " to researchers")
			table.RemoveByValue(resspawns, spawn)
			table.RemoveByValue(allply, pl)
		end
	end
	
	// Security
	local security = ALLCLASSES["security"]["roles"]
	local securityspawns = table.Copy(SPAWN_GUARD)
	
	local i4inuse = false
	for i = 1, pltab[2] do
		if #securityspawns < 1 then
			securityspawns = table.Copy(SPAWN_GUARD)
		end
		if #securityspawns > 0 then
			local pl = table.remove( allply, math.random( #allply ) )
			if !IsValid( pl ) then continue end
			local spawn = table.remove( securityspawns, math.random( #allply ) )
			local thebestone
			for k, v in pairs( ALLCLASSES["security"]["roles"] ) do
				local useci = math.random( 1, 6 )
				local can = true
				if v.customcheck != nil then
					if !v.customcheck( self ) then
						can = false
					end
				end
				local using = 0
				for _, pl in pairs( player.GetAll() ) do
					if pl:GetNClass() == v.name then
						using = using + 1
					end
				end
				if using >= v.max then
					can = false
				end
				if v.importancelevel == 4 and ( i < GetConVar( "br_i4_min_mtf" ):GetInt() or i4inuse ) then
					can = false
				end
				if can then
					if pl:GetLevel() >= v.level then
						if thebestone != nil then
							if thebestone.sorting < v.sorting then
								thebestone = v
							end
						else
							thebestone = v
						end
					else
						can = false
					end
				end
			end
			if !thebestone then
				thebestone = ALLCLASSES["security"]["roles"][1]
			end
			if thebestone.name == ROLES.ROLE_MTFGUARD then
				if math.random( 1, 4 ) == 4 then
					for _, role in pairs( ALLCLASSES["security"]["roles"] ) do
						if role.name == ROLES.ROLE_CHAOSSPY then
							thebestone = role
							break
						end
					end
				end
			end
			if useci == 6 then
				local fakeci = math.random( 1, 3 ) == 1
				for _, role in pairs( ALLCLASSES["security"]["roles"] ) do
					local tofind = ROLES.ROLE_CHAOSSPY
					if fakeci then tofind = ROLES.ROLE_MTFGUARD end
					if role.name == tofind then
						thebestone = role
						break
					end
				end
			end
			if thebestone.importancelevel == 4 then
				i4inuse = true
			end
			pl:SetupNormal()
			pl:ApplyRoleStats( thebestone )
			pl:SetPos( spawn )
			print("assigning " .. pl:Nick() .. " to MTFs")
		end
	end
	
	net.Start("RolesSelected")
	net.Broadcast()
end*/

function SetupAdmins( players )
	for k, v in pairs( players ) do
		if v.admpref then
			if !v.AdminMode then
				v:ToggleAdminMode()
			end
			v:SetupAdmin()
		elseif v.AdminMode then
			v:ToggleAdminMode()
		end
	end
end

function GiveExp()
	for k, v in pairs( player.GetAll() ) do
		local exptogive = v:Frags() * 50
		v:SetFrags( 0 )
		if exptogive > 0 then
			v:AddExp( exptogive, true )
			v:PrintMessage( HUD_PRINTTALK, "You have recived "..exptogive.." experience for "..(exptogive / 50).." points" )
		end
	end
end

activevote = false
suspectname = ""
activesuspect = nil
activevictim = nil
votepunish = 0
voteforgive = 0
specpunish = 0
specforgive = 0

function PunishVote( ply, victim )
	if GetConVar( "br_allow_punish" ):GetInt() == 0 then return end
	if ply == victim then return end
	if activevote then
		EndPunishVote()
		timer.Destroy( "PunishEnd" )
	end
	net.Start( "ShowText" )
		net.WriteString( "text_punish" )
		net.WriteString( ply:GetName() )
	net.Broadcast()
	activevote = true
	votepunish = 0
	voteforgive = 0
	specpunish = 0
	specforgive = 0
	suspectname = ply:GetName()
	activesuspect = ply:SteamID64()
	activevictim = victim:SteamID64()
	timer.Create( "PunishEnd", GetConVar( "br_punishvote_time" ):GetInt(), 1, function()
		EndPunishVote()
	end )
end

function EndPunishVote()
	local specvotedforgive = math.Round( 3 * specforgive / ( specpunish + specforgive ) )
	if tostring( specvotedforgive ) != "nan" then
		voteforgive = voteforgive + specvotedforgive
		votepunish = votepunish + ( 3 - specvotedforgive )
	end
	print( "Player: "..suspectname, " Forgive: "..voteforgive, "Punish: "..votepunish )
	activevote = false
	for k,v in pairs( player.GetAll() ) do
		v.voted = false
	end
	local result = {
		punish = votepunish > voteforgive,
		punishvotes = votepunish,
		forgivevotes = voteforgive,
		punished = suspectname
	}
	net.Start( "ShowText" )
		net.WriteString( "text_punish_end" )
		net.WriteTable( result )
	net.Broadcast()
	if votepunish > voteforgive then
		for k,v in pairs( player.GetAll() ) do
			if v:SteamID64() == activesuspect then
				if v.warn then
					v:Kill()
				else
					v.warn = true
				end
				break
			end
		end
	end
	suspectname = ""
	activesuspect = nil
	activevictim = nil
end

function CancelVote()
	timer.Destroy( "PunishEnd" )
	net.Start( "ShowText" )
		net.WriteString( "text_punish_cancel" )
	net.Broadcast()
	activevote = false
	suspectname = ""
	activesuspect = nil
	activevictim = nil
	votepunish = 0
	voteforgive = 0
	specpunish = 0
	specforgive = 0
end


================================================
FILE: gamemodes/breach/gamemode/modules/sv_syringe_regen.lua
================================================
-- Syringe regeneration and poison system for Breach
DHPRegenList = DHPRegenList or {}
SyringePoisonList = SyringePoisonList or {}

-- Add ammo type for syringes
game.AddAmmoType({name = "Syringes", dmgtype = DMG_DIRECT})

-- Network strings for client communication
util.AddNetworkString("regen_hp")

-- Main regeneration think hook
hook.Add("Think", "SyringeHPRegen", function()
    -- Handle healing regeneration
    for target, value in pairs(DHPRegenList) do
        if value and IsValid(target) and target:Health() > 0 and target.DHPRegen then
            if target.LastDHPRegen <= CurTime() then
                target:SetHealth(math.min(target:Health() + 1, target:GetMaxHealth()))
                target.DHPRegen = target.DHPRegen - 1
                target.LastDHPRegen = CurTime() + 1
                
                if target:Health() >= target:GetMaxHealth() or target.DHPRegen == 0 then
                    target.DHPRegen = nil
                    target.LastDHPRegen = nil
                    DHPRegenList[target] = nil
                end

                if target:IsPlayer() then
                    net.Start("regen_hp")
                    net.WriteUInt(target.DHPRegen and target.DHPRegen or 0, 8)
                    net.Send(target)
                end
            end
        else
            if IsValid(target) then
                target.DHPRegen = nil
                target.LastDHPRegen = nil
            end
            DHPRegenList[target] = nil
        end
    end

    -- Handle poison damage
    for target, value in pairs(SyringePoisonList) do
        if value and IsValid(target) and target:Health() > 0 and target.SyringePoison then
            if target.SyringePoisonNext <= CurTime() then
                -- Deal poison damage
                local dmginfo = DamageInfo()
                dmginfo:SetDamage(1)
                dmginfo:SetAttacker(target.SyringePoisonAttacker or target)
                dmginfo:SetInflictor(target.SyringePoisonAttacker or target)
                dmginfo:SetDamageType(DMG_POISON)
                
                target:TakeDamageInfo(dmginfo)
                target.SyringePoisonNext = CurTime() + 2 -- Next tick in 2 seconds
                
                if target:IsPlayer() then
                    target:PrintMessage(HUD_PRINTCENTER, "Poison Effect (-1 HP)")
                end
            end
        else
            -- Clean up dead/invalid targets
            if IsValid(target) then
                target.SyringePoison = nil
                target.SyringePoisonNext = nil
                target.SyringePoisonAttacker = nil
            end
            SyringePoisonList[target] = nil
        end
    end
end)

-- Cancel regeneration when taking damage
hook.Add("PostEntityTakeDamage", "SyringeRegenDamage", function(ply, dmginfo, took)
    if IsValid(ply) and ply:IsPlayer() and ply.DHPRegen then
        local RegenLeft = math.max(0, ply.DHPRegen - dmginfo:GetDamage())

        if RegenLeft == 0 then
            ply.DHPRegen = nil
            ply.LastDHPRegen = nil
            DHPRegenList[ply] = nil
        else
            ply.DHPRegen = RegenLeft
            ply.LastDHPRegen = CurTime()
        end

        net.Start("regen_hp")
        net.WriteUInt(ply.DHPRegen and ply.DHPRegen or 0, 8)
        net.Send(ply)
    end
end)

-- Clean up poison on death
hook.Add("PlayerDeath", "CleanSyringePoison", function(victim, inflictor, attacker)
    if IsValid(victim) then
        victim.SyringePoison = nil
        victim.SyringePoisonNext = nil
        victim.SyringePoisonAttacker = nil
        SyringePoisonList[victim] = nil
    end
end)

-- Clean up on round restart
hook.Add("RoundRestart", "CleanSyringeEffects", function()
    DHPRegenList = {}
    SyringePoisonList = {}
    for k, v in pairs(player.GetAll()) do
        if IsValid(v) then
            v.DHPRegen = nil
            v.LastDHPRegen = nil
            v.SyringePoison = nil
            v.SyringePoisonNext = nil
            v.SyringePoisonAttacker = nil
        end
    end
end) 


================================================
FILE: gamemodes/breach/gamemode/modules/sv_vip_panic.lua
================================================
-- VIP Panic Button System
-- Allows VIP to send panic signal visible to MTF and CI Spy

-- Network strings
util.AddNetworkString("VIP_PanicButtonPressed")
util.AddNetworkString("VIP_PanicAlert")
util.AddNetworkString("VIP_PanicCooldown")

-- VIP panic button variables
local VIP_PANIC_COOLDOWN = 60 -- 60 seconds cooldown
local VIP_PANIC_DURATION = 30 -- Alert lasts 30 seconds

-- Store active panic alerts
local ActivePanicAlerts = {}

-- Function to send panic alert
local function SendPanicAlert(vipPlayer, vipPos, alertEndTime)
    -- Remove any existing alerts from this VIP
    for i = #ActivePanicAlerts, 1, -1 do
        if ActivePanicAlerts[i].vip == vipPlayer then
            table.remove(ActivePanicAlerts, i)
        end
    end
    
    -- Add new alert
    table.insert(ActivePanicAlerts, {
        vip = vipPlayer,
        pos = vipPos,
        endTime = alertEndTime,
        startTime = CurTime()
    })
    
    -- Send to authorized players (MTF and CI Spy)
    for _, ply in pairs(player.GetAll()) do
        if IsValid(ply) and ply:Alive() then
            if ply:GTeam() == TEAM_GUARD or (ply:GTeam() == TEAM_CHAOS and ply:GetNClass() == ROLES.ROLE_CHAOSSPY) then
                net.Start("VIP_PanicAlert")
                    net.WriteString(vipPlayer:Nick())
                    net.WriteVector(vipPos)
                    net.WriteFloat(alertEndTime)
                net.Send(ply)
            end
        end
    end
    
    -- Send confirmation to VIP
    local message = "[PANIC] Emergency signal sent to security forces!"
    if ALLLANGUAGES.english and ALLLANGUAGES.english.VIP_PANIC then
        message = ALLLANGUAGES.english.VIP_PANIC.signal_sent
    end
    vipPlayer:PrintMessage(HUD_PRINTTALK, message)
    
    -- Send cooldown info to client
    net.Start("VIP_PanicCooldown")
        net.WriteFloat(vipPlayer.VIPPanicCooldown)
    net.Send(vipPlayer)
    
    -- Play sound for VIP
    vipPlayer:EmitSound("buttons/button09.wav", 75, 120)
end

-- Handle panic button press
net.Receive("VIP_PanicButtonPressed", function(len, ply)
    if not IsValid(ply) or not ply:Alive() then return end
    if ply:GetNClass() != ROLES.ROLE_VIP then return end
    if preparing or postround then 
        local message = "[PANIC] Cannot use panic button during this phase!"
        if ALLLANGUAGES.english and ALLLANGUAGES.english.VIP_PANIC then
            message = ALLLANGUAGES.english.VIP_PANIC.phase_blocked
        end
        ply:PrintMessage(HUD_PRINTTALK, message)
        return 
    end
    
    -- Check cooldown
    if not ply.VIPPanicCooldown then
        ply.VIPPanicCooldown = 0
    end
    
    if CurTime() < ply.VIPPanicCooldown then
        local timeLeft = math.ceil(ply.VIPPanicCooldown - CurTime())
        local message = "[PANIC] Cooldown: " .. timeLeft .. "s"
        if ALLLANGUAGES.english and ALLLANGUAGES.english.VIP_PANIC then
            message = string.format(ALLLANGUAGES.english.VIP_PANIC.cooldown_active, timeLeft)
        end
        ply:PrintMessage(HUD_PRINTTALK, message)
        return
    end
    
    -- Set cooldown
    ply.VIPPanicCooldown = CurTime() + VIP_PANIC_COOLDOWN
    
    -- Send panic alert
    local alertEndTime = CurTime() + VIP_PANIC_DURATION
    SendPanicAlert(ply, ply:GetPos(), alertEndTime)
    
    -- Log the panic button usage
    print("[VIP PANIC] " .. ply:Nick() .. " (" .. ply:SteamID() .. ") used panic button at " .. tostring(ply:GetPos()))
end)

-- Clean up expired alerts
timer.Create("VIP_CleanupPanicAlerts", 1, 0, function()
    for i = #ActivePanicAlerts, 1, -1 do
        if CurTime() > ActivePanicAlerts[i].endTime then
            table.remove(ActivePanicAlerts, i)
        end
    end
end)

-- Reset panic cooldowns on round restart
hook.Add("PostCleanupMap", "VIP_ResetPanicCooldowns", function()
    for _, ply in pairs(player.GetAll()) do
        if IsValid(ply) then
            ply.VIPPanicCooldown = 0
        end
    end
    ActivePanicAlerts = {}
end)

-- Console command for admin testing
concommand.Add("br_vip_panic_test", function(ply, cmd, args)
    if not IsValid(ply) or not ply:IsSuperAdmin() then return end
    
    -- Force trigger panic as admin
    ply.VIPPanicCooldown = 0
    local alertEndTime = CurTime() + VIP_PANIC_DURATION
    SendPanicAlert(ply, ply:GetPos(), alertEndTime)
    ply:PrintMessage(HUD_PRINTTALK, "[ADMIN] VIP panic test activated!")
end) 


================================================
FILE: gamemodes/breach/gamemode/modules/sv_weapon_damage_modifiers.lua
================================================
-- Weapon Damage Modifiers System
-- Server-side handling

-- Default modifiers table
WEAPON_DAMAGE_MODIFIERS = WEAPON_DAMAGE_MODIFIERS or {}

-- Load saved modifiers from file
local function LoadModifiers()
    if file.Exists("breach/weapon_modifiers.txt", "DATA") then
        local data = file.Read("breach/weapon_modifiers.txt", "DATA")
        if data then
            local tbl = util.JSONToTable(data)
            if tbl then
                WEAPON_DAMAGE_MODIFIERS = tbl
                print("[WEAPON MODIFIERS] Loaded " .. table.Count(WEAPON_DAMAGE_MODIFIERS) .. " weapon modifiers")
            end
        end
    else
        -- Create default modifiers for common CW2.0 weapons
        WEAPON_DAMAGE_MODIFIERS = {
            -- Assault Rifles
            ["cw_ak74"] = { vs_scp = 1.0, vs_human = 1.0 },
            ["cw_ar15"] = { vs_scp = 1.0, vs_human = 1.0 },
            ["cw_m4a1"] = { vs_scp = 1.0, vs_human = 1.0 },
            ["cw_g36c"] = { vs_scp = 1.0, vs_human = 1.0 },
            ["cw_scarh"] = { vs_scp = 1.0, vs_human = 1.0 },
            
            -- SMGs
            ["cw_mp5"] = { vs_scp = 1.0, vs_human = 1.0 },
            ["cw_ump45"] = { vs_scp = 1.0, vs_human = 1.0 },
            ["cw_mac11"] = { vs_scp = 1.0, vs_human = 1.0 },
            
            -- Pistols
            ["cw_deagle"] = { vs_scp = 1.0, vs_human = 1.0 },
            ["cw_fiveseven"] = { vs_scp = 1.0, vs_human = 1.0 },
            ["cw_m1911"] = { vs_scp = 1.0, vs_human = 1.0 },
            ["cw_p99"] = { vs_scp = 1.0, vs_human = 1.0 },
            
            -- Shotguns
            ["cw_m3super90"] = { vs_scp = 1.0, vs_human = 1.0 },
            ["cw_shorty"] = { vs_scp = 1.0, vs_human = 1.0 },
            
            -- Sniper Rifles
            ["cw_l115"] = { vs_scp = 1.0, vs_human = 1.0 },
            ["cw_m14"] = { vs_scp = 1.0, vs_human = 1.0 },
            
            -- Other
            ["cw_m249_official"] = { vs_scp = 1.0, vs_human = 1.0 },
            ["cw_flash_grenade"] = { vs_scp = 1.0, vs_human = 1.0 },
            ["cw_smoke_grenade"] = { vs_scp = 1.0, vs_human = 1.0 },
            ["cw_frag_grenade"] = { vs_scp = 1.0, vs_human = 1.0 }
        }
        SaveModifiers()
    end
end

-- Save modifiers to file
local function SaveModifiers()
    if not file.Exists("breach", "DATA") then
        file.CreateDir("breach")
    end
    
    local data = util.TableToJSON(WEAPON_DAMAGE_MODIFIERS, true)
    file.Write("breach/weapon_modifiers.txt", data)
    print("[WEAPON MODIFIERS] Saved modifiers to file")
end

-- Sync modifiers with clients
util.AddNetworkString("BR_SyncWeaponModifiers")
util.AddNetworkString("BR_RequestWeaponModifiers")
util.AddNetworkString("BR_UpdateWeaponModifier")

local function SyncModifiersToPlayer(ply)
    net.Start("BR_SyncWeaponModifiers")
    net.WriteTable(WEAPON_DAMAGE_MODIFIERS)
    net.Send(ply)
end

-- Send modifiers when player requests them
net.Receive("BR_RequestWeaponModifiers", function(len, ply)
    if not ply:IsSuperAdmin() then return end
    SyncModifiersToPlayer(ply)
end)

-- Update modifier from client
net.Receive("BR_UpdateWeaponModifier", function(len, ply)
    if not ply:IsSuperAdmin() then 
        ply:PrintMessage(HUD_PRINTTALK, "Only super admins can modify weapon damage!")
        return 
    end
    
    local weapon = net.ReadString()
    local vs_scp = net.ReadFloat()
    local vs_human = net.ReadFloat()
    
    -- Validate values
    vs_scp = math.Clamp(vs_scp, 0, 5)
    vs_human = math.Clamp(vs_human, 0, 5)
    
    -- Create entry if it doesn't exist
    if not WEAPON_DAMAGE_MODIFIERS[weapon] then
        WEAPON_DAMAGE_MODIFIERS[weapon] = {}
    end
    
    WEAPON_DAMAGE_MODIFIERS[weapon].vs_scp = vs_scp
    WEAPON_DAMAGE_MODIFIERS[weapon].vs_human = vs_human
    
    SaveModifiers()
    
    -- Sync to all players
    net.Start("BR_SyncWeaponModifiers")
    net.WriteTable(WEAPON_DAMAGE_MODIFIERS)
    net.Broadcast()
    
    ply:PrintMessage(HUD_PRINTTALK, "Updated damage modifiers for " .. weapon)
    print("[WEAPON MODIFIERS] " .. ply:Nick() .. " updated " .. weapon .. " - vs_scp: " .. vs_scp .. ", vs_human: " .. vs_human)
end)

-- Hook into damage system
hook.Add("EntityTakeDamage", "BR_WeaponDamageModifiers", function(target, dmginfo)
    if not target:IsPlayer() or not target:Alive() then return end
    
    local attacker = dmginfo:GetAttacker()
    if not IsValid(attacker) or not attacker:IsPlayer() then return end
    
    local weapon = attacker:GetActiveWeapon()
    if not IsValid(weapon) then return end
    
    local weaponClass = weapon:GetClass()
    local modifiers = WEAPON_DAMAGE_MODIFIERS[weaponClass]
    
    if modifiers then
        local multiplier = 1.0
        
        -- Check if target is SCP or human
        if target:GTeam() == TEAM_SCP then
            multiplier = modifiers.vs_scp or 1.0
        else
            multiplier = modifiers.vs_human or 1.0
        end
        
        if multiplier != 1.0 then
            local originalDmg = dmginfo:GetDamage()
            dmginfo:ScaleDamage(multiplier)
            
            if GetConVar("developer"):GetInt() > 0 then
                print("[WEAPON MODIFIERS] " .. weaponClass .. " damage: " .. originalDmg .. " -> " .. dmginfo:GetDamage() .. " (x" .. multiplier .. ")")
            end
        end
    end
end, HOOK_NORMAL) -- Normal priority to apply before other modifiers

-- Load modifiers on server start
hook.Add("Initialize", "BR_LoadWeaponModifiers", function()
    LoadModifiers()
end)

-- Console commands
concommand.Add("br_reload_weapon_modifiers", function(ply, cmd, args)
    if IsValid(ply) and not ply:IsSuperAdmin() then 
        ply:PrintMessage(HUD_PRINTTALK, "Only super admins can reload weapon modifiers!")
        return 
    end
    
    LoadModifiers()
    
    -- Sync to all players
    net.Start("BR_SyncWeaponModifiers")
    net.WriteTable(WEAPON_DAMAGE_MODIFIERS)
    net.Broadcast()
    
    if IsValid(ply) then
        ply:PrintMessage(HUD_PRINTTALK, "Reloaded weapon damage modifiers")
    else
        print("[WEAPON MODIFIERS] Reloaded from console")
    end
end)

concommand.Add("br_reset_weapon_modifiers", function(ply, cmd, args)
    if IsValid(ply) and not ply:IsSuperAdmin() then 
        ply:PrintMessage(HUD_PRINTTALK, "Only super admins can reset weapon modifiers!")
        return 
    end
    
    -- Reset all to 1.0
    for weapon, _ in pairs(WEAPON_DAMAGE_MODIFIERS) do
        WEAPON_DAMAGE_MODIFIERS[weapon].vs_scp = 1.0
        WEAPON_DAMAGE_MODIFIERS[weapon].vs_human = 1.0
    end
    
    SaveModifiers()
    
    -- Sync to all players
    net.Start("BR_SyncWeaponModifiers")
    net.WriteTable(WEAPON_DAMAGE_MODIFIERS)
    net.Broadcast()
    
    if IsValid(ply) then
        ply:PrintMessage(HUD_PRINTTALK, "Reset all weapon damage modifiers to default")
    else
        print("[WEAPON MODIFIERS] Reset all modifiers to default")
    end
end)

-- Initialize on first player join
hook.Add("PlayerInitialSpawn", "BR_SendWeaponModifiers", function(ply)
    timer.Simple(2, function()
        if IsValid(ply) then
            SyncModifiersToPlayer(ply)
        end
    end)
end)


================================================
FILE: gamemodes/breach/gamemode/modules/zz_sam_breach.lua
================================================
[Empty file]


================================================
FILE: lua/autorun/autorun_3199.lua
================================================
sound.Add({
    name = "SCP3199scream",
    channel = CHAN_VOICE,
    volume = 1.0,
    level = 100,
    pitch = {95, 105},
    sound = "newenemy.wav"
})

sound.Add({
    name = "SCP3199Bite1",
    channel = CHAN_STATIC,
    volume = 1.0,
    level = 65,
    pitch = {95, 105},
    sound = "3199attack.wav"
})

sound.Add({
    name = "SCP3199Bite2",
    channel = CHAN_STATIC,
    volume = 1.0,
    level = 65,
    pitch = {95, 105},
    sound = "3199attack2.wav"
})

sound.Add({
    name = "SCP3199Bite3",
    channel = CHAN_STATIC,
    volume = 1.0,
    level = 65,
    pitch = {95, 105},
    sound = "3199attack3.wav"
})

sound.Add({
    name = "SCP3199Bite4",
    channel = CHAN_STATIC,
    volume = 1.0,
    level = 65,
    pitch = {95, 105},
    sound = "3199attack4.wav"
})

sound.Add({
    name = "SCP3199Corrosion",
    channel = CHAN_STATIC,
    volume = 1.0,
    level = 55,
    pitch = {95, 105},
    sound = "3199corrosion.wav"
})

sound.Add({
    name = "SCP3199Vomit",
    channel = CHAN_STATIC,
    volume = 1.0,
    level = 65,
    pitch = {95, 105},
    sound = "3199vomit.wav"
})

sound.Add({
    name = "SCP3199Death",
    channel = CHAN_STATIC,
    volume = 1.0,
    level = 75,
    pitch = {95, 105},
    sound = "eggspawn.wav"
})

PrecacheParticleSystem( "eml_generic_crsv" )
game.AddParticles( "particles/corrosion_fx.pcf" )
game.AddParticles( "particles/cryo_fx.pcf" )
game.AddParticles( "particles/ngen_fx.pcf" )

if SERVER then
    hook.Add("PlayerDeath", "3199DeathSound", function(ply, inflictor, attacker)
        if not IsValid(ply) then return end
    
        if ply:HasWeapon("weapon_scp_3199") then
            ply:EmitSound("SCP3199Death")
        end
    end)
end


================================================
FILE: lua/autorun/tfa_crucible.lua
================================================
-- TFA Crucible Sound Register dla Breach
-- Rejestruje dźwięki broni Crucible

if SERVER then
	resource.AddFile("sound/weapons/tfa_kf2/crucible/shock_impact.wav")
	resource.AddFile("sound/weapons/tfa_kf2/crucible/WPN_LS_Equip_01.wav")
	resource.AddFile("sound/weapons/tfa_kf2/crucible/WPN_LS_UnEquip_01.wav")
	resource.AddFile("sound/weapons/tfa_kf2/crucible/wpn_ls_idle_01_lpm.wav")
end

-- Rejestracja dźwięków
sound.Add({
	name = "TFA_crucible.Swing",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 75,
	pitch = {95, 105},
	sound = {
		"weapons/tfa_kf2/crucible/wpn_ls_swing_01.wav",
		"weapons/tfa_kf2/crucible/wpn_ls_swing_02.wav",
		"weapons/tfa_kf2/crucible/wpn_ls_swing_03.wav"
	}
})

sound.Add({
	name = "TFA_crucible.HitFlesh",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 75,
	pitch = {95, 105},
	sound = {
		"weapons/tfa_kf2/crucible/wpn_ls_hit_flesh_01.wav",
		"weapons/tfa_kf2/crucible/wpn_ls_hit_flesh_02.wav",
		"weapons/tfa_kf2/crucible/wpn_ls_hit_flesh_03.wav"
	}
})

sound.Add({
	name = "TFA_crucible.HitWorld",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 75,
	pitch = {95, 105},
	sound = {
		"weapons/tfa_kf2/crucible/wpn_ls_hit_world_01.wav",
		"weapons/tfa_kf2/crucible/wpn_ls_hit_world_02.wav"
	}
})

-- Upewnij się że dźwięki są precache
if CLIENT then
	timer.Simple(1, function()
		util.PrecacheSound("TFA_crucible.Swing")
		util.PrecacheSound("TFA_crucible.HitFlesh")
		util.PrecacheSound("TFA_crucible.HitWorld")
		util.PrecacheSound("weapons/tfa_kf2/crucible/shock_impact.wav")
		util.PrecacheSound("weapons/tfa_kf2/crucible/WPN_LS_Equip_01.wav")
		util.PrecacheSound("weapons/tfa_kf2/crucible/WPN_LS_UnEquip_01.wav")
		util.PrecacheSound("weapons/tfa_kf2/crucible/wpn_ls_idle_01_lpm.wav")
	end)
end


================================================
FILE: models/breach/cctvcamera.dx80.vtx
================================================
[Binary file]


================================================
FILE: models/breach/cctvcamera.dx90.vtx
================================================
[Binary file]


================================================
FILE: models/breach/cctvcamera.mdl
================================================
[Binary file]


================================================
FILE: models/breach/cctvcamera.phy
================================================
[Binary file]


================================================
FILE: models/breach/cctvcamera.sw.vtx
================================================
[Binary file]


================================================
FILE: models/breach/cctvcamera.vvd
================================================
[Binary file]


================================================
FILE: models/breach/keycard_new.dx80.vtx
================================================
[Binary file]


================================================
FILE: models/breach/keycard_new.dx90.vtx
================================================
[Binary file]


================================================
FILE: models/breach/keycard_new.mdl
================================================
[Binary file]


================================================
FILE: models/breach/keycard_new.phy
================================================
[Binary file]


================================================
FILE: models/breach/keycard_new.sw.vtx
================================================
[Binary file]


================================================
FILE: models/breach/keycard_new.vvd
================================================
[Binary file]


================================================
FILE: models/combine_vests/militaryvest.dx80.vtx
================================================
[Binary file]


================================================
FILE: models/combine_vests/militaryvest.dx90.vtx
================================================
[Binary file]


================================================
FILE: models/combine_vests/militaryvest.mdl
================================================
[Binary file]


================================================
FILE: models/combine_vests/militaryvest.phy
================================================
[Binary file]


================================================
FILE: models/combine_vests/militaryvest.sw.vtx
================================================
[Binary file]


================================================
FILE: models/combine_vests/militaryvest.vvd
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/ayran.dx80.vtx
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/ayran.dx90.vtx
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/ayran.mdl
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/ayran.phy
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/ayran.sw.vtx
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/ayran.vvd
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/doner_doner.dx80.vtx
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/doner_doner.dx90.vtx
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/doner_doner.mdl
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/doner_doner.phy
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/doner_doner.sw.vtx
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/doner_doner.vvd
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/doner_stand.dx80.vtx
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/doner_stand.dx90.vtx
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/doner_stand.mdl
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/doner_stand.phy
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/doner_stand.sw.vtx
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/doner_stand.vvd
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/ekmek.dx80.vtx
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/ekmek.dx90.vtx
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/ekmek.mdl
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/ekmek.phy
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/ekmek.sw.vtx
================================================
[Binary file]


================================================
FILE: models/doner_makinesi/ekmek.vvd
================================================
[Binary file]


================================================
FILE: models/weapons/v_zombiearms.dx80.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/v_zombiearms.dx90.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/v_zombiearms.mdl
================================================
[Binary file]


================================================
FILE: models/weapons/v_zombiearms.sw.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/v_zombiearms.vvd
================================================
[Binary file]


================================================
FILE: models/weapons/scp076/v_katana.dx80.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/scp076/v_katana.dx90.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/scp076/v_katana.mdl
================================================
[Binary file]


================================================
FILE: models/weapons/scp076/v_katana.sw.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/scp076/v_katana.vvd
================================================
[Binary file]


================================================
FILE: models/weapons/scp076/w_katana.dx80.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/scp076/w_katana.dx90.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/scp076/w_katana.mdl
================================================
[Binary file]


================================================
FILE: models/weapons/scp076/w_katana.phy
================================================
[Binary file]


================================================
FILE: models/weapons/scp076/w_katana.sw.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/scp076/w_katana.vvd
================================================
[Binary file]


================================================
FILE: models/weapons/scp082/v_machete.dx80.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/scp082/v_machete.dx90.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/scp082/v_machete.mdl
================================================
[Binary file]


================================================
FILE: models/weapons/scp082/v_machete.sw.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/scp082/v_machete.vvd
================================================
[Binary file]


================================================
FILE: models/weapons/scp082/v_machete.xbox.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/scp082/w_fc2_machete.dx80.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/scp082/w_fc2_machete.dx90.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/scp082/w_fc2_machete.mdl
================================================
[Binary file]


================================================
FILE: models/weapons/scp082/w_fc2_machete.phy
================================================
[Binary file]


================================================
FILE: models/weapons/scp082/w_fc2_machete.sw.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/scp082/w_fc2_machete.vvd
================================================
[Binary file]


================================================
FILE: models/weapons/scp500/scp500model.dx80.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/scp500/scp500model.dx90.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/scp500/scp500model.mdl
================================================
[Binary file]


================================================
FILE: models/weapons/scp500/scp500model.phy
================================================
[Binary file]


================================================
FILE: models/weapons/scp500/scp500model.sw.vtx
================================================
[Binary file]


================================================
FILE: models/weapons/scp500/scp500model.vvd
================================================
[Binary file]
